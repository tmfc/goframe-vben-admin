import {
  addClass,
  cell_default,
  checkTargetElement,
  clearTableAllStatus,
  colToVisible,
  convertHeaderColumnToRows,
  convertHeaderToGridRows,
  createHandleGetRowId,
  createHandleUpdateRowId,
  createInternalData,
  getAbsolutePos,
  getCalcHeight,
  getCellRestHeight,
  getCellValue,
  getColReMinWidth,
  getColumnList,
  getDomNode,
  getEventTargetNode,
  getLastChildColumn,
  getPaddingTopBottomSize,
  getPropClass,
  getRefElem,
  getRootColumn,
  getRowUniqueId,
  getRowid,
  getRowkey,
  getTpImg,
  handleFieldOrColumn,
  handleRowidOrRow,
  hasClass,
  hasControlKey,
  hasDeepKey,
  initTpImg,
  isColumnInfo,
  isPx,
  isScale,
  removeClass,
  restoreScrollLocation,
  rowToVisible,
  scrollToView,
  setCellValue,
  setScrollLeft,
  setScrollTop,
  toCssUnit,
  toFilters,
  toTreePathSeq,
  triggerEvent,
  updateCellTitle
} from "./chunk-3XCGTZXD.js";
import {
  defineVxeComponent,
  errLog,
  getChangeEvent,
  getModelEvent,
  getOnName,
  getSlotVNs,
  hasInputType,
  warnLog
} from "./chunk-CCJLNSLP.js";
import {
  eqEmptyValue,
  formatText,
  getFuncText,
  getLastZIndex,
  hasChildrenList,
  isEmptyValue,
  isEnableConf,
  nextZIndex,
  parseFile
} from "./chunk-LYJ5CTIB.js";
import {
  VxeUI,
  require_xe_utils
} from "./chunk-IFBSOPU2.js";
import {
  Teleport,
  TransitionGroup,
  computed,
  h,
  inject,
  nextTick,
  onActivated,
  onBeforeUnmount,
  onDeactivated,
  onMounted,
  onUnmounted,
  provide,
  reactive,
  ref,
  resolveComponent,
  watch
} from "./chunk-W3DDEFPZ.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/src/table.js
var import_xe_utils18 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/src/anime.js
var import_xe_utils = __toESM(require_xe_utils());
var rowMoveCls = "row--drag-move";
var colMoveClass = "col--drag-move";
function moveRowAnimateToTb(elemList, offsetTop) {
  import_xe_utils.default.arrayEach(elemList, (trEl) => {
    trEl.style.transform = `translateY(${offsetTop}px)`;
  });
  requestAnimationFrame(() => {
    import_xe_utils.default.arrayEach(elemList, (trEl) => {
      addClass(trEl, rowMoveCls);
      trEl.style.transform = "";
    });
  });
}
function clearRowAnimate(elem, clss) {
  setTimeout(() => {
    if (elem) {
      import_xe_utils.default.arrayEach(elem.querySelectorAll(clss.map((cls) => `${cls}.${rowMoveCls}`).join(",")), (elem2) => removeClass(elem2, rowMoveCls));
    }
  }, 500);
}
function moveColAnimateToLr(elemList, offsetLeft) {
  import_xe_utils.default.arrayEach(elemList, (trEl) => {
    trEl.style.transform = `translateX(${offsetLeft}px)`;
  });
  requestAnimationFrame(() => {
    import_xe_utils.default.arrayEach(elemList, (trEl) => {
      addClass(trEl, colMoveClass);
      trEl.style.transform = "";
    });
  });
}
function clearColAnimate(elem, clss) {
  setTimeout(() => {
    if (elem) {
      import_xe_utils.default.arrayEach(elem.querySelectorAll(clss.map((cls) => `${cls}.${rowMoveCls}`).join(",")), (elem2) => removeClass(elem2, colMoveClass));
    }
  }, 500);
}

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/src/store.js
var crossTableDragRowInfo = reactive({
  row: null
});
function getCrossTableDragRowInfo() {
  return crossTableDragRowInfo;
}

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/src/body.js
var import_xe_utils2 = __toESM(require_xe_utils());
var { getI18n, renderer, renderEmptyElement } = VxeUI;
var sourceType = "table";
var renderType = "body";
var body_default = defineVxeComponent({
  name: "VxeTableBody",
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: ""
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { xID, props: tableProps2, context: tableContext, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { computeEditOpts, computeMouseOpts, computeCellOffsetWidth, computeAreaOpts, computeDefaultRowHeight, computeEmptyOpts, computeTooltipOpts, computeRadioOpts, computeExpandOpts, computeTreeOpts, computeCheckboxOpts, computeCellOpts, computeValidOpts, computeRowOpts, computeColumnOpts, computeRowDragOpts, computeResizableOpts, computeVirtualXOpts, computeVirtualYOpts, computeIsBodyRenderOptimize } = $xeTable.getComputeMaps();
    const refElem = ref();
    const refBodyScroll = ref();
    const refBodyTable = ref();
    const refBodyColgroup = ref();
    const refBodyTBody = ref();
    const refBodyXSpace = ref();
    const refBodyYSpace = ref();
    const refBodyEmptyBlock = ref();
    const isVMScrollProcess = () => {
      const { delayHover } = tableProps2;
      const { lastScrollTime, isDragResize } = tableReactData;
      return !!(isDragResize || lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const renderLine = (rowid, params, cellHeight) => {
      const { column } = params;
      const { treeConfig } = tableProps2;
      const cellOpts = computeCellOpts.value;
      const rowOpts = computeRowOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const treeOpts = computeTreeOpts.value;
      const { slots, treeNode } = column;
      const { fullAllDataRowIdData } = tableInternalData;
      if (treeConfig && treeNode && (treeOpts.showLine || treeOpts.line)) {
        if (slots && slots.line) {
          return $xeTable.callSlot(slots.line, params);
        }
        const rowRest = fullAllDataRowIdData[rowid];
        let rLevel = 0;
        let prevRow = null;
        let parentRow = null;
        let lineHeight = "";
        if (rowRest) {
          rLevel = rowRest.level;
          prevRow = rowRest.items[rowRest.treeIndex - 1];
          parentRow = rowRest.parent;
        }
        if (!rLevel && !treeOpts.showRootLine) {
          return [];
        }
        if (prevRow) {
          const prevRowRest = fullAllDataRowIdData[getRowid($xeTable, prevRow)] || {};
          lineHeight = `${prevRowRest.lineHeight || 0}px`;
        } else if (rLevel && parentRow) {
          const parentRowRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)] || {};
          lineHeight = `calc(-1em + ${Math.floor(cellHeight / 2 + getCellRestHeight(parentRowRest, cellOpts, rowOpts, defaultRowHeight) / 2)}px)`;
        }
        return [
          h("div", {
            key: "tl",
            class: "vxe-tree--line-wrapper"
          }, [
            h("div", {
              class: "vxe-tree--line",
              style: {
                height: lineHeight,
                bottom: `-${Math.floor(cellHeight / 2)}px`,
                left: `calc(${rLevel * treeOpts.indent}px + 1em)`
              }
            })
          ])
        ];
      }
      return [];
    };
    const renderTdColumn = (seq, rowid, fixedType, isOptimizeMode, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, columns, items) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const { columnKey, resizable: allResizable, showOverflow: allShowOverflow, border, height, treeConfig, cellClassName: allCellClassName, cellStyle, align: allAlign, spanMethod, mouseConfig, editConfig, editRules, tooltipConfig, padding: allPadding } = tableProps2;
      const { tableData, tableColumn, dragRow, overflowX, overflowY, currentColumn, scrollXLoad, scrollYLoad, mergeBodyFlag, calcCellHeightFlag, resizeHeightFlag, resizeWidthFlag, editStore, isAllOverflow, validErrorMaps } = tableReactData;
      const { fullAllDataRowIdData, fullColumnIdData, mergeBodyCellMaps, visibleColumn, afterFullData, mergeBodyList, scrollXStore, scrollYStore } = tableInternalData;
      const cellOpts = computeCellOpts.value;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const editOpts = computeEditOpts.value;
      const tooltipOpts = computeTooltipOpts.value;
      const resizableOpts = computeResizableOpts.value;
      const virtualXOpts = computeVirtualXOpts.value;
      const virtualYOpts = computeVirtualYOpts.value;
      const { isAllColumnDrag, isAllRowDrag } = resizableOpts;
      const rowOpts = computeRowOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const customCellHeight = calcCellHeightFlag ? cellOpts.height || rowOpts.height : 0;
      const { disabledMethod: dragDisabledMethod, isCrossDrag, isPeerDrag } = rowDragOpts;
      const columnOpts = computeColumnOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const areaOpts = computeAreaOpts.value;
      const cellOffsetWidth = computeCellOffsetWidth.value;
      const { selectCellToRow } = areaOpts;
      const { type, cellRender, editRender, align, showOverflow, className, treeNode, rowResize, padding, verticalAlign, slots } = column;
      const { verticalAlign: allVerticalAlign } = cellOpts;
      const { actived } = editStore;
      const rowRest = fullAllDataRowIdData[rowid] || {};
      const colid = column.id;
      const colRest = fullColumnIdData[colid] || {};
      const renderOpts = editRender || cellRender;
      const compConf = renderOpts ? renderer.get(renderOpts.name) : null;
      const compCellClassName = compConf ? compConf.tableCellClassName || compConf.cellClassName : null;
      const compCellStyle = compConf ? compConf.tableCellStyle || compConf.cellStyle : "";
      const showAllTip = tooltipOpts.showAll;
      const columnIndex = colRest.index;
      const _columnIndex = colRest._index;
      const isEdit = isEnableConf(editRender);
      const resizeHeight = resizeHeightFlag ? rowRest.resizeHeight : 0;
      let fixedHiddenColumn = overflowX && (fixedType ? column.fixed !== fixedType : !!column.fixed);
      const isCellPadding = import_xe_utils2.default.eqNull(padding) ? allPadding === null ? cellOpts.padding : allPadding : padding;
      const cellOverflow = import_xe_utils2.default.eqNull(showOverflow) ? allShowOverflow : showOverflow;
      const showEllipsis = cellOverflow === "ellipsis";
      const showTitle = cellOverflow === "title";
      const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
      const hasEllipsis = isAllOverflow || showTitle || showTooltip || showEllipsis;
      const showResizable = import_xe_utils2.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
      const isCsHeight = !!customCellHeight;
      const isRsHeight = resizeHeight > 0;
      let isDirty;
      const tdOns = {};
      const cellAlign = align || (compConf ? compConf.tableCellAlign : "") || allAlign;
      const cellVerticalAlign = import_xe_utils2.default.eqNull(verticalAlign) ? allVerticalAlign : verticalAlign;
      const errorValidItem = validErrorMaps[`${rowid}:${colid}`];
      const showValidTip = editRules && validOpts.showMessage && (validOpts.message === "default" ? height || tableData.length > 1 : validOpts.message === "inline");
      const tdAttrs = { colid };
      const cellParams = {
        $table: $xeTable,
        $grid: $xeGrid,
        $gantt: $xeGantt,
        isEdit: false,
        seq,
        rowid,
        row,
        rowIndex,
        $rowIndex,
        _rowIndex,
        column,
        columnIndex,
        $columnIndex,
        _columnIndex,
        fixed: fixedType,
        source: sourceType,
        type: renderType,
        isHidden: !!fixedHiddenColumn,
        level: rowLevel,
        visibleData: afterFullData,
        data: tableData,
        items
      };
      let isRowDragCell = false;
      let isDisabledDrag = false;
      if (rowOpts.drag) {
        isRowDragCell = rowDragOpts.trigger === "row" || column.dragSort && rowDragOpts.trigger === "cell";
      }
      if (isRowDragCell) {
        isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(cellParams));
      }
      if (showTitle || showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseover = (evnt) => {
          if (!isVMScrollProcess()) {
            if (showTitle) {
              updateCellTitle(evnt.currentTarget, column);
            } else if (showTooltip || showAllTip) {
              $xeTable.triggerBodyTooltipEvent(evnt, cellParams);
            }
          }
          $xeTable.dispatchEvent("cell-mouseenter", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
      }
      if (showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseleave = (evnt) => {
          if (!isVMScrollProcess()) {
            if (showTooltip || showAllTip) {
              $xeTable.handleTargetLeaveEvent(evnt);
            }
          }
          $xeTable.dispatchEvent("cell-mouseleave", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
      }
      if (isRowDragCell || checkboxOpts.range || mouseConfig) {
        tdOns.onMousedown = (evnt) => {
          $xeTable.triggerCellMousedownEvent(evnt, cellParams);
        };
      }
      if (isRowDragCell) {
        tdOns.onMouseup = $xeTable.triggerCellMouseupEvent;
      }
      tdOns.onClick = (evnt) => {
        $xeTable.triggerCellClickEvent(evnt, cellParams);
      };
      tdOns.onDblclick = (evnt) => {
        $xeTable.triggerCellDblclickEvent(evnt, cellParams);
      };
      let isMergeCell = false;
      let mergeColspan = 1;
      let mergeRowspan = 1;
      if (mergeBodyFlag && mergeBodyList.length) {
        const spanRest = mergeBodyCellMaps[`${_rowIndex}:${_columnIndex}`];
        if (spanRest) {
          const { rowspan, colspan } = spanRest;
          if (!rowspan || !colspan) {
            return renderEmptyElement($xeTable);
          }
          if (rowspan > 1) {
            isMergeCell = true;
            mergeRowspan = rowspan;
            tdAttrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            isMergeCell = true;
            mergeColspan = colspan;
            tdAttrs.colspan = colspan;
          }
        }
      } else if (spanMethod) {
        const { rowspan = 1, colspan = 1 } = spanMethod(cellParams) || {};
        if (!rowspan || !colspan) {
          return renderEmptyElement($xeTable);
        }
        if (rowspan > 1) {
          isMergeCell = true;
          mergeRowspan = rowspan;
          tdAttrs.rowspan = rowspan;
        }
        if (colspan > 1) {
          isMergeCell = true;
          mergeColspan = colspan;
          tdAttrs.colspan = colspan;
        }
      }
      if (fixedHiddenColumn && isMergeCell) {
        if (tdAttrs.colspan > 1 || tdAttrs.rowspan > 1) {
          fixedHiddenColumn = false;
        }
      }
      if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {
        isDirty = $xeTable.isUpdateByRow(row, column.field);
      }
      const isVNAutoHeight = !hasEllipsis && (scrollYLoad || scrollXLoad);
      let cellHeight = getCellRestHeight(rowRest, cellOpts, rowOpts, defaultRowHeight);
      const isLastColumn = $columnIndex === columns.length - 1;
      const isAutoCellWidth = !column.resizeWidth && (column.minWidth === "auto" || column.width === "auto");
      let isVNPreEmptyStatus = false;
      if (!isMergeCell) {
        if (!dragRow || getRowid($xeTable, dragRow) !== rowid) {
          if (overflowY && scrollYLoad && tableData.length > 16 && !treeConfig && !virtualYOpts.immediate && (_rowIndex < scrollYStore.visibleStartIndex - scrollYStore.preloadSize || _rowIndex > scrollYStore.visibleEndIndex + scrollYStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          } else if (overflowX && scrollXLoad && tableColumn.length > 10 && !virtualXOpts.immediate && !column.fixed && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          }
        }
      }
      if (mergeRowspan > 1) {
        const mEndRow = afterFullData[_rowIndex + mergeRowspan - 1];
        if (mEndRow) {
          const meRowRest = fullAllDataRowIdData[getRowid($xeTable, mEndRow)];
          if (meRowRest) {
            cellHeight += meRowRest.oTop + getCellRestHeight(meRowRest, cellOpts, rowOpts, defaultRowHeight) - rowRest.oTop - getCellRestHeight(rowRest, cellOpts, rowOpts, defaultRowHeight);
          }
        }
      }
      const tcStyle = {};
      if (hasEllipsis && resizeWidthFlag) {
        let mergeColWidth = 0;
        if (mergeColspan > 1) {
          for (let index = 1; index < mergeColspan; index++) {
            const nextColumn = visibleColumn[columnIndex + index];
            if (nextColumn) {
              mergeColWidth += nextColumn.renderWidth;
            }
          }
        }
        tcStyle.width = `${column.renderWidth + mergeColWidth - cellOffsetWidth}px`;
      }
      if (scrollYLoad || scrollXLoad || hasEllipsis || isCsHeight || isRsHeight) {
        tcStyle.height = `${cellHeight}px`;
      } else {
        tcStyle.minHeight = `${cellHeight}px`;
      }
      const tdVNs = [];
      if (fixedHiddenColumn && isAllOverflow) {
        tdVNs.push(h("div", {
          key: "tc",
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: tcStyle
        }));
      } else {
        if (treeConfig) {
          tdVNs.push(...renderLine(rowid, cellParams, cellHeight));
        }
        tdVNs.push(h("div", {
          key: "tc",
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: tcStyle,
          title: showTitle ? $xeTable.getCellLabel(row, column) : null
        }, isVNPreEmptyStatus ? [] : [
          h("div", {
            colid,
            rowid,
            class: "vxe-cell--wrapper vxe-body-cell--wrapper"
          }, column.renderCell(cellParams))
        ]));
        if (showValidTip && errorValidItem) {
          const errRule = errorValidItem.rule;
          const validSlot = slots ? slots.valid : null;
          const validParams = Object.assign(Object.assign(Object.assign({}, cellParams), errorValidItem), { rule: errorValidItem });
          tdVNs.push(h("div", {
            key: "tcv",
            class: ["vxe-cell--valid-error-tip", getPropClass(validOpts.className, validParams)],
            style: errRule && errRule.maxWidth ? {
              width: `${errRule.maxWidth}px`
            } : null
          }, [
            h("div", {
              class: `vxe-cell--valid-error-wrapper vxe-cell--valid-error-theme-${validOpts.theme || "normal"}`
            }, [
              validSlot ? $xeTable.callSlot(validSlot, validParams) : [
                h("span", {
                  class: "vxe-cell--valid-error-msg"
                }, errorValidItem.content)
              ]
            ])
          ]));
        }
      }
      let showAreaRowStatus = false;
      if (mouseConfig && mouseOpts.area && !_columnIndex && selectCellToRow) {
        showAreaRowStatus = true;
      }
      if (!fixedHiddenColumn && showResizable && isAllColumnDrag) {
        tdVNs.push(h("div", {
          key: "tcc",
          class: ["vxe-cell--col-resizable", {
            "is--line": !border || border === "none"
          }],
          onMousedown: (evnt) => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
          onDblclick: (evnt) => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
        }));
      }
      if ((rowResize || isAllRowDrag) && rowOpts.resizable) {
        tdVNs.push(h("div", {
          key: "tcr",
          class: "vxe-cell--row-resizable",
          onMousedown: (evnt) => $xeTable.handleRowResizeMousedownEvent(evnt, cellParams),
          onDblclick: (evnt) => $xeTable.handleRowResizeDblclickEvent(evnt, cellParams)
        }));
      }
      return h("td", Object.assign(Object.assign(Object.assign({ class: [
        "vxe-table--column vxe-body--column",
        colid,
        cellVerticalAlign ? `col--vertical-${cellVerticalAlign}` : "",
        cellAlign ? `col--${cellAlign}` : "",
        type ? `col--${type}` : "",
        {
          "col--last": isLastColumn,
          "col--tree-node": treeNode,
          "col--edit": isEdit,
          "col--ellipsis": hasEllipsis,
          "col--cs-height": isCsHeight,
          "col--rs-height": isRsHeight,
          "col--to-row": showAreaRowStatus,
          "col--auto-height": isVNAutoHeight,
          "fixed--width": !isAutoCellWidth,
          "fixed--hidden": fixedHiddenColumn,
          "is--padding": isCellPadding,
          "is--progress": fixedHiddenColumn && isAllOverflow || isVNPreEmptyStatus,
          "is--drag-cell": isRowDragCell && (isCrossDrag || isPeerDrag || !rowLevel),
          "is--drag-disabled": isDisabledDrag,
          "col--dirty": isDirty,
          "col--active": editConfig && isEdit && (actived.row === row && (actived.column === column || editOpts.mode === "row")),
          "col--valid-error": !!errorValidItem,
          "col--current": currentColumn === column
        },
        getPropClass(compCellClassName, cellParams),
        getPropClass(className, cellParams),
        getPropClass(allCellClassName, cellParams)
      ], key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || rowOpts.useKey || columnOpts.drag ? colid : $columnIndex }, tdAttrs), { style: Object.assign({}, import_xe_utils2.default.isFunction(compCellStyle) ? compCellStyle(cellParams) : compCellStyle, import_xe_utils2.default.isFunction(cellStyle) ? cellStyle(cellParams) : cellStyle) }), tdOns), isOptimizeMode && fixedHiddenColumn ? [] : tdVNs);
    };
    const renderRows = (fixedType, isOptimizeMode, tableData, tableColumn) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const { stripe, rowKey, highlightHoverRow, rowClassName, rowStyle, editConfig, treeConfig } = tableProps2;
      const { hasFixedColumn, treeExpandedFlag, scrollXLoad, scrollYLoad, isAllOverflow, rowExpandedFlag, expandColumn, selectRadioRow, pendingRowFlag, rowExpandHeightFlag, isRowGroupStatus } = tableReactData;
      const { fullAllDataRowIdData, fullColumnIdData, treeExpandedMaps, pendingRowMaps, rowExpandedMaps } = tableInternalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const radioOpts = computeRadioOpts.value;
      const treeOpts = computeTreeOpts.value;
      const editOpts = computeEditOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const { transform, seqMode } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rows = [];
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      const isDeepRow = treeConfig || isRowGroupStatus;
      tableData.forEach((row, $rowIndex) => {
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid] || {};
        let rowIndex = $rowIndex;
        let rowLevel = 0;
        let seq = -1;
        let _rowIndex = -1;
        const hasRowGroupAggregate = isRowGroupStatus && row.isAggregate;
        const trOn = {};
        if (rowOpts.isHover || highlightHoverRow) {
          trOn.onMouseover = (evnt) => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.triggerHoverEvent(evnt, { row, rowIndex });
          };
          trOn.onMouseleave = () => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.clearHoverRow();
          };
        }
        if (rowRest) {
          rowIndex = rowRest.index;
          _rowIndex = rowRest._index;
          rowLevel = rowRest.level;
          seq = rowRest.seq;
          if (hasRowGroupAggregate || treeConfig && transform && seqMode === "increasing") {
            seq = rowRest._index + 1;
          } else if (treeConfig && seqMode === "fixed") {
            seq = rowRest._tIndex + 1;
          }
        }
        const params = {
          $table: $xeTable,
          seq,
          rowid,
          fixed: fixedType,
          type: renderType,
          level: rowLevel,
          row,
          rowIndex,
          $rowIndex,
          _rowIndex
        };
        const isExpandRow = expandColumn && !!rowExpandedFlag && !!rowExpandedMaps[rowid];
        let isExpandTree = false;
        let rowChildren = [];
        let isNewRow = false;
        if (editConfig) {
          isNewRow = $xeTable.isInsertByRow(row);
        }
        if (treeConfig && !scrollYLoad && !transform) {
          rowChildren = row[childrenField];
          isExpandTree = !!treeExpandedFlag && rowChildren && rowChildren.length > 0 && !!treeExpandedMaps[rowid];
        }
        if (rowOpts.drag && !isRowGroupStatus && (!treeConfig || transform)) {
          trOn.onDragstart = $xeTable.handleRowDragDragstartEvent;
          trOn.onDragend = $xeTable.handleRowDragDragendEvent;
          trOn.onDragover = $xeTable.handleRowDragDragoverEvent;
        }
        const trClass = [
          "vxe-body--row",
          isDeepRow ? `row--level-${rowLevel}` : "",
          {
            "row--stripe": stripe && (_rowIndex + 1) % 2 === 0,
            "is--new": isNewRow,
            "is--expand-row": isExpandRow,
            "is--expand-tree": isExpandTree,
            "row--new": isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),
            "row--radio": radioOpts.highlight && $xeTable.eqRow(selectRadioRow, row),
            "row--checked": checkboxOpts.highlight && $xeTable.isCheckedByCheckboxRow(row),
            "row--pending": !!pendingRowFlag && !!pendingRowMaps[rowid],
            "row--group": hasRowGroupAggregate
          },
          getPropClass(rowClassName, params)
        ];
        const tdVNs = tableColumn.map((column, $columnIndex) => {
          return renderTdColumn(seq, rowid, fixedType, isOptimizeMode, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, tableColumn, tableData);
        });
        rows.push(h("tr", Object.assign({ class: trClass, rowid, style: rowStyle ? import_xe_utils2.default.isFunction(rowStyle) ? rowStyle(params) : rowStyle : null, key: rowKey || scrollXLoad || scrollYLoad || rowOpts.useKey || rowOpts.drag || columnOpts.drag || isRowGroupStatus || treeConfig ? rowid : $rowIndex }, trOn), tdVNs));
        if (isExpandRow) {
          const expandOpts = computeExpandOpts.value;
          const { height: expandHeight, padding, mode: expandMode } = expandOpts;
          if (expandMode === "fixed") {
            rows.push(h("tr", {
              class: "vxe-body--row-expanded-place",
              key: `expand_${rowid}`,
              rowid
            }, [
              h("td", {
                class: "vxe-body--row-expanded-place-column",
                colspan: tableColumn.length,
                style: {
                  height: `${rowExpandHeightFlag ? rowRest.expandHeight || expandHeight : 0}px`
                }
              })
            ]));
          } else {
            const cellStyle = {};
            if (expandHeight) {
              cellStyle.height = `${expandHeight}px`;
            }
            if (treeConfig) {
              cellStyle.paddingLeft = `${rowLevel * treeOpts.indent + 30}px`;
            }
            const { showOverflow } = expandColumn || {};
            const colid = expandColumn.id;
            const colRest = fullColumnIdData[colid] || {};
            const hasEllipsis = import_xe_utils2.default.eqNull(showOverflow) ? isAllOverflow : showOverflow;
            let columnIndex = -1;
            let $columnIndex = -1;
            let _columnIndex = -1;
            if (colRest) {
              columnIndex = colRest.index;
              $columnIndex = colRest.$index;
              _columnIndex = colRest._index;
            }
            const expandParams = {
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt,
              seq,
              column: expandColumn,
              columnIndex,
              $columnIndex,
              _columnIndex,
              fixed: fixedType,
              source: sourceType,
              type: renderType,
              level: rowLevel,
              row,
              rowid,
              rowIndex,
              $rowIndex,
              _rowIndex,
              isHidden: false,
              isEdit: false,
              visibleData: [],
              data: [],
              items: []
            };
            rows.push(h("tr", {
              class: ["vxe-body--expanded-row", {
                "is--padding": padding
              }],
              key: `expand_${rowid}`
            }, [
              h("td", {
                class: ["vxe-body--expanded-column", {
                  "fixed--hidden": fixedType && !hasFixedColumn,
                  "col--ellipsis": hasEllipsis
                }],
                colspan: tableColumn.length
              }, [
                h("div", {
                  class: ["vxe-body--expanded-cell", {
                    "is--ellipsis": expandHeight
                  }],
                  style: cellStyle
                }, [
                  expandColumn.renderData(expandParams)
                ])
              ])
            ]));
          }
        }
        if (isExpandTree) {
          rows.push(...renderRows(fixedType, isOptimizeMode, rowChildren, tableColumn));
        }
      });
      return rows;
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-body-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refBodyScroll;
        elemStore[`${prefix}table`] = refBodyTable;
        elemStore[`${prefix}colgroup`] = refBodyColgroup;
        elemStore[`${prefix}list`] = refBodyTBody;
        elemStore[`${prefix}xSpace`] = refBodyXSpace;
        elemStore[`${prefix}ySpace`] = refBodyYSpace;
        elemStore[`${prefix}emptyBlock`] = refBodyEmptyBlock;
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-body-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}ySpace`] = null;
      elemStore[`${prefix}emptyBlock`] = null;
    });
    const renderVN = () => {
      const { slots } = tableContext;
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const { fixedColumn, fixedType, tableColumn } = props;
      const { mouseConfig } = tableProps2;
      const { isGroup, tableData, isColLoading, overflowX, scrollXLoad, scrollYLoad, dragRow, dragCol } = tableReactData;
      const { visibleColumn, fullAllDataRowIdData, fullColumnIdData } = tableInternalData;
      const emptyOpts = computeEmptyOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const isBodyRenderOptimize = computeIsBodyRenderOptimize.value;
      let renderDataList = tableData;
      let renderColumnList = tableColumn;
      const isOptimizeMode = isBodyRenderOptimize;
      if (!isColLoading && (fixedType || !overflowX)) {
        renderColumnList = visibleColumn;
      }
      if (fixedType) {
        if (isOptimizeMode) {
          renderColumnList = fixedColumn || [];
        }
      }
      if (scrollYLoad && dragRow) {
        if (renderDataList.length > 2) {
          const dRowRest = fullAllDataRowIdData[getRowid($xeTable, dragRow)];
          if (dRowRest) {
            const drIndex = dRowRest._index;
            const firstRow = renderDataList[0];
            const lastRow = renderDataList[renderDataList.length - 1];
            const firstRowRest = fullAllDataRowIdData[getRowid($xeTable, firstRow)];
            const lastRowRest = fullAllDataRowIdData[getRowid($xeTable, lastRow)];
            if (firstRowRest && lastRowRest) {
              const frIndex = firstRowRest._index;
              const lrIndex = lastRowRest._index;
              if (drIndex < frIndex) {
                renderDataList = [dragRow].concat(renderDataList);
              } else if (drIndex > lrIndex) {
                renderDataList = renderDataList.concat([dragRow]);
              }
            }
          }
        }
      }
      if (!fixedType && !isGroup) {
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                }
              }
            }
          }
        }
      }
      let emptyContent;
      const emptySlot = slots ? slots.empty : null;
      const emptyParams = { $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt };
      if (emptySlot) {
        emptyContent = $xeTable.callSlot(emptySlot, emptyParams);
      } else {
        const compConf = emptyOpts.name ? renderer.get(emptyOpts.name) : null;
        const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (rtEmptyView) {
          emptyContent = getSlotVNs(rtEmptyView(emptyOpts, emptyParams));
        } else {
          emptyContent = tableProps2.emptyText || getI18n("vxe.table.emptyText");
        }
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table--body-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID
      }, [
        h("div", {
          ref: refBodyScroll,
          class: "vxe-table--body-inner-wrapper",
          onScroll(evnt) {
            $xeTable.triggerBodyScrollEvent(evnt, fixedType);
          }
        }, [
          fixedType ? renderEmptyElement($xeTable) : h("div", {
            ref: refBodyXSpace,
            class: "vxe-body--x-space"
          }),
          h("div", {
            ref: refBodyYSpace,
            class: "vxe-body--y-space"
          }),
          h("table", {
            ref: refBodyTable,
            class: "vxe-table--body",
            xid: xID,
            cellspacing: 0,
            cellpadding: 0,
            border: 0,
            xvm: isOptimizeMode ? "1" : null
          }, [
            /**
             * 列宽
             */
            h("colgroup", {
              ref: refBodyColgroup
            }, renderColumnList.map((column, $columnIndex) => {
              return h("col", {
                name: column.id,
                key: $columnIndex,
                style: {
                  width: `${column.renderWidth}px`
                }
              });
            })),
            /**
             * 内容
             */
            h("tbody", {
              ref: refBodyTBody
            }, renderRows(fixedType, isOptimizeMode, renderDataList, renderColumnList))
          ]),
          h("div", {
            class: "vxe-table--checkbox-range"
          }),
          mouseConfig && mouseOpts.area ? h("div", {
            class: "vxe-table--cell-area",
            xid: xID
          }, [
            h("span", {
              class: "vxe-table--cell-main-area"
            }, mouseOpts.extension ? [
              h("span", {
                class: "vxe-table--cell-main-area-btn",
                onMousedown(evnt) {
                  if ($xeTable.triggerCellAreaExtendMousedownEvent) {
                    $xeTable.triggerCellAreaExtendMousedownEvent(evnt, { $table: $xeTable, fixed: fixedType, type: renderType });
                  }
                }
              })
            ] : []),
            h("span", {
              class: "vxe-table--cell-clip-area"
            }),
            h("span", {
              class: "vxe-table--cell-extend-area"
            }),
            h("span", {
              class: "vxe-table--cell-multi-area"
            }),
            h("span", {
              class: "vxe-table--cell-active-area"
            }),
            h("span", {
              class: "vxe-table--cell-row-status-area"
            })
          ]) : renderEmptyElement($xeTable),
          !fixedType ? h("div", {
            class: "vxe-table--empty-block",
            ref: refBodyEmptyBlock
          }, [
            h("div", {
              class: "vxe-table--empty-content"
            }, emptyContent)
          ]) : renderEmptyElement($xeTable)
        ])
      ]);
    };
    return renderVN;
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/src/header.js
var import_xe_utils3 = __toESM(require_xe_utils());
var { renderer: renderer2, renderEmptyElement: renderEmptyElement2 } = VxeUI;
var sourceType2 = "table";
var renderType2 = "header";
function getColumnFirstChild(column) {
  const { children } = column;
  if (children && children.length) {
    return getColumnFirstChild(children[0]);
  }
  return column;
}
function getColumnLastChild(column) {
  const { children } = column;
  if (children && children.length) {
    return getColumnLastChild(children[children.length - 1]);
  }
  return column;
}
var header_default = defineVxeComponent({
  name: "VxeTableHeader",
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { xID, props: tableProps2, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { computeColumnOpts, computeColumnDragOpts, computeCellOpts, computeMouseOpts, computeHeaderCellOpts, computeDefaultRowHeight, computeVirtualXOpts, computeFloatingFilterOpts, computeIsHeaderRenderOptimize } = $xeTable.getComputeMaps();
    const headerColumn = ref([]);
    const refElem = ref();
    const refHeaderScroll = ref();
    const refHeaderTable = ref();
    const refHeaderColgroup = ref();
    const refHeaderTHead = ref();
    const refHeaderXSpace = ref();
    const refHeaderBorderRepair = ref();
    const uploadColumn = () => {
      const { showCustomHeader } = tableProps2;
      const { collectColumn, visibleColumn } = tableInternalData;
      const { tableGroupColumn } = props;
      const { isGroup } = tableReactData;
      let spanColumns = isGroup ? convertHeaderColumnToRows(tableGroupColumn) : [];
      let visibleColgroups = [];
      if (showCustomHeader && spanColumns.length > 1) {
        visibleColgroups = convertHeaderToGridRows(spanColumns);
        spanColumns = visibleColgroups;
      }
      headerColumn.value = spanColumns;
      $xeTable.dispatchEvent("columns-change", { visibleColgroups, collectColumn, visibleColumn }, null);
    };
    const renderRows = (isGroup, isOptimizeMode, headerGroups, $rowIndex, cols) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const { fixedType } = props;
      const { resizable: allResizable, columnKey, showCustomHeader, headerCellClassName, headerCellStyle, showHeaderOverflow: allColumnHeaderOverflow, headerAlign: allHeaderAlign, align: allAlign, mouseConfig } = tableProps2;
      const { currentColumn, dragCol, scrollXLoad, scrollYLoad, overflowX, mergeHeadFlag, tableColumn } = tableReactData;
      const { fullColumnIdData, scrollXStore, mergeHeaderList, mergeHeaderCellMaps } = tableInternalData;
      const virtualXOpts = computeVirtualXOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const headerCellOpts = computeHeaderCellOpts.value;
      const currCellHeight = getCalcHeight(headerCellOpts.height) || defaultRowHeight;
      const { disabledMethod: dragDisabledMethod, isCrossDrag, isPeerDrag } = columnDragOpts;
      const isLastRow = $rowIndex === headerGroups.length - 1;
      return cols.map((column, $columnIndex) => {
        const { type, showHeaderOverflow, headerAlign, align, filters, headerClassName, editRender, cellRender } = column;
        const colid = column.id;
        const colRest = fullColumnIdData[colid] || {};
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? renderer2.get(renderOpts.name) : null;
        const isColGroup = column.children && column.children.length;
        const fixedHiddenColumn = overflowX && !isColGroup && (fixedType ? column.fixed !== fixedType : !!column.fixed);
        const isPadding = import_xe_utils3.default.isBoolean(headerCellOpts.padding) ? headerCellOpts.padding : cellOpts.padding;
        const headOverflow = import_xe_utils3.default.eqNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
        const headAlign = headerAlign || (compConf ? compConf.tableHeaderCellAlign : "") || allHeaderAlign || align || (compConf ? compConf.tableCellAlign : "") || allAlign;
        const showEllipsis = headOverflow === "ellipsis";
        const showTitle = headOverflow === "title";
        const showTooltip = headOverflow === true || headOverflow === "tooltip";
        const hasEllipsis = showTitle || showTooltip || showEllipsis;
        let hasFilter = false;
        let firstFilterOption = null;
        if (filters) {
          firstFilterOption = filters[0];
          hasFilter = filters.some((item) => item.checked);
        }
        const columnIndex = colRest.index;
        const _columnIndex = colRest._index;
        const cellParams = {
          $table: $xeTable,
          $grid: $xeGrid,
          $gantt: $xeGantt,
          $rowIndex,
          column,
          columnIndex,
          $columnIndex,
          _columnIndex,
          firstFilterOption,
          fixed: fixedType,
          source: sourceType2,
          type: renderType2,
          isHidden: fixedHiddenColumn,
          hasFilter
        };
        const thAttrs = {
          colid
        };
        let isMergeCell = false;
        if (!showCustomHeader) {
          thAttrs.colspan = column.colSpan > 1 ? column.colSpan : null;
          thAttrs.rowspan = column.rowSpan > 1 ? column.rowSpan : null;
        }
        if (mergeHeadFlag && mergeHeaderList.length && (showCustomHeader || isLastRow)) {
          const spanRest = mergeHeaderCellMaps[`${$rowIndex}:${showCustomHeader ? $columnIndex : _columnIndex}`];
          if (spanRest) {
            const { rowspan, colspan } = spanRest;
            if (!rowspan || !colspan) {
              return null;
            }
            if (rowspan > 1) {
              isMergeCell = true;
              thAttrs.rowspan = rowspan;
            }
            if (colspan > 1) {
              isMergeCell = true;
              thAttrs.colspan = colspan;
            }
          }
        }
        const thOns = {
          onClick: (evnt) => $xeTable.triggerHeaderCellClickEvent(evnt, cellParams),
          onDblclick: (evnt) => $xeTable.triggerHeaderCellDblclickEvent(evnt, cellParams)
        };
        const isColDragCell = columnOpts.drag && columnDragOpts.trigger === "cell";
        let isDisabledDrag = false;
        if (isColDragCell) {
          isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(cellParams));
        }
        if (mouseConfig || isColDragCell) {
          thOns.onMousedown = (evnt) => $xeTable.triggerHeaderCellMousedownEvent(evnt, cellParams);
        }
        if (columnOpts.drag) {
          thOns.onDragstart = $xeTable.handleHeaderCellDragDragstartEvent;
          thOns.onDragend = $xeTable.handleHeaderCellDragDragendEvent;
          thOns.onDragover = $xeTable.handleHeaderCellDragDragoverEvent;
          if (isColDragCell) {
            thOns.onMouseup = $xeTable.handleHeaderCellDragMouseupEvent;
          }
        }
        const isLastColumn = $columnIndex === cols.length - 1;
        const showResizable = import_xe_utils3.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
        const isAutoCellWidth = !column.resizeWidth && (column.minWidth === "auto" || column.width === "auto");
        let isVNPreEmptyStatus = false;
        if (isOptimizeMode && overflowX && !isGroup && !isMergeCell) {
          if (!dragCol || dragCol.id !== colid) {
            if (scrollXLoad && tableColumn.length > 10 && !column.fixed && !virtualXOpts.immediate && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
              isVNPreEmptyStatus = true;
            }
          }
        }
        const tcStyle = {};
        if (hasEllipsis) {
          tcStyle.height = `${currCellHeight}px`;
        } else {
          tcStyle.minHeight = `${currCellHeight}px`;
        }
        if (showCustomHeader) {
        } else if (isColGroup && !isLastRow) {
          const firstCol = getColumnFirstChild(column);
          const lastCol = getColumnLastChild(column);
          if (firstCol && lastCol && firstCol.id !== lastCol.id) {
            const firstColRest = fullColumnIdData[firstCol.id];
            const lastColRest = fullColumnIdData[lastCol.id];
            if (firstColRest && lastColRest) {
              tcStyle.width = `${lastColRest.oLeft - firstColRest.oLeft + lastCol.renderWidth}px`;
            }
          }
        }
        return h("th", Object.assign(Object.assign(Object.assign({ class: [
          "vxe-table--column vxe-header--column",
          colid,
          fixedHiddenColumn ? "fixed--hidden" : "fixed--visible",
          {
            [`col--${headAlign}`]: headAlign,
            [`col--${type}`]: type,
            "col--last": isLastColumn,
            "col--fixed": column.fixed,
            "col--group": isColGroup,
            "col--ellipsis": hasEllipsis,
            "fixed--width": !isAutoCellWidth,
            "is--padding": isPadding,
            "is--sortable": column.sortable,
            "col--filter": !!filters,
            "is--filter-active": hasFilter,
            "is--drag-active": columnOpts.drag && !column.fixed && !isDisabledDrag && (isCrossDrag || isPeerDrag || !column.parentId),
            "is--drag-disabled": columnOpts.drag && isDisabledDrag,
            "col--current": currentColumn === column
          },
          headerClassName ? import_xe_utils3.default.isFunction(headerClassName) ? headerClassName(cellParams) : headerClassName : "",
          headerCellClassName ? import_xe_utils3.default.isFunction(headerCellClassName) ? headerCellClassName(cellParams) : headerCellClassName : ""
        ], style: headerCellStyle ? import_xe_utils3.default.isFunction(headerCellStyle) ? headerCellStyle(cellParams) : headerCellStyle : null }, thAttrs), thOns), { key: showCustomHeader ? `${colid}${$columnIndex}` : columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || columnOpts.drag || isColGroup ? colid : $columnIndex }), [
          h("div", {
            class: ["vxe-cell", {
              "c--title": showTitle,
              "c--tooltip": showTooltip,
              "c--ellipsis": showEllipsis
            }],
            style: tcStyle
          }, isVNPreEmptyStatus || isOptimizeMode && fixedHiddenColumn ? [] : [
            h("div", {
              colid,
              class: "vxe-cell--wrapper vxe-header-cell--wrapper"
            }, column.renderHeader(cellParams))
          ]),
          /**
           * 列宽拖动
           */
          !fixedHiddenColumn && showResizable && (!showCustomHeader || isLastRow) ? h("div", {
            class: "vxe-cell--col-resizable",
            onMousedown: (evnt) => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
            onDblclick: (evnt) => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
          }) : renderEmptyElement2($xeTable)
        ]);
      });
    };
    const renderFilterRows = (isOptimizeMode, cols) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const { fixedType } = props;
      const { showHeaderOverflow: allColumnHeaderOverflow, headerAlign: allHeaderAlign, align: allAlign } = tableProps2;
      const { currentColumn, overflowX } = tableReactData;
      const { fullColumnIdData } = tableInternalData;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const headerCellOpts = computeHeaderCellOpts.value;
      const currCellHeight = getCalcHeight(headerCellOpts.height) || defaultRowHeight;
      return cols.map((column, $columnIndex) => {
        const { type, showHeaderOverflow, headerAlign, align, filters, editRender, cellRender, floatingFilters, filterRender, slots } = column;
        const colid = column.id;
        const colRest = fullColumnIdData[colid] || {};
        const renderOpts = editRender || cellRender;
        const flSlot = slots ? slots.floatingFilter || slots["floating-filter"] : null;
        const compConf = renderOpts ? renderer2.get(renderOpts.name) : null;
        const flCompConf = isEnableConf(filterRender) ? renderer2.get(filterRender.name) : null;
        const rtFloatingFilter = flCompConf ? flCompConf.renderTableFloatingFilter : null;
        const fixedHiddenColumn = overflowX && (fixedType ? column.fixed !== fixedType : !!column.fixed);
        const isPadding = import_xe_utils3.default.isBoolean(headerCellOpts.padding) ? headerCellOpts.padding : cellOpts.padding;
        const headOverflow = import_xe_utils3.default.eqNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
        const headAlign = headerAlign || (compConf ? compConf.tableHeaderCellAlign : "") || allHeaderAlign || align || (compConf ? compConf.tableCellAlign : "") || allAlign;
        const showEllipsis = headOverflow === "ellipsis";
        const showTitle = headOverflow === "title";
        const showTooltip = headOverflow === true || headOverflow === "tooltip";
        const hasEllipsis = showTitle || showTooltip || showEllipsis;
        let hasFilter = false;
        let firstFilterOption = null;
        if (filters) {
          firstFilterOption = filters[0];
          hasFilter = filters.some((item) => item.checked);
        }
        const columnIndex = colRest.index;
        const _columnIndex = colRest._index;
        const cellParams = {
          $table: $xeTable,
          $grid: $xeGrid,
          $gantt: $xeGantt,
          column,
          columnIndex,
          $columnIndex,
          _columnIndex,
          option: firstFilterOption,
          fixed: fixedType,
          source: sourceType2,
          type: renderType2,
          isHidden: fixedHiddenColumn,
          hasFilter
        };
        const thAttrs = {
          colid
        };
        const isLastColumn = $columnIndex === cols.length - 1;
        const isAutoCellWidth = !column.resizeWidth && (column.minWidth === "auto" || column.width === "auto");
        const tcStyle = {};
        if (hasEllipsis) {
          tcStyle.height = `${currCellHeight}px`;
        } else {
          tcStyle.minHeight = `${currCellHeight}px`;
        }
        return h("th", Object.assign({ class: [
          "vxe-table--column vxe-header--column",
          colid,
          fixedHiddenColumn ? "fixed--hidden" : "fixed--visible",
          {
            [`col--${headAlign}`]: headAlign,
            [`col--${type}`]: type,
            "col--last": isLastColumn,
            "col--fixed": column.fixed,
            "col--ellipsis": hasEllipsis,
            "fixed--width": !isAutoCellWidth,
            "is--padding": isPadding,
            "is--sortable": column.sortable,
            "col--current": currentColumn === column
          }
        ], key: colid }, thAttrs), [
          h("div", {
            class: ["vxe-cell", {
              "c--title": showTitle,
              "c--tooltip": showTooltip,
              "c--ellipsis": showEllipsis
            }],
            style: tcStyle
          }, isOptimizeMode && fixedHiddenColumn && !floatingFilters ? [] : [
            h("div", {
              colid,
              class: "vxe-cell--wrapper vxe-header-cell--wrapper"
            }, flSlot ? $xeTable.callSlot(flSlot, cellParams) : rtFloatingFilter && firstFilterOption ? getSlotVNs(rtFloatingFilter(filterRender, cellParams)) : [])
          ])
        ]);
      });
    };
    const renderHeads = (isGroup, isOptimizeMode, headerGroups) => {
      const { fixedType } = props;
      const { headerRowClassName, headerRowStyle } = tableProps2;
      const floatingFilterOpts = computeFloatingFilterOpts.value;
      const rowVNs = headerGroups.map((cols, $rowIndex) => {
        const params = { $table: $xeTable, $rowIndex, fixed: fixedType, type: renderType2 };
        return h("tr", {
          key: $rowIndex,
          class: [
            "vxe-header--row",
            headerRowClassName ? import_xe_utils3.default.isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ""
          ],
          style: headerRowStyle ? import_xe_utils3.default.isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : null
        }, renderRows(isGroup, isOptimizeMode, headerGroups, $rowIndex, cols));
      });
      if (floatingFilterOpts.enabled) {
        rowVNs.push(h("tr", {
          key: "ff",
          class: [
            "vxe-header--row"
          ]
        }, renderFilterRows(isOptimizeMode, headerGroups[headerGroups.length - 1])));
      }
      return rowVNs;
    };
    const renderVN = () => {
      const { fixedType, fixedColumn, tableColumn } = props;
      const { mouseConfig } = tableProps2;
      const { isGroup, isColLoading, overflowX, scrollXLoad, dragCol } = tableReactData;
      const { visibleColumn, fullColumnIdData } = tableInternalData;
      const mouseOpts = computeMouseOpts.value;
      const isHeaderRenderOptimize = computeIsHeaderRenderOptimize.value;
      let renderHeaderList = headerColumn.value || [];
      let renderColumnList = tableColumn;
      const isOptimizeMode = isHeaderRenderOptimize;
      if (isGroup) {
        renderColumnList = visibleColumn;
      } else {
        if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
          renderColumnList = visibleColumn;
        }
        if (fixedType) {
          if (isOptimizeMode) {
            renderColumnList = fixedColumn || [];
          }
        }
        renderHeaderList = [renderColumnList];
      }
      if (!fixedType && !isGroup) {
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                  renderHeaderList = [[dragCol].concat(renderHeaderList[0])].concat(renderHeaderList.slice(1));
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                  renderHeaderList = [renderHeaderList[0].concat([dragCol])].concat(renderHeaderList.slice(1));
                }
              }
            }
          }
        }
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table--header-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID
      }, [
        h("div", {
          ref: refHeaderScroll,
          class: "vxe-table--header-inner-wrapper",
          onScroll(evnt) {
            $xeTable.triggerHeaderScrollEvent(evnt, fixedType);
          }
        }, [
          fixedType ? renderEmptyElement2($xeTable) : h("div", {
            ref: refHeaderXSpace,
            class: "vxe-body--x-space"
          }),
          h("table", {
            ref: refHeaderTable,
            class: "vxe-table--header",
            xid: xID,
            cellspacing: 0,
            cellpadding: 0,
            border: 0,
            xvm: isOptimizeMode ? "1" : null
          }, [
            /**
             * 列宽
             */
            h("colgroup", {
              ref: refHeaderColgroup
            }, renderColumnList.map((column, $columnIndex) => {
              return h("col", {
                name: column.id,
                key: $columnIndex,
                style: {
                  width: `${column.renderWidth}px`
                }
              });
            })),
            /**
             * 头部
             */
            h("thead", {
              ref: refHeaderTHead
            }, renderHeads(isGroup, isOptimizeMode, renderHeaderList))
          ]),
          mouseConfig && mouseOpts.area ? h("div", {
            class: "vxe-table--cell-area",
            xid: xID
          }, [
            h("span", {
              class: "vxe-table--cell-main-area"
            }),
            h("span", {
              class: "vxe-table--cell-clip-area"
            }),
            h("span", {
              class: "vxe-table--cell-extend-area"
            }),
            h("span", {
              class: "vxe-table--cell-multi-area"
            }),
            h("span", {
              class: "vxe-table--cell-active-area"
            }),
            h("span", {
              class: "vxe-table--cell-col-status-area"
            })
          ]) : renderEmptyElement2($xeTable)
        ])
      ]);
    };
    watch(() => props.tableColumn, uploadColumn);
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { internalData } = $xeTable;
        const { elemStore } = internalData;
        const prefix = `${fixedType || "main"}-header-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refHeaderScroll;
        elemStore[`${prefix}table`] = refHeaderTable;
        elemStore[`${prefix}colgroup`] = refHeaderColgroup;
        elemStore[`${prefix}list`] = refHeaderTHead;
        elemStore[`${prefix}xSpace`] = refHeaderXSpace;
        elemStore[`${prefix}repair`] = refHeaderBorderRepair;
        uploadColumn();
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { internalData } = $xeTable;
      const { elemStore } = internalData;
      const prefix = `${fixedType || "main"}-header-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}repair`] = null;
    });
    return renderVN;
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/src/footer.js
var import_xe_utils4 = __toESM(require_xe_utils());
var { renderer: renderer3, renderEmptyElement: renderEmptyElement3 } = VxeUI;
var sourceType3 = "table";
var renderType3 = "footer";
var footer_default = defineVxeComponent({
  name: "VxeTableFooter",
  props: {
    footerTableData: {
      type: Array,
      default: () => []
    },
    tableColumn: {
      type: Array,
      default: () => []
    },
    fixedColumn: {
      type: Array,
      default: () => []
    },
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { xID, props: tableProps2, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { computeFooterTooltipOpts, computeColumnOpts, computeCellOpts, computeFooterCellOpts, computeDefaultRowHeight, computeResizableOpts, computeVirtualXOpts, computeIsFooterRenderOptimize } = $xeTable.getComputeMaps();
    const refElem = ref();
    const refFooterScroll = ref();
    const refFooterTable = ref();
    const refFooterColgroup = ref();
    const refFooterTFoot = ref();
    const refFooterXSpace = ref();
    const renderRows = (isOptimizeMode, tableColumn, footerTableData, row, $rowIndex, _rowIndex) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const { fixedType } = props;
      const { resizable: allResizable, border, footerCellClassName, footerCellStyle, footerAlign: allFooterAlign, footerSpanMethod, align: allAlign, columnKey, showFooterOverflow: allColumnFooterOverflow } = tableProps2;
      const { scrollXLoad, scrollYLoad, overflowX, currentColumn, mergeFootFlag } = tableReactData;
      const { fullColumnIdData, mergeFooterList, mergeFooterCellMaps, scrollXStore } = tableInternalData;
      const virtualXOpts = computeVirtualXOpts.value;
      const footerTooltipOpts = computeFooterTooltipOpts.value;
      const resizableOpts = computeResizableOpts.value;
      const { isAllColumnDrag } = resizableOpts;
      const columnOpts = computeColumnOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const cellOpts = computeCellOpts.value;
      const footerCellOpts = computeFooterCellOpts.value;
      const currCellHeight = getCalcHeight(footerCellOpts.height) || defaultRowHeight;
      return tableColumn.map((column, $columnIndex) => {
        const { type, showFooterOverflow, footerAlign, align, footerClassName, editRender, cellRender } = column;
        const colid = column.id;
        const colRest = fullColumnIdData[colid] || {};
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? renderer3.get(renderOpts.name) : null;
        const showAllTip = footerTooltipOpts.showAll;
        const fixedHiddenColumn = overflowX && (fixedType ? column.fixed !== fixedType : !!column.fixed);
        const isPadding = import_xe_utils4.default.isBoolean(footerCellOpts.padding) ? footerCellOpts.padding : cellOpts.padding;
        const footOverflow = import_xe_utils4.default.eqNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
        const footAlign = footerAlign || (compConf ? compConf.tableFooterCellAlign : "") || allFooterAlign || align || (compConf ? compConf.tableCellAlign : "") || allAlign;
        const showEllipsis = footOverflow === "ellipsis";
        const showTitle = footOverflow === "title";
        const showTooltip = footOverflow === true || footOverflow === "tooltip";
        const hasEllipsis = showTitle || showTooltip || showEllipsis;
        const showResizable = import_xe_utils4.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
        const attrs = { colid };
        const tfOns = {};
        const columnIndex = colRest.index;
        const _columnIndex = colRest._index;
        const itemIndex = _columnIndex;
        const cellParams = {
          $table: $xeTable,
          $grid: $xeGrid,
          $gantt: $xeGantt,
          row,
          rowIndex: _rowIndex,
          _rowIndex,
          $rowIndex,
          column,
          columnIndex,
          $columnIndex,
          _columnIndex,
          itemIndex,
          items: row,
          fixed: fixedType,
          source: sourceType3,
          type: renderType3,
          data: footerTableData
        };
        if (showTitle || showTooltip || showAllTip) {
          tfOns.onMouseenter = (evnt) => {
            if (showTitle) {
              updateCellTitle(evnt.currentTarget, column);
            } else if (showTooltip || showAllTip) {
              $xeTable.triggerFooterTooltipEvent(evnt, cellParams);
            }
          };
        }
        if (showTooltip || showAllTip) {
          tfOns.onMouseleave = (evnt) => {
            if (showTooltip || showAllTip) {
              $xeTable.handleTargetLeaveEvent(evnt);
            }
          };
        }
        tfOns.onClick = (evnt) => {
          $xeTable.dispatchEvent("footer-cell-click", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
        tfOns.onDblclick = (evnt) => {
          $xeTable.dispatchEvent("footer-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
        let isMergeCell = false;
        if (mergeFootFlag && mergeFooterList.length) {
          const spanRest = mergeFooterCellMaps[`${_rowIndex}:${_columnIndex}`];
          if (spanRest) {
            const { rowspan, colspan } = spanRest;
            if (!rowspan || !colspan) {
              return null;
            }
            if (rowspan > 1) {
              isMergeCell = true;
              attrs.rowspan = rowspan;
            }
            if (colspan > 1) {
              isMergeCell = true;
              attrs.colspan = colspan;
            }
          }
        } else if (footerSpanMethod) {
          const { rowspan = 1, colspan = 1 } = footerSpanMethod(cellParams) || {};
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            attrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            attrs.colspan = colspan;
          }
        }
        const isLastColumn = $columnIndex === tableColumn.length - 1;
        const isAutoCellWidth = !column.resizeWidth && (column.minWidth === "auto" || column.width === "auto");
        let isVNPreEmptyStatus = false;
        if (isOptimizeMode && overflowX && !isMergeCell) {
          if (scrollXLoad && tableColumn.length > 10 && !column.fixed && !virtualXOpts.immediate && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          }
        }
        const tcStyle = {};
        if (hasEllipsis) {
          tcStyle.height = `${currCellHeight}px`;
        } else {
          tcStyle.minHeight = `${currCellHeight}px`;
        }
        return h("td", Object.assign(Object.assign(Object.assign(Object.assign({ class: ["vxe-table--column vxe-footer--column", column.id, {
          [`col--${footAlign}`]: footAlign,
          [`col--${type}`]: type,
          "col--last": isLastColumn,
          "fixed--width": !isAutoCellWidth,
          "fixed--hidden": fixedHiddenColumn,
          "is--padding": isPadding,
          "col--ellipsis": hasEllipsis,
          "col--current": currentColumn === column
        }, getPropClass(footerClassName, cellParams), getPropClass(footerCellClassName, cellParams)] }, attrs), { style: footerCellStyle ? import_xe_utils4.default.isFunction(footerCellStyle) ? footerCellStyle(cellParams) : footerCellStyle : null }), tfOns), { key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || columnOpts.drag ? column.id : $columnIndex }), [
          h("div", {
            class: ["vxe-cell", {
              "c--title": showTitle,
              "c--tooltip": showTooltip,
              "c--ellipsis": showEllipsis
            }],
            style: tcStyle
          }, isVNPreEmptyStatus ? [] : [
            h("div", {
              colid,
              class: "vxe-cell--wrapper vxe-footer-cell--wrapper"
            }, column.renderFooter(cellParams))
          ]),
          /**
           * 列宽拖动
           */
          !fixedHiddenColumn && showResizable && isAllColumnDrag ? h("div", {
            class: ["vxe-cell--col-resizable", {
              "is--line": !border || border === "none"
            }],
            onMousedown: (evnt) => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
            onDblclick: (evnt) => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
          }) : renderEmptyElement3($xeTable)
        ]);
      });
    };
    const renderHeads = (isOptimizeMode, renderColumnList) => {
      const { fixedType, footerTableData } = props;
      const { footerRowClassName, footerRowStyle } = tableProps2;
      return footerTableData.map((row, $rowIndex) => {
        const _rowIndex = $rowIndex;
        const rowParams = { $table: $xeTable, row, _rowIndex, $rowIndex, fixed: fixedType, type: renderType3 };
        return h("tr", {
          key: $rowIndex,
          class: [
            "vxe-footer--row",
            footerRowClassName ? import_xe_utils4.default.isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ""
          ],
          style: footerRowStyle ? import_xe_utils4.default.isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
        }, renderRows(isOptimizeMode, renderColumnList, footerTableData, row, $rowIndex, _rowIndex));
      });
    };
    const renderVN = () => {
      const { fixedType, fixedColumn, tableColumn } = props;
      const { visibleColumn, fullColumnIdData } = tableInternalData;
      const { isGroup, isColLoading, overflowX, scrollXLoad, dragCol } = tableReactData;
      const isFooterRenderOptimize = computeIsFooterRenderOptimize.value;
      let renderColumnList = tableColumn;
      const isOptimizeMode = isFooterRenderOptimize;
      if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
        renderColumnList = visibleColumn;
      }
      if (fixedType) {
        if (isOptimizeMode) {
          renderColumnList = fixedColumn || [];
        }
      }
      if (!fixedType && !isGroup) {
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                }
              }
            }
          }
        }
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table--footer-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID
      }, [
        h("div", {
          ref: refFooterScroll,
          class: "vxe-table--footer-inner-wrapper",
          onScroll(evnt) {
            $xeTable.triggerFooterScrollEvent(evnt, fixedType);
          }
        }, [
          fixedType ? renderEmptyElement3($xeTable) : h("div", {
            ref: refFooterXSpace,
            class: "vxe-body--x-space"
          }),
          h("table", {
            ref: refFooterTable,
            class: "vxe-table--footer",
            xid: xID,
            cellspacing: 0,
            cellpadding: 0,
            border: 0,
            xvm: isOptimizeMode ? "1" : null
          }, [
            /**
            * 列宽
            */
            h("colgroup", {
              ref: refFooterColgroup
            }, renderColumnList.map((column, $columnIndex) => {
              return h("col", {
                name: column.id,
                key: $columnIndex,
                style: {
                  width: `${column.renderWidth}px`
                }
              });
            })),
            /**
            * 底部
            */
            h("tfoot", {
              ref: refFooterTFoot
            }, renderHeads(isOptimizeMode, renderColumnList))
          ])
        ])
      ]);
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-footer-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refFooterScroll;
        elemStore[`${prefix}table`] = refFooterTable;
        elemStore[`${prefix}colgroup`] = refFooterColgroup;
        elemStore[`${prefix}list`] = refFooterTFoot;
        elemStore[`${prefix}xSpace`] = refFooterXSpace;
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-footer-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
    });
    return renderVN;
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/src/props.js
var { getConfig } = VxeUI;
var tableProps = {
  /** 基本属性 */
  id: [String, Function],
  // 数据
  data: Array,
  // 表格的高度
  height: [Number, String],
  // 表格的最小高度
  minHeight: {
    type: [Number, String],
    default: () => null
  },
  // 表格的最大高度
  maxHeight: [Number, String],
  // 已废弃，被 column-config.resizable 替换
  resizable: {
    type: Boolean,
    default: () => getConfig().table.resizable
  },
  // 是否带有斑马纹
  stripe: {
    type: Boolean,
    default: () => getConfig().table.stripe
  },
  // 是否带有边框
  border: {
    type: [Boolean, String],
    default: () => getConfig().table.border
  },
  // 已废弃，被 cell-config.padding 替换
  padding: {
    type: Boolean,
    default: null
  },
  // 是否圆角边框
  round: {
    type: Boolean,
    default: () => getConfig().table.round
  },
  // 表格的尺寸
  size: {
    type: String,
    default: () => getConfig().table.size || getConfig().size
  },
  // 列的宽度是否自撑开（可能会被废弃的参数，不要使用）
  fit: {
    type: Boolean,
    default: () => getConfig().table.fit
  },
  // 表格是否加载中
  loading: Boolean,
  // 所有的列对其方式
  align: {
    type: String,
    default: () => getConfig().table.align
  },
  // 所有的表头列的对齐方式
  headerAlign: {
    type: String,
    default: () => getConfig().table.headerAlign
  },
  // 所有的表尾列的对齐方式
  footerAlign: {
    type: String,
    default: () => getConfig().table.footerAlign
  },
  // 是否显示表头
  showHeader: {
    type: Boolean,
    default: () => getConfig().table.showHeader
  },
  // （即将废弃）是否要高亮当前选中行
  highlightCurrentRow: {
    type: Boolean,
    default: () => getConfig().table.highlightCurrentRow
  },
  // （即将废弃）鼠标移到行是否要高亮显示
  highlightHoverRow: {
    type: Boolean,
    default: () => getConfig().table.highlightHoverRow
  },
  /**
   * （即将废弃）是否要高亮当前选中列
   * @deprecated
   */
  highlightCurrentColumn: {
    type: Boolean,
    default: () => getConfig().table.highlightCurrentColumn
  },
  /**
   * （即将废弃）鼠标移到列是否要高亮显示
   * @deprecated
   */
  highlightHoverColumn: {
    type: Boolean,
    default: () => getConfig().table.highlightHoverColumn
  },
  // （即将废弃）激活单元格编辑时是否高亮显示
  highlightCell: Boolean,
  // 是否显示表尾合计
  showFooter: Boolean,
  // 表尾数据
  footerData: Array,
  // 表尾合计的计算方法
  footerMethod: Function,
  // 给行附加 className
  rowClassName: [String, Function],
  // 给单元格附加 className
  cellClassName: [String, Function],
  // 给表头的行附加 className
  headerRowClassName: [String, Function],
  // 给表头的单元格附加 className
  headerCellClassName: [String, Function],
  // 给表尾的行附加 className
  footerRowClassName: [String, Function],
  // 给表尾的单元格附加 className
  footerCellClassName: [String, Function],
  // 给单元格附加样式
  cellStyle: [Object, Function],
  // 给表头单元格附加样式
  headerCellStyle: [Object, Function],
  // 给表尾单元格附加样式
  footerCellStyle: [Object, Function],
  // 给行附加样式
  rowStyle: [Object, Function],
  // 给表头行附加样式
  headerRowStyle: [Object, Function],
  // 给表尾行附加样式
  footerRowStyle: [Object, Function],
  // 用于分组表头，显示为自定义列头，配合 mergeHeaderCells 灵活实现自定义合并
  showCustomHeader: {
    type: Boolean,
    default: () => getConfig().table.showCustomHeader
  },
  // 临时合并指定的表头单元格
  mergeHeaderCells: Array,
  // 临时合并指定的单元格
  mergeCells: Array,
  // 临时合并指定的表尾单元格
  mergeFooterCells: Array,
  mergeFooterItems: Array,
  // 自定义合并行或列的方法
  spanMethod: Function,
  // 表尾合并行或列
  footerSpanMethod: Function,
  // 设置所有内容过长时显示为省略号
  showOverflow: {
    type: [Boolean, String],
    default: () => getConfig().table.showOverflow
  },
  // 设置表头所有内容过长时显示为省略号
  showHeaderOverflow: {
    type: [Boolean, String],
    default: () => getConfig().table.showHeaderOverflow
  },
  // 设置表尾所有内容过长时显示为省略号
  showFooterOverflow: {
    type: [Boolean, String],
    default: () => getConfig().table.showFooterOverflow
  },
  /** 高级属性 */
  /**
   * （即将废弃）columnKey 已废弃，被 column-config.useKey 替换
   * @deprecated
   */
  columnKey: Boolean,
  /**
   * （即将废弃）rowKey 已废弃，被 row-config.useKey 替换
   * @deprecated
   */
  rowKey: Boolean,
  /**
   * （即将废弃）rowId 已废弃，被 row-config.keyField 替换
   * @deprecated
   */
  rowId: {
    type: String,
    default: () => getConfig().table.rowId
  },
  zIndex: Number,
  emptyText: {
    type: String,
    default: () => getConfig().table.emptyText
  },
  keepSource: {
    type: Boolean,
    default: () => getConfig().table.keepSource
  },
  // 是否自动监听父容器变化去更新响应式表格宽高
  autoResize: {
    type: Boolean,
    default: () => getConfig().table.autoResize
  },
  // 是否自动根据状态属性去更新响应式表格宽高
  syncResize: [Boolean, String, Number],
  // 响应式布局配置项
  resizeConfig: Object,
  // 列配置项
  columnConfig: Object,
  // 当前列配置项
  currentColumnConfig: Object,
  // 单元格配置项
  cellConfig: Object,
  // 表头单元格配置项
  headerCellConfig: Object,
  // 表尾单元格配置项
  footerCellConfig: Object,
  // 行配置项
  rowConfig: Object,
  // 数据聚合配置项
  aggregateConfig: Object,
  /**
   * 已废弃，被 aggregateConfig 替换
   * @deprecated
   */
  rowGroupConfig: Object,
  // 当前行配置项
  currentRowConfig: Object,
  /**
   * 已废弃，被 rowDragConfig 替换
   * @deprecated
   */
  dragConfig: Object,
  // 行拖拽排序配置项
  rowDragConfig: Object,
  // 列拖拽排序配置项
  columnDragConfig: Object,
  // 列调整配置项
  resizableConfig: Object,
  // 序号配置项
  seqConfig: Object,
  // 排序配置项
  sortConfig: Object,
  // 筛选配置项
  filterConfig: Object,
  // 浮动筛选配置项
  floatingFilterConfig: Object,
  // 单选框配置
  radioConfig: Object,
  // 复选框配置项
  checkboxConfig: Object,
  // tooltip 配置项
  tooltipConfig: Object,
  // 表头 tooltip 配置项
  headerTooltipConfig: Object,
  // 表尾 tooltip 配置项
  footerTooltipConfig: Object,
  // 导出配置项
  exportConfig: Object,
  // 导入配置项
  importConfig: Object,
  // 打印配置项
  printConfig: Object,
  // 展开行配置项
  expandConfig: Object,
  // 树形结构配置项
  treeConfig: Object,
  // 快捷菜单配置项
  menuConfig: Object,
  // 鼠标配置项
  mouseConfig: Object,
  // 区域配置项
  areaConfig: Object,
  // 按键配置项
  keyboardConfig: Object,
  // 复制粘/贴配置项
  clipConfig: Object,
  // 查找/替换配置项
  fnrConfig: Object,
  // 编辑配置项
  editConfig: Object,
  // 校验配置项
  validConfig: Object,
  // 校验规则配置项
  editRules: Object,
  // 加载中配置项
  loadingConfig: Object,
  // 空内容渲染配置项
  emptyRender: Object,
  // 自定义列配置项
  customConfig: Object,
  /**
   * （即将废弃）横向虚拟滚动配置项
   * @deprecated
   */
  scrollX: Object,
  /**
   * （即将废弃）纵向虚拟滚动配置项
   * @deprecated
   */
  scrollY: Object,
  // 横向虚拟滚动配置项
  virtualXConfig: Object,
  // 纵向虚拟滚动配置项
  virtualYConfig: Object,
  // 滚动条配置项
  scrollbarConfig: Object,
  // （即将废弃）优化相关
  animat: {
    type: Boolean,
    default: () => getConfig().table.animat
  },
  // （可能会被废弃的参数，不要使用）
  delayHover: {
    type: Number,
    default: () => getConfig().table.delayHover
  },
  // 额外的参数
  params: Object
};

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/src/emits.js
var tableEmits = [
  "update:data",
  "keydown-start",
  "keydown",
  "keydown-end",
  "paste",
  "copy",
  "cut",
  "columns-change",
  "data-change",
  "footer-data-change",
  "current-change",
  "current-row-change",
  "current-row-disabled",
  "current-column-change",
  "current-column-disabled",
  "radio-change",
  "checkbox-change",
  "checkbox-all",
  "checkbox-range-start",
  "checkbox-range-change",
  "checkbox-range-end",
  "checkbox-range-select",
  "cell-click",
  "cell-dblclick",
  "cell-menu",
  "cell-mouseenter",
  "cell-mouseleave",
  "cell-selected",
  "cell-delete-value",
  "cell-backspace-value",
  "header-cell-click",
  "header-cell-dblclick",
  "header-cell-menu",
  "footer-cell-click",
  "footer-cell-dblclick",
  "footer-cell-menu",
  "clear-merge",
  "sort-change",
  "clear-sort",
  "clear-all-sort",
  "filter-change",
  "filter-visible",
  "clear-filter",
  "clear-all-filter",
  "resizable-change",
  "column-resizable-change",
  "row-resizable-change",
  "toggle-row-group-expand",
  "toggle-row-expand",
  "toggle-tree-expand",
  "menu-click",
  "edit-closed",
  "row-dragstart",
  "row-dragover",
  "row-dragend",
  "row-remove-dragend",
  "row-insert-dragend",
  "column-dragstart",
  "column-dragover",
  "column-dragend",
  "enter-append-row",
  "edit-actived",
  "edit-activated",
  "edit-disabled",
  "valid-error",
  "scroll",
  "scroll-boundary",
  "custom",
  "custom-visible-change",
  "custom-visible-all",
  "custom-fixed-change",
  "custom-sort-change",
  "change-fnr",
  "open-fnr",
  "show-fnr",
  "hide-fnr",
  "fnr-change",
  "fnr-find",
  "fnr-find-all",
  "fnr-replace",
  "fnr-replace-all",
  "cell-area-copy",
  "cell-area-cut",
  "cell-area-paste",
  "cell-area-merge",
  "clear-cell-area-selection",
  "clear-cell-area-merge",
  "header-cell-area-selection",
  "cell-area-selection-invalid",
  "cell-area-selection-start",
  "cell-area-selection-drag",
  "cell-area-selection-end",
  "cell-area-extension-start",
  "cell-area-extension-drag",
  "cell-area-extension-end",
  "cell-area-extension-fill",
  "cell-area-selection-all-start",
  "cell-area-selection-all-end",
  "cell-area-arrows-start",
  "cell-area-arrows-end",
  "active-cell-change-start",
  "active-cell-change-end"
];

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/custom/panel.js
var import_xe_utils5 = __toESM(require_xe_utils());
var { getI18n: getI18n2, getIcon, renderEmptyElement: renderEmptyElement4 } = VxeUI;
function createInternalData2() {
  return {
    // teleportTo: undefined,
    // prevDragCol: undefined,
    // prevDragGroupField: undefined,
    // prevDragAggFnColid: undefined,
    // prevDragToChild: false,
    // prevDragPos: null
  };
}
var panel_default = defineVxeComponent({
  name: "TableCustomPanel",
  props: {
    customStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props, context) {
    const xID = import_xe_utils5.default.uniqueId();
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIDrawerComponent = VxeUI.getComponent("VxeDrawer");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUINumberInputComponent = VxeUI.getComponent("VxeNumberInput");
    const VxeUIRadioGroupComponent = VxeUI.getComponent("VxeRadioGroup");
    const $xeTable = inject("$xeTable", {});
    const { props: tableProps2, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { computeCustomOpts, computeColumnDragOpts, computeColumnOpts, computeIsMaxFixedColumn, computeResizableOpts } = $xeTable.getComputeMaps();
    const refElem = ref();
    const refBodyWrapperElem = ref();
    const refCustomBodyElem = ref();
    const refDragLineElem = ref();
    const refDragTipElem = ref();
    const customPanelReactData = reactive({
      dragCol: null,
      dragGroupField: null,
      dragAggFnCol: null,
      dragTipText: ""
    });
    let customPanelInternalData = createInternalData2();
    const refMaps = {
      refElem,
      refBodyWrapperElem,
      refCustomBodyElem,
      refDragLineElem,
      refDragTipElem
    };
    const computeMaps = {};
    const handleWrapperMouseenterEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = true;
      $xeTable.customOpenEvent(evnt);
    };
    const handleWrapperMouseleaveEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xeTable.customCloseEvent(evnt);
        }
      }, 300);
    };
    const confirmCustomEvent = ({ $event }) => {
      tableReactData.isCustomStatus = true;
      $xeTable.saveCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("confirm", $event);
      $xeTable.emitCustomEvent("close", $event);
    };
    const cancelCloseEvent = ({ $event }) => {
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("close", $event);
    };
    const cancelCustomEvent = ({ $event }) => {
      $xeTable.cancelCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("cancel", $event);
      $xeTable.emitCustomEvent("close", $event);
    };
    const handleResetCustomEvent = (evnt) => {
      $xeTable.resetCustom(true);
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("reset", evnt);
      $xeTable.emitCustomEvent("close", evnt);
    };
    const resetCustomEvent = ({ $event }) => {
      if (VxeUI.modal) {
        VxeUI.modal.confirm({
          content: getI18n2("vxe.custom.cstmConfirmRestore"),
          className: "vxe-table--ignore-clear",
          escClosable: true
        }).then((type) => {
          if (type === "confirm") {
            handleResetCustomEvent($event);
          }
        });
      } else {
        handleResetCustomEvent($event);
      }
    };
    const handleOptionCheck = (column) => {
      const { customColumnList } = tableReactData;
      const matchObj = import_xe_utils5.default.findTree(customColumnList, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.renderVisible = parent.children.every((column2) => column2.renderVisible);
          parent.halfVisible = !parent.renderVisible && parent.children.some((column2) => column2.renderVisible || column2.halfVisible);
          handleOptionCheck(parent);
        }
      }
    };
    const changeCheckboxOption = (column, evnt) => {
      const isChecked = !column.renderVisible;
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        import_xe_utils5.default.eachTree([column], (item) => {
          item.visible = isChecked;
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
        tableReactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:visible");
      } else {
        import_xe_utils5.default.eachTree([column], (item) => {
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
      }
      handleOptionCheck(column);
      $xeTable.checkCustomStatus();
      $xeTable.dispatchEvent("custom-visible-change", { column, checked: isChecked }, evnt);
    };
    const changeColumnWidth = (column) => {
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        if (column.renderResizeWidth !== column.renderWidth) {
          column.resizeWidth = column.renderResizeWidth;
          column.renderWidth = column.renderResizeWidth;
          tableReactData.isCustomStatus = true;
          $xeTable.handleCustom();
          $xeTable.saveCustomStore("update:width");
        }
      }
    };
    const changeFixedOption = (column, colFixed, evnt) => {
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const customOpts = computeCustomOpts.value;
      let targetFixed = null;
      if (customOpts.immediate) {
        if (column.renderFixed === colFixed) {
          targetFixed = "";
          import_xe_utils5.default.eachTree([column], (col) => {
            col.fixed = "";
            col.renderFixed = "";
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            targetFixed = colFixed;
            import_xe_utils5.default.eachTree([column], (col) => {
              col.fixed = colFixed;
              col.renderFixed = colFixed;
            });
          }
        }
        tableReactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:fixed");
      } else {
        if (column.renderFixed === colFixed) {
          targetFixed = "";
          import_xe_utils5.default.eachTree([column], (col) => {
            col.renderFixed = "";
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            targetFixed = colFixed;
            import_xe_utils5.default.eachTree([column], (col) => {
              col.renderFixed = colFixed;
            });
          }
        }
      }
      if (targetFixed !== null) {
        $xeTable.dispatchEvent("custom-fixed-change", { column, fixed: targetFixed }, evnt);
      }
    };
    const allOptionEvent = (evnt) => {
      const { customStore } = tableReactData;
      const isAll = !customStore.isAll;
      $xeTable.toggleCustomAllCheckbox();
      $xeTable.dispatchEvent("custom-visible-all", { checked: isAll }, evnt);
    };
    const showDropTip = (evnt, optEl, showLine, dragPos) => {
      const bodyWrapperElem = refBodyWrapperElem.value;
      if (!bodyWrapperElem) {
        return;
      }
      const customBodyElem = refCustomBodyElem.value;
      if (!customBodyElem) {
        return;
      }
      const { prevDragToChild } = customPanelInternalData;
      const bodyWrapperRect = bodyWrapperElem.getBoundingClientRect();
      const customBodyRect = customBodyElem.getBoundingClientRect();
      const dragLineEl = refDragLineElem.value;
      if (optEl) {
        if (dragLineEl) {
          if (showLine) {
            const optRect = optEl.getBoundingClientRect();
            dragLineEl.style.display = "block";
            dragLineEl.style.left = `${Math.max(0, customBodyRect.x - bodyWrapperRect.x)}px`;
            dragLineEl.style.top = `${Math.max(1, optRect.y + bodyWrapperElem.scrollTop - bodyWrapperRect.y)}px`;
            dragLineEl.style.height = `${optRect.height}px`;
            dragLineEl.style.width = `${optRect.width}px`;
            dragLineEl.setAttribute("drag-pos", dragPos);
            dragLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            dragLineEl.style.display = "";
          }
        }
      } else {
        if (dragLineEl) {
          dragLineEl.style.display = "node";
        }
      }
      const dragTipEl = refDragTipElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = "block";
        dragTipEl.style.top = `${Math.min(bodyWrapperElem.clientHeight + bodyWrapperElem.scrollTop - dragTipEl.clientHeight, evnt.clientY + bodyWrapperElem.scrollTop - bodyWrapperRect.y)}px`;
        dragTipEl.style.left = `${Math.min(bodyWrapperElem.clientWidth + bodyWrapperElem.scrollLeft - dragTipEl.clientWidth, evnt.clientX + bodyWrapperElem.scrollLeft - bodyWrapperRect.x)}px`;
        dragTipEl.setAttribute("drag-status", showLine ? prevDragToChild ? "sub" : "normal" : "disabled");
      }
    };
    const updateColDropTipContent = () => {
      const { dragCol } = customPanelReactData;
      const columnDragOpts = computeColumnDragOpts.value;
      const { tooltipMethod } = columnDragOpts;
      let tipContent = "";
      if (tooltipMethod) {
        const dtParams = {
          $table: $xeTable,
          column: dragCol
        };
        tipContent = `${tooltipMethod(dtParams) || ""}`;
      } else {
        tipContent = getI18n2("vxe.custom.cstmDragTarget", [dragCol && dragCol.type !== "html" ? dragCol.getTitle() : ""]);
      }
      customPanelReactData.dragTipText = tipContent;
    };
    const hideDropTip = () => {
      const dragTipEl = refDragTipElem.value;
      const dragLineEl = refDragLineElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = "";
      }
      if (dragLineEl) {
        dragLineEl.style.display = "";
      }
    };
    const sortMousedownEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      const colid = trEl.getAttribute("colid");
      const column = $xeTable.getColumnById(colid);
      trEl.draggable = true;
      customPanelReactData.dragCol = column;
      customPanelReactData.dragGroupField = null;
      customPanelReactData.dragAggFnCol = null;
      updateColDropTipContent();
      addClass(trEl, "active--drag-origin");
    };
    const sortMouseupEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      hideDropTip();
      trEl.draggable = false;
      customPanelReactData.dragCol = null;
      customPanelReactData.dragGroupField = null;
      customPanelReactData.dragAggFnCol = null;
      removeClass(trEl, "active--drag-origin");
    };
    const sortDragstartEvent = (evnt) => {
      if (evnt.dataTransfer) {
        evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
      }
      customPanelInternalData.prevDragGroupField = null;
      customPanelInternalData.prevDragAggFnColid = null;
    };
    const sortDragendEvent = (evnt) => {
      const { mouseConfig } = tableProps2;
      const { customColumnList } = tableReactData;
      const { collectColumn } = tableInternalData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const trEl = evnt.currentTarget;
      const columnDragOpts = computeColumnDragOpts.value;
      const { isCrossDrag, isSelfToChildDrag, isToChildDrag, dragEndMethod } = columnDragOpts;
      const { dragCol } = customPanelReactData;
      const { prevDragCol, prevDragGroupField, prevDragAggFnColid, prevDragPos, prevDragToChild } = customPanelInternalData;
      const dragOffsetIndex = prevDragPos === "bottom" ? 1 : 0;
      if (prevDragGroupField || prevDragAggFnColid) {
        if ($xeTable.handlePivotTableAggregatePanelDragendEvent) {
          $xeTable.handlePivotTableAggregatePanelDragendEvent(evnt);
        }
      } else if (prevDragCol && dragCol) {
        if (prevDragCol !== dragCol) {
          const dragColumn = dragCol;
          const newColumn = prevDragCol;
          Promise.resolve(dragEndMethod ? dragEndMethod({
            oldColumn: dragColumn,
            newColumn,
            dragColumn,
            dragPos: prevDragPos,
            dragToChild: !!prevDragToChild,
            offsetIndex: dragOffsetIndex
          }) : true).then((status) => {
            if (!status) {
              return;
            }
            let oafIndex = -1;
            let nafIndex = -1;
            const oldAllMaps = {};
            import_xe_utils5.default.eachTree([dragColumn], (column) => {
              oldAllMaps[column.id] = column;
            });
            let isSelfToChildStatus = false;
            if (immediate) {
              if (dragColumn.parentId && newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n2("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else if (dragColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
              } else if (newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n2("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else {
              }
              const oldewMatchRest = import_xe_utils5.default.findTree(collectColumn, (item) => item.id === dragColumn.id);
              if (isSelfToChildStatus && (isCrossDrag && isSelfToChildDrag)) {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex } = oldewMatchRest;
                  const childList = dragColumn.children || [];
                  childList.forEach((column) => {
                    column.parentId = dragColumn.parentId;
                  });
                  oCols.splice(oIndex, 1, ...childList);
                  dragColumn.children = [];
                }
              } else {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex, parent: oParent } = oldewMatchRest;
                  oCols.splice(oIndex, 1);
                  if (!oParent) {
                    oafIndex = oIndex;
                  }
                }
              }
              const newMatchRest = import_xe_utils5.default.findTree(collectColumn, (item) => item.id === newColumn.id);
              if (newMatchRest) {
                const { items: nCols, index: nIndex, parent: nParent } = newMatchRest;
                if (isCrossDrag && isToChildDrag && prevDragToChild) {
                  dragColumn.parentId = newColumn.id;
                  newColumn.children = (newColumn.children || []).concat([dragColumn]);
                } else {
                  dragColumn.parentId = newColumn.parentId;
                  nCols.splice(nIndex + dragOffsetIndex, 0, dragColumn);
                }
                if (!nParent) {
                  nafIndex = nIndex;
                }
              }
              import_xe_utils5.default.eachTree(collectColumn, (column, index, items, path, parent) => {
                if (!parent) {
                  const sortIndex = index + 1;
                  column.renderSortNumber = sortIndex;
                }
              });
            } else {
              oafIndex = import_xe_utils5.default.findIndexOf(customColumnList, (item) => item.id === dragColumn.id);
              customColumnList.splice(oafIndex, 1);
              nafIndex = import_xe_utils5.default.findIndexOf(customColumnList, (item) => item.id === newColumn.id);
              customColumnList.splice(nafIndex + dragOffsetIndex, 0, dragColumn);
            }
            if (mouseConfig) {
              if ($xeTable.clearSelected) {
                $xeTable.clearSelected();
              }
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
            }
            const csParams = {
              oldColumn: dragColumn,
              newColumn,
              dragColumn,
              dragPos: prevDragPos,
              offsetIndex: dragOffsetIndex,
              _index: {
                newIndex: nafIndex,
                oldIndex: oafIndex
              }
            };
            $xeTable.dispatchEvent("custom-sort-change", csParams, evnt);
            $xeTable.dispatchEvent("column-dragend", csParams, evnt);
            if (immediate) {
              tableReactData.customColumnList = collectColumn.slice(0);
              $xeTable.handleColDragSwapColumn();
            }
          }).catch(() => {
          });
        }
      }
      hideDropTip();
      customPanelReactData.dragCol = null;
      customPanelReactData.dragGroupField = null;
      customPanelReactData.dragAggFnCol = null;
      customPanelInternalData.prevDragGroupField = null;
      customPanelInternalData.prevDragAggFnColid = null;
      trEl.draggable = false;
      trEl.removeAttribute("drag-pos");
      removeClass(trEl, "active--drag-target");
      removeClass(trEl, "active--drag-origin");
    };
    const sortDragoverEvent = (evnt) => {
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { isCrossDrag, isToChildDrag } = columnDragOpts;
      const optEl = evnt.currentTarget;
      const isControlKey = hasControlKey(evnt);
      const colid = optEl.getAttribute("colid");
      const column = $xeTable.getColumnById(colid);
      const { dragCol } = customPanelReactData;
      customPanelInternalData.prevDragGroupField = null;
      customPanelInternalData.prevDragAggFnColid = null;
      if (column && (isCrossDrag || column.level === 1)) {
        evnt.preventDefault();
        const offsetY = evnt.clientY - optEl.getBoundingClientRect().y;
        const dragPos = offsetY < optEl.clientHeight / 2 ? "top" : "bottom";
        if (!dragCol || dragCol && dragCol.id === column.id || !isCrossDrag && column.level > 1 || !immediate && column.level > 1) {
          showDropTip(evnt, optEl, false, dragPos);
          return;
        }
        customPanelInternalData.prevDragToChild = !!(isCrossDrag && isToChildDrag && isControlKey && immediate);
        customPanelInternalData.prevDragCol = column;
        customPanelInternalData.prevDragPos = dragPos;
        showDropTip(evnt, optEl, true, dragPos);
      }
    };
    const renderDragTip = () => {
      const { dragTipText } = customPanelReactData;
      const columnDragOpts = computeColumnDragOpts.value;
      return h("div", {}, [
        h("div", {
          ref: refDragLineElem,
          class: ["vxe-table-custom-popup--drag-line", {
            "is--guides": columnDragOpts.showGuidesStatus
          }]
        }),
        h("div", {
          ref: refDragTipElem,
          class: "vxe-table-custom-popup--drag-tip"
        }, [
          h("div", {
            class: "vxe-table-custom-popup--drag-tip-wrapper"
          }, [
            h("div", {
              class: "vxe-table-custom-popup--drag-tip-status"
            }, [
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-normal-status", getIcon().TABLE_DRAG_STATUS_ROW]
              }),
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-sub-status", getIcon().TABLE_DRAG_STATUS_SUB_ROW]
              }),
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-group-status", getIcon().TABLE_DRAG_STATUS_AGG_GROUP]
              }),
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-values-status", getIcon().TABLE_DRAG_STATUS_AGG_VALUES]
              }),
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-disabled-status", getIcon().TABLE_DRAG_DISABLED]
              })
            ]),
            h("div", {
              class: "vxe-table-custom-popup--drag-tip-content"
            }, `${dragTipText || ""}`)
          ])
        ])
      ]);
    };
    const renderSimplePanel = () => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const tableProps3 = $xeTable.props;
      const { customStore } = props;
      const { treeConfig, rowGroupConfig, aggregateConfig } = tableProps3;
      const { isCustomStatus, customColumnList } = tableReactData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { maxHeight } = customStore;
      const { checkMethod, visibleMethod, allowVisible, allowSort, allowFixed, trigger, placement } = customOpts;
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const { isCrossDrag } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const colVNs = [];
      const customWrapperOns = {};
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      if (trigger === "hover") {
        customWrapperOns.onMouseenter = handleWrapperMouseenterEvent;
        customWrapperOns.onMouseleave = handleWrapperMouseleaveEvent;
      }
      const params = {
        $table: $xeTable,
        $grid: $xeGrid,
        $gantt: $xeGantt,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      import_xe_utils5.default.eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ $table: $xeTable, column }) : true;
        if (isVisible) {
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const isColGroup = column.children && column.children.length;
          const colTitle = formatText(column.getTitle(), 1);
          const isDisabled = checkMethod ? !checkMethod({ $table: $xeTable, column }) : false;
          const isHidden = !isChecked;
          colVNs.push(h("li", {
            key: column.id,
            colid: column.id,
            class: ["vxe-table-custom--option", `level--${column.level}`, {
              "is--hidden": isDisabled || isHidden,
              "is--group": isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [
            allowVisible ? h("div", {
              class: ["vxe-table-custom--checkbox-option", {
                "is--checked": isChecked,
                "is--indeterminate": isIndeterminate,
                "is--disabled": isDisabled
              }],
              title: getI18n2("vxe.custom.setting.colVisible"),
              onClick: (evnt) => {
                if (!isDisabled) {
                  changeCheckboxOption(column, evnt);
                }
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon().TABLE_CHECKBOX_CHECKED : getIcon().TABLE_CHECKBOX_UNCHECKED]
              })
            ]) : renderEmptyElement4($xeTable),
            h("div", {
              class: "vxe-table-custom--name-option"
            }, [
              allowSort && ((isCrossDrag ? immediate : false) || column.level === 1) ? h("div", {
                class: "vxe-table-custom--sort-option"
              }, [
                h("span", Object.assign({ class: ["vxe-table-custom--sort-btn", {
                  "is--disabled": isDisabled || isHidden
                }], title: getI18n2("vxe.custom.setting.sortHelpTip") }, isDisabled || isHidden ? {} : {
                  onMousedown: sortMousedownEvent,
                  onMouseup: sortMouseupEvent
                }), [
                  h("i", {
                    class: getIcon().TABLE_CUSTOM_SORT
                  })
                ])
              ]) : renderEmptyElement4($xeTable),
              column.type === "html" ? h("div", {
                key: "1",
                class: "vxe-table-custom--checkbox-label",
                innerHTML: colTitle
              }) : h("div", {
                key: "0",
                class: "vxe-table-custom--checkbox-label"
              }, colTitle)
            ]),
            !parent && allowFixed ? h("div", {
              class: "vxe-table-custom--fixed-option"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                mode: "text",
                icon: column.renderFixed === "left" ? getIcon().TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE : getIcon().TOOLBAR_TOOLS_FIXED_LEFT,
                status: column.renderFixed === "left" ? "primary" : "",
                disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
                title: getI18n2(column.renderFixed === "left" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedLeft"),
                onClick: ({ $event }) => {
                  changeFixedOption(column, "left", $event);
                }
              }) : renderEmptyElement4($xeTable),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                mode: "text",
                icon: column.renderFixed === "right" ? getIcon().TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE : getIcon().TOOLBAR_TOOLS_FIXED_RIGHT,
                status: column.renderFixed === "right" ? "primary" : "",
                disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
                title: getI18n2(column.renderFixed === "right" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedRight"),
                onClick: ({ $event }) => {
                  changeFixedOption(column, "right", $event);
                }
              }) : renderEmptyElement4($xeTable)
            ]) : renderEmptyElement4($xeTable)
          ]));
        }
      });
      return h("div", {
        ref: refElem,
        key: "simple",
        class: ["vxe-table-custom-wrapper", `placement--${placement}`, {
          "is--active": customStore.visible
        }],
        style: maxHeight && !["left", "right"].includes(placement || "") ? {
          maxHeight: `${maxHeight}px`
        } : {}
      }, customStore.visible ? [
        h("div", {
          ref: refBodyWrapperElem,
          class: "vxe-table-custom-simple--body-wrapper"
        }, [
          !treeConfig && (aggregateConfig || rowGroupConfig) && $xeTable.getPivotTableAggregateSimplePanel ? h($xeTable.getPivotTableAggregateSimplePanel(), {
            customStore
          }) : renderEmptyElement4($xeTable),
          h("div", {
            ref: refCustomBodyElem,
            class: "vxe-table-custom--handle-wrapper"
          }, [
            h("div", {
              class: "vxe-table-custom--header"
            }, headerSlot ? $xeTable.callSlot(headerSlot, params) : [
              h("ul", {
                class: "vxe-table-custom--panel-list"
              }, [
                h("li", {
                  class: "vxe-table-custom--option"
                }, [
                  allowVisible ? h("div", {
                    class: ["vxe-table-custom--checkbox-option", {
                      "is--checked": isAllChecked,
                      "is--indeterminate": isAllIndeterminate
                    }],
                    title: getI18n2("vxe.table.allTitle"),
                    onClick: allOptionEvent
                  }, [
                    h("span", {
                      class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon().TABLE_CHECKBOX_CHECKED : getIcon().TABLE_CHECKBOX_UNCHECKED]
                    }),
                    h("span", {
                      class: "vxe-checkbox--label"
                    }, getI18n2("vxe.toolbar.customAll"))
                  ]) : h("span", {
                    class: "vxe-checkbox--label"
                  }, getI18n2("vxe.table.customTitle"))
                ])
              ])
            ]),
            h("div", {
              class: "vxe-table-custom--body"
            }, [
              topSlot ? h("div", {
                class: "vxe-table-custom--panel-top"
              }, $xeTable.callSlot(topSlot, params)) : renderEmptyElement4($xeTable),
              defaultSlot ? h("div", {
                class: "vxe-table-custom--panel-body"
              }, $xeTable.callSlot(defaultSlot, params)) : h(TransitionGroup, Object.assign({ class: "vxe-table-custom--panel-list", name: "vxe-table-custom--list", tag: "ul" }, customWrapperOns), {
                default: () => colVNs
              }),
              bottomSlot ? h("div", {
                class: "vxe-table-custom--panel-bottom"
              }, $xeTable.callSlot(bottomSlot, params)) : renderEmptyElement4($xeTable)
            ]),
            customOpts.showFooter ? h("div", {
              class: "vxe-table-custom--footer"
            }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
              h("div", {
                class: "vxe-table-custom--footer-buttons"
              }, [
                VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                  mode: "text",
                  content: customOpts.resetButtonText || getI18n2("vxe.table.customRestore"),
                  disabled: !isCustomStatus,
                  onClick: resetCustomEvent
                }) : renderEmptyElement4($xeTable),
                immediate ? VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                  mode: "text",
                  content: customOpts.closeButtonText || getI18n2("vxe.table.customClose"),
                  onClick: cancelCloseEvent
                }) : renderEmptyElement4($xeTable) : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                  mode: "text",
                  content: customOpts.cancelButtonText || getI18n2("vxe.table.customCancel"),
                  onClick: cancelCustomEvent
                }) : renderEmptyElement4($xeTable),
                immediate ? renderEmptyElement4($xeTable) : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                  mode: "text",
                  status: "primary",
                  content: customOpts.confirmButtonText || getI18n2("vxe.table.customConfirm"),
                  onClick: confirmCustomEvent
                }) : renderEmptyElement4($xeTable)
              ])
            ]) : null
          ]),
          renderDragTip()
        ])
      ] : []);
    };
    const renderPopupPanel = () => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const { customStore } = props;
      const { treeConfig, rowGroupConfig, aggregateConfig, resizable: allResizable } = tableProps2;
      const { isCustomStatus, customColumnList } = tableReactData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { mode, modalOptions, drawerOptions, allowVisible, allowSort, allowFixed, allowResizable, checkMethod, visibleMethod } = customOpts;
      const columnOpts = computeColumnOpts.value;
      const { maxFixedSize } = columnOpts;
      const resizableOpts = computeResizableOpts.value;
      const { minWidth: reMinWidth, maxWidth: reMaxWidth } = resizableOpts;
      const modalOpts = Object.assign({}, modalOptions);
      const drawerOpts = Object.assign({}, drawerOptions);
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const { isCrossDrag } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const trVNs = [];
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      const params = {
        $table: $xeTable,
        $grid: $xeGrid,
        $gantt: $xeGantt,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      import_xe_utils5.default.eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ $table: $xeTable, column }) : true;
        if (isVisible) {
          let customMinWidth = 0;
          let customMaxWidth = 0;
          if (allowResizable) {
            const resizeParams = {
              $table: $xeTable,
              column,
              columnIndex: index,
              $columnIndex: index,
              $rowIndex: -1
            };
            if (reMinWidth) {
              customMinWidth = import_xe_utils5.default.toNumber(import_xe_utils5.default.isFunction(reMinWidth) ? reMinWidth(resizeParams) : reMinWidth);
            }
            if (reMaxWidth) {
              customMaxWidth = import_xe_utils5.default.toNumber(import_xe_utils5.default.isFunction(reMaxWidth) ? reMaxWidth(resizeParams) : reMaxWidth);
            }
          }
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const colTitle = formatText(column.getTitle(), 1);
          const isColGroup = column.children && column.children.length;
          const isDisabled = checkMethod ? !checkMethod({ $table: $xeTable, column }) : false;
          const isHidden = !isChecked;
          trVNs.push(h("tr", {
            key: column.id,
            colid: column.id,
            class: [`vxe-table-custom-popup--row level--${column.level}`, {
              "is--group": isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [
            allowVisible ? h("td", {
              class: "vxe-table-custom-popup--column-item col--visible"
            }, [
              h("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": isChecked,
                  "is--indeterminate": isIndeterminate,
                  "is--disabled": isDisabled
                }],
                title: getI18n2("vxe.custom.setting.colVisible"),
                onClick: (evnt) => {
                  if (!isDisabled) {
                    changeCheckboxOption(column, evnt);
                  }
                }
              }, [
                h("span", {
                  class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon().TABLE_CHECKBOX_CHECKED : getIcon().TABLE_CHECKBOX_UNCHECKED]
                })
              ])
            ]) : renderEmptyElement4($xeTable),
            h("td", {
              class: "vxe-table-custom-popup--column-item col--name"
            }, [
              h("div", {
                class: "vxe-table-custom-popup--name"
              }, [
                allowSort ? (isCrossDrag ? immediate : false) || column.level === 1 ? h("div", Object.assign({ class: ["vxe-table-custom-popup--column-sort-btn", {
                  "is--disabled": isDisabled || isHidden
                }], title: getI18n2("vxe.custom.setting.sortHelpTip") }, isDisabled || isHidden ? {} : {
                  onMousedown: sortMousedownEvent,
                  onMouseup: sortMouseupEvent
                }), [
                  h("i", {
                    class: getIcon().TABLE_CUSTOM_SORT
                  })
                ]) : h("div", {
                  class: "vxe-table-custom-popup--column-sort-placeholder"
                }) : renderEmptyElement4($xeTable),
                column.type === "html" ? h("div", {
                  key: "1",
                  class: "vxe-table-custom-popup--title",
                  innerHTML: colTitle
                }) : h("div", {
                  key: "0",
                  class: "vxe-table-custom-popup--title",
                  title: colTitle
                }, colTitle)
              ])
            ]),
            allowResizable ? h("td", {
              class: "vxe-table-custom-popup--column-item col--resizable"
            }, [
              column.children && column.children.length || !(import_xe_utils5.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable) ? h("span", "-") : VxeUINumberInputComponent ? h(VxeUINumberInputComponent, {
                type: "integer",
                immediate: false,
                disabled: isDisabled || isHidden,
                modelValue: column.renderResizeWidth,
                min: customMinWidth || void 0,
                max: customMaxWidth || void 0,
                "onUpdate:modelValue"(value) {
                  const width = Math.max(0, Number(value));
                  column.renderResizeWidth = width;
                },
                onChange() {
                  changeColumnWidth(column);
                }
              }) : renderEmptyElement4($xeTable)
            ]) : renderEmptyElement4($xeTable),
            allowFixed ? h("td", {
              class: "vxe-table-custom-popup--column-item col--fixed"
            }, [
              parent ? h("span", "-") : VxeUIRadioGroupComponent ? h(VxeUIRadioGroupComponent, {
                modelValue: column.renderFixed || "",
                type: "button",
                size: "mini",
                disabled: isDisabled || isHidden,
                options: [
                  { label: getI18n2("vxe.custom.setting.fixedLeft"), value: "left", disabled: isDisabled || isHidden || isMaxFixedColumn },
                  { label: getI18n2("vxe.custom.setting.fixedUnset"), value: "", disabled: isDisabled || isHidden },
                  { label: getI18n2("vxe.custom.setting.fixedRight"), value: "right", disabled: isDisabled || isHidden || isMaxFixedColumn }
                ],
                onChange({ label, $event }) {
                  changeFixedOption(column, label, $event);
                }
              }) : renderEmptyElement4($xeTable)
            ]) : renderEmptyElement4($xeTable)
          ]));
        }
      });
      const scopedSlots = {
        default: () => {
          return h("div", {
            ref: refBodyWrapperElem,
            class: "vxe-table-custom-popup--body-wrapper"
          }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [
            h("div", {
              ref: refCustomBodyElem,
              class: "vxe-table-custom-popup--handle-wrapper"
            }, [
              topSlot ? h("div", {
                class: "vxe-table-custom-popup--table-top"
              }, $xeTable.callSlot(topSlot, params)) : renderEmptyElement4($xeTable),
              h("div", {
                class: "vxe-table-custom-popup--table-wrapper"
              }, [
                h("table", {}, [
                  h("colgroup", {}, [
                    allowVisible ? h("col", {
                      class: "vxe-table-custom-popup--table-col-seq"
                    }) : renderEmptyElement4($xeTable),
                    h("col", {
                      class: "vxe-table-custom-popup--table-col-title"
                    }),
                    allowResizable ? h("col", {
                      class: "vxe-table-custom-popup--table-col-width"
                    }) : renderEmptyElement4($xeTable),
                    allowFixed ? h("col", {
                      class: "vxe-table-custom-popup--table-col-fixed"
                    }) : renderEmptyElement4($xeTable)
                  ]),
                  h("thead", {}, [
                    h("tr", {}, [
                      allowVisible ? h("th", {}, [
                        h("div", {
                          class: ["vxe-table-custom--checkbox-option", {
                            "is--checked": isAllChecked,
                            "is--indeterminate": isAllIndeterminate
                          }],
                          title: getI18n2("vxe.table.allTitle"),
                          onClick: allOptionEvent
                        }, [
                          h("span", {
                            class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon().TABLE_CHECKBOX_CHECKED : getIcon().TABLE_CHECKBOX_UNCHECKED]
                          }),
                          h("span", {
                            class: "vxe-checkbox--label"
                          }, getI18n2("vxe.toolbar.customAll"))
                        ])
                      ]) : renderEmptyElement4($xeTable),
                      h("th", {}, getI18n2("vxe.custom.setting.colTitle")),
                      allowResizable ? h("th", {}, getI18n2("vxe.custom.setting.colResizable")) : renderEmptyElement4($xeTable),
                      allowFixed ? h("th", {}, getI18n2(`vxe.custom.setting.${maxFixedSize ? "colFixedMax" : "colFixed"}`, [maxFixedSize])) : renderEmptyElement4($xeTable)
                    ])
                  ]),
                  h(TransitionGroup, {
                    class: "vxe-table-custom--panel-list",
                    tag: "tbody",
                    name: "vxe-table-custom--list"
                  }, {
                    default: () => trVNs
                  })
                ])
              ]),
              bottomSlot ? h("div", {
                class: "vxe-table-custom-popup--table-bottom"
              }, $xeTable.callSlot(bottomSlot, params)) : renderEmptyElement4($xeTable),
              renderDragTip()
            ]),
            !treeConfig && (aggregateConfig || rowGroupConfig) && $xeTable.getPivotTableAggregatePopupPanel ? h($xeTable.getPivotTableAggregatePopupPanel(), {
              customStore
            }) : renderEmptyElement4($xeTable)
          ]);
        },
        footer: () => {
          if (footerSlot) {
            return $xeTable.callSlot(footerSlot, params);
          }
          return h("div", {
            class: "vxe-table-custom-popup--footer"
          }, [
            VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.resetButtonText || getI18n2("vxe.custom.cstmRestore"),
              disabled: !isCustomStatus,
              onClick: resetCustomEvent
            }) : renderEmptyElement4($xeTable),
            immediate ? VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.closeButtonText || getI18n2("vxe.table.customClose"),
              onClick: cancelCloseEvent
            }) : renderEmptyElement4($xeTable) : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.cancelButtonText || getI18n2("vxe.table.customCancel"),
              onClick: cancelCustomEvent
            }) : renderEmptyElement4($xeTable),
            immediate ? renderEmptyElement4($xeTable) : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              status: "primary",
              content: customOpts.confirmButtonText || getI18n2("vxe.custom.cstmConfirm"),
              onClick: confirmCustomEvent
            }) : renderEmptyElement4($xeTable)
          ]);
        }
      };
      if (headerSlot) {
        scopedSlots.header = () => $xeTable.callSlot(headerSlot, params);
      }
      if (mode === "drawer") {
        return VxeUIDrawerComponent ? h(VxeUIDrawerComponent, {
          key: "drawer",
          className: ["vxe-table-custom-drawer-wrapper", "vxe-table--ignore-clear", drawerOpts.className || ""].join(" "),
          modelValue: customStore.visible,
          title: drawerOpts.title || getI18n2("vxe.custom.cstmTitle"),
          width: drawerOpts.width || Math.min(880, Math.floor(document.documentElement.clientWidth * 0.6)),
          position: drawerOpts.position,
          resize: !!drawerOpts.resize,
          escClosable: !!drawerOpts.escClosable,
          maskClosable: !!drawerOpts.maskClosable,
          destroyOnClose: true,
          showFooter: true,
          "onUpdate:modelValue"(value) {
            customStore.visible = value;
          }
        }, scopedSlots) : renderEmptyElement4($xeTable);
      }
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        key: "modal",
        className: ["vxe-table-custom-modal-wrapper", "vxe-table--ignore-clear", modalOpts.className || ""].join(" "),
        modelValue: customStore.visible,
        title: modalOpts.title || getI18n2("vxe.custom.cstmTitle"),
        width: modalOpts.width || Math.min(880, document.documentElement.clientWidth),
        minWidth: modalOpts.minWidth || 700,
        height: modalOpts.height || Math.min(680, document.documentElement.clientHeight),
        minHeight: modalOpts.minHeight || 400,
        showZoom: modalOpts.showZoom,
        showMaximize: modalOpts.showMaximize,
        showMinimize: modalOpts.showMinimize,
        mask: modalOpts.mask,
        lockView: modalOpts.lockView,
        resize: modalOpts.resize,
        escClosable: !!modalOpts.escClosable,
        maskClosable: !!modalOpts.maskClosable,
        destroyOnClose: true,
        showFooter: true,
        "onUpdate:modelValue"(value) {
          customStore.visible = value;
        }
      }, scopedSlots) : renderEmptyElement4($xeTable);
    };
    const renderVN = () => {
      const customOpts = computeCustomOpts.value;
      if (["modal", "drawer", "popup"].includes(`${customOpts.mode}`)) {
        return renderPopupPanel();
      }
      return renderSimplePanel();
    };
    nextTick(() => {
      const customOpts = computeCustomOpts.value;
      const { mode } = customOpts;
      if (!VxeUIModalComponent && mode === "modal") {
        errLog("vxe.error.reqComp", ["vxe-modal"]);
      }
      if (!VxeUIDrawerComponent && mode === "drawer") {
        errLog("vxe.error.reqComp", ["vxe-drawer"]);
      }
      if (!VxeUIButtonComponent) {
        errLog("vxe.error.reqComp", ["vxe-button"]);
      }
      if (!VxeUINumberInputComponent) {
        errLog("vxe.error.reqComp", ["vxe-number-input"]);
      }
      if (!VxeUIRadioGroupComponent) {
        errLog("vxe.error.reqComp", ["vxe-radio-group"]);
      }
    });
    const $xeTableCustomPanel = {
      xID,
      props,
      context,
      reactData: customPanelReactData,
      internalData: customPanelInternalData,
      xeTable: $xeTable,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps,
      renderVN
    };
    onUnmounted(() => {
      customPanelInternalData = createInternalData2();
    });
    provide("$xeTableCustomPanel", $xeTableCustomPanel);
    return $xeTableCustomPanel;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/filter/panel.js
var import_xe_utils6 = __toESM(require_xe_utils());
var { getI18n: getI18n3, getIcon: getIcon2, renderer: renderer4, renderEmptyElement: renderEmptyElement5 } = VxeUI;
var panel_default2 = defineVxeComponent({
  name: "VxeTableFilterPanel",
  props: {
    filterStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props, context) {
    const xID = import_xe_utils6.default.uniqueId();
    const $xeTable = inject("$xeTable", {});
    const { reactData: tableReactData, internalData: tableInternalData, getComputeMaps } = $xeTable;
    const { computeFilterOpts } = getComputeMaps();
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeFilterPanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const computeHasCheckOption = computed(() => {
      const { filterStore } = props;
      const { column } = filterStore;
      return column && column.filters && column.filters.some((option) => option.checked);
    });
    const filterCheckAllEvent = (evnt, value) => {
      const { filterStore } = props;
      const { column } = filterStore;
      if (column && column.filters) {
        column.filters.forEach((option) => {
          option._checked = value;
          option.checked = value;
        });
      }
      filterStore.isAllSelected = value;
      filterStore.isIndeterminate = false;
    };
    const confirmFilter = (evnt) => {
      const { filterStore } = props;
      if (!evnt) {
        warnLog("vxe.error.delFunc", ["confirmFilter", "saveFilterPanelByEvent"]);
      }
      $xeTable.handleFilterConfirmFilter(evnt || new Event("click"), filterStore.column || null);
    };
    const changeRadioOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeRadioOption(evnt, checked, item);
    };
    const resetFilter = (evnt) => {
      const { filterStore } = props;
      $xeTable.handleFilterResetFilter(evnt, filterStore.column || null);
    };
    const changeMultipleOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeMultipleOption(evnt, checked, item);
    };
    const changeOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeOption(evnt, checked, item);
    };
    const changeAllOption = (evnt, checked) => {
      const { filterStore } = props;
      const { column } = filterStore;
      if (column && column.filterMultiple) {
        filterCheckAllEvent(evnt, checked);
      } else {
        resetFilter(evnt);
      }
    };
    const filterPanelMethods = {
      changeRadioOption,
      changeMultipleOption,
      changeAllOption,
      changeOption,
      confirmFilter,
      resetFilter
    };
    Object.assign($xeFilterPanel, filterPanelMethods);
    const renderOptions = (filterRender, compConf) => {
      const { filterStore } = props;
      const { column, maxHeight } = filterStore;
      if (!column) {
        return [];
      }
      const { filterMultiple, filters, slots } = column;
      const filterOptions = filters || [];
      const filterSlot = slots ? slots.filter : null;
      const params = Object.assign({}, tableInternalData._currFilterParams, { option: filterOptions[0], $panel: $xeFilterPanel, $table: $xeTable });
      const rtFilter = compConf ? compConf.renderTableFilter || compConf.renderFilter : null;
      if (filterSlot) {
        return [
          h("div", {
            class: "vxe-table--filter-template",
            style: maxHeight ? {
              maxHeight: toCssUnit(maxHeight)
            } : {}
          }, $xeTable.callSlot(filterSlot, params))
        ];
      } else if (filterRender && rtFilter) {
        return [
          h("div", {
            class: "vxe-table--filter-template",
            style: maxHeight ? {
              maxHeight: toCssUnit(maxHeight)
            } : {}
          }, getSlotVNs(rtFilter(filterRender, params)))
        ];
      }
      const isAllChecked = filterMultiple ? filterStore.isAllSelected : !filterOptions.some((item) => item._checked);
      const isAllIndeterminate = filterMultiple && filterStore.isIndeterminate;
      return [
        h("ul", {
          class: "vxe-table--filter-header"
        }, [
          h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": isAllChecked,
              "is--indeterminate": isAllIndeterminate
            }],
            title: getI18n3(filterMultiple ? "vxe.table.allTitle" : "vxe.table.allFilter"),
            onClick: (evnt) => {
              changeAllOption(evnt, !filterStore.isAllSelected);
            }
          }, (filterMultiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon2().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon2().TABLE_CHECKBOX_CHECKED : getIcon2().TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, getI18n3("vxe.table.allFilter"))
          ]))
        ]),
        h("ul", {
          class: "vxe-table--filter-body",
          style: maxHeight ? {
            maxHeight: toCssUnit(maxHeight)
          } : {}
        }, filterOptions.map((item) => {
          const isChecked = item._checked;
          const isIndeterminate = false;
          return h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": item._checked
            }],
            title: item.label,
            onClick: (evnt) => {
              changeOption(evnt, !item._checked, item);
            }
          }, (filterMultiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isIndeterminate ? getIcon2().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon2().TABLE_CHECKBOX_CHECKED : getIcon2().TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, formatText(item.label, 1))
          ]));
        }))
      ];
    };
    const renderFooters = () => {
      const { filterStore } = props;
      const { column } = filterStore;
      if (!column) {
        return [];
      }
      const filterOpts = computeFilterOpts.value;
      const hasCheckOption = computeHasCheckOption.value;
      const { filterRender, filterMultiple } = column;
      const compConf = isEnableConf(filterRender) ? renderer4.get(filterRender.name) : null;
      const isDisabled = !hasCheckOption && !filterStore.isAllSelected && !filterStore.isIndeterminate;
      return (compConf ? !(compConf.showTableFilterFooter === false || compConf.showFilterFooter === false || compConf.isFooter === false) : filterMultiple) ? [
        h("div", {
          class: "vxe-table--filter-footer"
        }, [
          h("button", {
            class: {
              "is--disabled": isDisabled
            },
            disabled: isDisabled,
            onClick: confirmFilter
          }, filterOpts.confirmButtonText || getI18n3("vxe.table.confirmFilter")),
          h("button", {
            onClick: resetFilter
          }, filterOpts.resetButtonText || getI18n3("vxe.table.resetFilter"))
        ])
      ] : [];
    };
    const renderVN = () => {
      const { filterStore } = props;
      const { initStore } = tableReactData;
      const { visible, column } = filterStore;
      if (!column) {
        return renderEmptyElement5($xeFilterPanel);
      }
      const filterRender = column ? column.filterRender : null;
      const compConf = filterRender && isEnableConf(filterRender) ? renderer4.get(filterRender.name) : null;
      const filterClassName = compConf ? compConf.tableFilterClassName || compConf.filterClassName : "";
      const params = Object.assign({}, tableInternalData._currFilterParams, { $panel: $xeFilterPanel, $table: $xeTable });
      const tableProps2 = $xeTable.props;
      const { computeSize } = $xeTable.getComputeMaps();
      const vSize = computeSize.value;
      const filterOpts = computeFilterOpts.value;
      const { transfer, destroyOnClose, className } = filterOpts;
      return h(Teleport, {
        to: "body",
        disabled: !transfer
      }, [
        h("div", {
          ref: refElem,
          class: [
            "vxe-table--filter-wrapper",
            "filter--prevent-default",
            className,
            getPropClass(filterClassName, params),
            {
              [`size--${vSize}`]: vSize,
              "is--animat": tableProps2.animat,
              "is--multiple": column.filterMultiple,
              "is--active": visible
            }
          ],
          style: filterStore.style
        }, initStore.filter && (destroyOnClose ? visible : true) && column ? renderOptions(filterRender, compConf).concat(renderFooters()) : [])
      ]);
    };
    $xeFilterPanel.renderVN = renderVN;
    return $xeFilterPanel;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/export/import-panel.js
var import_xe_utils7 = __toESM(require_xe_utils());
var { getI18n: getI18n4, getIcon: getIcon3, renderEmptyElement: renderEmptyElement6 } = VxeUI;
var import_panel_default = defineVxeComponent({
  name: "VxeTableImportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUISelectComponent = VxeUI.getComponent("VxeSelect");
    const $xeTable = inject("$xeTable", {});
    const { computeImportOpts } = $xeTable.getComputeMaps();
    const reactData = reactive({
      loading: false
    });
    const refFileBtn = ref();
    const computeSelectName = computed(() => {
      const { storeData } = props;
      return `${storeData.filename}.${storeData.type}`;
    });
    const computeHasFile = computed(() => {
      const { storeData } = props;
      return storeData.file && storeData.type;
    });
    const computeParseTypeLabel = computed(() => {
      const { storeData } = props;
      const { type, typeList } = storeData;
      if (type) {
        const selectItem = import_xe_utils7.default.find(typeList, (item) => type === item.value);
        return selectItem ? selectItem.label : "*.*";
      }
      return `*.${typeList.map((item) => item.value).join(", *.")}`;
    });
    const clearFileEvent = () => {
      const { storeData } = props;
      Object.assign(storeData, {
        filename: "",
        sheetName: "",
        type: ""
      });
    };
    const selectFileEvent = () => {
      const { storeData, defaultOptions } = props;
      $xeTable.readFile(defaultOptions).then((params) => {
        const { file } = params;
        Object.assign(storeData, parseFile(file), { file });
      }).catch((e) => e);
    };
    const showEvent = () => {
      nextTick(() => {
        const targetElem = refFileBtn.value;
        if (targetElem) {
          targetElem.focus();
        }
      });
    };
    const cancelEvent = () => {
      const { storeData } = props;
      storeData.visible = false;
    };
    const importEvent = () => {
      const { storeData, defaultOptions } = props;
      const importOpts = computeImportOpts.value;
      reactData.loading = true;
      $xeTable.importByFile(storeData.file, Object.assign({}, importOpts, defaultOptions)).then(() => {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const renderVN = () => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const { defaultOptions, storeData } = props;
      const selectName = computeSelectName.value;
      const hasFile = computeHasFile.value;
      const parseTypeLabel = computeParseTypeLabel.value;
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        id: "VXE_IMPORT_MODAL",
        modelValue: storeData.visible,
        title: getI18n4("vxe.import.impTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 540,
        minWidth: 360,
        minHeight: 240,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-export--panel-top"
            }, $xeTable.callSlot(topSlot, params)) : renderEmptyElement6($xeTable),
            h("div", {
              class: "vxe-table-export--panel-body"
            }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [
              h("table", {
                class: "vxe-table-export--panel-table",
                cellspacing: 0,
                cellpadding: 0,
                border: 0
              }, [
                h("tbody", [
                  h("tr", [
                    h("td", getI18n4("vxe.import.impFile")),
                    h("td", [
                      hasFile ? h("div", {
                        class: "vxe-table-export--selected--file",
                        title: selectName
                      }, [
                        h("span", selectName),
                        h("i", {
                          class: getIcon3().INPUT_CLEAR,
                          onClick: clearFileEvent
                        })
                      ]) : h("button", {
                        ref: refFileBtn,
                        class: "vxe-table-export--select--file",
                        onClick: selectFileEvent
                      }, getI18n4("vxe.import.impSelect"))
                    ])
                  ]),
                  h("tr", [
                    h("td", getI18n4("vxe.import.impType")),
                    h("td", parseTypeLabel)
                  ]),
                  h("tr", [
                    h("td", getI18n4("vxe.import.impMode")),
                    h("td", [
                      VxeUISelectComponent ? h(VxeUISelectComponent, {
                        modelValue: defaultOptions.mode,
                        options: storeData.modeList,
                        "onUpdate:modelValue"(value) {
                          defaultOptions.mode = value;
                        }
                      }) : renderEmptyElement6($xeTable)
                    ])
                  ])
                ])
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-export--panel-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : renderEmptyElement6($xeTable)
          ]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel-footer"
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
            h("div", {
              class: "vxe-table-export--panel-btns"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                content: getI18n4("vxe.import.impCancel"),
                onClick: cancelEvent
              }) : renderEmptyElement6($xeTable),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                status: "primary",
                disabled: !hasFile || reactData.loading,
                content: getI18n4("vxe.import.impConfirm"),
                onClick: importEvent
              }) : renderEmptyElement6($xeTable)
            ])
          ]);
        }
      }) : renderEmptyElement6($xeTable);
    };
    nextTick(() => {
      if (!VxeUIModalComponent) {
        errLog("vxe.error.reqComp", ["vxe-modal"]);
      }
      if (!VxeUIButtonComponent) {
        errLog("vxe.error.reqComp", ["vxe-button"]);
      }
      if (!VxeUISelectComponent) {
        errLog("vxe.error.reqComp", ["vxe-select"]);
      }
    });
    return renderVN;
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/export/export-panel.js
var import_xe_utils8 = __toESM(require_xe_utils());
var { getI18n: getI18n5, getIcon: getIcon4, renderEmptyElement: renderEmptyElement7 } = VxeUI;
var export_panel_default = defineVxeComponent({
  name: "VxeTableExportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUISelectComponent = VxeUI.getComponent("VxeSelect");
    const VxeUIInputComponent = VxeUI.getComponent("VxeInput");
    const VxeUICheckboxComponent = VxeUI.getComponent("VxeCheckbox");
    const $xeTable = inject("$xeTable", {});
    const { computeExportOpts, computePrintOpts } = $xeTable.getComputeMaps();
    const reactData = reactive({
      isAll: false,
      isIndeterminate: false,
      loading: false
    });
    const xButtonConfirm = ref();
    const xInputFilename = ref();
    const xInputSheetname = ref();
    const computeCheckedAll = computed(() => {
      const { storeData } = props;
      return storeData.columns.every((column) => column.checked);
    });
    const computeShowSheet = computed(() => {
      const { defaultOptions } = props;
      return ["html", "xml", "xlsx", "pdf"].indexOf(defaultOptions.type) > -1;
    });
    const computeSupportMerge = computed(() => {
      const { storeData, defaultOptions } = props;
      return !defaultOptions.original && defaultOptions.mode === "current" && (storeData.isPrint || ["html", "xlsx"].indexOf(defaultOptions.type) > -1);
    });
    const computeSupportStyle = computed(() => {
      const { defaultOptions } = props;
      return !defaultOptions.original && ["xlsx"].indexOf(defaultOptions.type) > -1;
    });
    const handleOptionCheck = (column) => {
      const { storeData } = props;
      const matchObj = import_xe_utils8.default.findTree(storeData.columns, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.checked = parent.children.every((column2) => column2.checked);
          parent.halfChecked = !parent.checked && parent.children.some((column2) => column2.checked || column2.halfChecked);
          handleOptionCheck(parent);
        }
      }
    };
    const checkStatus = () => {
      const { storeData } = props;
      const columns = storeData.columns;
      reactData.isAll = columns.every((column) => column.disabled || column.checked);
      reactData.isIndeterminate = !reactData.isAll && columns.some((column) => !column.disabled && (column.checked || column.halfChecked));
    };
    const changeOption = (column) => {
      const isChecked = !column.checked;
      import_xe_utils8.default.eachTree([column], (item) => {
        item.checked = isChecked;
        item.halfChecked = false;
      });
      handleOptionCheck(column);
      checkStatus();
    };
    const allColumnEvent = () => {
      const { storeData } = props;
      const isAll = !reactData.isAll;
      import_xe_utils8.default.eachTree(storeData.columns, (column) => {
        if (!column.disabled) {
          column.checked = isAll;
          column.halfChecked = false;
        }
      });
      reactData.isAll = isAll;
      checkStatus();
    };
    const showEvent = () => {
      nextTick(() => {
        const filenameInp = xInputFilename.value;
        const sheetnameInp = xInputSheetname.value;
        const confirmBtn = xButtonConfirm.value;
        const targetElem = filenameInp || sheetnameInp || confirmBtn;
        if (targetElem) {
          targetElem.focus();
        }
      });
      checkStatus();
    };
    const getExportOption = () => {
      const { storeData, defaultOptions } = props;
      const { hasMerge, columns } = storeData;
      const checkedAll = computeCheckedAll.value;
      const supportMerge = computeSupportMerge.value;
      const expColumns = import_xe_utils8.default.searchTree(columns, (column) => column.checked, { children: "children", mapChildren: "childNodes", original: true });
      return Object.assign({}, defaultOptions, {
        columns: expColumns,
        isMerge: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false
      });
    };
    const printEvent = () => {
      const { storeData } = props;
      const printOpts = computePrintOpts.value;
      storeData.visible = false;
      $xeTable.print(Object.assign({}, printOpts, getExportOption()));
    };
    const exportEvent = () => {
      const { storeData } = props;
      const exportOpts = computeExportOpts.value;
      reactData.loading = true;
      $xeTable.exportData(Object.assign({}, exportOpts, getExportOption())).then(() => {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const cancelEvent = () => {
      const { storeData } = props;
      storeData.visible = false;
    };
    const confirmEvent = () => {
      const { storeData } = props;
      if (storeData.isPrint) {
        printEvent();
      } else {
        exportEvent();
      }
    };
    const renderVN = () => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const { defaultOptions, storeData } = props;
      const { isAll: isAllChecked, isIndeterminate: isAllIndeterminate } = reactData;
      const { hasTree, hasMerge, isPrint, hasColgroup, columns } = storeData;
      const { isHeader } = defaultOptions;
      const cols = [];
      const checkedAll = computeCheckedAll.value;
      const showSheet = computeShowSheet.value;
      const supportMerge = computeSupportMerge.value;
      const supportStyle = computeSupportStyle.value;
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const parameterSlot = slots.parameter;
      import_xe_utils8.default.eachTree(columns, (column) => {
        const colTitle = formatText(column.getTitle(), 1);
        const isColGroup = column.children && column.children.length;
        const isChecked = column.checked;
        const indeterminate = column.halfChecked;
        const isHtml = column.type === "html";
        cols.push(h("li", {
          key: column.id,
          class: ["vxe-table-export--panel-column-option", `level--${column.level}`, {
            "is--group": isColGroup,
            "is--checked": isChecked,
            "is--indeterminate": indeterminate,
            "is--disabled": column.disabled
          }],
          title: isHtml ? "" : colTitle,
          onClick: () => {
            if (!column.disabled) {
              changeOption(column);
            }
          }
        }, [
          h("span", {
            class: ["vxe-checkbox--icon", indeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
          }),
          isHtml ? h("span", {
            key: "1",
            class: "vxe-checkbox--label",
            innerHTML: colTitle
          }) : h("span", {
            key: "0",
            class: "vxe-checkbox--label"
          }, colTitle)
        ]));
      });
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        id: "VXE_EXPORT_MODAL",
        modelValue: storeData.visible,
        title: getI18n5(isPrint ? "vxe.export.printTitle" : "vxe.export.expTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 660,
        minWidth: 500,
        minHeight: 400,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          const hasEmptyData = defaultOptions.mode === "empty";
          return h("div", {
            class: "vxe-table-export--panel"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-export--panel-top"
            }, $xeTable.callSlot(topSlot, params)) : renderEmptyElement7($xeTable),
            h("div", {
              class: "vxe-table-export--panel-body"
            }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [
              h("table", {
                class: "vxe-table-export--panel-table",
                cellspacing: 0,
                cellpadding: 0,
                border: 0
              }, [
                h("tbody", [
                  [
                    isPrint ? renderEmptyElement7($xeTable) : h("tr", [
                      h("td", getI18n5("vxe.export.expName")),
                      h("td", [
                        VxeUIInputComponent ? h(VxeUIInputComponent, {
                          ref: xInputFilename,
                          modelValue: defaultOptions.filename,
                          type: "text",
                          clearable: true,
                          placeholder: getI18n5("vxe.export.expNamePlaceholder"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.filename = value;
                          }
                        }) : renderEmptyElement7($xeTable)
                      ])
                    ]),
                    isPrint ? renderEmptyElement7($xeTable) : h("tr", [
                      h("td", getI18n5("vxe.export.expType")),
                      h("td", [
                        VxeUISelectComponent ? h(VxeUISelectComponent, {
                          modelValue: defaultOptions.type,
                          options: storeData.typeList,
                          "onUpdate:modelValue"(value) {
                            defaultOptions.type = value;
                          }
                        }) : renderEmptyElement7($xeTable)
                      ])
                    ]),
                    isPrint || showSheet ? h("tr", [
                      h("td", getI18n5("vxe.export.expSheetName")),
                      h("td", [
                        VxeUIInputComponent ? h(VxeUIInputComponent, {
                          ref: xInputSheetname,
                          modelValue: defaultOptions.sheetName,
                          type: "text",
                          clearable: true,
                          placeholder: getI18n5("vxe.export.expSheetNamePlaceholder"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.sheetName = value;
                          }
                        }) : renderEmptyElement7($xeTable)
                      ])
                    ]) : renderEmptyElement7($xeTable),
                    h("tr", [
                      h("td", getI18n5("vxe.export.expMode")),
                      h("td", [
                        VxeUISelectComponent ? h(VxeUISelectComponent, {
                          modelValue: defaultOptions.mode,
                          options: storeData.modeList.map((item) => {
                            return {
                              value: item.value,
                              label: getI18n5(item.label)
                            };
                          }),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.mode = value;
                          }
                        }) : renderEmptyElement7($xeTable)
                      ])
                    ]),
                    h("tr", [
                      h("td", [getI18n5("vxe.export.expColumn")]),
                      h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-column"
                        }, [
                          h("ul", {
                            class: "vxe-table-export--panel-column-header"
                          }, [
                            h("li", {
                              class: ["vxe-table-export--panel-column-option", {
                                "is--checked": isAllChecked,
                                "is--indeterminate": isAllIndeterminate
                              }],
                              title: getI18n5("vxe.table.allTitle"),
                              onClick: allColumnEvent
                            }, [
                              h("span", {
                                class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
                              }),
                              h("span", {
                                class: "vxe-checkbox--label"
                              }, getI18n5("vxe.export.expCurrentColumn"))
                            ])
                          ]),
                          h("ul", {
                            class: "vxe-table-export--panel-column-body"
                          }, cols)
                        ])
                      ])
                    ]),
                    h("tr", [
                      h("td", getI18n5("vxe.export.expOpts")),
                      parameterSlot ? h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, $xeTable.callSlot(parameterSlot, params))
                      ]) : h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasEmptyData || isHeader,
                            disabled: hasEmptyData,
                            title: getI18n5("vxe.export.expHeaderTitle"),
                            content: getI18n5("vxe.export.expOptHeader"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isHeader = value;
                            }
                          }) : renderEmptyElement7($xeTable),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: isHeader ? defaultOptions.isTitle : false,
                            disabled: !isHeader,
                            title: getI18n5("vxe.export.expTitleTitle"),
                            content: getI18n5("vxe.export.expOptTitle"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isTitle = value;
                            }
                          }) : renderEmptyElement7($xeTable),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: isHeader && hasColgroup && supportMerge ? defaultOptions.isColgroup : false,
                            title: getI18n5("vxe.export.expColgroupTitle"),
                            disabled: !isHeader || !hasColgroup || !supportMerge,
                            content: getI18n5("vxe.export.expOptColgroup"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isColgroup = value;
                            }
                          }) : renderEmptyElement7($xeTable)
                        ]),
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasEmptyData ? false : defaultOptions.original,
                            disabled: hasEmptyData,
                            title: getI18n5("vxe.export.expOriginalTitle"),
                            content: getI18n5("vxe.export.expOptOriginal"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.original = value;
                            }
                          }) : renderEmptyElement7($xeTable),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false,
                            title: getI18n5("vxe.export.expMergeTitle"),
                            disabled: hasEmptyData || !hasMerge || !supportMerge || !checkedAll,
                            content: getI18n5("vxe.export.expOptMerge"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isMerge = value;
                            }
                          }) : renderEmptyElement7($xeTable),
                          isPrint || !VxeUICheckboxComponent ? renderEmptyElement7($xeTable) : h(VxeUICheckboxComponent, {
                            modelValue: supportStyle ? defaultOptions.useStyle : false,
                            disabled: !supportStyle,
                            title: getI18n5("vxe.export.expUseStyleTitle"),
                            content: getI18n5("vxe.export.expOptUseStyle"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.useStyle = value;
                            }
                          }),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasTree ? defaultOptions.isAllExpand : false,
                            disabled: hasEmptyData || !hasTree,
                            title: getI18n5("vxe.export.expAllExpandTitle"),
                            content: getI18n5("vxe.export.expOptAllExpand"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isAllExpand = value;
                            }
                          }) : renderEmptyElement7($xeTable)
                        ]),
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: defaultOptions.isFooter,
                            disabled: !storeData.hasFooter,
                            title: getI18n5("vxe.export.expFooterTitle"),
                            content: getI18n5("vxe.export.expOptFooter"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isFooter = value;
                            }
                          }) : renderEmptyElement7($xeTable)
                        ])
                      ])
                    ])
                  ]
                ])
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-export--panel-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : renderEmptyElement7($xeTable)
          ]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel-footer"
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
            h("div", {
              class: "vxe-table-export--panel-btns"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                content: getI18n5("vxe.export.expCancel"),
                onClick: cancelEvent
              }) : renderEmptyElement7($xeTable),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                ref: xButtonConfirm,
                status: "primary",
                content: getI18n5(isPrint ? "vxe.export.expPrint" : "vxe.export.expConfirm"),
                onClick: confirmEvent
              }) : renderEmptyElement7($xeTable)
            ])
          ]);
        }
      }) : renderEmptyElement7($xeTable);
    };
    nextTick(() => {
      if (!VxeUIModalComponent) {
        errLog("vxe.error.reqComp", ["vxe-modal"]);
      }
      if (!VxeUIButtonComponent) {
        errLog("vxe.error.reqComp", ["vxe-button"]);
      }
      if (!VxeUISelectComponent) {
        errLog("vxe.error.reqComp", ["vxe-select"]);
      }
      if (!VxeUIInputComponent) {
        errLog("vxe.error.reqComp", ["vxe-input"]);
      }
      if (!VxeUICheckboxComponent) {
        errLog("vxe.error.reqComp", ["vxe-checkbox"]);
      }
    });
    return renderVN;
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/menu/panel.js
var import_xe_utils9 = __toESM(require_xe_utils());
var { getIcon: getIcon5, getI18n: getI18n6, renderEmptyElement: renderEmptyElement8 } = VxeUI;
var panel_default3 = defineVxeComponent({
  name: "VxeTableMenuPanel",
  setup(props, context) {
    const xID = import_xe_utils9.default.uniqueId();
    const $xeTable = inject("$xeTable", {});
    const { reactData: tableReactData } = $xeTable;
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeMenuPanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const renderVN = () => {
      const { ctxMenuStore } = tableReactData;
      const { computeMenuOpts } = $xeTable.getComputeMaps();
      const menuOpts = computeMenuOpts.value;
      const { transfer, destroyOnClose } = menuOpts;
      const { visible, list, className } = ctxMenuStore;
      return h(Teleport, {
        to: "body",
        disabled: !transfer
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-table--context-menu-wrapper", className, {
            "is--visible": visible
          }],
          style: ctxMenuStore.style
        }, (destroyOnClose ? visible : true) ? list.map((options, gIndex) => {
          return options.every((item) => item.visible === false) ? renderEmptyElement8($xeTable) : h("ul", {
            class: "vxe-context-menu--option-wrapper",
            key: gIndex
          }, options.map((item, index) => {
            const { children, loading } = item;
            const hasChildMenus = children && children.some((child) => child.visible !== false);
            const prefixOpts = Object.assign({}, item.prefixConfig);
            const prefixIcon = prefixOpts.icon || item.prefixIcon;
            const suffixOpts = Object.assign({}, item.suffixConfig);
            const suffixIcon = suffixOpts.icon || item.suffixIcon;
            const menuContent = getFuncText(item.name);
            return item.visible === false ? renderEmptyElement8($xeTable) : h("li", {
              class: [item.className, {
                "link--loading": loading,
                "link--disabled": item.disabled,
                "link--active": item === ctxMenuStore.selected
              }],
              key: `${gIndex}_${index}`
            }, [
              h("a", {
                class: "vxe-context-menu--link",
                onClick(evnt) {
                  $xeTable.ctxMenuLinkEvent(evnt, item);
                },
                onMouseover(evnt) {
                  $xeTable.ctxMenuMouseoverEvent(evnt, item);
                },
                onMouseout(evnt) {
                  $xeTable.ctxMenuMouseoutEvent(evnt, item);
                }
              }, [
                h("div", {
                  class: ["vxe-context-menu--link-prefix", prefixOpts.className || ""]
                }, [
                  loading ? h("span", {
                    class: getIcon5("TABLE_MENU_OPTION_LOADING")
                  }) : prefixIcon && import_xe_utils9.default.isFunction(prefixIcon) ? h("span", {}, getSlotVNs(prefixIcon({}))) : h("span", {}, [
                    h("i", {
                      class: prefixIcon
                    })
                  ]),
                  prefixOpts.content ? h("span", {}, `${prefixOpts.content}`) : renderEmptyElement8($xeTable)
                ]),
                h("div", {
                  class: "vxe-context-menu--link-content",
                  title: menuContent
                }, loading ? getI18n6("vxe.table.menuLoading") : menuContent),
                h("div", {
                  class: ["vxe-context-menu--link-suffix", suffixOpts.className || ""]
                }, [
                  suffixIcon && import_xe_utils9.default.isFunction(suffixIcon) ? h("span", {}, getSlotVNs(suffixIcon({}))) : h("i", {
                    class: suffixIcon || (hasChildMenus ? getIcon5().TABLE_MENU_OPTIONS : "")
                  }),
                  suffixOpts.content ? h("span", `${suffixOpts.content}`) : renderEmptyElement8($xeTable)
                ])
              ]),
              hasChildMenus && item.children ? h("ul", {
                class: ["vxe-table--context-menu-clild-wrapper", {
                  "is--show": item === ctxMenuStore.selected && ctxMenuStore.showChild
                }]
              }, item.children.map((child, cIndex) => {
                const { loading: childLoading } = child;
                const childPrefixOpts = Object.assign({}, child.prefixConfig);
                const childPrefixIcon = childPrefixOpts.icon || child.prefixIcon;
                const childSuffixOpts = Object.assign({}, child.suffixConfig);
                const childSuffixIcon = childSuffixOpts.icon || child.suffixIcon;
                const childMenuContent = getFuncText(child.name);
                return child.visible === false ? null : h("li", {
                  class: [child.className, {
                    "link--loading": childLoading,
                    "link--disabled": child.disabled,
                    "link--active": child === ctxMenuStore.selectChild
                  }],
                  key: `${gIndex}_${index}_${cIndex}`
                }, [
                  h("a", {
                    class: "vxe-context-menu--link",
                    onClick(evnt) {
                      $xeTable.ctxMenuLinkEvent(evnt, child);
                    },
                    onMouseover(evnt) {
                      $xeTable.ctxMenuMouseoverEvent(evnt, item, child);
                    },
                    onMouseout(evnt) {
                      $xeTable.ctxMenuMouseoutEvent(evnt, item);
                    }
                  }, [
                    h("div", {
                      class: ["vxe-context-menu--link-prefix", childPrefixOpts.className || ""]
                    }, [
                      child.loading ? h("span", {
                        class: getIcon5("TABLE_MENU_OPTION_LOADING")
                      }) : childPrefixIcon && import_xe_utils9.default.isFunction(childPrefixIcon) ? h("span", {}, getSlotVNs(childPrefixIcon({}))) : h("span", {}, [
                        h("i", {
                          class: childPrefixIcon
                        })
                      ]),
                      childPrefixOpts.content ? h("span", `${childPrefixOpts.content}`) : renderEmptyElement8($xeTable)
                    ]),
                    h("div", {
                      class: "vxe-context-menu--link-content",
                      title: childMenuContent
                    }, childLoading ? getI18n6("vxe.table.menuLoading") : childMenuContent),
                    h("div", {
                      class: ["vxe-context-menu--link-suffix", childSuffixOpts.className || ""]
                    }, [
                      childSuffixIcon && import_xe_utils9.default.isFunction(childSuffixIcon) ? h("span", {}, getSlotVNs(childSuffixIcon({}))) : h("i", {
                        class: childSuffixIcon
                      }),
                      childSuffixOpts.content ? h("span", `${childSuffixOpts.content}`) : renderEmptyElement8($xeTable)
                    ])
                  ])
                ]);
              })) : null
            ]);
          }));
        }) : [])
      ]);
    };
    $xeMenuPanel.renderVN = renderVN;
    return $xeMenuPanel;
  },
  render() {
    return this.renderVN();
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/filter/hook.js
var import_xe_utils10 = __toESM(require_xe_utils());
var { renderer: renderer5, hooks } = VxeUI;
var tableFilterMethodKeys = ["openFilter", "setFilter", "clearFilter", "saveFilter", "saveFilterByEvent", "saveFilterPanel", "saveFilterPanelByEvent", "resetFilter", "resetFilterByEvent", "resetFilterPanel", "resetFilterPanelByEvent", "getCheckedFilters", "updateFilterOptionStatus"];
hooks.add("tableFilterModule", {
  setupTable($xeTable) {
    const $xeGrid = $xeTable.xeGrid;
    const $xeGantt = $xeTable.xeGantt;
    const $xeGGWrapper = $xeGrid || $xeGantt;
    const { props, reactData, internalData } = $xeTable;
    const { refElem, refTableFilter } = $xeTable.getRefMaps();
    const { computeFilterOpts, computeMouseOpts } = $xeTable.getComputeMaps();
    const filterPrivateMethods = {
      checkFilterOptions() {
        const { filterStore } = reactData;
        const { column } = filterStore;
        if (column) {
          const filterOptions = column.filters || [];
          filterStore.isAllSelected = filterOptions.every((item) => item._checked);
          filterStore.isIndeterminate = !filterStore.isAllSelected && filterOptions.some((item) => item._checked);
        }
      },
      /**
       * 点击筛选事件
       * 当筛选图标被点击时触发
       * 更新选项是否全部状态
       * 打开筛选面板
       * @param {Event} evnt 事件
       * @param {ColumnInfo} column 列配置
       * @param {Object} params 参数
       */
      triggerFilterEvent(evnt, column, params) {
        const { initStore, filterStore } = reactData;
        const { elemStore } = internalData;
        if (filterStore.column === column && filterStore.visible) {
          filterStore.visible = false;
        } else {
          const tableEl = refElem.value;
          const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode();
          const filterOpts = computeFilterOpts.value;
          const { transfer } = filterOpts;
          const tableRect = tableEl.getBoundingClientRect();
          const btnElem = evnt.currentTarget;
          const filterRender = column ? column.filterRender : null;
          const compConf = filterRender && isEnableConf(filterRender) ? renderer5.get(filterRender.name) : null;
          $xeTable.handleFilterOptions(column);
          internalData._currFilterParams = params;
          filterStore.style = null;
          filterStore.visible = true;
          initStore.filter = true;
          nextTick(() => {
            const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
            if (!headerScrollElem) {
              return;
            }
            const tableFilter = refTableFilter.value;
            const filterWrapperElem = tableFilter ? tableFilter.getRefMaps().refElem.value : null;
            if (!filterWrapperElem) {
              return;
            }
            const btnRect = btnElem.getBoundingClientRect();
            const filterHeadElem = filterWrapperElem.querySelector(".vxe-table--filter-header");
            const filterFootElem = filterWrapperElem.querySelector(".vxe-table--filter-footer");
            const filterWidth = filterWrapperElem.offsetWidth;
            const centerWidth = filterWidth / 2;
            let left = 0;
            let top = 0;
            let maxHeight = 0;
            if (transfer) {
              left = btnRect.left - centerWidth + scrollLeft;
              top = btnRect.top + btnElem.clientHeight + scrollTop;
              maxHeight = Math.min(Math.max(tableRect.height, Math.floor(visibleHeight / 2)), Math.max(80, visibleHeight - top - (filterHeadElem ? filterHeadElem.clientHeight : 0) - (filterFootElem ? filterFootElem.clientHeight : 0) - 28));
              if (left < 16) {
                left = 16;
              } else if (left > visibleWidth - filterWidth - 16) {
                left = visibleWidth - filterWidth - 16;
              }
            } else {
              left = btnRect.left - tableRect.left - centerWidth;
              top = btnRect.top - tableRect.top + btnElem.clientHeight;
              maxHeight = Math.max(40, tableEl.clientHeight - top - (filterHeadElem ? filterHeadElem.clientHeight : 0) - (filterFootElem ? filterFootElem.clientHeight : 0) - 14);
              if (left < 1) {
                left = 1;
              } else if (left > tableEl.clientWidth - filterWidth - 1) {
                left = tableEl.clientWidth - filterWidth - 1;
              }
              if ($xeGGWrapper) {
                const wrapperEl = $xeGGWrapper.getRefMaps().refElem.value;
                if (wrapperEl) {
                  const wrapperRect = wrapperEl.getBoundingClientRect();
                  top += tableRect.top - wrapperRect.top;
                }
              }
            }
            filterStore.style = {
              top: toCssUnit(top),
              left: toCssUnit(left)
            };
            if (compConf ? !compConf.tableFilterAutoHeight : false) {
              maxHeight = 0;
            }
            filterStore.maxHeight = maxHeight;
          });
        }
        $xeTable.dispatchEvent("filter-visible", { column, field: column.field, property: column.field, filterList: $xeTable.getCheckedFilters(), visible: filterStore.visible }, evnt);
      },
      handleClearFilter(column) {
        if (column) {
          const { filters, filterRender } = column;
          if (filters) {
            const compConf = isEnableConf(filterRender) ? renderer5.get(filterRender.name) : null;
            const frMethod = column.filterResetMethod || (compConf ? compConf.tableFilterResetMethod || compConf.filterResetMethod : null);
            filters.forEach((item) => {
              item._checked = false;
              item.checked = false;
              if (!frMethod) {
                item.data = import_xe_utils10.default.clone(item.resetValue, true);
              }
            });
            if (frMethod) {
              frMethod({ options: filters, column, $table: $xeTable });
            }
          }
        }
      },
      handleColumnConfirmFilter(column, evnt) {
        const { mouseConfig } = props;
        const { scrollXLoad: oldScrollXLoad, scrollYLoad: oldScrollYLoad } = reactData;
        const filterOpts = computeFilterOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const { field, filters } = column;
        const filterOptions = filters || [];
        const values = [];
        const datas = [];
        filterOptions.forEach((item) => {
          if (item.checked) {
            values.push(item.value);
            datas.push(item.data);
          }
        });
        const filterList = $xeTable.getCheckedFilters();
        const params = { $table: $xeTable, $event: evnt, column, field, property: field, values, datas, filters: filterList, filterList };
        if (!filterOpts.remote) {
          $xeTable.handleTableData(true);
          $xeTable.checkSelectionStatus();
        }
        if (mouseConfig && mouseOpts.area && $xeTable.handleFilterEvent) {
          $xeTable.handleFilterEvent(evnt, params);
        }
        if (evnt) {
          $xeTable.dispatchEvent("filter-change", params, evnt);
        }
        $xeTable.closeFilter();
        return $xeTable.updateFooter().then(() => {
          const { scrollXLoad, scrollYLoad } = reactData;
          if (oldScrollXLoad || scrollXLoad || (oldScrollYLoad || scrollYLoad)) {
            if (oldScrollXLoad || scrollXLoad) {
              $xeTable.updateScrollXSpace();
            }
            if (oldScrollYLoad || scrollYLoad) {
              $xeTable.updateScrollYSpace();
            }
            return $xeTable.refreshScroll();
          }
        }).then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate(true);
        }).then(() => {
          setTimeout(() => $xeTable.recalculate(), 50);
        });
      },
      /**
       * 确认筛选
       * 当筛选面板中的确定按钮被按下时触发
       */
      confirmFilterEvent(evnt, column) {
        if (column) {
          $xeTable.handleColumnConfirmFilter(column, evnt);
        }
      },
      // （单选）筛选发生改变
      handleFilterChangeRadioOption(evnt, checked, item) {
        const { filterStore } = reactData;
        const { column } = filterStore;
        if (column) {
          const filterOptions = column.filters || [];
          filterOptions.forEach((option) => {
            option._checked = false;
          });
          item._checked = checked;
          $xeTable.checkFilterOptions();
          $xeTable.handleFilterConfirmFilter(evnt, column);
        }
      },
      // （多选）筛选发生改变
      handleFilterChangeMultipleOption(evnt, checked, item) {
        item._checked = checked;
        $xeTable.checkFilterOptions();
      },
      // 筛选发生改变
      handleFilterChangeOption(evnt, checked, item) {
        const { filterStore } = reactData;
        const { fullColumnIdData } = internalData;
        let column = filterStore.column;
        if (!column) {
          const colRest = fullColumnIdData[item._colId];
          if (colRest) {
            column = colRest.column;
            filterStore.column = column;
          }
        }
        if (column) {
          if (column.filterMultiple) {
            $xeTable.handleFilterChangeMultipleOption(evnt, checked, item);
          } else {
            $xeTable.handleFilterChangeRadioOption(evnt, checked, item);
          }
        }
      },
      // 确认筛选
      handleFilterConfirmFilter(evnt, column) {
        if (column) {
          const filterOptions = column.filters || [];
          filterOptions.forEach((option) => {
            option.checked = option._checked;
          });
          $xeTable.confirmFilterEvent(evnt, column);
        }
      },
      /**
       * 重置筛选
       * 当筛选面板中的重置按钮被按下时触发
       */
      handleFilterResetFilter(evnt, column) {
        if (column) {
          $xeTable.handleClearFilter(column);
          $xeTable.confirmFilterEvent(evnt, column);
          if (evnt) {
            $xeTable.dispatchEvent("clear-filter", { filterList: [] }, evnt);
          }
        }
      }
    };
    const filterMethods = {
      /**
       * 手动弹出筛选面板
       * @param column
       */
      openFilter(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && column.filters) {
          const { elemStore } = internalData;
          const { fixed } = column;
          return $xeTable.scrollToColumn(column).then(() => {
            const headerWrapperElem = getRefElem(elemStore[`${fixed || "main"}-header-wrapper`] || elemStore["main-header-wrapper"]);
            if (headerWrapperElem) {
              const filterBtnElem = headerWrapperElem.querySelector(`.vxe-header--column.${column.id} .vxe-cell--filter`);
              triggerEvent(filterBtnElem, "click");
            }
          });
        }
        return nextTick();
      },
      /**
       * 修改筛选条件列表
       * @param {ColumnInfo} fieldOrColumn 列或字段名
       * @param {Array} options 选项
       */
      setFilter(fieldOrColumn, options, isUpdate) {
        const { filterStore } = reactData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && column.filters) {
          column.filters = toFilters(options || [], column.id);
          if (isUpdate) {
            return $xeTable.handleColumnConfirmFilter(column, null);
          } else {
            if (filterStore.visible) {
              $xeTable.handleFilterOptions(column);
            }
          }
        }
        return nextTick();
      },
      /**
       * 清空指定列的筛选条件
       * 如果为空则清空所有列的筛选条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearFilter(fieldOrColumn) {
        const { filterStore } = reactData;
        const { tableFullColumn } = internalData;
        const filterOpts = computeFilterOpts.value;
        let column;
        if (fieldOrColumn) {
          column = handleFieldOrColumn($xeTable, fieldOrColumn);
          if (column) {
            $xeTable.handleClearFilter(column);
          }
        } else {
          tableFullColumn.forEach($xeTable.handleClearFilter);
        }
        if (!fieldOrColumn || column !== filterStore.column) {
          Object.assign(filterStore, {
            isAllSelected: false,
            isIndeterminate: false,
            style: null,
            options: [],
            column: null,
            multiple: false,
            visible: false
          });
        }
        if (!filterOpts.remote) {
          return $xeTable.updateData();
        }
        return nextTick();
      },
      saveFilter(fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          $xeTable.handleFilterConfirmFilter(null, column);
        }
        return nextTick();
      },
      saveFilterByEvent(evnt, fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          $xeTable.handleFilterConfirmFilter(evnt, column);
        }
        return nextTick();
      },
      resetFilter(fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          $xeTable.handleFilterResetFilter(null, column);
        }
        return nextTick();
      },
      resetFilterByEvent(evnt, fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          $xeTable.handleFilterResetFilter(evnt, column);
        }
        return nextTick();
      },
      saveFilterPanel() {
        const { filterStore } = reactData;
        $xeTable.handleFilterConfirmFilter(null, filterStore.column || null);
        return nextTick();
      },
      saveFilterPanelByEvent(evnt) {
        const { filterStore } = reactData;
        $xeTable.handleFilterConfirmFilter(evnt, filterStore.column || null);
        return nextTick();
      },
      resetFilterPanel() {
        const { filterStore } = reactData;
        $xeTable.handleFilterResetFilter(null, filterStore.column || null);
        return nextTick();
      },
      resetFilterPanelByEvent(evnt) {
        const { filterStore } = reactData;
        $xeTable.handleFilterResetFilter(evnt, filterStore.column || null);
        return nextTick();
      },
      getCheckedFilters() {
        const { tableFullColumn } = internalData;
        const filterList = [];
        tableFullColumn.forEach((column) => {
          const { field, filters } = column;
          const filterOptions = filters || [];
          const valueList = [];
          const dataList = [];
          if (filterOptions) {
            filterOptions.forEach((item) => {
              if (item.checked) {
                valueList.push(item.value);
                dataList.push(item.data);
              }
            });
            if (valueList.length) {
              filterList.push({ column, field, property: field, values: valueList, datas: dataList });
            }
          }
        });
        return filterList;
      },
      updateFilterOptionStatus(item, checked) {
        item._checked = checked;
        item.checked = checked;
        return nextTick();
      }
    };
    return Object.assign(Object.assign({}, filterMethods), filterPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableFilterMethodKeys);
  },
  setupGantt($xeGantt) {
    return $xeGantt.extendTableMethods(tableFilterMethodKeys);
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/menu/hook.js
var import_xe_utils11 = __toESM(require_xe_utils());
var { menus, hooks: hooks2, globalEvents, GLOBAL_EVENT_KEYS } = VxeUI;
var tableMenuMethodKeys = ["closeMenu"];
hooks2.add("tableMenuModule", {
  setupTable($xeTable) {
    const { xID, props, reactData, internalData } = $xeTable;
    const { refElem, refTableFilter, refTableMenu } = $xeTable.getRefMaps();
    const { computeMouseOpts, computeIsContentMenu, computeMenuOpts } = $xeTable.getComputeMaps();
    const $xeGrid = $xeTable.xeGrid;
    const $xeGantt = $xeTable.xeGantt;
    const $xeGGWrapper = $xeGrid || $xeGantt;
    let menuMethods = {};
    let menuPrivateMethods = {};
    const handleOpenMenuEvent = (evnt, type, params) => {
      const { ctxMenuStore } = reactData;
      const isContentMenu = computeIsContentMenu.value;
      const menuOpts = computeMenuOpts.value;
      const config = menuOpts[type];
      const { transfer, visibleMethod } = menuOpts;
      if (config) {
        const { options, disabled } = config;
        if (disabled) {
          evnt.preventDefault();
        } else if (isContentMenu && options && options.length) {
          params.options = options;
          $xeTable.preventEvent(evnt, "event.showMenu", params, () => {
            if (!visibleMethod || visibleMethod(params)) {
              evnt.preventDefault();
              $xeTable.updateZindex();
              const el = $xeGGWrapper ? $xeGGWrapper.getRefMaps().refElem.value : refElem.value;
              if (!el) {
                return;
              }
              const tableRect = el.getBoundingClientRect();
              const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode();
              let top = evnt.clientY - tableRect.y;
              let left = evnt.clientX - tableRect.x;
              if (transfer) {
                top = evnt.clientY + scrollTop;
                left = evnt.clientX + scrollLeft;
              }
              const handleVisible = () => {
                internalData._currMenuParams = params;
                Object.assign(ctxMenuStore, {
                  visible: true,
                  list: options,
                  selected: null,
                  selectChild: null,
                  showChild: false,
                  style: {
                    zIndex: internalData.tZindex,
                    top: `${top}px`,
                    left: `${left}px`
                  }
                });
                nextTick(() => {
                  const tableMenu = refTableMenu.value;
                  const ctxElem = tableMenu.getRefMaps().refElem.value;
                  const clientHeight = ctxElem.clientHeight;
                  const clientWidth = ctxElem.clientWidth;
                  const { boundingTop, boundingLeft } = getAbsolutePos(ctxElem);
                  const offsetTop = boundingTop + clientHeight - visibleHeight;
                  const offsetLeft = boundingLeft + clientWidth - visibleWidth;
                  if (offsetTop > -10) {
                    ctxMenuStore.style.top = `${Math.max(scrollTop + 2, top - clientHeight - 2)}px`;
                  }
                  if (offsetLeft > -10) {
                    ctxMenuStore.style.left = `${Math.max(scrollLeft + 2, left - clientWidth - 2)}px`;
                  }
                });
              };
              const { keyboard, row, column } = params;
              if (keyboard && row && column) {
                $xeTable.scrollToRow(row, column).then(() => {
                  const cell = $xeTable.getCellElement(row, column);
                  if (cell) {
                    const { boundingTop, boundingLeft } = getAbsolutePos(cell);
                    top = boundingTop + scrollTop + Math.floor(cell.offsetHeight / 2);
                    left = boundingLeft + scrollLeft + Math.floor(cell.offsetWidth / 2);
                  }
                  handleVisible();
                });
              } else {
                handleVisible();
              }
            } else {
              menuMethods.closeMenu();
            }
          });
        }
      }
      $xeTable.closeFilter();
    };
    menuMethods = {
      /**
       * 关闭快捷菜单
       */
      closeMenu() {
        Object.assign(reactData.ctxMenuStore, {
          visible: false,
          selected: null,
          selectChild: null,
          showChild: false
        });
        return nextTick();
      }
    };
    menuPrivateMethods = {
      /**
       * 处理菜单的移动
       */
      moveCtxMenu(evnt, ctxMenuStore, property, hasOper, operRest, menuList) {
        let selectItem;
        const selectIndex = import_xe_utils11.default.findIndexOf(menuList, (item) => ctxMenuStore[property] === item);
        if (hasOper) {
          if (operRest && hasChildrenList(ctxMenuStore.selected)) {
            ctxMenuStore.showChild = true;
          } else {
            ctxMenuStore.showChild = false;
            ctxMenuStore.selectChild = null;
          }
        } else if (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP)) {
          for (let len = selectIndex - 1; len >= 0; len--) {
            if (menuList[len].visible !== false) {
              selectItem = menuList[len];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[menuList.length - 1];
        } else if (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN)) {
          for (let index = selectIndex + 1; index < menuList.length; index++) {
            if (menuList[index].visible !== false) {
              selectItem = menuList[index];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[0];
        } else if (ctxMenuStore[property] && (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER) || globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR))) {
          $xeTable.ctxMenuLinkEvent(evnt, ctxMenuStore[property]);
        }
      },
      handleOpenMenuEvent,
      /**
       * 快捷菜单事件处理
       */
      handleGlobalContextmenuEvent(evnt) {
        const $xeGrid2 = $xeTable.xeGrid;
        const $xeGantt2 = $xeTable.xeGantt;
        const { mouseConfig, menuConfig } = props;
        const { editStore, ctxMenuStore } = reactData;
        const { visibleColumn } = internalData;
        const tableFilter = refTableFilter.value;
        const tableMenu = refTableMenu.value;
        const mouseOpts = computeMouseOpts.value;
        const menuOpts = computeMenuOpts.value;
        const el = refElem.value;
        const { selected } = editStore;
        const layoutList = ["header", "body", "footer"];
        if (isEnableConf(menuConfig)) {
          if (ctxMenuStore.visible && tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
            evnt.preventDefault();
            return;
          }
          if (internalData._keyCtx) {
            const type = "body";
            const params = { source: "table", type, $table: $xeTable, $grid: $xeGrid2, $gantt: $xeGantt2, keyboard: true, columns: visibleColumn.slice(0), $event: evnt };
            if (mouseConfig && mouseOpts.area) {
              const activeArea = $xeTable.getActiveCellArea();
              if (activeArea && activeArea.row && activeArea.column) {
                params.row = activeArea.row;
                params.column = activeArea.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            } else if (mouseConfig && mouseOpts.selected) {
              if (selected.row && selected.column) {
                params.row = selected.row;
                params.column = selected.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            }
          }
          for (let index = 0; index < layoutList.length; index++) {
            const layout = layoutList[index];
            const columnTargetNode = getEventTargetNode(evnt, el, `vxe-${layout}--column`, (target) => {
              return target.parentNode.parentNode.parentNode.getAttribute("xid") === xID;
            });
            const params = { source: "table", type: layout, $table: $xeTable, $grid: $xeGrid2, $gantt: $xeGantt2, columns: visibleColumn.slice(0), $event: evnt };
            if (columnTargetNode.flag) {
              const cell = columnTargetNode.targetElem;
              const columnNodeRest = $xeTable.getColumnNode(cell);
              const column = columnNodeRest ? columnNodeRest.item : null;
              let typePrefix = `${layout}-`;
              if (column) {
                Object.assign(params, { column, columnIndex: $xeTable.getColumnIndex(column), cell });
              }
              if (layout === "body") {
                const rowNodeRest = $xeTable.getRowNode(cell.parentNode);
                const row = rowNodeRest ? rowNodeRest.item : null;
                typePrefix = "";
                if (row) {
                  params.row = row;
                  params.rowIndex = $xeTable.getRowIndex(row);
                }
              }
              const eventType = `${typePrefix}cell-menu`;
              handleOpenMenuEvent(evnt, layout, params);
              $xeTable.dispatchEvent(eventType, params, evnt);
              return;
            } else if (getEventTargetNode(evnt, el, `vxe-table--${layout}-wrapper`, (target) => target.getAttribute("xid") === xID).flag) {
              if (menuOpts.trigger === "cell") {
                evnt.preventDefault();
              } else {
                handleOpenMenuEvent(evnt, layout, params);
              }
              return;
            }
          }
        }
        if (tableFilter && !getEventTargetNode(evnt, tableFilter.getRefMaps().refElem.value).flag) {
          $xeTable.closeFilter();
        }
        menuMethods.closeMenu();
      },
      ctxMenuMouseoverEvent(evnt, item, child) {
        const menuElem = evnt.currentTarget;
        const { ctxMenuStore } = reactData;
        evnt.preventDefault();
        evnt.stopPropagation();
        ctxMenuStore.selected = item;
        ctxMenuStore.selectChild = child;
        if (!child) {
          ctxMenuStore.showChild = hasChildrenList(item);
          if (ctxMenuStore.showChild) {
            nextTick(() => {
              const childWrapperElem = menuElem.nextElementSibling;
              if (childWrapperElem) {
                const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(menuElem);
                const posTop = boundingTop + menuElem.offsetHeight;
                const posLeft = boundingLeft + menuElem.offsetWidth;
                let left = "";
                let right = "";
                if (posLeft + childWrapperElem.offsetWidth > visibleWidth - 10) {
                  left = "auto";
                  right = `${menuElem.offsetWidth}px`;
                }
                let top = "";
                let bottom = "";
                if (posTop + childWrapperElem.offsetHeight > visibleHeight - 10) {
                  top = "auto";
                  bottom = "0";
                }
                childWrapperElem.style.left = left;
                childWrapperElem.style.right = right;
                childWrapperElem.style.top = top;
                childWrapperElem.style.bottom = bottom;
              }
            });
          }
        }
      },
      ctxMenuMouseoutEvent(evnt, item) {
        const { ctxMenuStore } = reactData;
        if (!item.children) {
          ctxMenuStore.selected = null;
        }
        ctxMenuStore.selectChild = null;
      },
      /**
       * 快捷菜单点击事件
       */
      ctxMenuLinkEvent(evnt, menu) {
        const $xeGrid2 = $xeTable.xeGrid;
        const $xeGantt2 = $xeTable.xeGantt;
        if (!menu.loading && !menu.disabled && (menu.code || !menu.children || !menu.children.length)) {
          const gMenuOpts = menus.get(menu.code);
          const params = Object.assign({}, internalData._currMenuParams, { menu, $table: $xeTable, $grid: $xeGrid2, $gantt: $xeGantt2, $event: evnt });
          const tmMethod = gMenuOpts ? gMenuOpts.tableMenuMethod || gMenuOpts.menuMethod : null;
          if (tmMethod) {
            tmMethod(params, evnt);
          }
          $xeTable.dispatchEvent("menu-click", params, evnt);
          menuMethods.closeMenu();
        }
      }
    };
    return Object.assign(Object.assign({}, menuMethods), menuPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableMenuMethodKeys);
  },
  setupGantt($xeGantt) {
    return $xeGantt.extendTableMethods(tableMenuMethodKeys);
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/edit/hook.js
var import_xe_utils12 = __toESM(require_xe_utils());
var { getConfig: getConfig2, renderer: renderer6, hooks: hooks3, getI18n: getI18n7 } = VxeUI;
var tableEditMethodKeys = ["insert", "insertAt", "insertNextAt", "insertChild", "insertChildAt", "insertChildNextAt", "remove", "removeCheckboxRow", "removeRadioRow", "removeCurrentRow", "getRecordset", "getInsertRecords", "getRemoveRecords", "getUpdateRecords", "getEditRecord", "getActiveRecord", "getEditCell", "getSelectedCell", "clearEdit", "clearActived", "clearSelected", "isEditByRow", "isActiveByRow", "setEditRow", "setActiveRow", "setEditCell", "setActiveCell", "setSelectCell"];
hooks3.add("tableEditModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refElem } = $xeTable.getRefMaps();
    const { computeMouseOpts, computeEditOpts, computeCheckboxOpts, computeTreeOpts, computeValidOpts } = $xeTable.getComputeMaps();
    const browseObj = import_xe_utils12.default.browse();
    let editMethods = {};
    let editPrivateMethods = {};
    const getEditColumnModel = (row, column) => {
      const { model, editRender } = column;
      if (editRender) {
        model.value = getCellValue(row, column);
        model.update = false;
      }
    };
    const setEditColumnModel = (row, column) => {
      const { model, editRender } = column;
      if (editRender && model.update) {
        setCellValue(row, column, model.value);
        model.update = false;
        model.value = null;
      }
    };
    const removeCellSelectedClass = () => {
      const el = refElem.value;
      if (el) {
        const cell = el.querySelector(".col--selected");
        if (cell) {
          removeClass(cell, "col--selected");
        }
      }
    };
    const syncActivedCell = () => {
      const { editStore, tableColumn } = reactData;
      const editOpts = computeEditOpts.value;
      const { actived } = editStore;
      const { row, column } = actived;
      if (row || column) {
        if (editOpts.mode === "row") {
          tableColumn.forEach((column2) => setEditColumnModel(row, column2));
        } else {
          setEditColumnModel(row, column);
        }
      }
    };
    const insertTreeRow = (newRecords, isAppend) => {
      const { tableFullTreeData, afterFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { rowField, parentField, mapChildrenField } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const funcName = isAppend ? "push" : "unshift";
      newRecords.forEach((item) => {
        const parentRowId = item[parentField];
        const rowid = getRowid($xeTable, item);
        const matchObj = parentRowId ? import_xe_utils12.default.findTree(tableFullTreeData, (item2) => parentRowId === item2[rowField], { children: mapChildrenField }) : null;
        if (matchObj) {
          const { item: parentRow } = matchObj;
          const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
          const parentLevel = parentRest ? parentRest.level : 0;
          let pChilds = parentRow[childrenField];
          let pMapChilds = parentRow[mapChildrenField];
          if (!import_xe_utils12.default.isArray(pChilds)) {
            pChilds = parentRow[childrenField] = [];
          }
          if (!import_xe_utils12.default.isArray(pMapChilds)) {
            pMapChilds = parentRow[mapChildrenField] = [];
          }
          pChilds[funcName](item);
          pMapChilds[funcName](item);
          const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, treeIndex: -1, _tIndex: -1, items: pChilds, parent: parentRow, level: parentLevel + 1, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        } else {
          if (parentRowId) {
            warnLog("vxe.error.unableInsert");
          }
          afterFullData[funcName](item);
          tableFullTreeData[funcName](item);
          const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, treeIndex: -1, _tIndex: -1, items: tableFullTreeData, parent: null, level: 0, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        }
      });
    };
    const handleInsertRowAt = (records, targetRow, isInsertNextRow) => {
      const { treeConfig } = props;
      const { isRowGroupStatus } = reactData;
      const { tableFullTreeData, afterFullData, mergeBodyList, tableFullData, fullDataRowIdData, fullAllDataRowIdData, insertRowMaps, removeRowMaps } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { transform, parentField, rowField, mapChildrenField } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      if (!import_xe_utils12.default.isArray(records)) {
        records = [records];
      }
      const newRecords = reactive($xeTable.defineField(records.map((record) => Object.assign(treeConfig && transform ? { [mapChildrenField]: [], [childrenField]: [] } : {}, record))));
      let treeRecords = [];
      if (treeConfig && transform) {
        treeRecords = import_xe_utils12.default.toArrayTree(newRecords, { key: rowField, parentKey: parentField, children: childrenField });
      }
      if (import_xe_utils12.default.eqNull(targetRow)) {
        if (treeConfig && transform) {
          insertTreeRow(newRecords, false);
        } else if (isRowGroupStatus) {
          if (treeConfig) {
            throw new Error(getI18n7("vxe.error.noTree", ["insert"]));
          }
          warnLog(getI18n7("vxe.error.noGroup", ["remove"]));
        } else {
          newRecords.forEach((item) => {
            const rowid = getRowid($xeTable, item);
            const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, treeIndex: -1, _tIndex: -1, items: afterFullData, parent: null, level: 0, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
            afterFullData.unshift(item);
            tableFullData.unshift(item);
          });
          mergeBodyList.forEach((mergeItem) => {
            const { row: mergeRowIndex } = mergeItem;
            if (mergeRowIndex >= 0) {
              mergeItem.row = mergeRowIndex + newRecords.length;
            }
          });
        }
      } else {
        if (targetRow === -1) {
          if (treeConfig && transform) {
            insertTreeRow(newRecords, true);
          } else if (isRowGroupStatus) {
            if (treeConfig) {
              throw new Error(getI18n7("vxe.error.noTree", ["insert"]));
            }
            warnLog(getI18n7("vxe.error.noGroup", ["remove"]));
          } else {
            newRecords.forEach((item) => {
              const rowid = getRowid($xeTable, item);
              const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, treeIndex: -1, _tIndex: -1, $index: -1, items: afterFullData, parent: null, level: 0, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
              fullDataRowIdData[rowid] = rest;
              fullAllDataRowIdData[rowid] = rest;
              afterFullData.push(item);
              tableFullData.push(item);
            });
          }
        } else {
          if (treeConfig && transform) {
            const matchMapObj = import_xe_utils12.default.findTree(tableFullTreeData, (item) => targetRow[rowField] === item[rowField], { children: mapChildrenField });
            if (matchMapObj) {
              const { parent: parentRow } = matchMapObj;
              const parentMapChilds = parentRow ? parentRow[mapChildrenField] : tableFullTreeData;
              const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
              const parentLevel = parentRest ? parentRest.level : 0;
              treeRecords.forEach((row, i) => {
                if (parentRow) {
                  if (row[parentField] !== parentRow[rowField]) {
                    errLog("vxe.error.errProp", [`${parentField}=${row[parentField]}`, `${parentField}=${parentRow[rowField]}`]);
                    row[parentField] = parentRow[rowField];
                  }
                } else {
                  if (row[parentField] !== null) {
                    if (!import_xe_utils12.default.eqNull(row[parentField])) {
                      errLog("vxe.error.errProp", [`${parentField}=${row[parentField]}`, "null"]);
                    }
                    row[parentField] = null;
                  }
                }
                let targetIndex = matchMapObj.index + i;
                if (isInsertNextRow) {
                  targetIndex = targetIndex + 1;
                }
                parentMapChilds.splice(targetIndex, 0, row);
              });
              import_xe_utils12.default.eachTree(treeRecords, (item) => {
                const rowid = getRowid($xeTable, item);
                const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, treeIndex: -1, _tIndex: -1, items: parentMapChilds, parent: parentRow, level: parentLevel + 1, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
                if (item[childrenField]) {
                  item[mapChildrenField] = item[childrenField];
                }
                fullDataRowIdData[rowid] = rest;
                fullAllDataRowIdData[rowid] = rest;
              }, { children: childrenField });
              if (parentRow) {
                const matchObj = import_xe_utils12.default.findTree(tableFullTreeData, (item) => targetRow[rowField] === item[rowField], { children: childrenField });
                if (matchObj) {
                  const parentChilds = matchObj.items;
                  let targetIndex = matchObj.index;
                  if (isInsertNextRow) {
                    targetIndex = targetIndex + 1;
                  }
                  parentChilds.splice(targetIndex, 0, ...treeRecords);
                }
              }
            } else {
              warnLog("vxe.error.unableInsert");
              insertTreeRow(newRecords, true);
            }
          } else if (isRowGroupStatus) {
            if (treeConfig) {
              throw new Error(getI18n7("vxe.error.noTree", ["insert"]));
            }
            warnLog(getI18n7("vxe.error.noGroup", ["remove"]));
          } else {
            if (treeConfig) {
              throw new Error(getI18n7("vxe.error.noTree", ["insert"]));
            }
            let afIndex = -1;
            if (import_xe_utils12.default.isNumber(targetRow)) {
              if (targetRow < afterFullData.length) {
                afIndex = targetRow;
              }
            } else {
              afIndex = $xeTable.findRowIndexOf(afterFullData, targetRow);
            }
            if (isInsertNextRow) {
              afIndex = Math.min(afterFullData.length, afIndex + 1);
            }
            if (afIndex === -1) {
              throw new Error(getI18n7("vxe.error.unableInsert"));
            }
            afterFullData.splice(afIndex, 0, ...newRecords);
            const tfIndex = $xeTable.findRowIndexOf(tableFullData, targetRow);
            if (tfIndex > -1) {
              tableFullData.splice(tfIndex + (isInsertNextRow ? 1 : 0), 0, ...newRecords);
            } else {
              tableFullData.push(...newRecords);
            }
            mergeBodyList.forEach((mergeItem) => {
              const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
              if (mergeRowIndex >= afIndex) {
                mergeItem.row = mergeRowIndex + newRecords.length;
              } else if (isInsertNextRow ? mergeRowIndex + mergeRowspan >= afIndex : mergeRowIndex + mergeRowspan > afIndex) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        }
      }
      const handleStatus = (newRow) => {
        const rowid = getRowid($xeTable, newRow);
        if (removeRowMaps[rowid]) {
          delete removeRowMaps[rowid];
          if (insertRowMaps[rowid]) {
            delete insertRowMaps[rowid];
          }
        } else {
          insertRowMaps[rowid] = newRow;
        }
      };
      if (treeConfig && transform) {
        import_xe_utils12.default.eachTree(treeRecords, handleStatus, { children: mapChildrenField });
      } else {
        newRecords.forEach(handleStatus);
      }
      reactData.removeRowFlag++;
      reactData.insertRowFlag++;
      $xeTable.cacheRowMap(false);
      $xeTable.updateScrollYStatus();
      $xeTable.handleTableData(treeConfig && transform);
      if (!(treeConfig && transform)) {
        $xeTable.updateAfterDataIndex();
      }
      $xeTable.updateFooter();
      $xeTable.handleUpdateBodyMerge();
      $xeTable.checkSelectionStatus();
      if (reactData.scrollYLoad) {
        $xeTable.updateScrollYSpace();
      }
      return nextTick().then(() => {
        $xeTable.updateCellAreas();
        return $xeTable.recalculate(true);
      }).then(() => {
        return {
          row: newRecords.length ? newRecords[newRecords.length - 1] : null,
          rows: newRecords
        };
      });
    };
    const handleInsertChildRowAt = (records, parentRow, targetRow, isInsertNextRow) => {
      const { treeConfig } = props;
      const treeOpts = computeTreeOpts.value;
      const { transform, rowField, parentField } = treeOpts;
      if (treeConfig && transform) {
        if (!import_xe_utils12.default.isArray(records)) {
          records = [records];
        }
        return handleInsertRowAt(records.map((item) => Object.assign({}, item, { [parentField]: parentRow[rowField] })), targetRow, isInsertNextRow);
      } else {
        errLog("vxe.error.errProp", ["tree-config.transform=false", "tree-config.transform=true"]);
      }
      return Promise.resolve({ row: null, rows: [] });
    };
    const handleClearEdit = (evnt, targetRow) => {
      const { editStore } = reactData;
      const { actived, focused } = editStore;
      const { row, column } = actived;
      const validOpts = computeValidOpts.value;
      if (row || column) {
        if (targetRow && getRowid($xeTable, targetRow) !== getRowid($xeTable, row)) {
          return nextTick();
        }
        syncActivedCell();
        actived.args = null;
        actived.row = null;
        actived.column = null;
        $xeTable.updateFooter();
        $xeTable.dispatchEvent("edit-closed", {
          row,
          rowIndex: $xeTable.getRowIndex(row),
          $rowIndex: $xeTable.getVMRowIndex(row),
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          $columnIndex: $xeTable.getVMColumnIndex(column)
        }, evnt || null);
      }
      focused.row = null;
      focused.column = null;
      if (validOpts.autoClear) {
        if (validOpts.msgMode !== "full" || getConfig2().cellVaildMode === "obsolete") {
          if ($xeTable.clearValidate) {
            return $xeTable.clearValidate();
          }
        }
      }
      return nextTick().then(() => $xeTable.updateCellAreas());
    };
    const handleEditActive = (params, evnt, isFocus, isPos) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const { editConfig, mouseConfig } = props;
      const { editStore, tableColumn } = reactData;
      const editOpts = computeEditOpts.value;
      const { mode } = editOpts;
      const { actived, focused } = editStore;
      const { row, column } = params;
      const { editRender } = column;
      const cell = params.cell || $xeTable.getCellElement(row, column);
      const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
      params.cell = cell;
      if (cell && isEnableConf(editConfig) && isEnableConf(editRender)) {
        if (!$xeTable.isPendingByRow(row) && !$xeTable.isAggregateRecord(row)) {
          if (actived.row !== row || (mode === "cell" ? actived.column !== column : false)) {
            let type = "edit-disabled";
            if (!beforeEditMethod || beforeEditMethod(Object.assign(Object.assign({}, params), { $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt }))) {
              if (mouseConfig) {
                $xeTable.clearSelected();
                if ($xeTable.clearCellAreas) {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                }
              }
              $xeTable.closeTooltip();
              if (actived.column) {
                handleClearEdit(evnt);
              }
              type = "edit-activated";
              column.renderHeight = cell.offsetHeight;
              actived.args = params;
              actived.row = row;
              actived.column = column;
              if (mode === "row") {
                tableColumn.forEach((column2) => getEditColumnModel(row, column2));
              } else {
                getEditColumnModel(row, column);
              }
              const afterEditMethod = editOpts.afterEditMethod;
              nextTick(() => {
                if (isFocus) {
                  $xeTable.handleFocus(params, evnt);
                }
                if (afterEditMethod) {
                  afterEditMethod(Object.assign(Object.assign({}, params), { $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt }));
                }
              });
            }
            $xeTable.dispatchEvent(type, {
              row,
              rowIndex: $xeTable.getRowIndex(row),
              $rowIndex: $xeTable.getVMRowIndex(row),
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              $columnIndex: $xeTable.getVMColumnIndex(column)
            }, evnt);
            if (type === "edit-activated") {
              $xeTable.dispatchEvent("edit-actived", {
                row,
                rowIndex: $xeTable.getRowIndex(row),
                $rowIndex: $xeTable.getVMRowIndex(row),
                column,
                columnIndex: $xeTable.getColumnIndex(column),
                $columnIndex: $xeTable.getVMColumnIndex(column)
              }, evnt);
            }
          } else {
            const { column: oldColumn } = actived;
            if (mouseConfig) {
              $xeTable.clearSelected();
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
            }
            if (oldColumn !== column) {
              const { model: oldModel } = oldColumn;
              if (oldModel.update) {
                setCellValue(row, oldColumn, oldModel.value);
              }
              if ($xeTable.clearValidate) {
                $xeTable.clearValidate(row, column);
              }
            }
            column.renderHeight = cell.offsetHeight;
            actived.args = params;
            actived.column = column;
            if (isPos) {
              setTimeout(() => {
                $xeTable.handleFocus(params, evnt);
              });
            }
          }
          focused.column = null;
          focused.row = null;
          $xeTable.focus();
        }
      }
      return nextTick();
    };
    const handleEditCell = (row, fieldOrColumn, isPos) => {
      const { editConfig } = props;
      const column = import_xe_utils12.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
      if (row && column && isEnableConf(editConfig) && isEnableConf(column.editRender) && !$xeTable.isAggregateRecord(row)) {
        return Promise.resolve(isPos ? $xeTable.scrollToRow(row, column) : null).then(() => {
          const cell = $xeTable.getCellElement(row, column);
          if (cell) {
            handleEditActive({
              row,
              rowIndex: $xeTable.getRowIndex(row),
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              cell,
              $table: $xeTable
            }, null, isPos, isPos);
            internalData._lastCallTime = Date.now();
          }
          return nextTick();
        });
      }
      return nextTick();
    };
    editMethods = {
      /**
       * 往表格中插入临时数据
       *
       * @param {*} records
       */
      insert(records) {
        return handleInsertRowAt(records, null);
      },
      /**
       * 往表格指定行中插入临时数据
       * 如果 row 为空则从插入到顶部，如果为树结构，则插入到目标节点顶部
       * 如果 row 为 -1 则从插入到底部，如果为树结构，则插入到目标节点底部
       * 如果 row 为有效行则插入到该行的位置，如果为树结构，则有插入到效的目标节点该行的位置
       * @param {Object/Array} records 新的数据
       * @param {Row} targetRow 指定行
       */
      insertAt(records, targetRow) {
        return handleInsertRowAt(records, targetRow);
      },
      insertNextAt(records, targetRow) {
        return handleInsertRowAt(records, targetRow, true);
      },
      insertChild(records, parentRow) {
        return handleInsertChildRowAt(records, parentRow, null);
      },
      insertChildAt(records, parentRow, targetRow) {
        return handleInsertChildRowAt(records, parentRow, targetRow);
      },
      insertChildNextAt(records, parentRow, targetRow) {
        return handleInsertChildRowAt(records, parentRow, targetRow, true);
      },
      /**
       * 删除指定行数据
       * 如果传 row 则删除一行
       * 如果传 rows 则删除多行
       * 如果为空则删除所有
       */
      remove(rows) {
        const { treeConfig } = props;
        const { editStore, isRowGroupStatus } = reactData;
        const { tableFullTreeData, selectCheckboxMaps, afterFullData, mergeBodyList, tableFullData, pendingRowMaps, insertRowMaps, removeRowMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { actived } = editStore;
        const { checkField } = checkboxOpts;
        let delList = [];
        if (!rows) {
          rows = tableFullData;
        } else if (!import_xe_utils12.default.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach((row) => {
          if (!$xeTable.isInsertByRow(row)) {
            const rowid = getRowid($xeTable, row);
            removeRowMaps[rowid] = row;
          }
        });
        if (!checkField) {
          rows.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            if (selectCheckboxMaps[rowid]) {
              delete selectCheckboxMaps[rowid];
            }
          });
          reactData.updateCheckboxFlag++;
        }
        if (tableFullData === rows) {
          rows = delList = tableFullData.slice(0);
          internalData.tableFullData = [];
          internalData.afterFullData = [];
          $xeTable.clearMergeCells();
        } else {
          if (treeConfig && transform) {
            rows.forEach((row) => {
              const rowid = getRowid($xeTable, row);
              const matchMapObj = import_xe_utils12.default.findTree(tableFullTreeData, (item) => rowid === getRowid($xeTable, item), { children: mapChildrenField });
              if (matchMapObj) {
                const rItems = matchMapObj.items.splice(matchMapObj.index, 1);
                delList.push(rItems[0]);
              }
              const matchObj = import_xe_utils12.default.findTree(tableFullTreeData, (item) => rowid === getRowid($xeTable, item), { children: childrenField });
              if (matchObj) {
                matchObj.items.splice(matchObj.index, 1);
              }
              const afIndex = $xeTable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                afterFullData.splice(afIndex, 1);
              }
            });
          } else if (isRowGroupStatus) {
            warnLog(getI18n7("vxe.error.noGroup", ["remove"]));
          } else {
            rows.forEach((row) => {
              const tfIndex = $xeTable.findRowIndexOf(tableFullData, row);
              if (tfIndex > -1) {
                const rItems = tableFullData.splice(tfIndex, 1);
                delList.push(rItems[0]);
              }
              const afIndex = $xeTable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                mergeBodyList.forEach((mergeItem) => {
                  const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
                  if (mergeRowIndex > afIndex) {
                    mergeItem.row = mergeRowIndex - 1;
                  } else if (mergeRowIndex + mergeRowspan > afIndex) {
                    mergeItem.rowspan = mergeRowspan - 1;
                  }
                });
                afterFullData.splice(afIndex, 1);
              }
            });
          }
        }
        if (actived.row && $xeTable.findRowIndexOf(rows, actived.row) > -1) {
          editMethods.clearEdit();
        }
        rows.forEach((row) => {
          const rowid = getRowid($xeTable, row);
          if (insertRowMaps[rowid]) {
            delete insertRowMaps[rowid];
          }
          if (pendingRowMaps[rowid]) {
            delete pendingRowMaps[rowid];
          }
        });
        reactData.removeRowFlag++;
        reactData.insertRowFlag++;
        reactData.pendingRowFlag++;
        $xeTable.cacheRowMap(false);
        $xeTable.handleTableData(treeConfig && transform);
        $xeTable.updateFooter();
        $xeTable.handleUpdateBodyMerge();
        if (!(treeConfig && transform)) {
          $xeTable.updateAfterDataIndex();
        }
        $xeTable.checkSelectionStatus();
        if (reactData.scrollYLoad) {
          $xeTable.updateScrollYSpace();
        }
        return nextTick().then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate(true);
        }).then(() => {
          return { row: delList.length ? delList[delList.length - 1] : null, rows: delList };
        });
      },
      /**
       * 删除复选框选中的数据
       */
      removeCheckboxRow() {
        return editMethods.remove($xeTable.getCheckboxRecords()).then((params) => {
          $xeTable.clearCheckboxRow();
          return params;
        });
      },
      /**
       * 删除单选框选中的数据
       */
      removeRadioRow() {
        const radioRecord = $xeTable.getRadioRecord();
        return editMethods.remove(radioRecord || []).then((params) => {
          $xeTable.clearRadioRow();
          return params;
        });
      },
      /**
       * 删除当前行选中的数据
       */
      removeCurrentRow() {
        const currentRecord = $xeTable.getCurrentRecord();
        return editMethods.remove(currentRecord || []).then((params) => {
          $xeTable.clearCurrentRow();
          return params;
        });
      },
      /**
       * 获取表格数据集，包含新增、删除、修改、标记
       */
      getRecordset() {
        const removeRecords = editMethods.getRemoveRecords();
        const pendingRecords = $xeTable.getPendingRecords();
        const delRecords = removeRecords.concat(pendingRecords);
        const updateRecords = editMethods.getUpdateRecords().filter((row) => {
          return !delRecords.some((item) => $xeTable.eqRow(item, row));
        });
        return {
          insertRecords: editMethods.getInsertRecords(),
          removeRecords,
          updateRecords,
          pendingRecords
        };
      },
      /**
       * 获取新增的临时数据
       */
      getInsertRecords() {
        const { fullAllDataRowIdData, insertRowMaps } = internalData;
        const insertRecords = [];
        import_xe_utils12.default.each(insertRowMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      /**
       * 获取已删除的数据
       */
      getRemoveRecords() {
        const { removeRowMaps } = internalData;
        const removeRecords = [];
        import_xe_utils12.default.each(removeRowMaps, (row) => {
          removeRecords.push(row);
        });
        return removeRecords;
      },
      /**
       * 获取更新数据
       * 只精准匹配 row 的更改
       * 如果是树表格，子节点更改状态不会影响父节点的更新状态
       */
      getUpdateRecords() {
        const { keepSource, treeConfig } = props;
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        if (keepSource) {
          syncActivedCell();
          if (treeConfig) {
            return import_xe_utils12.default.filterTree(tableFullData, (row) => $xeTable.isUpdateByRow(row), treeOpts);
          }
          return tableFullData.filter((row) => $xeTable.isUpdateByRow(row));
        }
        return [];
      },
      getActiveRecord() {
        warnLog("vxe.error.delFunc", ["getActiveRecord", "getEditCell"]);
        const { editStore } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const { args, row } = editStore.actived;
        if (args && row && fullAllDataRowIdData[getRowid($xeTable, row)]) {
          return Object.assign({}, args, { row });
        }
        return null;
      },
      getEditRecord() {
        warnLog("vxe.error.delFunc", ["getEditRecord", "getEditCell"]);
        const { editStore } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const { args, row } = editStore.actived;
        if (args && row && fullAllDataRowIdData[getRowid($xeTable, row)]) {
          return Object.assign({}, args, { row });
        }
        return null;
      },
      getEditCell() {
        const { editStore } = reactData;
        const { row, column } = editStore.actived;
        if (column && row) {
          return {
            row,
            rowIndex: $xeTable.getRowIndex(row),
            column,
            columnIndex: $xeTable.getColumnIndex(column)
          };
        }
        return null;
      },
      /**
       * 获取选中的单元格
       */
      getSelectedCell() {
        const { editStore } = reactData;
        const { row, column } = editStore.selected;
        if (row && column) {
          return {
            row,
            column
          };
        }
        return null;
      },
      clearActived(row) {
        warnLog("vxe.error.delFunc", ["clearActived", "clearEdit"]);
        return $xeTable.clearEdit(row);
      },
      /**
       * 清除激活的编辑
       */
      clearEdit(row) {
        return handleClearEdit(null, row);
      },
      /**
       * 清除所选中源状态
       */
      clearSelected() {
        const { editStore } = reactData;
        const { selected } = editStore;
        selected.row = null;
        selected.column = null;
        removeCellSelectedClass();
        return nextTick();
      },
      isActiveByRow(row) {
        warnLog("vxe.error.delFunc", ["isActiveByRow", "isEditByRow"]);
        return $xeTable.isEditByRow(row);
      },
      /**
       * 判断行是否为激活编辑状态
       * @param {Row} row 行对象
       */
      isEditByRow(row) {
        const { editStore } = reactData;
        return editStore.actived.row === row;
      },
      setActiveRow(row) {
        warnLog("vxe.error.delFunc", ["setActiveRow", "setEditRow"]);
        return editMethods.setEditRow(row);
      },
      /**
       * 激活行编辑
       */
      setEditRow(row, fieldOrColumn) {
        const { visibleColumn } = internalData;
        let column = import_xe_utils12.default.find(visibleColumn, (column2) => isEnableConf(column2.editRender));
        let isPos = false;
        if (fieldOrColumn) {
          isPos = true;
          if (fieldOrColumn !== true) {
            column = import_xe_utils12.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
          }
        }
        return handleEditCell(row, column, isPos);
      },
      setActiveCell(row, fieldOrColumn) {
        warnLog("vxe.error.delFunc", ["setActiveCell", "setEditCell"]);
        return editMethods.setEditCell(row, fieldOrColumn);
      },
      /**
       * 激活单元格编辑
       */
      setEditCell(row, fieldOrColumn) {
        return handleEditCell(row, fieldOrColumn, true);
      },
      /**
       * 只对 trigger=dblclick 有效，选中单元格
       */
      setSelectCell(row, fieldOrColumn) {
        const { tableData } = reactData;
        const editOpts = computeEditOpts.value;
        const column = import_xe_utils12.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && editOpts.trigger !== "manual") {
          const rowIndex = $xeTable.findRowIndexOf(tableData, row);
          if (rowIndex > -1 && column) {
            const cell = $xeTable.getCellElement(row, column);
            const params = {
              row,
              rowIndex,
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              cell
            };
            $xeTable.handleSelected(params, {});
          }
        }
        return nextTick();
      }
    };
    editPrivateMethods = {
      /**
       * 处理激活编辑
       */
      handleEdit(params, evnt) {
        return handleEditActive(params, evnt, true, true);
      },
      /**
       * @deprecated
       */
      handleActived(params, evnt) {
        return editPrivateMethods.handleEdit(params, evnt);
      },
      /**
       * 处理取消编辑
       * @param evnt
       * @returns
       */
      handleClearEdit,
      /**
       * 处理聚焦
       */
      handleFocus(params) {
        const { row, column, cell } = params;
        const { editRender } = column;
        const editOpts = computeEditOpts.value;
        if (isEnableConf(editRender)) {
          const compRender = renderer6.get(editRender.name);
          let autoFocus = editRender.autofocus || editRender.autoFocus;
          let autoSelect = editRender.autoSelect || editRender.autoselect;
          let inputElem;
          if (editOpts.autoFocus) {
            if (!autoFocus && compRender) {
              autoFocus = compRender.tableAutoFocus || compRender.tableAutofocus || compRender.autofocus;
            }
            if (!autoSelect && compRender) {
              autoSelect = compRender.tableAutoSelect || compRender.autoselect;
            }
            if (import_xe_utils12.default.isFunction(autoFocus)) {
              inputElem = autoFocus(params);
            } else if (autoFocus) {
              if (autoFocus === true) {
                inputElem = cell.querySelector("input,textarea");
              } else {
                inputElem = cell.querySelector(autoFocus);
              }
              if (inputElem) {
                inputElem.focus();
              }
            }
          }
          if (inputElem) {
            if (autoSelect) {
              inputElem.select();
            } else {
              if (browseObj.msie) {
                const textRange = inputElem.createTextRange();
                textRange.collapse(false);
                textRange.select();
              }
            }
          } else {
            if (editOpts.autoPos) {
              if (!column.fixed) {
                $xeTable.scrollToRow(row, column);
              }
            }
          }
        }
      },
      /**
       * 处理选中源
       */
      handleSelected(params, evnt) {
        const { mouseConfig } = props;
        const { editStore } = reactData;
        const mouseOpts = computeMouseOpts.value;
        const editOpts = computeEditOpts.value;
        const { actived, selected } = editStore;
        const { row, column } = params;
        const isMouseSelected = mouseConfig && mouseOpts.selected;
        const selectMethod = () => {
          if (isMouseSelected && (selected.row !== row || selected.column !== column)) {
            if (actived.row !== row || (editOpts.mode === "cell" ? actived.column !== column : false)) {
              handleClearEdit(evnt);
              $xeTable.clearSelected();
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
              selected.args = params;
              selected.row = row;
              selected.column = column;
              if (isMouseSelected) {
                editPrivateMethods.addCellSelectedClass();
              }
              $xeTable.focus();
              if (evnt) {
                $xeTable.dispatchEvent("cell-selected", params, evnt);
              }
            }
          }
          return nextTick();
        };
        return selectMethod();
      },
      addCellSelectedClass() {
        const { editStore } = reactData;
        const { selected } = editStore;
        const { row, column } = selected;
        removeCellSelectedClass();
        if (row && column) {
          const cell = $xeTable.getCellElement(row, column);
          if (cell) {
            addClass(cell, "col--selected");
          }
        }
      }
    };
    return Object.assign(Object.assign({}, editMethods), editPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableEditMethodKeys);
  },
  setupGantt($xeGantt) {
    return $xeGantt.extendTableMethods(tableEditMethodKeys);
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/export/hook.js
var import_xe_utils13 = __toESM(require_xe_utils());

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/export/util.js
var defaultHtmlStyle = 'body{margin:0;padding: 0 1px;color:#333333;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function getExportBlobByContent(content, options) {
  return new Blob([content], { type: `text/${options.type};charset=utf-8;` });
}
function createHtmlPage(opts, content) {
  const { style } = opts;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${opts.sheetName}</title>`,
    '<style media="print">.vxe-page-break-before{page-break-before:always;}.vxe-page-break-after{page-break-after:always;}</style>',
    `<style>${defaultHtmlStyle}</style>`,
    style ? `<style>${style}</style>` : "",
    "</head>",
    `<body>${content}</body>`,
    "</html>"
  ].join("");
}

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/export/hook.js
var { getI18n: getI18n8, hooks: hooks4, renderer: renderer7 } = VxeUI;
var htmlCellElem;
var csvBOM = "\uFEFF";
var enterSymbol = "\r\n";
function defaultFilterExportColumn(column) {
  return !!column.field || ["seq", "checkbox", "radio"].indexOf(column.type || "") === -1;
}
var getConvertColumns = (columns) => {
  const result = [];
  columns.forEach((column) => {
    if (column.childNodes && column.childNodes.length) {
      result.push(column);
      result.push(...getConvertColumns(column.childNodes));
    } else {
      result.push(column);
    }
  });
  return result;
};
var convertToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column._level = parent._level + 1;
      if (maxLevel < column._level) {
        maxLevel = column._level;
      }
    }
    if (column.childNodes && column.childNodes.length) {
      let colSpan = 0;
      column.childNodes.forEach((subColumn) => {
        traverse(subColumn, column);
        colSpan += subColumn._colSpan;
      });
      column._colSpan = colSpan;
    } else {
      column._colSpan = 1;
    }
  };
  originColumns.forEach((column) => {
    column._level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getConvertColumns(originColumns);
  allColumns.forEach((column) => {
    if (column.childNodes && column.childNodes.length) {
      column._rowSpan = 1;
    } else {
      column._rowSpan = maxLevel - column._level + 1;
    }
    rows[column._level - 1].push(column);
  });
  return rows;
};
function toTableBorder(border) {
  if (border === true) {
    return "full";
  }
  if (border) {
    return border;
  }
  return "default";
}
function getBooleanValue(cellValue) {
  return cellValue === "TRUE" || cellValue === "true" || cellValue === true;
}
function getFooterData($xeTable, opts, footerTableData) {
  const $xeGrid = $xeTable.xeGrid;
  const $xeGantt = $xeTable.xeGantt;
  const { footerFilterMethod } = opts;
  return footerFilterMethod ? footerTableData.filter((items, index) => footerFilterMethod({ $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt, items, $rowIndex: index })) : footerTableData;
}
function getCsvCellTypeLabel(column, cellValue) {
  if (cellValue) {
    if (column.type === "seq") {
      return `	${cellValue}`;
    }
    switch (column.cellType) {
      case "string":
        if (!isNaN(cellValue)) {
          return `	${cellValue}`;
        }
        break;
      case "number":
        break;
      default:
        if (cellValue.length >= 12 && !isNaN(cellValue)) {
          return `	${cellValue}`;
        }
        break;
    }
  }
  return cellValue;
}
function toTxtCellLabel(val) {
  if (/[",\s\n]/.test(val)) {
    return `"${val.replace(/"/g, '""')}"`;
  }
  return val;
}
function getElementsByTagName(elem, qualifiedName) {
  return elem.getElementsByTagName(qualifiedName);
}
function getTxtCellKey(now) {
  return `#${now}@${import_xe_utils13.default.uniqueId()}`;
}
function replaceTxtCell(cell, vMaps) {
  return cell.replace(/#\d+@\d+/g, (key) => import_xe_utils13.default.hasOwnProp(vMaps, key) ? vMaps[key] : key);
}
function getTxtCellValue(val, vMaps) {
  const rest = replaceTxtCell(val, vMaps);
  return rest.replace(/^"+$/g, (qVal) => '"'.repeat(Math.ceil(qVal.length / 2)));
}
function toExportField(tableConf, field) {
  const { fieldMaps, titleMaps } = tableConf;
  if (!fieldMaps[field]) {
    const teCol = titleMaps[field];
    if (teCol && teCol.field) {
      field = teCol.field;
    }
  }
  return field;
}
function parseCsvAndTxt(tableConf, content, cellSeparator) {
  const list = content.split(enterSymbol);
  const rows = [];
  let fields = [];
  if (list.length) {
    const vMaps = {};
    const now = Date.now();
    list.forEach((rVal) => {
      if (rVal) {
        const item = {};
        rVal = rVal.replace(/("")|(\n)/g, (text, dVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = dVal ? '"' : "\n";
          return key;
        }).replace(/"(.*?)"/g, (text, cVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = replaceTxtCell(cVal, vMaps);
          return key;
        });
        const cells = rVal.split(cellSeparator);
        if (!fields.length) {
          fields = cells.map((val) => toExportField(tableConf, getTxtCellValue(val.trim(), vMaps)));
        } else {
          cells.forEach((val, colIndex) => {
            if (colIndex < fields.length) {
              item[fields[colIndex]] = getTxtCellValue(val.trim(), vMaps);
            }
          });
          rows.push(item);
        }
      }
    });
  }
  return { fields, rows };
}
function parseCsv(tableConf, content) {
  return parseCsvAndTxt(tableConf, content, ",");
}
function parseTxt(tableConf, content) {
  return parseCsvAndTxt(tableConf, content, "	");
}
function parseHTML(tableConf, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, "text/html");
  const bodyNodes = getElementsByTagName(xmlDoc, "body");
  const rows = [];
  const fields = [];
  if (bodyNodes.length) {
    const tableNodes = getElementsByTagName(bodyNodes[0], "table");
    if (tableNodes.length) {
      const theadNodes = getElementsByTagName(tableNodes[0], "thead");
      if (theadNodes.length) {
        import_xe_utils13.default.arrayEach(getElementsByTagName(theadNodes[0], "tr"), (rowNode) => {
          import_xe_utils13.default.arrayEach(getElementsByTagName(rowNode, "th"), (cellNode) => {
            fields.push(toExportField(tableConf, cellNode.textContent || ""));
          });
        });
        const tbodyNodes = getElementsByTagName(tableNodes[0], "tbody");
        if (tbodyNodes.length) {
          import_xe_utils13.default.arrayEach(getElementsByTagName(tbodyNodes[0], "tr"), (rowNode) => {
            const item = {};
            import_xe_utils13.default.arrayEach(getElementsByTagName(rowNode, "td"), (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent || "";
              }
            });
            rows.push(item);
          });
        }
      }
    }
  }
  return { fields, rows };
}
function parseXML(tableConf, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, "application/xml");
  const sheetNodes = getElementsByTagName(xmlDoc, "Worksheet");
  const rows = [];
  const fields = [];
  if (sheetNodes.length) {
    const tableNodes = getElementsByTagName(sheetNodes[0], "Table");
    if (tableNodes.length) {
      const rowNodes = getElementsByTagName(tableNodes[0], "Row");
      if (rowNodes.length) {
        import_xe_utils13.default.arrayEach(getElementsByTagName(rowNodes[0], "Cell"), (cellNode) => {
          fields.push(toExportField(tableConf, cellNode.textContent || ""));
        });
        import_xe_utils13.default.arrayEach(rowNodes, (rowNode, index) => {
          if (index) {
            const item = {};
            const cellNodes = getElementsByTagName(rowNode, "Cell");
            import_xe_utils13.default.arrayEach(cellNodes, (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent;
              }
            });
            rows.push(item);
          }
        });
      }
    }
  }
  return { fields, rows };
}
function clearColumnConvert(columns) {
  import_xe_utils13.default.eachTree(columns, (column) => {
    delete column._level;
    delete column._colSpan;
    delete column._rowSpan;
    delete column._children;
    delete column.childNodes;
  }, { children: "children" });
}
var tableExportMethodKeys = ["exportData", "importByFile", "importData", "saveFile", "readFile", "print", "getPrintHtml", "openImport", "closeImport", "openExport", "closeExport", "openPrint", "closePrint"];
hooks4.add("tableExportModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { computeTreeOpts, computePrintOpts, computeExportOpts, computeImportOpts, computeCustomOpts, computeSeqOpts, computeRadioOpts, computeCheckboxOpts, computeColumnOpts } = $xeTable.getComputeMaps();
    const hasTreeChildren = (row) => {
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      return row[childrenField] && row[childrenField].length;
    };
    const getSeq = (cellValue, row, $rowIndex, column, $columnIndex) => {
      const seqOpts = computeSeqOpts.value;
      const seqMd = seqOpts.seqMethod || column.seqMethod;
      if (seqMd) {
        return seqMd({
          $table: $xeTable,
          row,
          rowIndex: $xeTable.getRowIndex(row),
          _rowIndex: $xeTable.getVTRowIndex(row),
          $rowIndex,
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          _columnIndex: $xeTable.getVTColumnIndex(column),
          $columnIndex
        });
      }
      return cellValue;
    };
    function getHeaderTitle(opts, column) {
      const columnOpts = computeColumnOpts.value;
      const headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;
      return headExportMethod ? headExportMethod({ column, options: opts, $table: $xeTable }) : (opts.isTitle ? column.getTitle() : column.field) || "";
    }
    const toBooleanValue = (cellValue) => {
      return import_xe_utils13.default.isBoolean(cellValue) ? cellValue ? "TRUE" : "FALSE" : cellValue;
    };
    const toStringValue = (cellValue) => {
      return eqEmptyValue(cellValue) ? "" : `${cellValue}`;
    };
    const getBodyLabelData = (opts, columns, datas) => {
      const { isAllExpand, mode } = opts;
      const { treeConfig } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const columnOpts = computeColumnOpts.value;
      if (!htmlCellElem) {
        htmlCellElem = document.createElement("div");
      }
      if (treeConfig) {
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rest = [];
        const expandMaps = {};
        const useMaps = {};
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        import_xe_utils13.default.eachTree(datas, (item, $rowIndex, items, path, parent, nodes) => {
          const row = item._row || item;
          const rowid = handleGetRowId(row);
          if (useMaps[rowid]) {
            return;
          }
          const parentRow = parent && parent._row ? parent._row : parent;
          const pRowid = parentRow ? handleGetRowId(parentRow) : "";
          if (isAllExpand || !parentRow || expandMaps[pRowid] && $xeTable.isTreeExpandByRow(parentRow)) {
            const hasRowChild = hasTreeChildren(row);
            const item2 = {
              _row: row,
              _level: nodes.length - 1,
              _hasChild: hasRowChild,
              _expand: hasRowChild && $xeTable.isTreeExpandByRow(row)
            };
            columns.forEach((column, $columnIndex) => {
              let cellValue = "";
              const renderOpts = column.editRender || column.cellRender;
              let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
              if (!bodyExportMethod && renderOpts && renderOpts.name) {
                const compConf = renderer7.get(renderOpts.name);
                if (compConf) {
                  bodyExportMethod = compConf.tableExportMethod || compConf.exportMethod;
                }
              }
              if (!bodyExportMethod) {
                bodyExportMethod = columnOpts.exportMethod;
              }
              if (bodyExportMethod) {
                cellValue = bodyExportMethod({ $table: $xeTable, row, column, options: opts });
              } else {
                switch (column.type) {
                  case "seq": {
                    const seqVal = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
                    cellValue = mode === "all" ? seqVal : getSeq(seqVal, row, $rowIndex, column, $columnIndex);
                    break;
                  }
                  case "checkbox":
                    cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
                    item2._checkboxLabel = checkboxOpts.labelField ? import_xe_utils13.default.get(row, checkboxOpts.labelField) : "";
                    item2._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ $table: $xeTable, row });
                    break;
                  case "radio":
                    cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
                    item2._radioLabel = radioOpts.labelField ? import_xe_utils13.default.get(row, radioOpts.labelField) : "";
                    item2._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ $table: $xeTable, row });
                    break;
                  default:
                    if (opts.original) {
                      cellValue = getCellValue(row, column);
                    } else {
                      cellValue = $xeTable.getCellLabel(row, column);
                      if (column.type === "html") {
                        htmlCellElem.innerHTML = cellValue;
                        cellValue = htmlCellElem.innerText.trim();
                      } else {
                        const cell = $xeTable.getCellElement(row, column);
                        if (cell && !hasClass(cell, "is--progress")) {
                          cellValue = cell.innerText.trim();
                        }
                      }
                    }
                }
              }
              item2[column.id] = toStringValue(cellValue);
            });
            useMaps[rowid] = true;
            if (pRowid) {
              expandMaps[pRowid] = true;
            }
            rest.push(Object.assign(item2, row));
          }
        }, { children: childrenField });
        return rest;
      }
      return datas.map((row, $rowIndex) => {
        const item = {
          _row: row
        };
        columns.forEach((column, $columnIndex) => {
          let cellValue = "";
          const renderOpts = column.editRender || column.cellRender;
          let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
          if (!bodyExportMethod && renderOpts && renderOpts.name) {
            const compConf = renderer7.get(renderOpts.name);
            if (compConf) {
              bodyExportMethod = compConf.tableExportMethod || compConf.exportMethod;
            }
          }
          if (bodyExportMethod) {
            cellValue = bodyExportMethod({ $table: $xeTable, row, column, options: opts });
          } else {
            switch (column.type) {
              case "seq": {
                const seqValue = $rowIndex + 1;
                cellValue = mode === "all" ? seqValue : getSeq(seqValue, row, $rowIndex, column, $columnIndex);
                break;
              }
              case "checkbox":
                cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
                item._checkboxLabel = checkboxOpts.labelField ? import_xe_utils13.default.get(row, checkboxOpts.labelField) : "";
                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ $table: $xeTable, row });
                break;
              case "radio":
                cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
                item._radioLabel = radioOpts.labelField ? import_xe_utils13.default.get(row, radioOpts.labelField) : "";
                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ $table: $xeTable, row });
                break;
              default:
                if (opts.original) {
                  cellValue = getCellValue(row, column);
                } else {
                  cellValue = $xeTable.getCellLabel(row, column);
                  if (column.type === "html") {
                    htmlCellElem.innerHTML = cellValue;
                    cellValue = htmlCellElem.innerText.trim();
                  } else {
                    const cell = $xeTable.getCellElement(row, column);
                    if (cell && !hasClass(cell, "is--progress")) {
                      cellValue = cell.innerText.trim();
                    }
                  }
                }
            }
          }
          item[column.id] = toStringValue(cellValue);
        });
        return item;
      });
    };
    const getExportData = (opts) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const { columns, dataFilterMethod } = opts;
      let datas = opts.data;
      if (dataFilterMethod) {
        datas = datas.filter((row, index) => dataFilterMethod({ $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt, row, $rowIndex: index }));
      }
      return getBodyLabelData(opts, columns, datas);
    };
    const getFooterCellValue = (opts, row, column) => {
      const columnOpts = computeColumnOpts.value;
      const renderOpts = column.editRender || column.cellRender;
      let footLabelMethod = column.footerExportMethod;
      if (!footLabelMethod && renderOpts && renderOpts.name) {
        const compConf = renderer7.get(renderOpts.name);
        if (compConf) {
          footLabelMethod = compConf.tableFooterExportMethod || compConf.footerExportMethod;
        }
      }
      if (!footLabelMethod) {
        footLabelMethod = columnOpts.footerExportMethod;
      }
      if (footLabelMethod) {
        const _columnIndex = $xeTable.getVTColumnIndex(column);
        return footLabelMethod({ $table: $xeTable, items: row, itemIndex: _columnIndex, row, _columnIndex, column, options: opts });
      }
      const cellValue = $xeTable.getFooterCellLabel(row, column);
      return cellValue;
    };
    const toCsv = ($xeTable2, opts, columns, datas) => {
      let content = csvBOM;
      if (opts.isHeader) {
        content += columns.map((column) => toTxtCellLabel(getHeaderTitle(opts, column))).join(",") + enterSymbol;
      }
      datas.forEach((row) => {
        content += columns.map((column) => toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id]))).join(",") + enterSymbol;
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData($xeTable2, opts, footerTableData);
        footers.forEach((row) => {
          content += columns.map((column) => toTxtCellLabel(getFooterCellValue(opts, row, column))).join(",") + enterSymbol;
        });
      }
      return content;
    };
    const toTxt = ($xeTable2, opts, columns, datas) => {
      let content = "";
      if (opts.isHeader) {
        content += columns.map((column) => toTxtCellLabel(getHeaderTitle(opts, column))).join("	") + enterSymbol;
      }
      datas.forEach((row) => {
        content += columns.map((column) => toTxtCellLabel(row[column.id])).join("	") + enterSymbol;
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData($xeTable2, opts, footerTableData);
        footers.forEach((row) => {
          content += columns.map((column) => toTxtCellLabel(getFooterCellValue(opts, row, column))).join("	") + enterSymbol;
        });
      }
      return content;
    };
    const hasEllipsis = (column, property, allColumnOverflow) => {
      const columnOverflow = column[property];
      const headOverflow = import_xe_utils13.default.isUndefined(columnOverflow) || import_xe_utils13.default.isNull(columnOverflow) ? allColumnOverflow : columnOverflow;
      const showEllipsis = headOverflow === "ellipsis";
      const showTitle = headOverflow === "title";
      const showTooltip = headOverflow === true || headOverflow === "tooltip";
      let isEllipsis = showTitle || showTooltip || showEllipsis;
      const { scrollXLoad, scrollYLoad } = reactData;
      if ((scrollXLoad || scrollYLoad) && !isEllipsis) {
        isEllipsis = true;
      }
      return isEllipsis;
    };
    const toHtml = (opts, columns, datas) => {
      const { id, border, treeConfig, headerAlign: allHeaderAlign, align: allAlign, footerAlign: allFooterAlign, showOverflow: allColumnOverflow, showHeaderOverflow: allColumnHeaderOverflow } = props;
      const { isAllSelected, isIndeterminate } = reactData;
      const { mergeBodyCellMaps } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { print: isPrint, isHeader, isFooter, isColgroup, isMerge, colgroups, original } = opts;
      const allCls = "check-all";
      const clss = [
        "vxe-table",
        `border--${toTableBorder(border)}`,
        isPrint ? "is--print" : "",
        isHeader ? "is--header" : ""
      ].filter((cls) => cls);
      const tables = [
        `<table class="${clss.join(" ")}" border="0" cellspacing="0" cellpadding="0">`,
        `<colgroup>${columns.map((column) => `<col style="width:${column.renderWidth}px">`).join("")}</colgroup>`
      ];
      if (isHeader) {
        tables.push("<thead>");
        if (isColgroup && !original) {
          colgroups.forEach((cols) => {
            tables.push(`<tr>${cols.map((column) => {
              const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
              const classNames = hasEllipsis(column, "showHeaderOverflow", allColumnHeaderOverflow) ? ["col--ellipsis"] : [];
              const cellTitle = getHeaderTitle(opts, column);
              let childWidth = 0;
              let countChild = 0;
              import_xe_utils13.default.eachTree([column], (item) => {
                if (!item.childNodes || !column.childNodes.length) {
                  countChild++;
                }
                childWidth += item.renderWidth;
              }, { children: "childNodes" });
              const cellWidth = childWidth - countChild;
              if (headAlign) {
                classNames.push(`col--${headAlign}`);
              }
              if (column.type === "checkbox") {
                return `<th class="${classNames.join(" ")}" colspan="${column._colSpan}" rowspan="${column._rowSpan}"><div ${isPrint ? "" : `style="width: ${cellWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? "checked" : ""}><span>${cellTitle}</span></div></th>`;
              }
              return `<th class="${classNames.join(" ")}" colspan="${column._colSpan}" rowspan="${column._rowSpan}" title="${cellTitle}"><div ${isPrint ? "" : `style="width: ${cellWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
            }).join("")}</tr>`);
          });
        } else {
          tables.push(`<tr>${columns.map((column) => {
            const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
            const classNames = hasEllipsis(column, "showHeaderOverflow", allColumnHeaderOverflow) ? ["col--ellipsis"] : [];
            const cellTitle = getHeaderTitle(opts, column);
            if (headAlign) {
              classNames.push(`col--${headAlign}`);
            }
            if (column.type === "checkbox") {
              return `<th class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? "checked" : ""}><span>${cellTitle}</span></div></th>`;
            }
            return `<th class="${classNames.join(" ")}" title="${cellTitle}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
          }).join("")}</tr>`);
        }
        tables.push("</thead>");
      }
      if (datas.length) {
        tables.push("<tbody>");
        if (treeConfig) {
          datas.forEach((item) => {
            tables.push("<tr>" + columns.map((column) => {
              const colid = column.id;
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = item[colid];
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.treeNode) {
                let treeIcon = "";
                if (item._hasChild) {
                  treeIcon = `<i class="${item._expand ? "vxe-table--tree-fold-icon" : "vxe-table--tree-unfold-icon"}"></i>`;
                }
                classNames.push("vxe-table--tree-node");
                if (column.type === "radio") {
                  return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="radio" name="radio_${id}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></div></div></td>`;
                } else if (column.type === "checkbox") {
                  return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></div></div></td>`;
                }
                return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell">${cellValue}</div></div></div></td>`;
              }
              if (column.type === "radio") {
                return `<td class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === "checkbox") {
                return `<td class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("") + "</tr>");
          });
        } else {
          datas.forEach((item) => {
            tables.push("<tr>" + columns.map((column) => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = item[column.id];
              let rowSpan = 1;
              let colSpan = 1;
              if (isMerge) {
                const _rowIndex = $xeTable.getVTRowIndex(item._row);
                const _columnIndex = $xeTable.getVTColumnIndex(column);
                const spanRest = mergeBodyCellMaps[`${_rowIndex}:${_columnIndex}`];
                if (spanRest) {
                  const { rowspan, colspan } = spanRest;
                  if (!rowspan || !colspan) {
                    return "";
                  }
                  if (rowspan > 1) {
                    rowSpan = rowspan;
                  }
                  if (colspan > 1) {
                    colSpan = colspan;
                  }
                }
              }
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.type === "radio") {
                return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === "checkbox") {
                return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("") + "</tr>");
          });
        }
        tables.push("</tbody>");
      }
      if (isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData($xeTable, opts, footerTableData);
        if (footers.length) {
          tables.push("<tfoot>");
          footers.forEach((row) => {
            tables.push(`<tr>${columns.map((column) => {
              const footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = getFooterCellValue(opts, row, column);
              if (footAlign) {
                classNames.push(`col--${footAlign}`);
              }
              return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("")}</tr>`);
          });
          tables.push("</tfoot>");
        }
      }
      const script = !isAllSelected && isIndeterminate ? `<script>(function(){var a=document.querySelector(".${allCls}");if(a){a.indeterminate=true}})()<\/script>` : "";
      tables.push("</table>", script);
      return isPrint ? tables.join("") : createHtmlPage(opts, tables.join(""));
    };
    const toXML = (opts, columns, datas) => {
      let xml = [
        '<?xml version="1.0"?>',
        '<?mso-application progid="Excel.Sheet"?>',
        '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">',
        '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">',
        "<Version>16.00</Version>",
        "</DocumentProperties>",
        '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">',
        "<WindowHeight>7920</WindowHeight>",
        "<WindowWidth>21570</WindowWidth>",
        "<WindowTopX>32767</WindowTopX>",
        "<WindowTopY>32767</WindowTopY>",
        "<ProtectStructure>False</ProtectStructure>",
        "<ProtectWindows>False</ProtectWindows>",
        "</ExcelWorkbook>",
        `<Worksheet ss:Name="${opts.sheetName}">`,
        "<Table>",
        columns.map((column) => `<Column ss:Width="${column.renderWidth}"/>`).join("")
      ].join("");
      if (opts.isHeader) {
        xml += `<Row>${columns.map((column) => `<Cell><Data ss:Type="String">${getHeaderTitle(opts, column)}</Data></Cell>`).join("")}</Row>`;
      }
      datas.forEach((row) => {
        xml += "<Row>" + columns.map((column) => `<Cell><Data ss:Type="String">${row[column.id]}</Data></Cell>`).join("") + "</Row>";
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData($xeTable, opts, footerTableData);
        footers.forEach((row) => {
          xml += `<Row>${columns.map((column) => `<Cell><Data ss:Type="String">${getFooterCellValue(opts, row, column)}</Data></Cell>`).join("")}</Row>`;
        });
      }
      return `${xml}</Table></Worksheet></Workbook>`;
    };
    const getContent = ($xeTable2, opts, columns, datas) => {
      if (columns.length) {
        switch (opts.type) {
          case "csv":
            return toCsv($xeTable2, opts, columns, datas);
          case "txt":
            return toTxt($xeTable2, opts, columns, datas);
          case "html":
            return toHtml(opts, columns, datas);
          case "xml":
            return toXML(opts, columns, datas);
        }
      }
      return "";
    };
    const downloadFile = (opts, content) => {
      const { filename, type, download } = opts;
      if (!download) {
        const blob = getExportBlobByContent(content, opts);
        return Promise.resolve({ type, content, blob });
      }
      if (VxeUI.saveFile) {
        VxeUI.saveFile({ filename, type, content }).then(() => {
          if (opts.message !== false) {
            if (VxeUI.modal) {
              VxeUI.modal.message({ content: getI18n8("vxe.table.expSuccess"), status: "success" });
            }
          }
        });
      }
    };
    const handleExport = (opts) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const { remote, columns, colgroups, exportMethod, afterExportMethod } = opts;
      return new Promise((resolve) => {
        if (remote) {
          const params = { options: opts, $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt };
          resolve(exportMethod ? exportMethod(params) : params);
        } else {
          const datas = getExportData(opts);
          resolve($xeTable.preventEvent(null, "event.export", { options: opts, columns, colgroups, datas }, () => {
            return downloadFile(opts, getContent($xeTable, opts, columns, datas));
          }));
        }
      }).then((params) => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({ status: true, options: opts, $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt });
          }
        }
        return Object.assign({ status: true }, params);
      }).catch(() => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({ status: false, options: opts, $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt });
          }
        }
        const params = { status: false };
        return Promise.reject(params);
      });
    };
    const handleImport = (content, opts) => {
      const { tableFullColumn, _importResolve, _importReject } = internalData;
      let rest = { fields: [], rows: [] };
      const tableFieldMaps = {};
      const tableTitleMaps = {};
      tableFullColumn.forEach((column) => {
        const field = column.field;
        const title = column.getTitle();
        if (field) {
          tableFieldMaps[field] = column;
        }
        if (title) {
          tableTitleMaps[column.getTitle()] = column;
        }
      });
      const tableConf = {
        fieldMaps: tableFieldMaps,
        titleMaps: tableTitleMaps
      };
      switch (opts.type) {
        case "csv":
          rest = parseCsv(tableConf, content);
          break;
        case "txt":
          rest = parseTxt(tableConf, content);
          break;
        case "html":
          rest = parseHTML(tableConf, content);
          break;
        case "xml":
          rest = parseXML(tableConf, content);
          break;
      }
      const { fields, rows } = rest;
      const status = fields.some((field) => tableFieldMaps[field] || tableTitleMaps[field]);
      if (status) {
        $xeTable.createData(rows).then((data) => {
          let loadRest;
          if (opts.mode === "insert" || opts.mode === "insertBottom") {
            loadRest = $xeTable.insertAt(data, -1);
          } else if (opts.mode === "insertTop") {
            loadRest = $xeTable.insert(data);
          } else {
            loadRest = $xeTable.reloadData(data);
          }
          if (opts.message !== false) {
            if (VxeUI.modal) {
              VxeUI.modal.message({ content: getI18n8("vxe.table.impSuccess", [rows.length]), status: "success" });
            }
          }
          return loadRest.then(() => {
            if (_importResolve) {
              _importResolve({ status: true });
            }
          });
        });
      } else if (opts.message !== false) {
        if (VxeUI.modal) {
          VxeUI.modal.message({ content: getI18n8("vxe.error.impFields"), status: "error" });
        }
        if (_importReject) {
          _importReject({ status: false });
        }
      }
    };
    const handleFileImport = (file, opts) => {
      const { importMethod, afterImportMethod } = opts;
      const { type, filename } = parseFile(file);
      const importOpts = computeImportOpts.value;
      if (!importMethod && !import_xe_utils13.default.includes(import_xe_utils13.default.keys(importOpts._typeMaps), type)) {
        if (opts.message !== false) {
          if (VxeUI.modal) {
            VxeUI.modal.message({ content: getI18n8("vxe.error.notType", [type]), status: "error" });
          }
        }
        const params = { status: false };
        return Promise.reject(params);
      }
      const rest = new Promise((resolve, reject) => {
        const _importResolve = (params) => {
          resolve(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        const _importReject = (params) => {
          reject(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        internalData._importResolve = _importResolve;
        internalData._importReject = _importReject;
        if (window.FileReader) {
          const options = Object.assign({ mode: "insertTop" }, opts, { type, filename });
          if (options.remote) {
            if (importMethod) {
              Promise.resolve(importMethod({ file, options, $table: $xeTable })).then(() => {
                _importResolve({ status: true });
              }).catch(() => {
                _importResolve({ status: true });
              });
            } else {
              _importResolve({ status: true });
            }
          } else {
            const { tableFullColumn } = internalData;
            $xeTable.preventEvent(null, "event.import", { file, options, columns: tableFullColumn }, () => {
              const reader = new FileReader();
              reader.onerror = () => {
                errLog("vxe.error.notType", [type]);
                _importReject({ status: false });
              };
              reader.onload = (e) => {
                handleImport(e.target.result, options);
              };
              reader.readAsText(file, options.encoding || "UTF-8");
            });
          }
        } else {
          errLog("vxe.error.notExp");
          _importResolve({ status: true });
        }
      });
      return rest.then(() => {
        if (afterImportMethod) {
          afterImportMethod({ status: true, options: opts, $table: $xeTable });
        }
      }).catch((e) => {
        if (afterImportMethod) {
          afterImportMethod({ status: false, options: opts, $table: $xeTable });
        }
        return Promise.reject(e);
      });
    };
    const handleFilterColumns = (exportOpts, column, columns) => {
      return columns.some((item) => {
        if (isColumnInfo(item)) {
          return column.id === item.id;
        } else if (import_xe_utils13.default.isString(item)) {
          return column.field === item;
        } else {
          const colid = item.id || item.colId;
          const type = item.type;
          const field = item.field;
          if (colid) {
            return column.id === colid;
          } else if (field && type) {
            return column.field === field && column.type === type;
          } else if (field) {
            return column.field === field;
          } else if (type) {
            return column.type === type;
          }
        }
        return false;
      });
    };
    const handleFilterFields = (exportOpts, column, includeFields, excludeFields) => {
      if (excludeFields) {
        if (import_xe_utils13.default.includes(excludeFields, column.field)) {
          return false;
        }
      }
      if (includeFields) {
        if (import_xe_utils13.default.includes(includeFields, column.field)) {
          return true;
        }
        return false;
      }
      return exportOpts.original ? !!column.field : defaultFilterExportColumn(column);
    };
    const handleExportAndPrint = (options, isPrint) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const $xeGGWrapper = $xeGrid || $xeGantt;
      const { treeConfig, showHeader, showFooter } = props;
      const { initStore, isGroup, footerTableData, exportStore, exportParams } = reactData;
      const { collectColumn, mergeBodyList, mergeFooterList } = internalData;
      const exportOpts = computeExportOpts.value;
      const hasTree = treeConfig;
      const customOpts = computeCustomOpts.value;
      const selectRecords = $xeTable.getCheckboxRecords();
      const proxyOpts = $xeGGWrapper ? $xeGGWrapper.getComputeMaps().computeProxyOpts.value : {};
      const hasFooter = !!footerTableData.length;
      const hasMerge = !!(mergeBodyList.length || mergeFooterList.length);
      const defOpts = Object.assign({
        message: true,
        isHeader: showHeader,
        isTitle: showHeader,
        isFooter: showFooter,
        isColgroup: isGroup,
        isMerge: hasMerge,
        useStyle: true,
        current: "current",
        modes: (proxyOpts.ajax && proxyOpts.ajax.queryAll ? ["all"] : []).concat(["current", "selected", "empty"])
      }, options);
      const types = defOpts.types || import_xe_utils13.default.keys(exportOpts._typeMaps);
      const modes = defOpts.modes || [];
      const checkMethod = customOpts.checkMethod;
      const exportColumns = collectColumn.slice(0);
      const { columns, excludeFields, includeFields } = defOpts;
      const typeList = types.map((value) => {
        return {
          value,
          label: getI18n8(`vxe.export.types.${value}`)
        };
      });
      const modeList = modes.map((item) => {
        if (item && item.value) {
          return {
            value: item.value,
            label: item.label || item.value
          };
        }
        return {
          value: item,
          label: getI18n8(`vxe.export.modes.${item}`)
        };
      });
      import_xe_utils13.default.eachTree(exportColumns, (column, index, items, path, parent) => {
        const isColGroup = column.children && column.children.length > 0;
        let isChecked = false;
        if (columns && columns.length) {
          isChecked = handleFilterColumns(defOpts, column, columns);
        } else if (excludeFields || includeFields) {
          isChecked = handleFilterFields(defOpts, column, includeFields, excludeFields);
        } else {
          isChecked = column.visible && (isColGroup || defaultFilterExportColumn(column));
        }
        column.checked = isChecked;
        column.halfChecked = false;
        column.disabled = parent && parent.disabled || (checkMethod ? !checkMethod({ $table: $xeTable, column }) : false);
      });
      Object.assign(exportStore, {
        columns: exportColumns,
        typeList,
        modeList,
        hasFooter,
        hasMerge,
        hasTree,
        isPrint,
        hasColgroup: isGroup,
        visible: true
      });
      Object.assign(exportParams, {
        mode: selectRecords.length ? "selected" : "current"
      }, defOpts);
      const { filename, sheetName, mode, type } = exportParams;
      if (filename) {
        if (import_xe_utils13.default.isFunction(filename)) {
          exportParams.filename = filename({
            options: defOpts,
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt
          });
        } else {
          exportParams.filename = `${filename}`;
        }
      }
      if (sheetName) {
        if (import_xe_utils13.default.isFunction(sheetName)) {
          exportParams.sheetName = sheetName({
            options: defOpts,
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt
          });
        } else {
          exportParams.sheetName = `${sheetName}`;
        }
      }
      if (!modeList.some((item) => item.value === mode)) {
        exportParams.mode = modeList[0].value;
      }
      if (!typeList.some((item) => item.value === type)) {
        exportParams.type = typeList[0].value;
      }
      initStore.export = true;
      return nextTick();
    };
    const handleCloseExport = () => {
      if (VxeUI.modal) {
        return VxeUI.modal.close("VXE_EXPORT_MODAL");
      }
      return Promise.resolve();
    };
    const exportMethods = {
      /**
       * 导出文件，支持 csv/html/xml/txt
       * 如果是树表格，则默认是导出所有节点
       * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数转换数据
       * @param {Object} options 参数
       */
      exportData(options) {
        const $xeGrid = $xeTable.xeGrid;
        const $xeGantt = $xeTable.xeGantt;
        const $xeGGWrapper = $xeGrid || $xeGantt;
        const { treeConfig, showHeader, showFooter } = props;
        const { isGroup } = reactData;
        const { tableFullColumn, afterFullData, afterTreeFullData, collectColumn, mergeBodyList, mergeFooterList } = internalData;
        const exportOpts = computeExportOpts.value;
        const treeOpts = computeTreeOpts.value;
        const proxyOpts = $xeGGWrapper ? $xeGGWrapper.getComputeMaps().computeProxyOpts.value : {};
        const hasMerge = !!(mergeBodyList.length || mergeFooterList.length);
        const opts = Object.assign({
          message: true,
          isHeader: showHeader,
          isTitle: showHeader,
          isFooter: showFooter,
          isColgroup: isGroup,
          isMerge: hasMerge,
          useStyle: true,
          current: "current",
          modes: (proxyOpts.ajax && proxyOpts.ajax.queryAll ? ["all"] : []).concat(["current", "selected", "empty"]),
          download: true,
          type: "csv"
          // filename: '',
          // sheetName: '',
          // original: false,
          // isAllExpand: false,
          // data: null,
          // remote: false,
          // dataFilterMethod: null,
          // footerFilterMethod: null,
          // exportMethod: null,
          // columnFilterMethod: null,
          // beforeExportMethod: null,
          // afterExportMethod: null
        }, exportOpts, options);
        let { filename, sheetName, type, mode, columns, original, columnFilterMethod, beforeExportMethod, includeFields, excludeFields } = opts;
        let groups = [];
        const selectRecords = $xeTable.getCheckboxRecords();
        if (!mode) {
          mode = selectRecords.length ? "selected" : "current";
        }
        let isCustomCol = false;
        let customCols = [];
        if (columns && columns.length) {
          isCustomCol = true;
          customCols = columns;
        } else {
          customCols = import_xe_utils13.default.searchTree(collectColumn, (column) => {
            const isColGroup = column.children && column.children.length > 0;
            let isChecked = false;
            if (columns && columns.length) {
              isChecked = handleFilterColumns(opts, column, columns);
            } else if (excludeFields || includeFields) {
              isChecked = handleFilterFields(opts, column, includeFields, excludeFields);
            } else {
              isChecked = column.visible && (isColGroup || defaultFilterExportColumn(column));
            }
            return isChecked;
          }, { children: "children", mapChildren: "childNodes", original: true });
        }
        const handleOptions = Object.assign({}, opts, { filename: "", sheetName: "" });
        if (!isCustomCol && !columnFilterMethod) {
          columnFilterMethod = ({ column }) => {
            if (excludeFields) {
              if (import_xe_utils13.default.includes(excludeFields, column.field)) {
                return false;
              }
            }
            if (includeFields) {
              if (import_xe_utils13.default.includes(includeFields, column.field)) {
                return true;
              }
              return false;
            }
            return original ? !!column.field : defaultFilterExportColumn(column);
          };
          handleOptions.columnFilterMethod = columnFilterMethod;
        }
        if (customCols) {
          handleOptions._isCustomColumn = true;
          groups = import_xe_utils13.default.searchTree(import_xe_utils13.default.mapTree(customCols, (item) => {
            let targetColumn;
            if (item) {
              if (isColumnInfo(item)) {
                targetColumn = item;
              } else if (import_xe_utils13.default.isString(item)) {
                targetColumn = $xeTable.getColumnByField(item);
              } else {
                const colid = item.id || item.colId;
                const type2 = item.type;
                const field = item.field;
                if (colid) {
                  targetColumn = $xeTable.getColumnById(colid);
                } else if (field && type2) {
                  targetColumn = tableFullColumn.find((column) => column.field === field && column.type === type2);
                } else if (field) {
                  targetColumn = $xeTable.getColumnByField(field);
                } else if (type2) {
                  targetColumn = tableFullColumn.find((column) => column.type === type2);
                }
              }
              return targetColumn || {};
            }
          }, {
            children: "childNodes",
            mapChildren: "_children"
          }), (column, index) => isColumnInfo(column) && (!columnFilterMethod || columnFilterMethod({ $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt, column, $columnIndex: index })), {
            children: "_children",
            mapChildren: "childNodes",
            original: true
          });
        } else {
          groups = import_xe_utils13.default.searchTree(isGroup ? collectColumn : tableFullColumn, (column, index) => column.visible && (!columnFilterMethod || columnFilterMethod({ $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt, column, $columnIndex: index })), { children: "children", mapChildren: "childNodes", original: true });
        }
        const cols = [];
        import_xe_utils13.default.eachTree(groups, (column) => {
          const isColGroup = column.children && column.children.length;
          if (!isColGroup) {
            cols.push(column);
          }
        }, { children: "childNodes" });
        handleOptions.columns = cols;
        handleOptions.colgroups = convertToRows(groups);
        if (filename) {
          if (import_xe_utils13.default.isFunction(filename)) {
            handleOptions.filename = filename({
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt
            });
          } else {
            handleOptions.filename = `${filename}`;
          }
        }
        if (!handleOptions.filename) {
          handleOptions.filename = getI18n8(handleOptions.original ? "vxe.table.expOriginFilename" : "vxe.table.expFilename", [import_xe_utils13.default.toDateString(Date.now(), "yyyyMMddHHmmss")]);
        }
        if (sheetName) {
          if (import_xe_utils13.default.isFunction(sheetName)) {
            handleOptions.sheetName = sheetName({
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt
            });
          } else {
            handleOptions.sheetName = `${sheetName}`;
          }
        }
        if (!handleOptions.sheetName) {
          handleOptions.sheetName = document.title || "";
        }
        if (!handleOptions.exportMethod && !import_xe_utils13.default.includes(import_xe_utils13.default.keys(exportOpts._typeMaps), type)) {
          errLog("vxe.error.notType", [type]);
          if (["xlsx", "pdf"].includes(type)) {
            warnLog("vxe.error.reqPlugin", [4, "plugin-export-xlsx"]);
          }
          const params = { status: false };
          return Promise.reject(params);
        }
        if (!handleOptions.print) {
          if (beforeExportMethod) {
            beforeExportMethod({ options: handleOptions, $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt });
          }
        }
        if (!handleOptions.data) {
          handleOptions.data = [];
          if (mode === "selected") {
            if (["html", "pdf"].indexOf(type) > -1 && treeConfig) {
              handleOptions.data = import_xe_utils13.default.searchTree($xeTable.getTableData().fullData, (item) => $xeTable.findRowIndexOf(selectRecords, item) > -1, Object.assign({}, treeOpts, { data: "_row" }));
            } else {
              handleOptions.data = selectRecords;
            }
          } else if (mode === "all") {
            if (!$xeGGWrapper) {
              errLog("vxe.error.errProp", ["all", "mode=current,selected"]);
            }
            if ($xeGGWrapper && !handleOptions.remote) {
              const gridReactData = $xeGGWrapper.reactData;
              const { computeProxyOpts } = $xeGGWrapper.getComputeMaps();
              const proxyOpts2 = computeProxyOpts.value;
              const { sortData } = gridReactData;
              const { beforeQueryAll, afterQueryAll, ajax = {} } = proxyOpts2;
              const resConfigs = proxyOpts2.response || proxyOpts2.props || {};
              const ajaxMethods = ajax.queryAll;
              const queryAllSuccessMethods = ajax.queryAllSuccess;
              const queryAllErrorMethods = ajax.queryAllError;
              if (!ajaxMethods) {
                errLog("vxe.error.notFunc", ["proxy-config.ajax.queryAll"]);
              }
              if (ajaxMethods) {
                const params = {
                  $table: $xeTable,
                  $grid: $xeGrid,
                  $gantt: $xeGantt,
                  sort: sortData.length ? sortData[0] : {},
                  sorts: sortData,
                  filters: gridReactData.filterData,
                  form: gridReactData.formData,
                  options: handleOptions
                };
                return Promise.resolve((beforeQueryAll || ajaxMethods)(params)).then((rest) => {
                  const listProp = resConfigs.list;
                  handleOptions.data = (listProp ? import_xe_utils13.default.isFunction(listProp) ? listProp({ data: rest, $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt }) : import_xe_utils13.default.get(rest, listProp) : rest) || [];
                  if (afterQueryAll) {
                    afterQueryAll(params);
                  }
                  if (queryAllSuccessMethods) {
                    queryAllSuccessMethods(Object.assign(Object.assign({}, params), { response: rest }));
                  }
                  return handleExport(handleOptions);
                }).catch((rest) => {
                  if (queryAllErrorMethods) {
                    queryAllErrorMethods(Object.assign(Object.assign({}, params), { response: rest }));
                  }
                });
              }
            }
          }
          if (mode === "current") {
            handleOptions.data = treeConfig ? afterTreeFullData : afterFullData;
          }
        } else {
          handleOptions._isCustomData = true;
        }
        return handleExport(handleOptions);
      },
      importByFile(file, options) {
        const opts = Object.assign({}, options);
        const { beforeImportMethod } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({ options: opts, $table: $xeTable });
        }
        return handleFileImport(file, opts);
      },
      importData(options) {
        const importOpts = computeImportOpts.value;
        const opts = Object.assign({
          types: import_xe_utils13.default.keys(importOpts._typeMaps)
          // beforeImportMethod: null,
          // afterImportMethod: null
        }, importOpts, options);
        const { beforeImportMethod, afterImportMethod } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({ options: opts, $table: $xeTable });
        }
        return VxeUI.readFile(opts).catch((e) => {
          if (afterImportMethod) {
            afterImportMethod({ status: false, options: opts, $table: $xeTable });
          }
          return Promise.reject(e);
        }).then((params) => {
          const { file } = params;
          return handleFileImport(file, opts);
        });
      },
      saveFile(options) {
        return VxeUI.saveFile(options);
      },
      readFile(options) {
        return VxeUI.readFile(options);
      },
      print(options) {
        const $xeGrid = $xeTable.xeGrid;
        const $xeGantt = $xeTable.xeGantt;
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: "html",
          download: false,
          remote: false,
          print: true
        });
        const { sheetName } = opts;
        let printTitle = "";
        if (sheetName) {
          if (import_xe_utils13.default.isFunction(sheetName)) {
            printTitle = sheetName({
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt
            });
          } else {
            printTitle = `${sheetName}`;
          }
        }
        if (!printTitle) {
          printTitle = document.title || "";
        }
        const beforePrintMethod = opts.beforePrintMethod;
        const tableHtml = opts.html || opts.content;
        return new Promise((resolve, reject) => {
          if (VxeUI.print) {
            if (tableHtml) {
              resolve(VxeUI.print({
                title: printTitle,
                html: tableHtml,
                customStyle: opts.style,
                beforeMethod: beforePrintMethod ? ({ html }) => {
                  return beforePrintMethod({
                    html,
                    content: html,
                    options: opts,
                    $table: $xeTable,
                    $grid: $xeGrid,
                    $gantt: $xeGantt
                  });
                } : void 0
              }));
            } else {
              resolve(exportMethods.exportData(opts).then(({ content }) => {
                return VxeUI.print({
                  title: printTitle,
                  html: content,
                  customStyle: opts.style,
                  beforeMethod: beforePrintMethod ? ({ html }) => {
                    return beforePrintMethod({
                      html,
                      content: html,
                      options: opts,
                      $table: $xeTable,
                      $grid: $xeGrid,
                      $gantt: $xeGantt
                    });
                  } : void 0
                });
              }));
            }
          } else {
            const e = { status: false };
            reject(e);
          }
        });
      },
      getPrintHtml(options) {
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: "html",
          download: false,
          remote: false,
          print: true
        });
        return $xeTable.exportData(opts).then(({ content }) => {
          return {
            html: content
          };
        });
      },
      closeImport() {
        if (VxeUI.modal) {
          return VxeUI.modal.close("VXE_IMPORT_MODAL");
        }
        return Promise.resolve();
      },
      openImport(options) {
        const { treeConfig, importConfig } = props;
        const { initStore, importStore, importParams } = reactData;
        const importOpts = computeImportOpts.value;
        const defOpts = Object.assign({
          mode: "insertTop",
          message: true,
          types: import_xe_utils13.default.keys(importOpts._typeMaps),
          modes: ["insertTop", "covering"]
        }, importOpts, options);
        const types = defOpts.types || [];
        const modes = defOpts.modes || [];
        const isTree = !!treeConfig;
        if (isTree) {
          if (defOpts.message) {
            if (VxeUI.modal) {
              VxeUI.modal.message({ content: getI18n8("vxe.error.treeNotImp"), status: "error" });
            }
          }
          return;
        }
        if (!importConfig) {
          errLog("vxe.error.reqProp", ["import-config"]);
        }
        const typeList = types.map((value) => {
          return {
            value,
            label: getI18n8(`vxe.export.types.${value}`)
          };
        });
        const modeList = modes.map((item) => {
          if (item && item.value) {
            return {
              value: item.value,
              label: item.label || item.value
            };
          }
          return {
            value: item,
            label: getI18n8(`vxe.import.modes.${item}`)
          };
        });
        Object.assign(importStore, {
          file: null,
          type: "",
          filename: "",
          modeList,
          typeList,
          visible: true
        });
        Object.assign(importParams, defOpts);
        if (!modeList.some((item) => item.value === importParams.mode)) {
          importParams.mode = modeList[0].value;
        }
        initStore.import = true;
      },
      closeExport: handleCloseExport,
      openExport(options) {
        const exportOpts = computeExportOpts.value;
        const defOpts = Object.assign({
          message: true,
          types: import_xe_utils13.default.keys(exportOpts._typeMaps)
        }, exportOpts, options);
        if (!props.exportConfig) {
          errLog("vxe.error.reqProp", ["export-config"]);
        }
        return handleExportAndPrint(defOpts);
      },
      closePrint: handleCloseExport,
      openPrint(options) {
        const printOpts = computePrintOpts.value;
        const defOpts = Object.assign({
          message: true
        }, printOpts, options);
        if (!props.printConfig) {
          errLog("vxe.error.reqProp", ["print-config"]);
        }
        return handleExportAndPrint(defOpts, true);
      }
    };
    return exportMethods;
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableExportMethodKeys);
  },
  setupGantt($xeGantt) {
    return $xeGantt.extendTableMethods(tableExportMethodKeys);
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/keyboard/hook.js
var import_xe_utils14 = __toESM(require_xe_utils());
var { hooks: hooks5 } = VxeUI;
hooks5.add("tableKeyboardModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refElem } = $xeTable.getRefMaps();
    const { computeEditOpts, computeCheckboxOpts, computeMouseOpts, computeTreeOpts, computeRowOpts, computeColumnOpts, computeCellOpts, computeDefaultRowHeight, computeCurrentRowOpts, computeCurrentColumnOpts } = $xeTable.getComputeMaps();
    function getCheckboxRangeRows(evnt, params, targetTrElem, trRect, offsetClientTop, moveRange) {
      const { showOverflow } = props;
      const { fullAllDataRowIdData, isResizeCellHeight } = internalData;
      const rowOpts = computeRowOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const { row } = params;
      let countHeight = 0;
      let rangeRows = [];
      let moveSize = 0;
      const isDown = moveRange > 0;
      const { scrollYLoad } = reactData;
      const { afterFullData } = internalData;
      if (isDown) {
        moveSize = offsetClientTop + moveRange;
      } else {
        moveSize = trRect.height - offsetClientTop + Math.abs(moveRange);
      }
      if (scrollYLoad) {
        const _rowIndex = $xeTable.getVTRowIndex(row);
        const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
        if (!isCustomCellHeight && showOverflow) {
          if (isDown) {
            rangeRows = afterFullData.slice(_rowIndex, _rowIndex + Math.ceil(moveSize / defaultRowHeight));
          } else {
            rangeRows = afterFullData.slice(_rowIndex - Math.floor(moveSize / defaultRowHeight), _rowIndex + 1);
          }
        } else {
          if (isDown) {
            for (let i = _rowIndex; i < afterFullData.length; i++) {
              const item = afterFullData[i];
              const rowid = $xeTable.getRowid(item);
              const rowRest = fullAllDataRowIdData[rowid] || {};
              countHeight += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
              rangeRows.push(item);
              if (countHeight > moveSize) {
                return rangeRows;
              }
            }
          } else {
            for (let len = _rowIndex; len >= 0; len--) {
              const item = afterFullData[len];
              const rowid = $xeTable.getRowid(item);
              const rowRest = fullAllDataRowIdData[rowid] || {};
              countHeight += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
              rangeRows.push(item);
              if (countHeight > moveSize) {
                return rangeRows;
              }
            }
          }
        }
      } else {
        const siblingProp = isDown ? "next" : "previous";
        while (targetTrElem && countHeight < moveSize) {
          const rowNodeRest = $xeTable.getRowNode(targetTrElem);
          if (rowNodeRest) {
            rangeRows.push(rowNodeRest.item);
            countHeight += targetTrElem.offsetHeight;
            targetTrElem = targetTrElem[`${siblingProp}ElementSibling`];
          }
        }
      }
      return rangeRows;
    }
    const handleCheckboxRangeEvent = (evnt, params) => {
      const { elemStore } = internalData;
      const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
      const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
      const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
      const { column, cell } = params;
      if (column.type === "checkbox") {
        let bodyWrapperElem = bodyScrollElem;
        if (leftScrollElem && column.fixed === "left") {
          bodyWrapperElem = leftScrollElem;
        } else if (rightScrollElem && column.fixed === "right") {
          bodyWrapperElem = rightScrollElem;
        }
        if (!bodyWrapperElem) {
          return;
        }
        const bodyRect = bodyWrapperElem.getBoundingClientRect();
        const el = refElem.value;
        const disX = evnt.clientX;
        const disY = evnt.clientY;
        const checkboxRangeElem = bodyWrapperElem.querySelector(".vxe-table--checkbox-range");
        const trElem = cell.parentElement;
        const selectRecords = $xeTable.getCheckboxRecords();
        let lastRangeRows = [];
        const marginSize = 1;
        const startTop = evnt.clientY - bodyRect.y + bodyWrapperElem.scrollTop;
        const startLeft = evnt.clientX - bodyRect.x + bodyWrapperElem.scrollLeft;
        const startScrollTop = bodyWrapperElem.scrollTop;
        const rowHeight = trElem.offsetHeight;
        const trRect = trElem.getBoundingClientRect();
        const offsetClientTop = disY - trRect.y;
        let mouseScrollTimeout = null;
        let isMouseScrollDown = false;
        let mouseScrollSpaceSize = 1;
        const triggerEvent2 = (type, evnt2) => {
          $xeTable.dispatchEvent(`checkbox-range-${type}`, {
            records: () => $xeTable.getCheckboxRecords(),
            reserves: () => $xeTable.getCheckboxReserveRecords()
          }, evnt2);
        };
        const handleChecked = (evnt2) => {
          const { clientX, clientY } = evnt2;
          const offsetLeft = clientX - disX;
          const offsetTop = clientY - disY + (bodyWrapperElem.scrollTop - startScrollTop);
          let rangeHeight = Math.abs(offsetTop);
          let rangeWidth = Math.abs(offsetLeft);
          let rangeTop = startTop;
          let rangeLeft = startLeft;
          if (offsetTop < marginSize) {
            rangeTop += offsetTop;
            if (rangeTop < marginSize) {
              rangeTop = marginSize;
              rangeHeight = startTop;
            }
          } else {
            rangeHeight = Math.min(rangeHeight, bodyWrapperElem.scrollHeight - startTop - marginSize);
          }
          if (offsetLeft < marginSize) {
            rangeLeft += offsetLeft;
            if (rangeWidth > startLeft) {
              rangeLeft = marginSize;
              rangeWidth = startLeft;
            }
          } else {
            rangeWidth = Math.min(rangeWidth, bodyWrapperElem.clientWidth - startLeft - marginSize);
          }
          checkboxRangeElem.style.height = `${rangeHeight}px`;
          checkboxRangeElem.style.width = `${rangeWidth}px`;
          checkboxRangeElem.style.left = `${rangeLeft}px`;
          checkboxRangeElem.style.top = `${rangeTop}px`;
          checkboxRangeElem.style.display = "block";
          const rangeRows = getCheckboxRangeRows(evnt2, params, trElem, trRect, offsetClientTop, offsetTop < marginSize ? -rangeHeight : rangeHeight);
          if (rangeHeight > 10 && rangeRows.length !== lastRangeRows.length) {
            const isControlKey = hasControlKey(evnt2);
            lastRangeRows = rangeRows;
            if (isControlKey) {
              rangeRows.forEach((row) => {
                $xeTable.handleBatchSelectRows([row], selectRecords.indexOf(row) === -1);
              });
            } else {
              $xeTable.setAllCheckboxRow(false);
              $xeTable.handleCheckedCheckboxRow(rangeRows, true, false);
            }
            triggerEvent2("change", evnt2);
          }
        };
        const stopMouseScroll = () => {
          clearTimeout(mouseScrollTimeout);
          mouseScrollTimeout = null;
        };
        const startMouseScroll = (evnt2) => {
          stopMouseScroll();
          mouseScrollTimeout = setTimeout(() => {
            if (mouseScrollTimeout) {
              const { scrollLeft, scrollTop, clientHeight, scrollHeight } = bodyWrapperElem;
              const topSize = Math.ceil(mouseScrollSpaceSize * 50 / rowHeight);
              if (isMouseScrollDown) {
                if (scrollTop + clientHeight < scrollHeight) {
                  $xeTable.scrollTo(scrollLeft, scrollTop + topSize);
                  startMouseScroll(evnt2);
                  handleChecked(evnt2);
                } else {
                  stopMouseScroll();
                }
              } else {
                if (scrollTop) {
                  $xeTable.scrollTo(scrollLeft, scrollTop - topSize);
                  startMouseScroll(evnt2);
                  handleChecked(evnt2);
                } else {
                  stopMouseScroll();
                }
              }
            }
          }, 50);
        };
        addClass(el, "drag--range");
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          evnt2.stopPropagation();
          const { clientY } = evnt2;
          const { boundingTop } = getAbsolutePos(bodyWrapperElem);
          if (clientY < boundingTop) {
            isMouseScrollDown = false;
            mouseScrollSpaceSize = boundingTop - clientY;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt2);
            }
          } else if (clientY > boundingTop + bodyWrapperElem.clientHeight) {
            isMouseScrollDown = true;
            mouseScrollSpaceSize = clientY - boundingTop - bodyWrapperElem.clientHeight;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt2);
            }
          } else if (mouseScrollTimeout) {
            stopMouseScroll();
          }
          handleChecked(evnt2);
        };
        document.onmouseup = (evnt2) => {
          stopMouseScroll();
          removeClass(el, "drag--range");
          checkboxRangeElem.removeAttribute("style");
          document.onmousemove = null;
          document.onmouseup = null;
          triggerEvent2("end", evnt2);
        };
        triggerEvent2("start", evnt);
      }
    };
    const handleCellMousedownEvent = (evnt, params) => {
      const { editConfig, checkboxConfig, mouseConfig } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const editOpts = computeEditOpts.value;
      if (mouseConfig && mouseOpts.area && $xeTable.triggerCellAreaModnEvent) {
        return $xeTable.triggerCellAreaModnEvent(evnt, params);
      } else {
        if (checkboxConfig && checkboxOpts.range) {
          handleCheckboxRangeEvent(evnt, params);
        }
        if (mouseConfig && mouseOpts.selected) {
          if (!editConfig || editOpts.mode === "cell") {
            $xeTable.handleSelected(params, evnt);
          }
        }
      }
    };
    const handleMoveSelected = (evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow) => {
      const { afterFullData, visibleColumn } = internalData;
      const params = Object.assign({}, args);
      const _rowIndex = $xeTable.getVTRowIndex(params.row);
      const _columnIndex = $xeTable.getVTColumnIndex(params.column);
      evnt.preventDefault();
      if (isUpArrow && _rowIndex > 0) {
        params.rowIndex = _rowIndex - 1;
        params.row = afterFullData[params.rowIndex];
      } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
        params.rowIndex = _rowIndex + 1;
        params.row = afterFullData[params.rowIndex];
      } else if (isLeftArrow && _columnIndex) {
        params.columnIndex = _columnIndex - 1;
        params.column = visibleColumn[params.columnIndex];
      } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
        params.columnIndex = _columnIndex + 1;
        params.column = visibleColumn[params.columnIndex];
      }
      $xeTable.scrollToRow(params.row, params.column).then(() => {
        params.cell = $xeTable.getCellElement(params.row, params.column);
        $xeTable.handleSelected(params, evnt);
      });
      return params;
    };
    const keyboardMethods = {
      // 处理 Tab 键移动
      moveTabSelected(args, isLeft, evnt) {
        const { editConfig } = props;
        const { afterFullData, visibleColumn } = internalData;
        const editOpts = computeEditOpts.value;
        const rowOpts = computeRowOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        let targetRow;
        let targetRowIndex;
        let targetColumnIndex;
        const params = Object.assign({}, args);
        const _rowIndex = $xeTable.getVTRowIndex(params.row);
        const _columnIndex = $xeTable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isLeft) {
          if (_columnIndex <= 0) {
            if (_rowIndex > 0) {
              targetRowIndex = _rowIndex - 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = visibleColumn.length - 1;
            }
          } else {
            targetColumnIndex = _columnIndex - 1;
          }
        } else {
          if (_columnIndex >= visibleColumn.length - 1) {
            if (_rowIndex < afterFullData.length - 1) {
              targetRowIndex = _rowIndex + 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = 0;
            }
          } else {
            targetColumnIndex = _columnIndex + 1;
          }
        }
        const targetColumn = visibleColumn[targetColumnIndex];
        if (targetColumn) {
          if (targetRow) {
            params.rowIndex = targetRowIndex;
            params.row = targetRow;
          } else {
            params.rowIndex = _rowIndex;
          }
          params.columnIndex = targetColumnIndex;
          params.column = targetColumn;
          params.cell = $xeTable.getCellElement(params.row, params.column);
          if (rowOpts.isCurrent && currentRowOpts.isFollowSelected) {
            $xeTable.triggerCurrentRowEvent(evnt, params);
          }
          if (columnOpts.isCurrent && currentColumnOpts.isFollowSelected) {
            $xeTable.triggerCurrentColumnEvent(evnt, params);
          }
          if (editConfig) {
            if (editOpts.trigger === "click" || editOpts.trigger === "dblclick") {
              if (editOpts.mode === "row") {
                $xeTable.handleEdit(params, evnt);
              } else {
                $xeTable.scrollToRow(params.row, params.column).then(() => {
                  $xeTable.handleSelected(params, evnt);
                });
              }
            }
          } else {
            $xeTable.scrollToRow(params.row, params.column).then(() => {
              $xeTable.handleSelected(params, evnt);
            });
          }
        }
      },
      // 处理当前行方向键移动
      moveCurrentRow(isUpArrow, isDwArrow, evnt) {
        const { treeConfig } = props;
        const { currentRow } = reactData;
        const { afterFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let targetRow;
        if (currentRow) {
          if (treeConfig) {
            const { index, items } = import_xe_utils14.default.findTree(afterFullData, (item) => item === currentRow, { children: childrenField });
            if (isUpArrow && index > 0) {
              targetRow = items[index - 1];
            } else if (isDwArrow && index < items.length - 1) {
              targetRow = items[index + 1];
            }
          } else {
            const _rowIndex = $xeTable.getVTRowIndex(currentRow);
            if (isUpArrow && _rowIndex > 0) {
              targetRow = afterFullData[_rowIndex - 1];
            } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
              targetRow = afterFullData[_rowIndex + 1];
            }
          }
        } else {
          targetRow = afterFullData[0];
        }
        if (targetRow) {
          evnt.preventDefault();
          const params = {
            $table: $xeTable,
            row: targetRow,
            rowIndex: $xeTable.getRowIndex(targetRow),
            $rowIndex: $xeTable.getVMRowIndex(targetRow)
          };
          $xeTable.scrollToRow(targetRow).then(() => $xeTable.triggerCurrentRowEvent(evnt, params));
        }
      },
      // 处理当前列方向键移动
      moveCurrentColumn(isLeftArrow, isRightArrow, evnt) {
        const { currentColumn } = reactData;
        const { visibleColumn } = internalData;
        let targetCol = null;
        if (currentColumn) {
          const _columnIndex = $xeTable.getVTColumnIndex(currentColumn);
          if (isLeftArrow && _columnIndex > 0) {
            targetCol = visibleColumn[_columnIndex - 1];
          } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
            targetCol = visibleColumn[_columnIndex + 1];
          }
        } else {
          targetCol = visibleColumn[0];
        }
        if (targetCol) {
          evnt.preventDefault();
          const params = {
            $table: $xeTable,
            column: targetCol,
            columnIndex: $xeTable.getColumnIndex(targetCol),
            $columnIndex: $xeTable.getVMColumnIndex(targetCol)
          };
          $xeTable.scrollToColumn(targetCol).then(() => $xeTable.triggerCurrentColumnEvent(evnt, params));
        }
      },
      // 处理可编辑方向键移动
      moveArrowSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        const { highlightCurrentRow, highlightCurrentColumn } = props;
        const rowOpts = computeRowOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const params = handleMoveSelected(evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
        if (rowOpts.isCurrent || highlightCurrentRow) {
          if (currentRowOpts.isFollowSelected) {
            $xeTable.triggerCurrentRowEvent(evnt, params);
          } else {
            if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
              $xeTable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
            }
          }
        }
        if (columnOpts.isCurrent || highlightCurrentColumn) {
          if (currentColumnOpts.isFollowSelected) {
            $xeTable.triggerCurrentColumnEvent(evnt, params);
          } else {
            if ((isLeftArrow || isRightArrow) && (columnOpts.isCurrent || highlightCurrentColumn)) {
              $xeTable.moveCurrentColumn(isLeftArrow, isRightArrow, evnt);
            }
          }
        }
      },
      moveEnterSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        const { highlightCurrentRow, highlightCurrentColumn } = props;
        const rowOpts = computeRowOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const params = handleMoveSelected(evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
        if ((rowOpts.isCurrent || highlightCurrentRow) && currentRowOpts.isFollowSelected) {
          $xeTable.triggerCurrentRowEvent(evnt, params);
        }
        if ((columnOpts.isCurrent || highlightCurrentColumn) && currentColumnOpts.isFollowSelected) {
          $xeTable.triggerCurrentColumnEvent(evnt, params);
        }
      },
      // 已废弃，待删除
      moveSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        handleMoveSelected(evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
      },
      handleCellMousedownEvent
    };
    return keyboardMethods;
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/validator/hook.js
var import_xe_utils15 = __toESM(require_xe_utils());
var { getConfig: getConfig3, validators, hooks: hooks6 } = VxeUI;
var Rule = class {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.max,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  /**
   * 获取校验不通过的消息
   * 支持国际化翻译
   */
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
function validREValue(pattern, val) {
  if (pattern && !(import_xe_utils15.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return false;
  }
  return true;
}
function validMaxValue(max, num) {
  if (!import_xe_utils15.default.eqNull(max) && num > import_xe_utils15.default.toNumber(max)) {
    return false;
  }
  return true;
}
function validMinValue(min, num) {
  if (!import_xe_utils15.default.eqNull(min) && num < import_xe_utils15.default.toNumber(min)) {
    return false;
  }
  return true;
}
function validRuleValue(rule, val, required) {
  const { type, min, max, pattern } = rule;
  const isArrType = type === "array";
  const isNumType = type === "number";
  const isStrType = type === "string";
  const strVal = `${val}`;
  if (!validREValue(pattern, strVal)) {
    return false;
  }
  if (isArrType) {
    if (!import_xe_utils15.default.isArray(val)) {
      return false;
    }
    if (required) {
      if (!val.length) {
        return false;
      }
    }
    if (!validMinValue(min, val.length)) {
      return false;
    }
    if (!validMaxValue(max, val.length)) {
      return false;
    }
  } else if (isNumType) {
    const numVal = Number(val);
    if (isNaN(numVal)) {
      return false;
    }
    if (!validMinValue(min, numVal)) {
      return false;
    }
    if (!validMaxValue(max, numVal)) {
      return false;
    }
  } else {
    if (isStrType) {
      if (!import_xe_utils15.default.isString(val)) {
        return false;
      }
    }
    if (required) {
      if (!strVal) {
        return false;
      }
    }
    if (!validMinValue(min, strVal.length)) {
      return false;
    }
    if (!validMaxValue(max, strVal.length)) {
      return false;
    }
  }
  return true;
}
function checkRuleStatus(rule, val) {
  const { required } = rule;
  const isEmptyVal = import_xe_utils15.default.isArray(val) ? !val.length : eqEmptyValue(val);
  if (required) {
    if (isEmptyVal) {
      return false;
    }
    if (!validRuleValue(rule, val, required)) {
      return false;
    }
  } else {
    if (!isEmptyVal) {
      if (!validRuleValue(rule, val, required)) {
        return false;
      }
    }
  }
  return true;
}
var tableValidatorMethodKeys = ["fullValidate", "validate", "fullValidateField", "validateField", "clearValidate"];
hooks6.add("tableValidatorModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refValidTooltip } = $xeTable.getRefMaps();
    const { computeValidOpts, computeTreeOpts, computeEditOpts, computeAggregateOpts } = $xeTable.getComputeMaps();
    let validatorMethods = {};
    let validatorPrivateMethods = {};
    let validRuleErr;
    const handleValidError = (params) => {
      return new Promise((resolve) => {
        const validOpts = computeValidOpts.value;
        if (validOpts.autoPos === false) {
          $xeTable.dispatchEvent("valid-error", params, null);
          resolve();
        } else {
          $xeTable.handleEdit(params, { type: "valid-error", trigger: "call" }).then(() => {
            resolve(validatorPrivateMethods.showValidTooltip(params));
          });
        }
      });
    };
    const handleErrMsgMode = (validErrMaps) => {
      const validOpts = computeValidOpts.value;
      if (validOpts.msgMode === "single") {
        const keys = Object.keys(validErrMaps);
        const resMaps = {};
        if (keys.length) {
          const firstKey = keys[0];
          resMaps[firstKey] = validErrMaps[firstKey];
        }
        return resMaps;
      }
      return validErrMaps;
    };
    const beginValidate = (rows, cols, cb, isFull) => {
      const validRest = {};
      const { editRules, treeConfig } = props;
      const { isRowGroupStatus } = reactData;
      const { afterFullData, pendingRowMaps, removeRowMaps } = internalData;
      const treeOpts = computeTreeOpts.value;
      const aggregateOpts = computeAggregateOpts.value;
      const validOpts = computeValidOpts.value;
      let validList;
      if (rows === true) {
        validList = afterFullData;
      } else if (rows) {
        if (import_xe_utils15.default.isFunction(rows)) {
          cb = rows;
        } else {
          validList = import_xe_utils15.default.isArray(rows) ? rows : [rows];
        }
      }
      if (!validList) {
        if ($xeTable.getInsertRecords) {
          validList = $xeTable.getInsertRecords().concat($xeTable.getUpdateRecords());
        } else {
          validList = [];
        }
      }
      const rowValidErrs = [];
      internalData._lastCallTime = Date.now();
      validRuleErr = false;
      validatorMethods.clearValidate();
      const validErrMaps = {};
      if (editRules) {
        const columns = cols && cols.length ? cols : $xeTable.getColumns();
        const handleVaild = (row) => {
          const rowid = getRowid($xeTable, row);
          if (removeRowMaps[rowid]) {
            return;
          }
          if (pendingRowMaps[rowid]) {
            return;
          }
          if ($xeTable.isAggregateRecord(row)) {
            return;
          }
          if (isFull || !validRuleErr) {
            const colVailds = [];
            columns.forEach((column) => {
              const field = import_xe_utils15.default.isString(column) ? column : column.field;
              if ((isFull || !validRuleErr) && import_xe_utils15.default.has(editRules, field)) {
                colVailds.push(validatorPrivateMethods.validCellRules("all", row, column).catch(({ rule, rules }) => {
                  const rest = {
                    rule,
                    rules,
                    rowIndex: $xeTable.getRowIndex(row),
                    row,
                    columnIndex: $xeTable.getColumnIndex(column),
                    column,
                    field,
                    $table: $xeTable
                  };
                  if (!validRest[field]) {
                    validRest[field] = [];
                  }
                  validErrMaps[`${getRowid($xeTable, row)}:${column.id}`] = {
                    column,
                    row,
                    rule,
                    content: rule.content
                  };
                  validRest[field].push(rest);
                  if (!isFull) {
                    validRuleErr = true;
                    return Promise.reject(rest);
                  }
                }));
              }
            });
            rowValidErrs.push(Promise.all(colVailds));
          }
        };
        if (isRowGroupStatus) {
          import_xe_utils15.default.eachTree(validList, handleVaild, { children: aggregateOpts.mapChildrenField });
        } else if (treeConfig) {
          const childrenField = treeOpts.children || treeOpts.childrenField;
          import_xe_utils15.default.eachTree(validList, handleVaild, { children: childrenField });
        } else {
          validList.forEach(handleVaild);
        }
        return Promise.all(rowValidErrs).then(() => {
          const ruleProps = Object.keys(validRest);
          reactData.validErrorMaps = handleErrMsgMode(validErrMaps);
          return nextTick().then(() => {
            if (ruleProps.length) {
              return Promise.reject(validRest[ruleProps[0]][0]);
            }
            if (cb) {
              cb();
            }
          });
        }).catch((firstErrParams) => {
          return new Promise((resolve, reject) => {
            const finish = () => {
              nextTick(() => {
                if (cb) {
                  cb(validRest);
                  resolve();
                } else {
                  if (getConfig3().validToReject === "obsolete") {
                    reject(validRest);
                  } else {
                    resolve(validRest);
                  }
                }
              });
            };
            const posAndFinish = () => {
              firstErrParams.cell = $xeTable.getCellElement(firstErrParams.row, firstErrParams.column);
              scrollToView(firstErrParams.cell);
              handleValidError(firstErrParams).then(finish);
            };
            if (validOpts.autoPos === false) {
              finish();
            } else {
              const row = firstErrParams.row;
              const column = firstErrParams.column;
              $xeTable.scrollToRow(row, column).then(posAndFinish);
            }
          });
        });
      } else {
        reactData.validErrorMaps = {};
      }
      return nextTick().then(() => {
        if (cb) {
          cb();
        }
      });
    };
    validatorMethods = {
      /**
       * 完整校验行，和 validate 的区别就是会给有效数据中的每一行进行校验
       */
      fullValidate(rows, cb) {
        if (import_xe_utils15.default.isFunction(cb)) {
          warnLog("vxe.error.notValidators", ["fullValidate(rows, callback)", "fullValidate(rows)"]);
        }
        return beginValidate(rows, null, cb, true);
      },
      /**
       * 快速校验行，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
       */
      validate(rows, cb) {
        return beginValidate(rows, null, cb);
      },
      /**
       * 完整校验单元格，和 validateField 的区别就是会给有效数据中的每一行进行校验
       */
      fullValidateField(rows, fieldOrColumn) {
        const colList = (import_xe_utils15.default.isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xeTable, column));
        if (colList.length) {
          return beginValidate(rows, colList, null, true);
        }
        return nextTick();
      },
      /**
       * 快速校验单元格，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
       */
      validateField(rows, fieldOrColumn) {
        const colList = (import_xe_utils15.default.isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xeTable, column));
        if (colList.length) {
          return beginValidate(rows, colList, null);
        }
        return nextTick();
      },
      clearValidate(rows, fieldOrColumn) {
        const { validErrorMaps } = reactData;
        const validTip = refValidTooltip.value;
        const validOpts = computeValidOpts.value;
        const rowList = import_xe_utils15.default.isArray(rows) ? rows : rows ? [rows] : [];
        const colList = (import_xe_utils15.default.isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xeTable, column));
        let validErrMaps = {};
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        if (validOpts.msgMode === "single") {
          reactData.validErrorMaps = {};
          return nextTick();
        }
        if (rowList.length && colList.length) {
          validErrMaps = Object.assign({}, validErrorMaps);
          rowList.forEach((row) => {
            colList.forEach((column) => {
              const validKey = `${getRowid($xeTable, row)}:${column.id}`;
              if (validErrMaps[validKey]) {
                delete validErrMaps[validKey];
              }
            });
          });
        } else if (rowList.length) {
          const rowIdList = rowList.map((row) => `${getRowid($xeTable, row)}`);
          import_xe_utils15.default.each(validErrorMaps, (item, key) => {
            if (rowIdList.indexOf(key.split(":")[0]) > -1) {
              validErrMaps[key] = item;
            }
          });
        } else if (colList.length) {
          const colidList = colList.map((column) => `${column.id}`);
          import_xe_utils15.default.each(validErrorMaps, (item, key) => {
            if (colidList.indexOf(key.split(":")[1]) > -1) {
              validErrMaps[key] = item;
            }
          });
        }
        reactData.validErrorMaps = validErrMaps;
        return nextTick();
      }
    };
    validatorPrivateMethods = {
      /**
       * 校验数据
       * 按表格行、列顺序依次校验（同步或异步）
       * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
       * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>
       * 如果是传回调方式这返回一个校验不通过列的错误消息
       *
       * rule 配置：
       *  required=Boolean 是否必填
       *  min=Number 最小长度
       *  max=Number 最大长度
       *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise
       *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）
       */
      validCellRules(validType, row, column, val) {
        const $xeGrid = $xeTable.xeGrid;
        const $xeGantt = $xeTable.xeGantt;
        const { editRules } = props;
        const { field } = column;
        const errorRules = [];
        const syncValidList = [];
        if (field && editRules) {
          const rules = import_xe_utils15.default.get(editRules, field);
          if (rules) {
            const cellValue = import_xe_utils15.default.isUndefined(val) ? import_xe_utils15.default.get(row, field) : val;
            rules.forEach((rule) => {
              const { trigger, validator } = rule;
              if (validType === "all" || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    cellValue,
                    rule,
                    rules,
                    row,
                    rowIndex: $xeTable.getRowIndex(row),
                    column,
                    columnIndex: $xeTable.getColumnIndex(column),
                    field: column.field,
                    $table: $xeTable,
                    $grid: $xeGrid,
                    $gantt: $xeGantt
                  };
                  let customValid;
                  if (import_xe_utils15.default.isString(validator)) {
                    const gvItem = validators.get(validator);
                    if (gvItem) {
                      const tcvMethod = gvItem.tableCellValidatorMethod || gvItem.cellValidatorMethod;
                      if (tcvMethod) {
                        customValid = tcvMethod(validParams);
                      } else {
                        errLog("vxe.error.notValidators", [validator]);
                      }
                    } else {
                      errLog("vxe.error.notValidators", [validator]);
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (import_xe_utils15.default.isError(customValid)) {
                      validRuleErr = true;
                      errorRules.push(new Rule({ type: "custom", trigger, content: customValid.message, rule: new Rule(rule) }));
                    } else if (customValid.catch) {
                      syncValidList.push(customValid.catch((e) => {
                        validRuleErr = true;
                        errorRules.push(new Rule({ type: "custom", trigger, content: e && e.message ? e.message : rule.content || rule.message, rule: new Rule(rule) }));
                      }));
                    }
                  }
                } else {
                  if (!checkRuleStatus(rule, cellValue)) {
                    validRuleErr = true;
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncValidList).then(() => {
          if (errorRules.length) {
            const rest = { rules: errorRules, rule: errorRules[0] };
            return Promise.reject(rest);
          }
        });
      },
      hasCellRules(type, row, column) {
        const { editRules } = props;
        const { field } = column;
        if (field && editRules) {
          const rules = import_xe_utils15.default.get(editRules, field);
          return rules && !!import_xe_utils15.default.find(rules, (rule) => type === "all" || !rule.trigger || type === rule.trigger);
        }
        return false;
      },
      /**
       * 触发校验
       */
      triggerValidate(type) {
        const { editConfig, editRules } = props;
        const { editStore } = reactData;
        const { actived } = editStore;
        const editOpts = computeEditOpts.value;
        const validOpts = computeValidOpts.value;
        if (editRules && validOpts.msgMode === "single") {
          reactData.validErrorMaps = {};
        }
        if (editConfig && editRules && actived.row) {
          const { row, column, cell } = actived.args;
          if (validatorPrivateMethods.hasCellRules(type, row, column)) {
            return validatorPrivateMethods.validCellRules(type, row, column).then(() => {
              if (editOpts.mode === "row") {
                validatorMethods.clearValidate(row, column);
              }
            }).catch(({ rule }) => {
              if (!rule.trigger || type === rule.trigger) {
                const rest = { rule, row, column, cell };
                validatorPrivateMethods.showValidTooltip(rest);
                return Promise.reject(rest);
              }
              return Promise.resolve();
            });
          }
        }
        return Promise.resolve();
      },
      /**
       * 弹出校验错误提示
       */
      showValidTooltip(params) {
        const { height } = props;
        const { tableData, validStore, validErrorMaps } = reactData;
        const { rule, row, column, cell } = params;
        const validOpts = computeValidOpts.value;
        const validTip = refValidTooltip.value;
        const content = rule.content;
        validStore.visible = true;
        if (validOpts.msgMode === "single") {
          reactData.validErrorMaps = {
            [`${getRowid($xeTable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          };
        } else {
          reactData.validErrorMaps = Object.assign({}, validErrorMaps, {
            [`${getRowid($xeTable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          });
        }
        $xeTable.dispatchEvent("valid-error", params, null);
        if (validTip) {
          if (validTip && (validOpts.message === "tooltip" || validOpts.message === "default" && !height && tableData.length < 2)) {
            return validTip.open(cell, content);
          }
        }
        return nextTick();
      }
    };
    return Object.assign(Object.assign({}, validatorMethods), validatorPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableValidatorMethodKeys);
  },
  setupGantt($xeGantt) {
    return $xeGantt.extendTableMethods(tableValidatorMethodKeys);
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/module/custom/hook.js
var import_xe_utils16 = __toESM(require_xe_utils());
var tableCustomMethodKeys = ["openCustom", "closeCustom", "getCustomVisible", "toggleCustom", "saveCustom", "cancelCustom", "resetCustom", "toggleCustomAllCheckbox", "setCustomAllCheckbox"];
VxeUI.hooks.add("tableCustomModule", {
  setupTable($xeTable) {
    const { reactData, internalData } = $xeTable;
    const { computeCustomOpts, computeRowGroupFields } = $xeTable.getComputeMaps();
    const { refElem } = $xeTable.getRefMaps();
    const $xeGantt = $xeTable.xeGantt;
    const calcMaxHeight = () => {
      const { customStore } = reactData;
      let wrapperEl = refElem.value;
      let tableHeight = 0;
      if ($xeGantt) {
        const { refGanttContainerElem } = $xeGantt.getRefMaps();
        const ganttContainerElem = refGanttContainerElem.value;
        if (ganttContainerElem) {
          wrapperEl = ganttContainerElem;
        }
      }
      if (wrapperEl) {
        tableHeight = wrapperEl.clientHeight - 28;
      }
      customStore.maxHeight = Math.max(88, tableHeight);
    };
    const openCustom = () => {
      const { initStore, customStore } = reactData;
      customStore.visible = true;
      initStore.custom = true;
      handleUpdateCustomColumn();
      checkCustomStatus();
      calcMaxHeight();
      return nextTick().then(() => calcMaxHeight());
    };
    const handleUpdateCustomColumn = () => {
      const { customStore } = reactData;
      const { collectColumn } = internalData;
      if (customStore.visible) {
        const sortMaps = {};
        const fixedMaps = {};
        const visibleMaps = {};
        import_xe_utils16.default.eachTree(collectColumn, (column) => {
          const colid = column.getKey();
          column.renderFixed = column.fixed;
          column.renderVisible = column.visible;
          column.renderResizeWidth = column.renderWidth;
          sortMaps[colid] = column.renderSortNumber;
          fixedMaps[colid] = column.fixed;
          visibleMaps[colid] = column.visible;
        });
        customStore.oldSortMaps = sortMaps;
        customStore.oldFixedMaps = fixedMaps;
        customStore.oldVisibleMaps = visibleMaps;
        reactData.customColumnList = collectColumn.slice(0);
      }
    };
    const closeCustom = () => {
      const { customStore } = reactData;
      const customOpts = computeCustomOpts.value;
      if (customStore.visible) {
        customStore.visible = false;
        if (!customOpts.immediate) {
          $xeTable.handleCustom();
        }
      }
      return nextTick();
    };
    const toggleCustom = () => {
      const { customStore } = reactData;
      if (customStore.visible) {
        return closeCustom();
      }
      return openCustom();
    };
    const saveCustom = () => {
      const { customColumnList, aggHandleFields, rowGroupList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { allowVisible, allowSort, allowFixed, allowResizable, allowGroup, allowValues } = customOpts;
      import_xe_utils16.default.eachTree(customColumnList, (column, index, items, path, parentColumn) => {
        if (parentColumn) {
          column.fixed = parentColumn.fixed;
        } else {
          if (allowSort) {
            const sortIndex = index + 1;
            column.renderSortNumber = sortIndex;
          }
          if (allowFixed) {
            column.fixed = column.renderFixed;
          }
        }
        if (allowResizable) {
          if (column.renderVisible && (!column.children || !column.children.length)) {
            if (column.renderResizeWidth !== column.renderWidth) {
              column.resizeWidth = column.renderResizeWidth;
              column.renderWidth = column.renderResizeWidth;
            }
          }
        }
        if (allowVisible) {
          column.visible = column.renderVisible;
        }
        if (allowGroup && allowValues) {
          column.aggFunc = column.renderAggFn;
        }
      });
      reactData.isCustomStatus = true;
      if (allowGroup && !!$xeTable.handlePivotTableAggregateData) {
        if (rowGroupList.length !== aggHandleFields.length || rowGroupList.some((conf, i) => conf.field !== aggHandleFields[i])) {
          if (aggHandleFields.length) {
            $xeTable.setRowGroups(aggHandleFields);
          } else {
            $xeTable.clearRowGroups();
          }
        } else if (allowValues) {
          $xeTable.handleUpdateAggData();
        }
      }
      if (allowSort) {
        internalData.collectColumn = customColumnList;
      }
      return $xeTable.saveCustomStore("confirm");
    };
    const cancelCustom = () => {
      const { customColumnList, customStore } = reactData;
      const { oldSortMaps, oldFixedMaps, oldVisibleMaps } = customStore;
      const customOpts = computeCustomOpts.value;
      const { allowVisible, allowSort, allowFixed, allowResizable } = customOpts;
      import_xe_utils16.default.eachTree(customColumnList, (column) => {
        const colid = column.getKey();
        const visible = !!oldVisibleMaps[colid];
        const fixed = oldFixedMaps[colid] || "";
        if (allowVisible) {
          column.renderVisible = visible;
          column.visible = visible;
        }
        if (allowFixed) {
          column.renderFixed = fixed;
          column.fixed = fixed;
        }
        if (allowSort) {
          column.renderSortNumber = oldSortMaps[colid] || 0;
        }
        if (allowResizable) {
          column.renderResizeWidth = column.renderWidth;
        }
      }, { children: "children" });
      return nextTick();
    };
    const setCustomAllCheckbox = (checked) => {
      const { customStore } = reactData;
      const { customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod, visibleMethod } = customOpts;
      const isAll = !!checked;
      if (customOpts.immediate) {
        import_xe_utils16.default.eachTree(customColumnList, (column) => {
          if (visibleMethod && !visibleMethod({ $table: $xeTable, column })) {
            return;
          }
          if (checkMethod && !checkMethod({ $table: $xeTable, column })) {
            return;
          }
          column.visible = isAll;
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:visible");
      } else {
        import_xe_utils16.default.eachTree(customColumnList, (column) => {
          if (visibleMethod && !visibleMethod({ $table: $xeTable, column })) {
            return;
          }
          if (checkMethod && !checkMethod({ $table: $xeTable, column })) {
            return;
          }
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
      }
      $xeTable.checkCustomStatus();
      return nextTick();
    };
    const customMethods = {
      getCustomVisible() {
        const { customStore } = reactData;
        return customStore.visible;
      },
      openCustom,
      closeCustom,
      toggleCustom,
      saveCustom,
      cancelCustom,
      resetCustom(options) {
        const { rowGroupList } = reactData;
        const { collectColumn } = internalData;
        const customOpts = computeCustomOpts.value;
        const { checkMethod } = customOpts;
        const opts = Object.assign({
          visible: true,
          resizable: options === true,
          fixed: options === true,
          sort: options === true,
          aggFunc: options === true
        }, options);
        const allCols = [];
        import_xe_utils16.default.eachTree(collectColumn, (column) => {
          if (opts.resizable) {
            column.resizeWidth = 0;
          }
          if (opts.fixed) {
            column.fixed = column.defaultFixed;
          }
          if (opts.sort) {
            column.renderSortNumber = column.sortNumber;
            column.parentId = column.defaultParentId;
          }
          if (!checkMethod || checkMethod({ $table: $xeTable, column })) {
            column.visible = column.defaultVisible;
          }
          if (opts.aggFunc) {
            column.aggFunc = column.defaultAggFunc;
            column.renderAggFn = column.defaultAggFunc;
          }
          column.renderResizeWidth = column.renderWidth;
          allCols.push(column);
        });
        if (opts.sort) {
          const newCollectCols = import_xe_utils16.default.toArrayTree(import_xe_utils16.default.orderBy(allCols, "renderSortNumber"), { key: "id", parentKey: "parentId", children: "children" });
          internalData.collectColumn = newCollectCols;
          internalData.tableFullColumn = getColumnList(newCollectCols);
        }
        reactData.isCustomStatus = false;
        return $xeTable.handleCustom().then(() => {
          if (opts.aggFunc && $xeTable.handlePivotTableAggregateData) {
            const rowGroupFields = computeRowGroupFields.value;
            if (rowGroupFields ? rowGroupFields.length : rowGroupList.length) {
              if (rowGroupFields && rowGroupFields.length) {
                $xeTable.setRowGroups(rowGroupFields);
              } else {
                $xeTable.clearRowGroups();
              }
            } else {
              $xeTable.handleUpdateAggData();
            }
          }
          $xeTable.saveCustomStore("reset");
        });
      },
      toggleCustomAllCheckbox() {
        const { customStore } = reactData;
        const isAll = !customStore.isAll;
        return setCustomAllCheckbox(isAll);
      },
      setCustomAllCheckbox
    };
    const checkCustomStatus = () => {
      const { customStore } = reactData;
      const { collectColumn } = internalData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod } = customOpts;
      customStore.isAll = collectColumn.every((column) => (checkMethod ? !checkMethod({ $table: $xeTable, column }) : false) || column.renderVisible);
      customStore.isIndeterminate = !customStore.isAll && collectColumn.some((column) => (!checkMethod || checkMethod({ $table: $xeTable, column })) && (column.renderVisible || column.halfVisible));
    };
    const emitCustomEvent = (type, evnt) => {
      $xeTable.dispatchEvent("custom", { type }, evnt);
    };
    const customPrivateMethods = {
      checkCustomStatus,
      emitCustomEvent,
      triggerCustomEvent(evnt) {
        const reactData2 = $xeTable.reactData;
        const { customStore } = reactData2;
        if (customStore.visible) {
          closeCustom();
          emitCustomEvent("close", evnt);
        } else {
          customStore.btnEl = evnt.target;
          openCustom();
          emitCustomEvent("open", evnt);
        }
      },
      customOpenEvent(evnt) {
        const reactData2 = $xeTable.reactData;
        const { customStore } = reactData2;
        if (!customStore.visible) {
          customStore.activeBtn = true;
          customStore.btnEl = evnt.target;
          $xeTable.openCustom();
          $xeTable.emitCustomEvent("open", evnt);
        }
      },
      customCloseEvent(evnt) {
        const reactData2 = $xeTable.reactData;
        const { customStore } = reactData2;
        if (customStore.visible) {
          customStore.activeBtn = false;
          $xeTable.closeCustom();
          $xeTable.emitCustomEvent("close", evnt);
        }
      },
      handleUpdateCustomColumn
    };
    return Object.assign(Object.assign({}, customMethods), customPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableCustomMethodKeys);
  },
  setupGantt($xeGantt) {
    return $xeGantt.extendTableMethods(tableCustomMethodKeys);
  }
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/render/index.js
var import_xe_utils17 = __toESM(require_xe_utils());
var { getConfig: getConfig4, renderer: renderer8, getI18n: getI18n9, getComponent } = VxeUI;
var componentDefaultModelProp = "modelValue";
var defaultCompProps = {};
function handleDefaultValue(value, defaultVal, initVal) {
  return import_xe_utils17.default.eqNull(value) ? import_xe_utils17.default.eqNull(defaultVal) ? initVal : defaultVal : value;
}
function parseDate(value, props) {
  return value && props.valueFormat ? import_xe_utils17.default.toStringDate(value, props.valueFormat) : value;
}
function getFormatDate(value, props, defaultFormat) {
  const { dateConfig = {} } = props;
  return import_xe_utils17.default.toDateString(parseDate(value, props), dateConfig.labelFormat || defaultFormat);
}
function getLabelFormatDate(value, props) {
  return getFormatDate(value, props, getI18n9(`vxe.input.date.labelFormat.${props.type || "date"}`));
}
function getOldComponentName(name) {
  return `vxe-${name.replace("$", "")}`;
}
function getDefaultComponent({ name }) {
  return getComponent(name);
}
function getOldComponent({ name }) {
  return resolveComponent(getOldComponentName(name));
}
function updateFilterChangeOption(params, checked, option) {
  const { $table } = params;
  $table.updateFilterOptionStatus(option, checked);
}
function saveFilterEvent(params) {
  const { $table, column } = params;
  $table.saveFilterByEvent(new Event("change"), column);
}
function getNativeAttrs(renderOpts) {
  let { name, attrs } = renderOpts;
  if (name === "input") {
    attrs = Object.assign({ type: "text" }, attrs);
  }
  return attrs;
}
function getInputImmediateModel(renderOpts) {
  const { name, immediate, props } = renderOpts;
  if (!immediate) {
    if (name === "VxeInput" || name === "$input") {
      const { type } = props || {};
      return !(!type || type === "text" || type === "number" || type === "integer" || type === "float");
    }
    if (name === "input" || name === "textarea" || name === "$textarea") {
      return false;
    }
    return true;
  }
  return immediate;
}
function getCellEditProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils17.default.assign({ immediate: getInputImmediateModel(renderOpts) }, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function getCellEditFilterProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils17.default.assign({}, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function isImmediateCell(renderOpts, params) {
  return params.$type === "cell" || getInputImmediateModel(renderOpts);
}
function getCellLabelVNs(renderOpts, params, cellLabel, opts) {
  const { placeholder } = renderOpts;
  return [
    h("span", {
      class: ["vxe-cell--label", opts ? opts.class : ""]
    }, placeholder && isEmptyValue(cellLabel) ? [
      h("span", {
        class: "vxe-cell--placeholder"
      }, formatText(getFuncText(placeholder), 1))
    ] : formatText(cellLabel, 1))
  ];
}
function getNativeElementOns(renderOpts, params, eFns) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const { model: modelFunc, change: changeFunc, blur: blurFunc } = eFns || {};
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    import_xe_utils17.default.objectEach(events, (func, key) => {
      ons[getOnName(key)] = function(...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function(evnt) {
      changeFunc(evnt);
      if (events && events[changeEvent]) {
        events[changeEvent](params, evnt);
      }
    };
  }
  if (blurFunc) {
    ons[getOnName(blurEvent)] = function(evnt) {
      blurFunc(evnt);
      if (events && events[blurEvent]) {
        events[blurEvent](params, evnt);
      }
    };
  }
  return ons;
}
var blurEvent = "blur";
var clearEvent = "clear";
function getComponentOns(renderOpts, params, eFns, eventOns) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const { model: modelFunc, change: changeFunc, blur: blurFunc, clear: clearFunc } = eFns || {};
  const ons = {};
  import_xe_utils17.default.objectEach(events, (func, key) => {
    ons[getOnName(key)] = function(...args) {
      if (!import_xe_utils17.default.isFunction(func)) {
        errLog("vxe.error.errFunc", [func]);
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  if (blurFunc) {
    ons[getOnName(blurEvent)] = function(...args) {
      blurFunc(...args);
      if (events && events[blurEvent]) {
        events[blurEvent](params, ...args);
      }
    };
  }
  if (clearFunc) {
    ons[getOnName(clearEvent)] = function(...args) {
      clearFunc(...args);
      if (events && events[clearEvent]) {
        events[clearEvent](params, ...args);
      }
    };
  }
  return eventOns ? Object.assign(ons, eventOns) : ons;
}
function getEditOns(renderOpts, params) {
  const { $table, row, column } = params;
  const { name } = renderOpts;
  const { model } = column;
  const isImmediate = isImmediateCell(renderOpts, params);
  return getComponentOns(renderOpts, params, {
    model(cellValue) {
      model.update = true;
      model.value = cellValue;
      if (isImmediate) {
        setCellValue(row, column, cellValue);
      }
    },
    change(eventParams) {
      if (!isImmediate && name && ["VxeInput", "VxeNumberInput", "VxeTextarea", "$input", "$textarea"].includes(name)) {
        const cellValue = eventParams.value;
        model.update = true;
        model.value = cellValue;
        $table.updateStatus(params, cellValue);
      } else {
        $table.updateStatus(params);
      }
    },
    blur() {
      if (isImmediate) {
        $table.handleCellRuleUpdateStatus("blur", params);
      } else {
        $table.handleCellRuleUpdateStatus("blur", params, model.value);
      }
    }
  });
}
function getFilterOns(renderOpts, params, option) {
  return getComponentOns(renderOpts, params, {
    model(value) {
      option.data = value;
    },
    change() {
      updateFilterChangeOption(params, !isEmptyValue(option.data), option);
    },
    blur() {
      updateFilterChangeOption(params, !isEmptyValue(option.data), option);
    }
  });
}
function getFloatingFilterOns(renderOpts, params, option) {
  const { $table, column } = params;
  if (hasInputType(renderOpts)) {
    return getComponentOns(renderOpts, params, {
      model(value) {
        option.data = value;
      },
      change() {
        updateFilterChangeOption(params, !isEmptyValue(option.data), option);
      },
      clear() {
        updateFilterChangeOption(params, !isEmptyValue(option.data), option);
        saveFilterEvent(params);
      },
      blur() {
        $table.saveFilterByEvent(new Event("change"), column);
      }
    }, renderOpts.name === "VxeNumberInput" ? {
      [getOnName("plus-number")]() {
        updateFilterChangeOption(params, !isEmptyValue(option.data), option);
        saveFilterEvent(params);
      },
      [getOnName("minus-number")]() {
        updateFilterChangeOption(params, !isEmptyValue(option.data), option);
        saveFilterEvent(params);
      }
    } : {});
  }
  return getComponentOns(renderOpts, params, {
    model(value) {
      option.data = value;
    },
    clear() {
      updateFilterChangeOption(params, !isEmptyValue(option.data), option);
      $table.saveFilterByEvent(new Event("change"), column);
    },
    change() {
      updateFilterChangeOption(params, !isEmptyValue(option.data), option);
      $table.saveFilterByEvent(new Event("change"), column);
    }
  });
}
function getNativeEditOns(renderOpts, params) {
  const { $table, row, column } = params;
  const { model } = column;
  return getNativeElementOns(renderOpts, params, {
    model(evnt) {
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        if (isImmediateCell(renderOpts, params)) {
          setCellValue(row, column, cellValue);
        } else {
          model.update = true;
          model.value = cellValue;
        }
      }
    },
    change(evnt) {
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        $table.updateStatus(params, cellValue);
      }
    },
    blur(evnt) {
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        $table.updateStatus(params, cellValue);
      }
    }
  });
}
function getNativeFilterOns(renderOpts, params, option) {
  return getNativeElementOns(renderOpts, params, {
    model(evnt) {
      const targetEl = evnt.target;
      if (targetEl) {
        option.data = targetEl.value;
      }
    },
    change() {
      updateFilterChangeOption(params, !import_xe_utils17.default.eqNull(option.data), option);
    },
    blur() {
      updateFilterChangeOption(params, !import_xe_utils17.default.eqNull(option.data), option);
    }
  });
}
function nativeEditRender(renderOpts, params) {
  const { row, column } = params;
  const { name } = renderOpts;
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return [
    h(`${name}`, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${name}` }, getNativeAttrs(renderOpts)), { value: cellValue }), getNativeEditOns(renderOpts, params)))
  ];
}
function buttonCellRender(renderOpts, params) {
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function defaultEditRender(renderOpts, params) {
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function checkboxEditRender(renderOpts, params) {
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function radioAndCheckboxGroupEditRender(renderOpts, params) {
  const { options } = renderOpts;
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ options }, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function oldEditRender(renderOpts, params) {
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function oldButtonEditRender(renderOpts, params) {
  return [
    h(getComponent("vxe-button"), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function oldButtonsEditRender(renderOpts, params) {
  const { children } = renderOpts;
  return children ? children.map((childRenderOpts) => oldButtonEditRender(childRenderOpts, params)[0]) : [];
}
function renderNativeOptgroups(renderOpts, params, renderOptionsMethods) {
  const { optionGroups, optionGroupProps = {} } = renderOpts;
  const groupOptions = optionGroupProps.options || "options";
  const groupLabel = optionGroupProps.label || "label";
  if (optionGroups) {
    return optionGroups.map((group, gIndex) => {
      return h("optgroup", {
        key: gIndex,
        label: group[groupLabel]
      }, renderOptionsMethods(group[groupOptions], renderOpts, params));
    });
  }
  return [];
}
function renderNativeOptions(options, renderOpts, params) {
  const { optionProps = {} } = renderOpts;
  const { row, column } = params;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  if (options) {
    return options.map((option, oIndex) => {
      return h("option", {
        key: oIndex,
        value: option[valueProp],
        disabled: option[disabledProp],
        /* eslint-disable eqeqeq */
        selected: option[valueProp] == cellValue
      }, option[labelProp]);
    });
  }
  return [];
}
function nativeFilterRender(renderOpts, params) {
  const { column } = params;
  const { name } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  return column.filters.map((option, oIndex) => {
    return h(`${name}`, Object.assign(Object.assign(Object.assign({ key: oIndex, class: `vxe-default-${name}` }, attrs), { value: option.data }), getNativeFilterOns(renderOpts, params, option)));
  });
}
function defaultFilterRender(renderOpts, params) {
  const { column } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFilterOns(renderOpts, params, option)));
  });
}
function defaultFloatingFilterRender(renderOpts, params) {
  const { option } = params;
  const optionValue = option.data;
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFloatingFilterOns(renderOpts, params, option)))
  ];
}
function defaultFilterOptions() {
  return [
    { data: null }
  ];
}
function oldFilterRender(renderOpts, params) {
  const { column } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return h(getOldComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFilterOns(renderOpts, params, option)));
  });
}
function handleFilterMethod({ option, row, column }) {
  const { data } = option;
  const cellValue = import_xe_utils17.default.get(row, column.field);
  return cellValue == data;
}
function handleInputFilterMethod({ option, row, column }) {
  const { data } = option;
  const cellValue = import_xe_utils17.default.get(row, column.field);
  return import_xe_utils17.default.toValueString(cellValue).indexOf(data) > -1;
}
function nativeSelectEditRender(renderOpts, params) {
  return [
    h("select", Object.assign(Object.assign({ class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeEditOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params))
  ];
}
function defaultSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps, optionGroups, optionGroupProps })), getEditOns(renderOpts, params)))
  ];
}
function defaultTableOrTreeSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps })), getEditOns(renderOpts, params)))
  ];
}
function oldSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps, optionGroups, optionGroupProps })), getEditOns(renderOpts, params)))
  ];
}
function getSelectCellValue(renderOpts, { row, column }) {
  const { options, optionGroups, optionProps = {}, optionGroupProps = {}, props = {} } = renderOpts;
  const cellValue = import_xe_utils17.default.get(row, column.field);
  let selectItem;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  if (!(cellValue === null || cellValue === void 0)) {
    let vals = [];
    if (import_xe_utils17.default.isArray(cellValue)) {
      vals = cellValue;
    } else {
      if (props.multiple && `${cellValue}`.indexOf(",") > -1) {
        vals = `${cellValue}`.split(",");
      } else {
        vals = [cellValue];
      }
    }
    return import_xe_utils17.default.map(vals, optionGroups ? (value) => {
      const groupOptions = optionGroupProps.options || "options";
      for (let index = 0; index < optionGroups.length; index++) {
        selectItem = import_xe_utils17.default.find(optionGroups[index][groupOptions], (item) => item[valueProp] == value);
        if (selectItem) {
          break;
        }
      }
      return selectItem ? selectItem[labelProp] : value;
    } : (value) => {
      selectItem = import_xe_utils17.default.find(options, (item) => item[valueProp] == value);
      return selectItem ? selectItem[labelProp] : value;
    }).join(", ");
  }
  return "";
}
function handleExportSelectMethod(params) {
  const { row, column, options } = params;
  return options.original ? getCellValue(row, column) : getSelectCellValue(column.editRender || column.cellRender, params);
}
function getTreeSelectCellValue(renderOpts, { row, column }) {
  const { options, optionProps = {} } = renderOpts;
  const cellValue = import_xe_utils17.default.get(row, column.field);
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const childrenProp = optionProps.children || "children";
  if (!(cellValue === null || cellValue === void 0)) {
    const keyMaps = {};
    import_xe_utils17.default.eachTree(options, (item) => {
      keyMaps[import_xe_utils17.default.get(item, valueProp)] = item;
    }, { children: childrenProp });
    return import_xe_utils17.default.map(import_xe_utils17.default.isArray(cellValue) ? cellValue : [cellValue], (value) => {
      const item = keyMaps[value];
      return item ? import_xe_utils17.default.get(item, labelProp) : item;
    }).join(", ");
  }
  return "";
}
function handleExportTreeSelectMethod(params) {
  const { row, column, options } = params;
  return options.original ? getCellValue(row, column) : getTreeSelectCellValue(column.editRender || column.cellRender, params);
}
function handleNumberCell(renderOpts, params) {
  const { props = {}, showNegativeStatus } = renderOpts;
  const { row, column } = params;
  const { type } = props;
  let cellValue = import_xe_utils17.default.get(row, column.field);
  let isNegative = false;
  if (!isEmptyValue(cellValue)) {
    const numberInputConfig = getConfig4().numberInput || {};
    if (type === "float") {
      const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
      const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 1);
      cellValue = import_xe_utils17.default.toFixed(import_xe_utils17.default.floor(cellValue, digits), digits);
      if (!autoFill) {
        cellValue = import_xe_utils17.default.toNumber(cellValue);
      }
      if (showNegativeStatus) {
        if (cellValue < 0) {
          isNegative = true;
        }
      }
    } else if (type === "amount") {
      const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
      const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 2);
      const showCurrency = handleDefaultValue(props.showCurrency, numberInputConfig.showCurrency, false);
      cellValue = import_xe_utils17.default.toNumber(cellValue);
      if (showNegativeStatus) {
        if (cellValue < 0) {
          isNegative = true;
        }
      }
      cellValue = import_xe_utils17.default.commafy(cellValue, { digits });
      if (!autoFill) {
        const [iStr, dStr] = cellValue.split(".");
        if (dStr) {
          const dRest = dStr.replace(/0+$/, "");
          cellValue = dRest ? [iStr, ".", dRest].join("") : iStr;
        }
      }
      if (showCurrency) {
        cellValue = `${props.currencySymbol || numberInputConfig.currencySymbol || getI18n9("vxe.numberInput.currencySymbol") || ""}${cellValue}`;
      }
    } else {
      if (showNegativeStatus) {
        if (import_xe_utils17.default.toNumber(cellValue) < 0) {
          isNegative = true;
        }
      }
    }
  }
  return getCellLabelVNs(renderOpts, params, cellValue, isNegative ? {
    class: "is--negative"
  } : {});
}
renderer8.mixin({
  input: {
    tableAutoFocus: "input",
    renderTableEdit: nativeEditRender,
    renderTableDefault: nativeEditRender,
    renderTableFilter: nativeFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  textarea: {
    tableAutoFocus: "textarea",
    renderTableEdit: nativeEditRender
  },
  select: {
    renderTableEdit: nativeSelectEditRender,
    renderTableDefault: nativeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const { column } = params;
      return column.filters.map((option, oIndex) => {
        return h("select", Object.assign(Object.assign({ key: oIndex, class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeFilterOns(renderOpts, params, option)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeInput: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const inputConfig = getConfig4().input || {};
      const digits = props.digits || inputConfig.digits || 2;
      let cellValue = import_xe_utils17.default.get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case "date":
          case "week":
          case "month":
          case "quarter":
          case "year":
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case "float":
            cellValue = import_xe_utils17.default.toFixed(import_xe_utils17.default.floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    createTableFilterOptions: defaultFilterOptions,
    renderTableFilter: defaultFilterRender,
    renderTableFloatingFilter: defaultFloatingFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  FormatNumberInput: {
    renderTableDefault: handleNumberCell,
    tableFilterDefaultMethod: handleInputFilterMethod,
    tableExportMethod(params) {
      const { row, column } = params;
      const cellValue = import_xe_utils17.default.get(row, column.field);
      return cellValue;
    }
  },
  VxeNumberInput: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell: handleNumberCell,
    renderTableFooter(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column, _columnIndex } = params;
      const { type } = props;
      const itemValue = import_xe_utils17.default.isArray(row) ? row[_columnIndex] : import_xe_utils17.default.get(row, column.field);
      if (import_xe_utils17.default.isNumber(itemValue)) {
        const numberInputConfig = getConfig4().numberInput || {};
        if (type === "float") {
          const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
          const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 1);
          let amountLabel = import_xe_utils17.default.toFixed(import_xe_utils17.default.floor(itemValue, digits), digits);
          if (!autoFill) {
            amountLabel = import_xe_utils17.default.toNumber(amountLabel);
          }
          return amountLabel;
        } else if (type === "amount") {
          const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
          const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 2);
          const showCurrency = handleDefaultValue(props.showCurrency, numberInputConfig.showCurrency, false);
          let amountLabel = import_xe_utils17.default.commafy(import_xe_utils17.default.toNumber(itemValue), { digits });
          if (!autoFill) {
            const [iStr, dStr] = amountLabel.split(".");
            if (dStr) {
              const dRest = dStr.replace(/0+$/, "");
              amountLabel = dRest ? [iStr, ".", dRest].join("") : iStr;
            }
          }
          if (showCurrency) {
            amountLabel = `${props.currencySymbol || numberInputConfig.currencySymbol || getI18n9("vxe.numberInput.currencySymbol") || ""}${amountLabel}`;
          }
          return amountLabel;
        }
      }
      return getFuncText(itemValue, 1);
    },
    renderTableDefault: defaultEditRender,
    createTableFilterOptions: defaultFilterOptions,
    renderTableFilter: defaultFilterRender,
    renderTableFloatingFilter: defaultFloatingFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod,
    tableExportMethod(params) {
      const { row, column } = params;
      const cellValue = import_xe_utils17.default.get(row, column.field);
      return cellValue;
    }
  },
  VxeDatePicker: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column } = params;
      let cellValue = import_xe_utils17.default.get(row, column.field);
      if (cellValue) {
        if (props.type !== "time") {
          cellValue = getLabelFormatDate(cellValue, props);
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    createTableFilterOptions: defaultFilterOptions,
    renderTableFilter: defaultFilterRender,
    renderTableFloatingFilter: defaultFloatingFilterRender,
    tableFilterDefaultMethod: handleFilterMethod
  },
  VxeDateRangePicker: {
    tableAutoFocus: "input",
    renderTableEdit(renderOpts, params) {
      const { startField, endField } = renderOpts;
      const { $table, row, column } = params;
      const { model } = column;
      const cellValue = getCellValue(row, column);
      const seProps = {};
      const seOs = {};
      if (startField && endField) {
        seProps.startValue = import_xe_utils17.default.get(row, startField);
        seProps.endValue = import_xe_utils17.default.get(row, endField);
        seOs["onUpdate:startValue"] = (value) => {
          if (startField) {
            import_xe_utils17.default.set(row, startField, value);
          }
        };
        seOs["onUpdate:endValue"] = (value) => {
          if (endField) {
            import_xe_utils17.default.set(row, endField, value);
          }
        };
      }
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, seProps)), getComponentOns(renderOpts, params, {
          model(cellValue2) {
            model.update = true;
            model.value = cellValue2;
            setCellValue(row, column, cellValue2);
          },
          change() {
            $table.updateStatus(params);
          },
          blur() {
            $table.handleCellRuleUpdateStatus("blur", params);
          }
        }, seOs)))
      ];
    },
    renderTableCell(renderOpts, params) {
      const { startField, endField } = renderOpts;
      const { row, column } = params;
      let startValue = "";
      let endValue = "";
      if (startField && endField) {
        startValue = import_xe_utils17.default.get(row, startField);
        endValue = import_xe_utils17.default.get(row, endField);
      } else {
        const cellValue = import_xe_utils17.default.get(row, column.field);
        if (cellValue) {
          if (import_xe_utils17.default.isArray(cellValue)) {
            startValue = cellValue[0];
            endValue = cellValue[1];
          } else {
            const strs = `${cellValue}`.split(",");
            startValue = strs[0];
            endValue = strs[1];
          }
        }
      }
      let cellLabel = "";
      if (startValue && endValue) {
        cellLabel = `${startValue} ~ ${endValue}`;
      }
      return getCellLabelVNs(renderOpts, params, cellLabel);
    }
  },
  VxeTextarea: {
    tableAutoFocus: "textarea",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { row, column } = params;
      const cellValue = import_xe_utils17.default.get(row, column.field);
      return getCellLabelVNs(renderOpts, params, cellValue);
    }
  },
  VxeButton: {
    renderTableDefault: buttonCellRender
  },
  VxeButtonGroup: {
    renderTableDefault(renderOpts, params) {
      const { options } = renderOpts;
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ options }, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
      ];
    }
  },
  VxeSelect: {
    tableAutoFocus: "input",
    renderTableEdit: defaultSelectEditRender,
    renderTableDefault: defaultSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    createTableFilterOptions: defaultFilterOptions,
    renderTableFilter(renderOpts, params) {
      const { column } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFilterOns(renderOpts, params, option)));
      });
    },
    renderTableFloatingFilter(renderOpts, params) {
      const { option } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const optionValue = option.data;
      return h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFloatingFilterOns(renderOpts, params, option)));
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeText: {
    renderTableDefault(renderOpts, params) {
      const { $table, row, column } = params;
      const { props } = renderOpts;
      const cellLabel = $table.getCellLabel(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props || {}), { content: cellLabel }), getComponentOns(renderOpts, params)))
      ];
    }
  },
  VxeLink: {
    renderTableDefault(renderOpts, params) {
      const { $table, row, column } = params;
      const { props } = renderOpts;
      const { href } = props || {};
      const cellLabel = $table.getCellLabel(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props || {}), { content: cellLabel, href: import_xe_utils17.default.toFormatString(href, params) }), getComponentOns(renderOpts, params)))
      ];
    }
  },
  /**
   * 已废弃，被 FormatSelect 替换
   * @deprecated
   */
  formatOption: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    }
  },
  FormatSelect: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeTreeSelect: {
    tableAutoFocus: "input",
    renderTableEdit: defaultTableOrTreeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  /**
   * 已废弃，被 FormatTreeSelect 替换
   * @deprecated
   */
  formatTree: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    }
  },
  FormatTreeSelect: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeTableSelect: {
    tableAutoFocus: "input",
    renderTableEdit: defaultTableOrTreeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeColorPicker: {
    tableAutoFocus: "input",
    renderTableEdit(renderOpts, params) {
      const { row, column } = params;
      const { options } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { colors: options })), getEditOns(renderOpts, params)))
      ];
    },
    renderTableCell(renderOpts, params) {
      const { row, column } = params;
      const cellValue = import_xe_utils17.default.get(row, column.field);
      return h("span", {
        class: "vxe-color-picker--readonly"
      }, [
        h("div", {
          class: "vxe-color-picker--readonly-color",
          style: {
            backgroundColor: cellValue
          }
        })
      ]);
    }
  },
  VxeIconPicker: {
    tableAutoFocus: "input",
    renderTableEdit(renderOpts, params) {
      const { row, column } = params;
      const { options } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { icons: options })), getEditOns(renderOpts, params)))
      ];
    },
    renderTableCell(renderOpts, params) {
      const { row, column } = params;
      const cellValue = import_xe_utils17.default.get(row, column.field);
      return h("i", {
        class: cellValue
      });
    }
  },
  VxeRadioGroup: {
    renderTableDefault: radioAndCheckboxGroupEditRender
  },
  VxeCheckbox: {
    renderTableDefault: checkboxEditRender
  },
  VxeCheckboxGroup: {
    renderTableDefault: radioAndCheckboxGroupEditRender
  },
  VxeSwitch: {
    tableAutoFocus: "button",
    renderTableEdit: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeUpload: {
    renderTableEdit: defaultEditRender,
    renderTableCell: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeImage: {
    renderTableDefault(renderOpts, params) {
      const { row, column } = params;
      const { props } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { src: cellValue }), getEditOns(renderOpts, params)))
      ];
    }
  },
  VxeImageGroup: {
    renderTableDefault(renderOpts, params) {
      const { row, column } = params;
      const { props } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { urlList: cellValue }), getEditOns(renderOpts, params)))
      ];
    }
  },
  VxeTextEllipsis: {
    renderTableDefault(renderOpts, params) {
      const { row, column } = params;
      const { props } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { content: cellValue }), getEditOns(renderOpts, params)))
      ];
    }
  },
  VxeRate: {
    renderTableDefault: defaultEditRender
  },
  VxeSlider: {
    renderTableDefault: defaultEditRender
  },
  // 以下已废弃
  $input: {
    tableAutoFocus: ".vxe-input--inner",
    renderTableEdit: oldEditRender,
    renderTableCell(renderOpts, params) {
      var _a;
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const digits = props.digits || ((_a = getConfig4().input) === null || _a === void 0 ? void 0 : _a.digits) || 2;
      let cellValue = import_xe_utils17.default.get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case "date":
          case "week":
          case "month":
          case "year":
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case "float":
            cellValue = import_xe_utils17.default.toFixed(import_xe_utils17.default.floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: oldEditRender,
    renderTableFilter: oldFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  $textarea: {
    tableAutoFocus: ".vxe-textarea--inner"
  },
  $button: {
    renderTableDefault: oldButtonEditRender
  },
  $buttons: {
    renderTableDefault: oldButtonsEditRender
  },
  $select: {
    tableAutoFocus: ".vxe-input--inner",
    renderTableEdit: oldSelectEditRender,
    renderTableDefault: oldSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const { column } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return h(getOldComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFilterOns(renderOpts, params, option)));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  $radio: {
    tableAutoFocus: ".vxe-radio--input"
  },
  $checkbox: {
    tableAutoFocus: ".vxe-checkbox--input"
  },
  $switch: {
    tableAutoFocus: ".vxe-switch--button",
    renderTableEdit: oldEditRender,
    renderTableDefault: oldEditRender
  }
  // 以上已废弃
});

// ../../node_modules/.pnpm/vxe-table@4.17.15_vue@3.5.24_typescript@5.9.3_/node_modules/vxe-table/es/table/src/table.js
var { getConfig: getConfig5, getIcon: getIcon6, getI18n: getI18n10, renderer: renderer9, formats, createEvent, globalResize, interceptor, hooks: hooks7, globalEvents: globalEvents2, GLOBAL_EVENT_KEYS: GLOBAL_EVENT_KEYS2, useFns, renderEmptyElement: renderEmptyElement9 } = VxeUI;
var supportMaxRow = 5e6;
var customStorageKey = "VXE_CUSTOM_STORE";
var maxYHeight = 5e6;
var maxXWidth = 5e6;
var crossTableDragRowObj = null;
var table_default = defineVxeComponent({
  name: "VxeTable",
  props: tableProps,
  emits: tableEmits,
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils18.default.uniqueId();
    const browseObj = import_xe_utils18.default.browse();
    const VxeUILoadingComponent = VxeUI.getComponent("VxeLoading");
    const VxeUITooltipComponent = VxeUI.getComponent("VxeTooltip");
    const $xeTabs = inject("$xeTabs", null);
    const $xeParentTable = inject("$xeTable", null);
    const $xeGrid = inject("$xeGrid", null);
    const $xeGantt = inject("$xeGantt", null);
    const $xeGGWrapper = $xeGrid || $xeGantt;
    const { computeSize } = useFns.useSize(props);
    const crossTableDragRowInfo2 = getCrossTableDragRowInfo();
    const reactData = reactive({
      // 低性能的静态列
      staticColumns: [],
      // 渲染的列分组
      tableGroupColumn: [],
      // 可视区渲染的列
      tableColumn: [],
      // 渲染中的数据
      tableData: [],
      // 是否启用了横向 X 可视渲染方式加载
      scrollXLoad: false,
      // 是否启用了纵向 Y 可视渲染方式加载
      scrollYLoad: false,
      // 是否存在纵向滚动条
      overflowY: true,
      // 是否存在横向滚动条
      overflowX: false,
      // 纵向滚动条的宽度
      scrollbarWidth: 0,
      // 横向滚动条的高度
      scrollbarHeight: 0,
      // 最后滚动时间戳
      lastScrollTime: 0,
      // 行高
      rowHeight: 0,
      // 表格父容器的高度
      parentHeight: 0,
      // 是否使用分组表头
      isGroup: false,
      isAllOverflow: false,
      // 复选框属性，是否全选
      isAllSelected: false,
      // 复选框属性，有选中且非全选状态
      isIndeterminate: false,
      // 当前行
      currentRow: null,
      // 单选框属性，选中列
      currentColumn: null,
      // 单选框属性，选中行
      selectRadioRow: null,
      // 表尾合计数据
      footerTableData: [],
      // 行分组列信息
      rowGroupColumn: null,
      // 展开列信息
      expandColumn: null,
      checkboxColumn: null,
      radioColumn: null,
      // 树节点列信息
      treeNodeColumn: null,
      hasFixedColumn: false,
      // 刷新列标识，当列筛选被改变时，触发表格刷新数据
      upDataFlag: 0,
      // 刷新列标识，当列的特定属性被改变时，触发表格刷新列
      reColumnFlag: 0,
      // 初始化标识
      initStore: {
        filter: false,
        import: false,
        export: false,
        custom: false
      },
      // 自定义列相关的信息
      customStore: {
        btnEl: null,
        isAll: false,
        isIndeterminate: false,
        activeBtn: false,
        activeWrapper: false,
        visible: false,
        maxHeight: 0,
        oldSortMaps: {},
        oldFixedMaps: {},
        oldVisibleMaps: {}
      },
      customColumnList: [],
      // 当前选中的筛选列
      filterStore: {
        isAllSelected: false,
        isIndeterminate: false,
        style: null,
        column: null,
        visible: false,
        maxHeight: null
      },
      // 存放列相关的信息
      columnStore: {
        leftList: [],
        centerList: [],
        rightList: [],
        resizeList: [],
        pxList: [],
        pxMinList: [],
        autoMinList: [],
        scaleList: [],
        scaleMinList: [],
        autoList: [],
        remainList: []
      },
      // 存放快捷菜单的信息
      ctxMenuStore: {
        selected: null,
        visible: false,
        showChild: false,
        selectChild: null,
        list: [],
        style: null
      },
      // 存放可编辑相关信息
      editStore: {
        indexs: {
          columns: []
        },
        titles: {
          columns: []
        },
        // 选中源
        selected: {
          row: null,
          column: null
        },
        // 已复制源
        copyed: {
          cut: false,
          rows: [],
          columns: []
        },
        // 激活
        actived: {
          row: null,
          column: null
        },
        // 当前被强制聚焦单元格，只会在鼠标点击后算聚焦
        focused: {
          row: null,
          column: null
        }
      },
      // 存放 tooltip 相关信息
      tooltipStore: {
        row: null,
        column: null,
        content: null,
        visible: false,
        type: null,
        currOpts: {}
      },
      // 存放数据校验相关信息
      validStore: {
        visible: false
      },
      validErrorMaps: {},
      // 导入相关信息
      importStore: {
        inited: false,
        file: null,
        type: "",
        modeList: [],
        typeList: [],
        filename: "",
        visible: false
      },
      importParams: {
        mode: "",
        types: null,
        message: true
      },
      // 导出相关信息
      exportStore: {
        inited: false,
        name: "",
        modeList: [],
        typeList: [],
        columns: [],
        isPrint: false,
        hasFooter: false,
        hasMerge: false,
        hasTree: false,
        hasColgroup: false,
        visible: false
      },
      exportParams: {
        filename: "",
        sheetName: "",
        mode: "",
        type: "",
        isColgroup: false,
        isMerge: false,
        isAllExpand: false,
        useStyle: false,
        original: false,
        message: true,
        isHeader: false,
        isTitle: false,
        isFooter: false
      },
      visiblwRowsFlag: 1,
      isRowGroupStatus: false,
      rowGroupList: [],
      aggHandleFields: [],
      aggHandleAggColumns: [],
      rowGroupExpandedFlag: 1,
      rowExpandedFlag: 1,
      treeExpandedFlag: 1,
      updateCheckboxFlag: 1,
      pendingRowFlag: 1,
      insertRowFlag: 1,
      removeRowFlag: 1,
      mergeHeadFlag: 1,
      mergeBodyFlag: 1,
      mergeFootFlag: 1,
      rowHeightStore: {
        large: 52,
        default: 48,
        medium: 44,
        small: 40,
        mini: 36
      },
      scrollVMLoading: false,
      scrollYHeight: 0,
      scrollYTop: 0,
      isScrollYBig: false,
      scrollXLeft: 0,
      scrollXWidth: 0,
      isScrollXBig: false,
      lazScrollLoading: false,
      rowExpandHeightFlag: 1,
      calcCellHeightFlag: 1,
      resizeHeightFlag: 1,
      resizeWidthFlag: 1,
      isCustomStatus: false,
      isCrossDragRow: false,
      dragRow: null,
      isCrossDragCol: false,
      dragCol: null,
      dragTipText: "",
      isDragResize: false,
      isRowLoading: false,
      isColLoading: false
    });
    const internalData = createInternalData();
    let tableMethods = {};
    let tablePrivateMethods = {};
    const refElem = ref();
    const refVarElem = ref();
    const refTooltip = ref();
    const refCommTooltip = ref();
    const refValidTooltip = ref();
    const refTableMenu = ref();
    const refTableFilter = ref();
    const refTableCustom = ref();
    const refTableViewportElem = ref();
    const refTableHeader = ref();
    const refTableBody = ref();
    const refTableFooter = ref();
    const refTableLeftHeader = ref();
    const refTableLeftBody = ref();
    const refTableLeftFooter = ref();
    const refTableRightHeader = ref();
    const refTableRightBody = ref();
    const refTableRightFooter = ref();
    const refTeleportWrapper = ref();
    const refPopupWrapperElem = ref();
    const refLeftContainer = ref();
    const refRightContainer = ref();
    const refColResizeBar = ref();
    const refRowResizeBar = ref();
    const refEmptyPlaceholder = ref();
    const refDragTipElem = ref();
    const refDragRowLineElem = ref();
    const refDragColLineElem = ref();
    const refRowExpandElem = ref();
    const refRowExpandYSpaceElem = ref();
    const refScrollXVirtualElem = ref();
    const refScrollYVirtualElem = ref();
    const refScrollXHandleElem = ref();
    const refScrollXLeftCornerElem = ref();
    const refScrollXRightCornerElem = ref();
    const refScrollYHandleElem = ref();
    const refScrollYTopCornerElem = ref();
    const refScrollXWrapperElem = ref();
    const refScrollYWrapperElem = ref();
    const refScrollYBottomCornerElem = ref();
    const refScrollXSpaceElem = ref();
    const refScrollYSpaceElem = ref();
    let $xeToolbar;
    const computeTableId = computed(() => {
      const { id } = props;
      if (id) {
        if (import_xe_utils18.default.isFunction(id)) {
          return `${id({ $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt }) || ""}`;
        }
        return `${id}`;
      }
      return "";
    });
    const computeRowField = computed(() => {
      const rowOpts = computeRowOpts.value;
      return `${props.rowId || rowOpts.keyField || "_X_ROW_KEY"}`;
    });
    const computeValidOpts = computed(() => {
      return Object.assign({}, getConfig5().table.validConfig, props.validConfig);
    });
    const computeSXOpts = computed(() => {
      const virtualXOpts = computeVirtualXOpts.value;
      return virtualXOpts;
    });
    const computeScrollXThreshold = computed(() => {
      const virtualXOpts = computeVirtualXOpts.value;
      const { threshold } = virtualXOpts;
      if (threshold) {
        return import_xe_utils18.default.toNumber(threshold);
      }
      return 0;
    });
    const computeSYOpts = computed(() => {
      const virtualYOpts = computeVirtualYOpts.value;
      return virtualYOpts;
    });
    const computeVirtualXOpts = computed(() => {
      const { virtualXConfig, scrollX } = props;
      const globalVirtualXConfig = getConfig5().table.virtualXConfig;
      const globalScrollX = getConfig5().table.scrollX;
      if (virtualXConfig) {
        return Object.assign({}, globalVirtualXConfig, virtualXConfig);
      }
      if (scrollX) {
        return Object.assign({}, globalScrollX, scrollX);
      }
      if (globalVirtualXConfig) {
        return Object.assign({}, globalVirtualXConfig, virtualXConfig);
      }
      return Object.assign({}, globalScrollX, scrollX);
    });
    const computeVirtualYOpts = computed(() => {
      const { virtualYConfig, scrollY } = props;
      const globalVirtualYConfig = getConfig5().table.virtualYConfig;
      const globalScrollY = getConfig5().table.scrollY;
      if (virtualYConfig) {
        return Object.assign({}, globalVirtualYConfig, virtualYConfig);
      }
      if (scrollY) {
        return Object.assign({}, globalScrollY, scrollY);
      }
      if (globalVirtualYConfig) {
        return Object.assign({}, globalVirtualYConfig, virtualYConfig);
      }
      return Object.assign({}, globalScrollY, scrollY);
    });
    const computeScrollbarOpts = computed(() => {
      return Object.assign({}, getConfig5().table.scrollbarConfig, props.scrollbarConfig);
    });
    const computeScrollbarXOpts = computed(() => {
      var _a;
      const scrollbarOpts = computeScrollbarOpts.value;
      return Object.assign({}, scrollbarOpts.x, ((_a = props.scrollbarConfig) === null || _a === void 0 ? void 0 : _a.x) || {});
    });
    const computeScrollbarYOpts = computed(() => {
      var _a;
      const scrollbarOpts = computeScrollbarOpts.value;
      return Object.assign({}, scrollbarOpts.y, ((_a = props.scrollbarConfig) === null || _a === void 0 ? void 0 : _a.y) || {});
    });
    const computeScrollbarXToTop = computed(() => {
      const scrollbarXOpts = computeScrollbarXOpts.value;
      return scrollbarXOpts.position === "top";
    });
    const computeScrollbarYToLeft = computed(() => {
      const scrollbarYOpts = computeScrollbarYOpts.value;
      return scrollbarYOpts.position === "left";
    });
    const computeScrollYThreshold = computed(() => {
      const virtualYOpts = computeVirtualYOpts.value;
      const { threshold } = virtualYOpts;
      if (threshold) {
        return import_xe_utils18.default.toNumber(threshold);
      }
      return 0;
    });
    const computeRowHeightMaps = computed(() => {
      return reactData.rowHeightStore;
    });
    const computeDefaultRowHeight = computed(() => {
      const vSize = computeSize.value;
      const rowHeightMaps = computeRowHeightMaps.value;
      return rowHeightMaps[vSize || "default"] || 18;
    });
    const computeColumnOpts = computed(() => {
      return Object.assign({}, getConfig5().table.columnConfig, props.columnConfig);
    });
    const computeCurrentColumnOpts = computed(() => {
      return Object.assign({}, getConfig5().table.currentColumnConfig, props.currentColumnConfig);
    });
    const computeCellOpts = computed(() => {
      const cellOpts = Object.assign({}, getConfig5().table.cellConfig, props.cellConfig);
      if (cellOpts.height) {
        cellOpts.height = import_xe_utils18.default.toNumber(cellOpts.height);
      }
      return cellOpts;
    });
    const computeHeaderCellOpts = computed(() => {
      const headerCellOpts = Object.assign({}, getConfig5().table.headerCellConfig, props.headerCellConfig);
      const defaultRowHeight = computeDefaultRowHeight.value;
      const cellOpts = computeCellOpts.value;
      let headCellHeight = import_xe_utils18.default.toNumber(getCalcHeight(headerCellOpts.height || cellOpts.height));
      if ($xeGantt) {
        const { computeTaskScaleConfs } = $xeGantt.getComputeMaps();
        const taskScaleConfs = computeTaskScaleConfs.value;
        if (taskScaleConfs && taskScaleConfs.length > 2) {
          const ganttMinHeadCellHeight = defaultRowHeight / 2 * taskScaleConfs.length;
          headCellHeight = Math.max(ganttMinHeadCellHeight, headCellHeight);
        }
      }
      headerCellOpts.height = headCellHeight;
      return headerCellOpts;
    });
    const computeFooterCellOpts = computed(() => {
      const footerCellOpts = Object.assign({}, getConfig5().table.footerCellConfig, props.footerCellConfig);
      const cellOpts = computeCellOpts.value;
      footerCellOpts.height = import_xe_utils18.default.toNumber(getCalcHeight(footerCellOpts.height || cellOpts.height));
      return footerCellOpts;
    });
    const computeRowOpts = computed(() => {
      return Object.assign({}, getConfig5().table.rowConfig, props.rowConfig);
    });
    const computeAggregateOpts = computed(() => {
      return Object.assign({}, getConfig5().table.aggregateConfig || getConfig5().table.rowGroupConfig, props.aggregateConfig || props.rowGroupConfig);
    });
    const computeRowGroupOpts = computed(() => {
      return computeAggregateOpts.value;
    });
    const computeCurrentRowOpts = computed(() => {
      return Object.assign({}, getConfig5().table.currentRowConfig, props.currentRowConfig);
    });
    const computeRowDragOpts = computed(() => {
      return Object.assign({}, getConfig5().table.rowDragConfig, props.rowDragConfig);
    });
    const computeColumnDragOpts = computed(() => {
      return Object.assign({}, getConfig5().table.columnDragConfig, props.columnDragConfig);
    });
    const computeResizeOpts = computed(() => {
      return Object.assign({}, getConfig5().table.resizeConfig, props.resizeConfig);
    });
    const computeResizableOpts = computed(() => {
      return Object.assign({}, getConfig5().table.resizableConfig, props.resizableConfig);
    });
    const computeSeqOpts = computed(() => {
      return Object.assign({ startIndex: 0 }, getConfig5().table.seqConfig, props.seqConfig);
    });
    const computeRadioOpts = computed(() => {
      return Object.assign({}, getConfig5().table.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = computed(() => {
      return Object.assign({}, getConfig5().table.checkboxConfig, props.checkboxConfig);
    });
    const computeTooltipOpts = computed(() => {
      return Object.assign({}, getConfig5().tooltip, getConfig5().table.tooltipConfig, props.tooltipConfig);
    });
    const computeHeaderTooltipOpts = computed(() => {
      return Object.assign({}, getConfig5().tooltip, getConfig5().table.headerTooltipConfig, props.headerTooltipConfig);
    });
    const computeFooterTooltipOpts = computed(() => {
      return Object.assign({}, getConfig5().tooltip, getConfig5().table.footerTooltipConfig, props.footerTooltipConfig);
    });
    const computeTableTipConfig = computed(() => {
      const { tooltipStore } = reactData;
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({}, tooltipOpts, tooltipStore.currOpts);
    });
    const computeValidTipConfig = computed(() => {
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({}, tooltipOpts);
    });
    const computeEditOpts = computed(() => {
      return Object.assign({}, getConfig5().table.editConfig, props.editConfig);
    });
    const computeSortOpts = computed(() => {
      return Object.assign({ orders: ["asc", "desc", null] }, getConfig5().table.sortConfig, props.sortConfig);
    });
    const computeFilterOpts = computed(() => {
      return Object.assign({}, getConfig5().table.filterConfig, props.filterConfig);
    });
    const computeFloatingFilterOpts = computed(() => {
      return Object.assign({}, getConfig5().table.floatingFilterConfig, props.floatingFilterConfig);
    });
    const computeMouseOpts = computed(() => {
      return Object.assign({}, getConfig5().table.mouseConfig, props.mouseConfig);
    });
    const computeAreaOpts = computed(() => {
      return Object.assign({}, getConfig5().table.areaConfig, props.areaConfig);
    });
    const computeKeyboardOpts = computed(() => {
      return Object.assign({}, getConfig5().table.keyboardConfig, props.keyboardConfig);
    });
    const computeClipOpts = computed(() => {
      return Object.assign({}, getConfig5().table.clipConfig, props.clipConfig);
    });
    const computeFNROpts = computed(() => {
      const fnrOpts = computeFnrOpts.value;
      return fnrOpts;
    });
    const computeFnrOpts = computed(() => {
      return Object.assign({}, getConfig5().table.fnrConfig, props.fnrConfig);
    });
    const computeMenuOpts = computed(() => {
      return Object.assign({}, getConfig5().table.menuConfig, props.menuConfig);
    });
    const computeLeftFixedWidth = computed(() => {
      const { columnStore } = reactData;
      const { leftList } = columnStore;
      let leftWidth = 0;
      for (let i = 0; i < leftList.length; i++) {
        const column = leftList[i];
        leftWidth += column.renderWidth;
      }
      return leftWidth;
    });
    const computeRightFixedWidth = computed(() => {
      const { columnStore } = reactData;
      const { rightList } = columnStore;
      let leftWidth = 0;
      for (let i = 0; i < rightList.length; i++) {
        const column = rightList[i];
        leftWidth += column.renderWidth;
      }
      return leftWidth;
    });
    const computeBodyMergeCoverFixed = computed(() => {
      const { columnStore, mergeBodyFlag } = reactData;
      const { mergeBodyList, visibleColumn } = internalData;
      const { leftList, rightList } = columnStore;
      const rscIndex = visibleColumn.length - rightList.length;
      if (mergeBodyFlag && (leftList.length || rightList.length)) {
        const lecIndex = leftList.length;
        for (let i = 0; i < mergeBodyList.length; i++) {
          const { col, colspan } = mergeBodyList[i];
          if (col < lecIndex || col + colspan > rscIndex) {
            return true;
          }
        }
      }
      return false;
    });
    const computeIsHeaderRenderOptimize = computed(() => {
      const { spanMethod, footerSpanMethod, showHeaderOverflow: allColumnHeaderOverflow } = props;
      const { isGroup, scrollXLoad } = reactData;
      let isOptimizeMode = false;
      if (isGroup) {
      } else {
        if (scrollXLoad && allColumnHeaderOverflow) {
          if (spanMethod || footerSpanMethod) {
          } else {
            isOptimizeMode = true;
          }
        }
      }
      return isOptimizeMode;
    });
    const computeIsBodyRenderOptimize = computed(() => {
      const { spanMethod, footerSpanMethod } = props;
      const { scrollXLoad, scrollYLoad, isAllOverflow, expandColumn } = reactData;
      const bodyMergeCoverFixed = computeBodyMergeCoverFixed.value;
      const expandOpts = computeExpandOpts.value;
      let isOptimizeMode = false;
      if (scrollXLoad || scrollYLoad || isAllOverflow) {
        if (expandColumn && expandOpts.mode !== "fixed" || bodyMergeCoverFixed || spanMethod || footerSpanMethod) {
        } else {
          isOptimizeMode = true;
        }
      }
      return isOptimizeMode;
    });
    const computeIsFooterRenderOptimize = computed(() => {
      const { spanMethod, footerSpanMethod, showFooterOverflow: allColumnFooterOverflow } = props;
      const { scrollXLoad } = reactData;
      let isOptimizeMode = false;
      if (scrollXLoad && allColumnFooterOverflow) {
        if (spanMethod || footerSpanMethod) {
        } else {
          isOptimizeMode = true;
        }
      }
      return isOptimizeMode;
    });
    const computeHeaderMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerOpts = menuOpts.header;
      return headerOpts && headerOpts.options ? headerOpts.options : [];
    });
    const computeBodyMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const bodyOpts = menuOpts.body;
      return bodyOpts && bodyOpts.options ? bodyOpts.options : [];
    });
    const computeFooterMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const footerOpts = menuOpts.footer;
      return footerOpts && footerOpts.options ? footerOpts.options : [];
    });
    const computeIsMenu = computed(() => {
      const isContentMenu = computeIsContentMenu.value;
      return isContentMenu;
    });
    const computeIsContentMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerMenu = computeHeaderMenu.value;
      const bodyMenu = computeBodyMenu.value;
      const footerMenu = computeFooterMenu.value;
      return !!(props.menuConfig && isEnableConf(menuOpts) && (headerMenu.length || bodyMenu.length || footerMenu.length));
    });
    const computeMenuList = computed(() => {
      const { ctxMenuStore } = reactData;
      const rest = [];
      ctxMenuStore.list.forEach((list) => {
        list.forEach((item) => {
          rest.push(item);
        });
      });
      return rest;
    });
    const computeExportOpts = computed(() => {
      return Object.assign({}, getConfig5().table.exportConfig, props.exportConfig);
    });
    const computeImportOpts = computed(() => {
      return Object.assign({}, getConfig5().table.importConfig, props.importConfig);
    });
    const computePrintOpts = computed(() => {
      return Object.assign({}, getConfig5().table.printConfig, props.printConfig);
    });
    const computeExpandOpts = computed(() => {
      return Object.assign({}, getConfig5().table.expandConfig, props.expandConfig);
    });
    const computeTreeOpts = computed(() => {
      return Object.assign({}, getConfig5().table.treeConfig, props.treeConfig);
    });
    const computeEmptyOpts = computed(() => {
      return Object.assign({}, getConfig5().table.emptyRender, props.emptyRender);
    });
    const computeLoadingOpts = computed(() => {
      return Object.assign({}, getConfig5().table.loadingConfig, props.loadingConfig);
    });
    const computeCellOffsetWidth = computed(() => {
      return props.border ? Math.max(2, Math.ceil(reactData.scrollbarWidth / reactData.tableColumn.length)) : 1;
    });
    const computeCustomOpts = computed(() => {
      return Object.assign({}, getConfig5().table.customConfig, props.customConfig);
    });
    const computeTableRowExpandedList = computed(() => {
      const { tableData, rowExpandedFlag, expandColumn, rowGroupExpandedFlag, treeExpandedFlag } = reactData;
      const { visibleDataRowIdData, rowExpandedMaps } = internalData;
      const expandList = [];
      if (tableData.length && expandColumn && rowExpandedFlag && rowGroupExpandedFlag && treeExpandedFlag) {
        import_xe_utils18.default.each(rowExpandedMaps, (row, rowid) => {
          if (visibleDataRowIdData[rowid]) {
            expandList.push(row);
          }
        });
      }
      return expandList;
    });
    const computeAutoWidthColumnList = computed(() => {
      const { visibleColumn } = internalData;
      const { tableColumn } = reactData;
      return tableColumn.length || visibleColumn.length ? visibleColumn.filter((column) => column.width === "auto" || column.minWidth === "auto") : [];
    });
    const computeFixedColumnSize = computed(() => {
      const { tableColumn } = reactData;
      const { collectColumn } = internalData;
      let fixedSize = 0;
      if (tableColumn.length && collectColumn.length) {
        collectColumn.forEach((column) => {
          if (column.renderFixed) {
            fixedSize++;
          }
        });
      }
      return fixedSize;
    });
    const computeIsMaxFixedColumn = computed(() => {
      const fixedColumnSize = computeFixedColumnSize.value;
      const columnOpts = computeColumnOpts.value;
      const { maxFixedSize } = columnOpts;
      if (maxFixedSize) {
        return fixedColumnSize >= maxFixedSize;
      }
      return false;
    });
    const computeTableBorder = computed(() => {
      const { border } = props;
      if (border === true) {
        return "full";
      }
      if (border) {
        return border;
      }
      return "default";
    });
    const computeIsAllCheckboxDisabled = computed(() => {
      const { treeConfig } = props;
      const { tableData } = reactData;
      const { tableFullData } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const { strict, checkMethod } = checkboxOpts;
      if (strict) {
        if (tableData.length || tableFullData.length) {
          if (checkMethod) {
            if (treeConfig) {
            }
            return tableFullData.every((row) => !checkMethod({ $table: $xeTable, row }));
          }
          return false;
        }
        return true;
      }
      return false;
    });
    const computeVirtualScrollBars = computed(() => {
      const { overflowX, scrollXLoad, overflowY, scrollYLoad } = reactData;
      return {
        x: overflowX && scrollXLoad,
        y: overflowY && scrollYLoad
      };
    });
    const computeRowGroupFields = computed(() => {
      const rowGroupOpts = computeRowGroupOpts.value;
      return rowGroupOpts.groupFields;
    });
    const computeRowGroupColumns = computed(() => {
      const { rowGroupList } = reactData;
      const { fullColumnFieldData } = internalData;
      const rgColumns = [];
      rowGroupList.forEach((aggConf) => {
        const colRest = fullColumnFieldData[aggConf.field];
        if (colRest) {
          rgColumns.push(colRest.column);
        }
      });
      return rgColumns;
    });
    const refMaps = {
      refElem,
      refTooltip,
      refValidTooltip,
      refTableFilter,
      refTableCustom,
      refTableMenu,
      refTableHeader,
      refTableBody,
      refTableFooter,
      refTableLeftHeader,
      refTableLeftBody,
      refTableLeftFooter,
      refTableRightHeader,
      refTableRightBody,
      refTableRightFooter,
      refLeftContainer,
      refRightContainer,
      refColResizeBar,
      refRowResizeBar,
      refScrollXVirtualElem,
      refScrollYVirtualElem,
      refScrollXHandleElem,
      refScrollYHandleElem,
      refScrollXSpaceElem,
      refScrollYSpaceElem
    };
    const computeMaps = {
      computeSize,
      computeTableId,
      computeValidOpts,
      computeRowField,
      computeVirtualXOpts,
      computeVirtualYOpts,
      computeScrollbarOpts,
      computeScrollbarXOpts,
      computeScrollbarYOpts,
      computeScrollbarXToTop,
      computeScrollbarYToLeft,
      computeColumnOpts,
      computeCurrentColumnOpts,
      computeScrollXThreshold,
      computeScrollYThreshold,
      computeRowHeightMaps,
      computeDefaultRowHeight,
      computeCellOpts,
      computeHeaderCellOpts,
      computeFooterCellOpts,
      computeRowOpts,
      computeAggregateOpts,
      computeRowGroupOpts,
      computeCurrentRowOpts,
      computeRowDragOpts,
      computeColumnDragOpts,
      computeResizeOpts,
      computeResizableOpts,
      computeSeqOpts,
      computeRadioOpts,
      computeCheckboxOpts,
      computeTooltipOpts,
      computeHeaderTooltipOpts,
      computeFooterTooltipOpts,
      computeEditOpts,
      computeSortOpts,
      computeFilterOpts,
      computeFloatingFilterOpts,
      computeMouseOpts,
      computeAreaOpts,
      computeKeyboardOpts,
      computeClipOpts,
      computeFnrOpts,
      computeHeaderMenu,
      computeBodyMenu,
      computeFooterMenu,
      computeIsMenu,
      computeIsContentMenu,
      computeMenuList,
      computeMenuOpts,
      computeExportOpts,
      computeImportOpts,
      computePrintOpts,
      computeExpandOpts,
      computeTreeOpts,
      computeEmptyOpts,
      computeLoadingOpts,
      computeCellOffsetWidth,
      computeCustomOpts,
      computeLeftFixedWidth,
      computeRightFixedWidth,
      computeBodyMergeCoverFixed,
      computeFixedColumnSize,
      computeIsMaxFixedColumn,
      computeIsAllCheckboxDisabled,
      computeIsHeaderRenderOptimize,
      computeIsBodyRenderOptimize,
      computeIsFooterRenderOptimize,
      computeVirtualScrollBars,
      computeRowGroupFields,
      computeRowGroupColumns,
      computeFNROpts,
      computeSXOpts,
      computeSYOpts
    };
    const $xeTable = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps,
      xeGrid: $xeGrid,
      xeGantt: $xeGantt,
      // 已废弃
      xegrid: $xeGrid
    };
    const eqCellValue = (row1, row2, field) => {
      const val1 = import_xe_utils18.default.get(row1, field);
      const val2 = import_xe_utils18.default.get(row2, field);
      if (eqEmptyValue(val1) && eqEmptyValue(val2)) {
        return true;
      }
      if (import_xe_utils18.default.isString(val1) || import_xe_utils18.default.isNumber(val1)) {
        return "" + val1 === "" + val2;
      }
      return import_xe_utils18.default.isEqual(val1, val2);
    };
    const handleKeyField = () => {
      const keyField = computeRowField.value;
      internalData.currKeyField = keyField;
      internalData.isCurrDeepKey = hasDeepKey(keyField);
    };
    const hangleStorageDefaultValue = (value, isAll) => {
      return import_xe_utils18.default.isBoolean(value) ? value : isAll;
    };
    const getNextSortOrder = (column) => {
      const sortOpts = computeSortOpts.value;
      const { orders = [] } = sortOpts;
      const currOrder = column.order || null;
      const oIndex = orders.indexOf(currOrder) + 1;
      return orders[oIndex < orders.length ? oIndex : 0];
    };
    const getCustomStorageMap = (id) => {
      const version = getConfig5().version;
      const rest = import_xe_utils18.default.toStringJSON(localStorage.getItem(customStorageKey) || "");
      const maps = rest && rest._v === version ? rest : { _v: version };
      return (id ? maps[id] : maps) || {};
    };
    const setCustomStorageMap = (id, data) => {
      const version = getConfig5().version;
      const maps = getCustomStorageMap();
      maps[id] = data || void 0;
      maps._v = version;
      localStorage.setItem(customStorageKey, import_xe_utils18.default.toJSONString(maps));
    };
    const getRecoverRowMaps = (keyMaps) => {
      const { fullAllDataRowIdData } = internalData;
      const restKeys = {};
      import_xe_utils18.default.each(keyMaps, (row, rowid) => {
        if (fullAllDataRowIdData[rowid]) {
          restKeys[rowid] = row;
        }
      });
      return restKeys;
    };
    const handleReserveRow = (reserveRowMap) => {
      const { fullDataRowIdData } = internalData;
      const reserveList = [];
      import_xe_utils18.default.each(reserveRowMap, (item, rowid) => {
        if (fullDataRowIdData[rowid] && $xeTable.findRowIndexOf(reserveList, fullDataRowIdData[rowid].row) === -1) {
          reserveList.push(fullDataRowIdData[rowid].row);
        }
      });
      return reserveList;
    };
    const handleVirtualXVisible = () => {
      const { isScrollXBig, scrollXWidth } = reactData;
      const { elemStore, visibleColumn, fullColumnIdData } = internalData;
      const leftFixedWidth = computeLeftFixedWidth.value;
      const rightFixedWidth = computeRightFixedWidth.value;
      const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
      if (bodyScrollElem) {
        const clientWidth = bodyScrollElem.clientWidth;
        let scrollLeft = bodyScrollElem.scrollLeft;
        if (isScrollXBig) {
          scrollLeft = Math.ceil((scrollXWidth - clientWidth) * Math.min(1, scrollLeft / (maxXWidth - clientWidth)));
        }
        const startLeft = scrollLeft + leftFixedWidth;
        const endLeft = scrollLeft + clientWidth - rightFixedWidth;
        let leftIndex = 0;
        let rightIndex = visibleColumn.length;
        while (leftIndex < rightIndex) {
          const cIndex = Math.floor((leftIndex + rightIndex) / 2);
          const column = visibleColumn[cIndex];
          const colid = column.id;
          const colRest = fullColumnIdData[colid] || {};
          if (colRest.oLeft <= startLeft) {
            leftIndex = cIndex + 1;
          } else {
            rightIndex = cIndex;
          }
        }
        let visibleSize = 0;
        const toVisibleIndex = leftIndex === visibleColumn.length ? leftIndex : Math.max(0, leftIndex < visibleColumn.length ? leftIndex - 2 : 0);
        for (let cIndex = toVisibleIndex, cLen = visibleColumn.length; cIndex < cLen; cIndex++) {
          const column = visibleColumn[cIndex];
          const colid = column.id;
          const colRest = fullColumnIdData[colid] || {};
          visibleSize++;
          if (colRest.oLeft > endLeft || visibleSize >= 60) {
            break;
          }
        }
        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(1, visibleSize) };
      }
      return { toVisibleIndex: 0, visibleSize: 6 };
    };
    const calcVarRowHeightConfig = (sizeKey, sizeEl) => {
      const { rowHeightStore } = reactData;
      if (sizeEl && sizeEl.clientHeight) {
        rowHeightStore[sizeKey] = sizeEl.clientHeight;
      }
    };
    const computeRowHeight = () => {
      const { isAllOverflow } = reactData;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      const defaultRowHeight = computeDefaultRowHeight.value;
      let rowHeight = 0;
      if (isAllOverflow) {
        if (tableBodyElem) {
          const tableHeaderElem = tableHeader ? tableHeader.$el : null;
          let firstTrElem;
          firstTrElem = tableBodyElem.querySelector("tr");
          if (!firstTrElem && tableHeaderElem) {
            firstTrElem = tableHeaderElem.querySelector("tr");
          }
          if (firstTrElem) {
            rowHeight = firstTrElem.clientHeight;
          }
        }
        if (!rowHeight) {
          rowHeight = defaultRowHeight;
        }
      } else {
        rowHeight = defaultRowHeight;
      }
      return Math.max(18, rowHeight);
    };
    const handleVirtualYVisible = () => {
      const { isAllOverflow, expandColumn, isScrollYBig, scrollYHeight } = reactData;
      const { elemStore, isResizeCellHeight, afterFullData, fullAllDataRowIdData } = internalData;
      const rowOpts = computeRowOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
      if (bodyScrollElem) {
        const clientHeight = bodyScrollElem.clientHeight;
        let scrollTop = bodyScrollElem.scrollTop;
        if (isScrollYBig) {
          scrollTop = Math.ceil((scrollYHeight - clientHeight) * Math.min(1, scrollTop / (maxYHeight - clientHeight)));
        }
        const startTop = scrollTop;
        const endTop = scrollTop + clientHeight;
        let toVisibleIndex = -1;
        let visibleSize = 0;
        const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
        if (!isCustomCellHeight && !expandColumn && isAllOverflow) {
          toVisibleIndex = Math.floor(startTop / defaultRowHeight) - 1;
          visibleSize = Math.ceil(clientHeight / defaultRowHeight) + 1;
        } else {
          const { handleGetRowId } = createHandleGetRowId($xeTable);
          let leftIndex = 0;
          let rightIndex = afterFullData.length;
          while (leftIndex < rightIndex) {
            const rIndex = Math.floor((leftIndex + rightIndex) / 2);
            const row = afterFullData[rIndex];
            const rowid = handleGetRowId(row);
            const rowRest = fullAllDataRowIdData[rowid] || {};
            if (rowRest.oTop <= startTop) {
              leftIndex = rIndex + 1;
            } else {
              rightIndex = rIndex;
            }
          }
          toVisibleIndex = leftIndex === afterFullData.length ? leftIndex : Math.max(0, leftIndex < afterFullData.length ? leftIndex - 2 : 0);
          for (let rIndex = toVisibleIndex, rLen = afterFullData.length; rIndex < rLen; rIndex++) {
            const row = afterFullData[rIndex];
            const rowid = handleGetRowId(row);
            const rowRest = fullAllDataRowIdData[rowid] || {};
            visibleSize++;
            if (rowRest.oTop > endTop || visibleSize >= 100) {
              break;
            }
          }
        }
        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(6, visibleSize) };
      }
      return { toVisibleIndex: 0, visibleSize: 6 };
    };
    const calculateMergerOffsetIndex = (list, offsetItem, type) => {
      for (let mcIndex = 0, len = list.length; mcIndex < len; mcIndex++) {
        const mergeItem = list[mcIndex];
        const { startIndex, endIndex } = offsetItem;
        const mergeStartIndex = mergeItem[type];
        const mergeSpanNumber = mergeItem[type + "span"];
        const mergeEndIndex = mergeStartIndex + mergeSpanNumber;
        if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {
          offsetItem.startIndex = mergeStartIndex;
        }
        if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {
          offsetItem.endIndex = mergeEndIndex;
        }
        if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {
          mcIndex = -1;
        }
      }
    };
    function buildMergeData(mergeConfigs) {
      const mergeMaps = {};
      if (mergeConfigs && mergeConfigs.length) {
        for (let mIndex = 0; mIndex < mergeConfigs.length; mIndex++) {
          const { row: _rowIndex, col: _columnIndex, rowspan: mergeRowspan, colspan: mergeColspan } = mergeConfigs[mIndex];
          for (let i = 0; i < mergeRowspan; i++) {
            for (let j = 0; j < mergeColspan; j++) {
              mergeMaps[`${_rowIndex + i}:${_columnIndex + j}`] = !i && !j ? {
                rowspan: mergeRowspan,
                colspan: mergeColspan
              } : {
                rowspan: 0,
                colspan: 0
              };
            }
          }
        }
      }
      return mergeMaps;
    }
    const handleUpdateMergeBodyCells = (merges) => {
      internalData.mergeBodyList = [];
      internalData.mergeBodyMaps = {};
      internalData.mergeBodyCellMaps = {};
      $xeTable.setMergeCells(merges);
    };
    const handleBodyMerge = (merges) => {
      const { fullAllDataRowIdData, fullColumnIdData, visibleColumn, afterFullData, mergeBodyList, mergeBodyMaps } = internalData;
      if (merges) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        if (!import_xe_utils18.default.isArray(merges)) {
          merges = [merges];
        }
        merges.forEach((item) => {
          let { row: margeRow, col: margeCol, rowspan, colspan } = item;
          let mergeRowIndex = -1;
          let mergeColumnIndex = -1;
          if (import_xe_utils18.default.isNumber(margeRow)) {
            mergeRowIndex = margeRow;
          } else {
            const rowid = margeRow ? handleGetRowId(margeRow) : null;
            const rowRest = rowid ? fullAllDataRowIdData[rowid] : null;
            if (rowRest) {
              mergeRowIndex = rowRest._index;
            }
          }
          if (import_xe_utils18.default.isNumber(margeCol)) {
            mergeColumnIndex = margeCol;
          } else {
            const colid = margeCol ? margeCol.id : null;
            const colRest = colid ? fullColumnIdData[colid] : null;
            if (colRest) {
              mergeColumnIndex = colRest._index;
            }
          }
          if (mergeRowIndex > -1 && mergeColumnIndex > -1 && (rowspan || colspan)) {
            rowspan = import_xe_utils18.default.toNumber(rowspan) || 1;
            colspan = import_xe_utils18.default.toNumber(colspan) || 1;
            if (rowspan > 1 || colspan > 1) {
              const row = afterFullData[mergeRowIndex];
              const column = visibleColumn[mergeColumnIndex];
              let mergeItem = mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`];
              if (mergeItem) {
                mergeItem.rowspan = rowspan;
                mergeItem.colspan = colspan;
                mergeItem._rowspan = rowspan;
                mergeItem._colspan = colspan;
              } else {
                mergeItem = {
                  row: mergeRowIndex,
                  col: mergeColumnIndex,
                  rowspan,
                  colspan,
                  _row: row,
                  _col: column,
                  _rowspan: rowspan,
                  _colspan: colspan
                };
                mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`] = mergeItem;
                mergeBodyList.push(mergeItem);
              }
            }
          }
        });
      }
    };
    const removeBodyMerges = (merges) => {
      const { mergeBodyList, fullColumnIdData, fullAllDataRowIdData, mergeBodyMaps } = internalData;
      const rest = [];
      if (merges) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        if (!import_xe_utils18.default.isArray(merges)) {
          merges = [merges];
        }
        merges.forEach((item) => {
          const { row: margeRow, col: margeCol } = item;
          let mergeRowIndex = -1;
          let mergeColumnIndex = -1;
          if (import_xe_utils18.default.isNumber(margeRow)) {
            mergeRowIndex = margeRow;
          } else {
            const rowid = margeRow ? handleGetRowId(margeRow) : null;
            const rowRest = rowid ? fullAllDataRowIdData[rowid] : null;
            if (rowRest) {
              mergeRowIndex = rowRest._index;
            }
          }
          if (import_xe_utils18.default.isNumber(margeCol)) {
            mergeColumnIndex = margeCol;
          } else {
            const colid = margeCol ? margeCol.id : null;
            const colRest = colid ? fullColumnIdData[colid] : null;
            if (colRest) {
              mergeColumnIndex = colRest._index;
            }
          }
          const mcIndex = import_xe_utils18.default.findIndexOf(mergeBodyList, (item2) => item2.row === mergeRowIndex && item2.col === mergeColumnIndex);
          if (mcIndex > -1) {
            const rItems = mergeBodyList.splice(mcIndex, 1);
            const item2 = rItems[0];
            if (item2) {
              rest.push(rItems[0]);
              if (mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`]) {
                delete mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`];
              }
            }
          }
        });
      }
      return rest;
    };
    const handleUpdateMergeHeaderCells = (merges) => {
      internalData.mergeHeaderList = [];
      internalData.mergeHeaderMaps = {};
      internalData.mergeHeaderCellMaps = {};
      $xeTable.setMergeHeaderCells(merges);
    };
    const handleHeaderMerge = (merges) => {
      const { showCustomHeader } = props;
      const { footerTableData } = reactData;
      const { mergeHeaderList, mergeHeaderMaps, fullColumnIdData } = internalData;
      if (merges) {
        const { visibleColumn } = internalData;
        if (!import_xe_utils18.default.isArray(merges)) {
          merges = [merges];
        }
        merges.forEach((item) => {
          let { row: margeRow, col: margeCol, rowspan, colspan } = item;
          const mergeRowIndex = import_xe_utils18.default.isNumber(margeRow) ? margeRow : -1;
          let mergeColumnIndex = -1;
          if (import_xe_utils18.default.isNumber(margeCol)) {
            mergeColumnIndex = margeCol;
          } else {
            const colid = margeCol ? margeCol.id : null;
            const colRest = colid ? fullColumnIdData[colid] : null;
            if (colRest) {
              mergeColumnIndex = colRest._index;
            }
          }
          if (mergeRowIndex > -1 && mergeColumnIndex > -1 && (rowspan || colspan)) {
            rowspan = import_xe_utils18.default.toNumber(rowspan) || 1;
            colspan = import_xe_utils18.default.toNumber(colspan) || 1;
            if (!showCustomHeader && rowspan > 1) {
              errLog("vxe.error.notSupportProp", ["[table] show-custom-header=false", `rowspan=${rowspan}`, "rowspan=1"]);
              return;
            }
            if (rowspan > 1 || colspan > 1) {
              const row = footerTableData[mergeRowIndex];
              const column = visibleColumn[mergeColumnIndex];
              let mergeItem = mergeHeaderMaps[`${mergeRowIndex}:${mergeColumnIndex}`];
              if (mergeItem) {
                mergeItem.rowspan = rowspan;
                mergeItem.colspan = colspan;
                mergeItem._rowspan = rowspan;
                mergeItem._colspan = colspan;
              } else {
                mergeItem = {
                  row: mergeRowIndex,
                  col: mergeColumnIndex,
                  rowspan,
                  colspan,
                  _row: row,
                  _col: column,
                  _rowspan: rowspan,
                  _colspan: colspan
                };
                mergeHeaderMaps[`${mergeRowIndex}:${mergeColumnIndex}`] = mergeItem;
                mergeHeaderList.push(mergeItem);
              }
            }
          }
        });
      }
    };
    const removeHeaderMerges = (merges) => {
      const { mergeHeaderList, fullColumnIdData, mergeHeaderMaps } = internalData;
      const rest = [];
      if (merges) {
        if (!import_xe_utils18.default.isArray(merges)) {
          merges = [merges];
        }
        merges.forEach((item) => {
          const { row: margeRow, col: margeCol } = item;
          const mergeRowIndex = import_xe_utils18.default.isNumber(margeRow) ? margeRow : -1;
          let mergeColumnIndex = -1;
          if (import_xe_utils18.default.isNumber(margeCol)) {
            mergeColumnIndex = margeCol;
          } else {
            const colid = margeCol ? margeCol.id : null;
            const colRest = colid ? fullColumnIdData[colid] : null;
            if (colRest) {
              mergeColumnIndex = colRest._index;
            }
          }
          const mcIndex = import_xe_utils18.default.findIndexOf(mergeHeaderList, (item2) => item2.row === mergeRowIndex && item2.col === mergeColumnIndex);
          if (mcIndex > -1) {
            const rItems = mergeHeaderList.splice(mcIndex, 1);
            const item2 = rItems[0];
            if (item2) {
              rest.push(item2);
              if (mergeHeaderMaps[`${mergeRowIndex}:${mergeColumnIndex}`]) {
                delete mergeHeaderMaps[`${mergeRowIndex}:${mergeColumnIndex}`];
              }
            }
          }
        });
      }
      return rest;
    };
    const handleUpdateMergeFooterCells = (merges) => {
      internalData.mergeFooterList = [];
      internalData.mergeFooterMaps = {};
      internalData.mergeFooterCellMaps = {};
      $xeTable.setMergeFooterCells(merges);
    };
    const handleFooterMerge = (merges) => {
      const { footerTableData } = reactData;
      const { mergeFooterList, mergeFooterMaps, fullColumnIdData } = internalData;
      if (merges) {
        const { visibleColumn } = internalData;
        if (!import_xe_utils18.default.isArray(merges)) {
          merges = [merges];
        }
        merges.forEach((item) => {
          let { row: margeRow, col: margeCol, rowspan, colspan } = item;
          const mergeRowIndex = import_xe_utils18.default.isNumber(margeRow) ? margeRow : -1;
          let mergeColumnIndex = -1;
          if (import_xe_utils18.default.isNumber(margeCol)) {
            mergeColumnIndex = margeCol;
          } else {
            const colid = margeCol ? margeCol.id : null;
            const colRest = colid ? fullColumnIdData[colid] : null;
            if (colRest) {
              mergeColumnIndex = colRest._index;
            }
          }
          if (mergeRowIndex > -1 && mergeColumnIndex > -1 && (rowspan || colspan)) {
            rowspan = import_xe_utils18.default.toNumber(rowspan) || 1;
            colspan = import_xe_utils18.default.toNumber(colspan) || 1;
            if (rowspan > 1 || colspan > 1) {
              const row = footerTableData[mergeRowIndex];
              const column = visibleColumn[mergeColumnIndex];
              let mergeItem = mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`];
              if (mergeItem) {
                mergeItem.rowspan = rowspan;
                mergeItem.colspan = colspan;
                mergeItem._rowspan = rowspan;
                mergeItem._colspan = colspan;
              } else {
                mergeItem = {
                  row: mergeRowIndex,
                  col: mergeColumnIndex,
                  rowspan,
                  colspan,
                  _row: row,
                  _col: column,
                  _rowspan: rowspan,
                  _colspan: colspan
                };
                mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`] = mergeItem;
                mergeFooterList.push(mergeItem);
              }
            }
          }
        });
      }
    };
    const removeFooterMerges = (merges) => {
      const { mergeFooterList, fullColumnIdData, mergeFooterMaps } = internalData;
      const rest = [];
      if (merges) {
        if (!import_xe_utils18.default.isArray(merges)) {
          merges = [merges];
        }
        merges.forEach((item) => {
          const { row: margeRow, col: margeCol } = item;
          const mergeRowIndex = import_xe_utils18.default.isNumber(margeRow) ? margeRow : -1;
          let mergeColumnIndex = -1;
          if (import_xe_utils18.default.isNumber(margeCol)) {
            mergeColumnIndex = margeCol;
          } else {
            const colid = margeCol ? margeCol.id : null;
            const colRest = colid ? fullColumnIdData[colid] : null;
            if (colRest) {
              mergeColumnIndex = colRest._index;
            }
          }
          const mcIndex = import_xe_utils18.default.findIndexOf(mergeFooterList, (item2) => item2.row === mergeRowIndex && item2.col === mergeColumnIndex);
          if (mcIndex > -1) {
            const rItems = mergeFooterList.splice(mcIndex, 1);
            const item2 = rItems[0];
            if (item2) {
              rest.push(item2);
              if (mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`]) {
                delete mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`];
              }
            }
          }
        });
      }
      return rest;
    };
    const handleSortEvent = (evnt, sortConfs, isUpdate) => {
      const { tableFullColumn } = internalData;
      const sortOpts = computeSortOpts.value;
      const { multiple, remote, orders } = sortOpts;
      if (!import_xe_utils18.default.isArray(sortConfs)) {
        sortConfs = [sortConfs];
      }
      if (sortConfs && sortConfs.length) {
        const orderActiveMaps = {};
        if (!multiple) {
          sortConfs = [sortConfs[0]];
          tableFullColumn.forEach((column) => {
            if (column.order) {
              orderActiveMaps[column.id] = column;
            }
          });
        }
        const sortColMpps = {};
        let firstColumn = null;
        sortConfs.forEach((confs, index) => {
          let { field, order } = confs;
          let column = field;
          if (import_xe_utils18.default.isString(field)) {
            column = $xeTable.getColumnByField(field);
          }
          if (!firstColumn) {
            firstColumn = column;
          }
          if (column && column.sortable) {
            if (orders && orders.indexOf(order) === -1) {
              order = getNextSortOrder(column);
            }
            if (column.order !== order) {
              column.order = order;
            }
            column.sortTime = Date.now() + index;
            sortColMpps[column.id] = column;
          }
        });
        if (!multiple) {
          import_xe_utils18.default.each(orderActiveMaps, (oaCol, oaId) => {
            if (!sortColMpps[oaId]) {
              oaCol.order = null;
            }
          });
        }
        if (isUpdate) {
          if (!remote) {
            $xeTable.handleTableData(true);
          }
        }
        if (evnt) {
          $xeTable.handleColumnSortEvent(evnt, firstColumn);
        }
        return nextTick().then(() => {
          updateRowOffsetTop();
          $xeTable.updateCellAreas();
          return updateStyle();
        });
      }
      return nextTick();
    };
    const clearAllSort = () => {
      const { tableFullColumn } = internalData;
      tableFullColumn.forEach((column) => {
        column.order = null;
      });
    };
    const calcTableHeight = (key) => {
      const { editConfig, editRules } = props;
      const { parentHeight } = reactData;
      let val = props[key];
      if (key === "minHeight") {
        const defMinHeight = getConfig5().table.minHeight;
        if (import_xe_utils18.default.eqNull(val)) {
          if (eqEmptyValue(defMinHeight)) {
            if (editRules && isEnableConf(editConfig)) {
              val = 144;
            }
          } else {
            val = defMinHeight;
          }
        }
      }
      let num = 0;
      if (val) {
        if (val === "100%" || val === "auto") {
          num = parentHeight;
        } else {
          const excludeHeight = $xeTable.getExcludeHeight();
          if (isScale(val)) {
            num = Math.floor((import_xe_utils18.default.toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = import_xe_utils18.default.toNumber(val);
          }
          num = Math.max(40, num - excludeHeight);
        }
      }
      return num;
    };
    const handleCustomRestore = (storeData) => {
      const { aggregateConfig, rowGroupConfig } = props;
      const { collectColumn } = internalData;
      const customOpts = computeCustomOpts.value;
      const { storage, storeOptions } = customOpts;
      const isAllCustom = storage === true;
      const storageOpts = Object.assign({}, isAllCustom ? {} : storage || {}, storeOptions);
      const isCustomResizable = hangleStorageDefaultValue(storageOpts.resizable, isAllCustom);
      const isCustomVisible = hangleStorageDefaultValue(storageOpts.visible, isAllCustom);
      const isCustomFixed = hangleStorageDefaultValue(storageOpts.fixed, isAllCustom);
      const isCustomSort = hangleStorageDefaultValue(storageOpts.sort, isAllCustom);
      const isCustomAggGroup = hangleStorageDefaultValue(storageOpts.aggGroup, isAllCustom);
      const isCustomAggFunc = hangleStorageDefaultValue(storageOpts.aggFunc, isAllCustom);
      let { resizableData, sortData, visibleData, fixedData, aggGroupData, aggFuncData } = storeData;
      if (isCustomResizable && resizableData || isCustomSort && sortData || isCustomVisible && visibleData || isCustomFixed && fixedData || isCustomAggGroup && aggGroupData || isCustomAggFunc && aggFuncData) {
        const sortColMaps = {};
        if (isCustomSort && sortData) {
          if (!import_xe_utils18.default.isArray(sortData)) {
            const sortRests = [];
            import_xe_utils18.default.each(sortData, (index, colKey) => {
              sortRests.push({ key: colKey, index });
            });
            sortData = import_xe_utils18.default.orderBy(sortRests, { field: "index", order: "asc" }).map((item) => ({ k: item.key }));
          }
          let colNum = 1;
          import_xe_utils18.default.eachTree(sortData, (sObj, index, sOjs, path, pSObj) => {
            sortColMaps[sObj.k] = {
              key: sObj.k,
              sNum: colNum++,
              pKey: pSObj ? pSObj.k : null
            };
          }, { children: "c" });
        }
        const colKeyMaps = {};
        const allCols = [];
        const aggGroupConfs = [];
        import_xe_utils18.default.eachTree(collectColumn, (column, index, items, path, parentColumn) => {
          const colKey = column.getKey();
          if (!parentColumn) {
            if (isCustomFixed && fixedData && fixedData[colKey] !== void 0) {
              column.fixed = fixedData[colKey];
            }
          }
          if (isCustomResizable && resizableData && import_xe_utils18.default.isNumber(resizableData[colKey])) {
            column.resizeWidth = resizableData[colKey];
          }
          if (isCustomVisible && visibleData && import_xe_utils18.default.isBoolean(visibleData[colKey])) {
            column.visible = visibleData[colKey];
          }
          if (isCustomAggFunc && aggFuncData && (aggregateConfig || rowGroupConfig) && aggFuncData[colKey]) {
            column.aggFunc = aggFuncData[colKey];
          }
          if (isCustomAggGroup && aggGroupData && aggGroupData[colKey]) {
            aggGroupConfs.push({ field: column.field });
          }
          colKeyMaps[colKey] = column;
          allCols.push(column);
        });
        if ((aggregateConfig || rowGroupConfig) && aggGroupConfs.length) {
          const groupRest = handleGroupData(internalData.tableFullData, aggGroupConfs);
          internalData.tableFullTreeData = [];
          internalData.tableFullGroupData = groupRest.treeData;
          reactData.isRowGroupStatus = true;
          reactData.rowGroupList = aggGroupConfs;
          $xeTable.cacheRowMap(false);
        }
        if (isCustomSort && sortData) {
          allCols.forEach((column) => {
            const colKey = column.getKey();
            const scItem = sortColMaps[colKey];
            if (scItem) {
              const parentColumn = scItem.pKey ? colKeyMaps[scItem.pKey] : null;
              column.parentId = parentColumn ? parentColumn.id : null;
              column.renderSortNumber = scItem.sNum;
            }
          });
          const newCollectCols = import_xe_utils18.default.toArrayTree(import_xe_utils18.default.orderBy(allCols, "renderSortNumber"), { key: "id", parentKey: "parentId", children: "children" });
          internalData.collectColumn = newCollectCols;
          internalData.tableFullColumn = getColumnList(newCollectCols);
        }
        reactData.isCustomStatus = true;
      } else {
        reactData.isCustomStatus = false;
      }
    };
    const restoreCustomStorage = () => {
      const { customConfig } = props;
      const tableId = computeTableId.value;
      const customOpts = computeCustomOpts.value;
      const { storage, restoreStore, storeOptions } = customOpts;
      const isAllCustom = storage === true;
      const storageOpts = Object.assign({}, isAllCustom ? {} : storage || {}, storeOptions);
      const isCustomResizable = hangleStorageDefaultValue(storageOpts.resizable, isAllCustom);
      const isCustomVisible = hangleStorageDefaultValue(storageOpts.visible, isAllCustom);
      const isCustomFixed = hangleStorageDefaultValue(storageOpts.fixed, isAllCustom);
      const isCustomSort = hangleStorageDefaultValue(storageOpts.sort, isAllCustom);
      const isCustomAggGroup = hangleStorageDefaultValue(storageOpts.aggGroup, isAllCustom);
      const isCustomAggFunc = hangleStorageDefaultValue(storageOpts.aggFunc, isAllCustom);
      if (storage && (customConfig ? isEnableConf(customOpts) : customOpts.enabled) && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort || isCustomAggGroup || isCustomAggFunc)) {
        if (!tableId) {
          errLog("vxe.error.reqProp", ["id"]);
          return;
        }
        const storeData = getCustomStorageMap(tableId);
        if (restoreStore) {
          return Promise.resolve(restoreStore({ $table: $xeTable, id: tableId, type: "restore", storeData })).then((storeData2) => {
            if (!storeData2) {
              return;
            }
            return handleCustomRestore(storeData2);
          }).catch((e) => e);
        } else {
          return handleCustomRestore(storeData);
        }
      }
    };
    const cacheColumnMap = () => {
      const { treeConfig, showOverflow } = props;
      const { tableFullColumn, collectColumn } = internalData;
      const fullColIdData = internalData.fullColumnIdData = {};
      const fullColFieldData = internalData.fullColumnFieldData = {};
      const mouseOpts = computeMouseOpts.value;
      const expandOpts = computeExpandOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const virtualYOpts = computeVirtualYOpts.value;
      const { isCrossDrag, isSelfToChildDrag } = columnDragOpts;
      const customOpts = computeCustomOpts.value;
      const treeOpts = computeTreeOpts.value;
      const { storage } = customOpts;
      const rowOpts = computeRowOpts.value;
      const isGroup = collectColumn.some(hasChildrenList);
      let isAllOverflow = !!showOverflow;
      let rowGroupColumn;
      let expandColumn;
      let treeNodeColumn;
      let checkboxColumn;
      let radioColumn;
      let htmlColumn;
      let hasFixed;
      const handleFunc = (column, index, items, path, parentColumn) => {
        const { id: colid, field, fixed, type, treeNode, rowGroupNode } = column;
        const rest = { $index: -1, _index: -1, column, colid, index, items, parent: parentColumn || null, width: 0, oLeft: 0 };
        if (field) {
          if (fullColFieldData[field]) {
            errLog("vxe.error.colRepet", ["field", field]);
          }
          fullColFieldData[field] = rest;
        } else {
          if (storage && !type) {
            errLog("vxe.error.reqSupportProp", ["storage", `[${type ? `type=${type}` : `title=${column.getTitle()}`}]field=?`]);
          }
          if (columnOpts.drag && (isCrossDrag || isSelfToChildDrag)) {
            errLog("vxe.error.reqSupportProp", ["column-drag-config.isCrossDrag | column-drag-config.isSelfToChildDrag", `${column.getTitle() || type || ""} -> field=?`]);
          }
        }
        if (!hasFixed && fixed) {
          hasFixed = fixed;
        }
        if (!htmlColumn && type === "html") {
          htmlColumn = column;
        }
        if (treeNode) {
          if (treeNodeColumn) {
            warnLog("vxe.error.colRepet", ["tree-node", treeNode]);
          }
          if (!treeNodeColumn) {
            treeNodeColumn = column;
          }
        }
        if (rowGroupNode) {
          if (treeNodeColumn) {
            warnLog("vxe.error.colRepet", ["row-group-node", rowGroupNode]);
          }
          if (!rowGroupColumn) {
            rowGroupColumn = column;
          }
        }
        if (type === "expand") {
          if (expandColumn) {
            warnLog("vxe.error.colRepet", ["type", type]);
          }
          if (!expandColumn) {
            expandColumn = column;
          }
        }
        if (type === "checkbox") {
          if (checkboxColumn) {
            warnLog("vxe.error.colRepet", ["type", type]);
          }
          if (!checkboxColumn) {
            checkboxColumn = column;
          }
        } else if (type === "radio") {
          if (radioColumn) {
            warnLog("vxe.error.colRepet", ["type", type]);
          }
          if (!radioColumn) {
            radioColumn = column;
          }
        }
        if (isAllOverflow && column.showOverflow === false) {
          isAllOverflow = false;
        }
        if (fullColIdData[colid]) {
          errLog("vxe.error.colRepet", ["colId", colid]);
        }
        fullColIdData[colid] = rest;
      };
      if (isGroup) {
        import_xe_utils18.default.eachTree(collectColumn, (column, index, items, path, parentColumn, nodes) => {
          column.level = nodes.length;
          handleFunc(column, index, items, path, parentColumn);
        });
      } else {
        tableFullColumn.forEach(handleFunc);
      }
      if (expandColumn && expandOpts.mode !== "fixed" && virtualYOpts.enabled) {
        warnLog("vxe.error.notConflictProp", ['column.type="expand', "virtual-y-config.enabled=false"]);
      }
      if (expandColumn && expandOpts.mode !== "fixed" && mouseOpts.area) {
        errLog("vxe.error.errConflicts", ["mouse-config.area", "column.type=expand"]);
      }
      if (expandColumn && expandOpts.mode !== "inside" && (treeConfig && !treeOpts.transform)) {
        errLog("vxe.error.notConflictProp", ["tree-config.transform=false", "expand-config.mode=fixed"]);
      }
      if (htmlColumn) {
        if (!columnOpts.useKey) {
          errLog("vxe.error.notSupportProp", ["column.type=html", "column-config.useKey=false", "column-config.useKey=true"]);
        }
        if (!rowOpts.useKey) {
          errLog("vxe.error.notSupportProp", ["column.type=html", "row-config.useKey=false", "row-config.useKey=true"]);
        }
      }
      reactData.isGroup = isGroup;
      reactData.rowGroupColumn = rowGroupColumn;
      reactData.treeNodeColumn = treeNodeColumn;
      reactData.expandColumn = expandColumn;
      reactData.checkboxColumn = checkboxColumn;
      reactData.radioColumn = radioColumn;
      reactData.isAllOverflow = isAllOverflow;
    };
    const updateHeight = () => {
      internalData.customHeight = calcTableHeight("height");
      internalData.customMinHeight = calcTableHeight("minHeight");
      internalData.customMaxHeight = calcTableHeight("maxHeight");
      if (reactData.scrollYLoad && !(internalData.customHeight || internalData.customMinHeight || internalData.customMaxHeight)) {
        internalData.customHeight = 300;
      }
    };
    const calcColumnAutoWidth = (column, wrapperEl) => {
      const columnOpts = computeColumnOpts.value;
      const { autoOptions } = columnOpts;
      const { isCalcHeader, isCalcBody, isCalcFooter } = autoOptions || {};
      const querySelections = [];
      if (isCalcHeader) {
        querySelections.push(`.vxe-header-cell--wrapper[colid="${column.id}"]`);
      }
      if (isCalcBody) {
        querySelections.push(`.vxe-body-cell--wrapper[colid="${column.id}"]`);
      }
      if (isCalcFooter) {
        querySelections.push(`.vxe-footer-cell--wrapper[colid="${column.id}"]`);
      }
      const cellElemList = querySelections.length ? wrapperEl.querySelectorAll(querySelections.join(",")) : [];
      let leftRightPadding = 0;
      const firstCellEl = cellElemList[0];
      if (firstCellEl && firstCellEl.parentElement) {
        const cellStyle = getComputedStyle(firstCellEl.parentElement);
        leftRightPadding = Math.ceil(import_xe_utils18.default.toNumber(cellStyle.paddingLeft) + import_xe_utils18.default.toNumber(cellStyle.paddingRight));
      }
      let colWidth = column.renderAutoWidth - leftRightPadding;
      for (let i = 0; i < cellElemList.length; i++) {
        const celEl = cellElemList[i];
        colWidth = Math.max(colWidth, celEl ? Math.ceil(celEl.scrollWidth) + 4 : 0);
      }
      return colWidth + leftRightPadding;
    };
    const calcCellWidth = () => {
      const autoWidthColumnList = computeAutoWidthColumnList.value;
      const { fullColumnIdData } = internalData;
      const el = refElem.value;
      if (el) {
        el.setAttribute("data-calc-col", "Y");
        autoWidthColumnList.forEach((column) => {
          const colid = column.id;
          const colRest = fullColumnIdData[colid];
          const colWidth = calcColumnAutoWidth(column, el);
          if (colRest) {
            colRest.width = Math.max(colWidth, colRest.width);
          }
          column.renderAutoWidth = colWidth;
        });
        $xeTable.analyColumnWidth();
        el.removeAttribute("data-calc-col");
      }
    };
    const autoCellWidth = () => {
      const { elemStore } = internalData;
      const bodyWrapperElem = getRefElem(elemStore["main-body-wrapper"]);
      if (!bodyWrapperElem) {
        return;
      }
      const yHandleEl = refScrollYHandleElem.value;
      if (!yHandleEl) {
        return;
      }
      const xHandleEl = refScrollXHandleElem.value;
      if (!xHandleEl) {
        return;
      }
      let tWidth = 0;
      const minCellWidth = 40;
      const bodyWidth = bodyWrapperElem.clientWidth;
      let remainWidth = bodyWidth;
      let meanWidth = remainWidth / 100;
      const { fit } = props;
      const { columnStore } = reactData;
      const { resizeList, pxMinList, autoMinList, pxList, scaleList, scaleMinList, autoList, remainList } = columnStore;
      pxMinList.forEach((column) => {
        const minWidth = import_xe_utils18.default.toInteger(column.minWidth);
        tWidth += minWidth;
        column.renderWidth = minWidth;
      });
      autoMinList.forEach((column) => {
        const caWidth = Math.max(60, import_xe_utils18.default.toInteger(column.renderAutoWidth));
        tWidth += caWidth;
        column.renderWidth = caWidth;
      });
      scaleMinList.forEach((column) => {
        const smWidth = Math.floor(import_xe_utils18.default.toInteger(column.minWidth) * meanWidth);
        tWidth += smWidth;
        column.renderWidth = smWidth;
      });
      scaleList.forEach((column) => {
        const sfWidth = Math.floor(import_xe_utils18.default.toInteger(column.width) * meanWidth);
        tWidth += sfWidth;
        column.renderWidth = sfWidth;
      });
      pxList.forEach((column) => {
        const pWidth = import_xe_utils18.default.toInteger(column.width);
        tWidth += pWidth;
        column.renderWidth = pWidth;
      });
      autoList.forEach((column) => {
        const aWidth = Math.max(60, import_xe_utils18.default.toInteger(column.renderAutoWidth));
        tWidth += aWidth;
        column.renderWidth = aWidth;
      });
      resizeList.forEach((column) => {
        const reWidth = import_xe_utils18.default.toInteger(column.resizeWidth);
        tWidth += reWidth;
        column.renderWidth = reWidth;
      });
      remainWidth -= tWidth;
      meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoMinList.length + remainList.length)) : 0;
      if (fit) {
        if (remainWidth > 0) {
          scaleMinList.concat(pxMinList).concat(autoMinList).forEach((column) => {
            tWidth += meanWidth;
            column.renderWidth += meanWidth;
          });
        }
      } else {
        meanWidth = minCellWidth;
      }
      remainList.forEach((column) => {
        const width = Math.max(meanWidth, minCellWidth);
        column.renderWidth = width;
        tWidth += width;
      });
      if (fit) {
        const dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoMinList).concat(remainList);
        let dynamicSize = dynamicList.length - 1;
        if (dynamicSize > 0) {
          let i = bodyWidth - tWidth;
          if (i > 0) {
            while (i > 0 && dynamicSize >= 0) {
              i--;
              dynamicList[dynamicSize--].renderWidth++;
            }
            tWidth = bodyWidth;
          }
        }
      }
      reactData.scrollXWidth = tWidth;
      reactData.resizeWidthFlag++;
      updateColumnOffsetLeft();
      updateHeight();
    };
    const calcCellAutoHeight = (rowRest, wrapperEl) => {
      const { scrollXLoad } = reactData;
      const wrapperElemList = wrapperEl.querySelectorAll(`.vxe-cell--wrapper[rowid="${rowRest.rowid}"]`);
      let colHeight = 0;
      let firstCellStyle = null;
      let topBottomPadding = 0;
      for (let i = 0; i < wrapperElemList.length; i++) {
        const wrapperElem = wrapperElemList[i];
        const cellElem = wrapperElem.parentElement;
        const cellStyle = cellElem.style;
        const orHeight = cellStyle.height;
        if (!scrollXLoad) {
          cellStyle.height = "";
        }
        if (!firstCellStyle) {
          firstCellStyle = getComputedStyle(cellElem);
          topBottomPadding = firstCellStyle ? Math.ceil(import_xe_utils18.default.toNumber(firstCellStyle.paddingTop) + import_xe_utils18.default.toNumber(firstCellStyle.paddingBottom)) : 0;
        }
        if (!scrollXLoad) {
          cellStyle.height = orHeight;
        }
        const cellHeight = wrapperElem ? wrapperElem.clientHeight : 0;
        colHeight = Math.max(colHeight, Math.ceil(cellHeight + topBottomPadding));
      }
      if (scrollXLoad) {
        colHeight = Math.max(colHeight, rowRest.height);
      }
      return colHeight;
    };
    const calcCellHeight = () => {
      const { treeConfig } = props;
      const { tableData, isAllOverflow, scrollYLoad, scrollXLoad } = reactData;
      const { fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const el = refElem.value;
      if (el && !isAllOverflow && (scrollYLoad || scrollXLoad || treeConfig && treeOpts.showLine)) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        el.setAttribute("data-calc-row", "Y");
        tableData.forEach((row) => {
          const rowid = handleGetRowId(row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            const reHeight = calcCellAutoHeight(rowRest, el);
            rowRest.height = Math.max(defaultRowHeight, reHeight);
          }
          el.removeAttribute("data-calc-row");
        });
        reactData.calcCellHeightFlag++;
      }
    };
    const getOrderField = (column) => {
      const { sortBy, sortType } = column;
      return (row) => {
        let cellValue;
        if (sortBy) {
          cellValue = import_xe_utils18.default.isFunction(sortBy) ? sortBy({ row, column }) : import_xe_utils18.default.get(row, sortBy);
        } else {
          cellValue = tableMethods.getCellLabel(row, column);
        }
        if (!sortType || sortType === "auto") {
          return isNaN(cellValue) ? cellValue : import_xe_utils18.default.toNumber(cellValue);
        } else if (sortType === "number") {
          return import_xe_utils18.default.toNumber(cellValue);
        } else if (sortType === "string") {
          return import_xe_utils18.default.toValueString(cellValue);
        }
        return cellValue;
      };
    };
    const updateAfterListIndex = () => {
      const { treeConfig } = props;
      const { afterFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      const fullMaps = {};
      afterFullData.forEach((row, index) => {
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid];
        const seq = index + 1;
        if (rowRest) {
          if (!treeConfig) {
            rowRest.seq = seq;
          }
          rowRest._index = index;
        } else {
          const rest = { row, rowid, seq, index: -1, $index: -1, _index: index, treeIndex: -1, _tIndex: -1, items: [], parent: null, level: 0, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
          fullAllDataRowIdData[rowid] = rest;
          fullDataRowIdData[rowid] = rest;
        }
        fullMaps[rowid] = row;
      });
      internalData.afterFullRowMaps = fullMaps;
    };
    const updateAfterDataIndex = () => {
      const { treeConfig } = props;
      const { fullDataRowIdData, fullAllDataRowIdData, afterFullData, afterTreeFullData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const fullMaps = {};
      if (treeConfig) {
        let _treeIndex = 0;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        import_xe_utils18.default.eachTree(afterTreeFullData, (row, index, items, path) => {
          const rowid = handleGetRowId(row);
          const rowRest = fullAllDataRowIdData[rowid];
          const seq = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
          if (rowRest) {
            rowRest.seq = seq;
            rowRest.treeIndex = index;
            rowRest._tIndex = _treeIndex;
          } else {
            const rest = { row, rowid, seq, index: -1, $index: -1, _index: -1, treeIndex: -1, _tIndex: _treeIndex, items: [], parent: null, level: 0, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
          _treeIndex++;
          fullMaps[rowid] = row;
        }, { children: transform ? treeOpts.mapChildrenField : childrenField });
        if (transform) {
          afterFullData.forEach((row, index) => {
            const rowid = handleGetRowId(row);
            const rowRest = fullAllDataRowIdData[rowid];
            const seq = index + 1;
            if (rowRest) {
              if (!treeConfig) {
                rowRest.seq = seq;
              }
              rowRest._index = index;
            }
          });
        }
        internalData.afterFullRowMaps = fullMaps;
      } else {
        updateAfterListIndex();
      }
    };
    const handleVirtualTreeToList = () => {
      const { treeConfig } = props;
      const { isRowGroupStatus } = reactData;
      const { fullAllDataRowIdData, treeExpandedMaps, rowGroupExpandedMaps } = internalData;
      const aggregateOpts = computeAggregateOpts.value;
      const treeOpts = computeTreeOpts.value;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      const fullData = [];
      const expandMaps = {};
      if (treeConfig && treeOpts.transform) {
        const childrenField = treeOpts.children || treeOpts.childrenField;
        import_xe_utils18.default.eachTree(internalData.afterTreeFullData, (row, index, items, path, parentRow) => {
          const rowid = handleGetRowId(row);
          const parentRowid = handleGetRowId(parentRow);
          if (!parentRow || expandMaps[parentRowid] && treeExpandedMaps[parentRowid]) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest._index = fullData.length;
            }
            expandMaps[rowid] = 1;
            fullData.push(row);
          }
        }, { children: childrenField });
        internalData.afterFullData = fullData;
        updateScrollYStatus(fullData);
        return fullData;
      } else if (isRowGroupStatus) {
        const { childrenField } = aggregateOpts;
        import_xe_utils18.default.eachTree(internalData.afterGroupFullData, (row, index, items, path, parentRow) => {
          const rowid = handleGetRowId(row);
          const parentRowid = handleGetRowId(parentRow);
          if (!parentRow || expandMaps[parentRowid] && rowGroupExpandedMaps[parentRowid]) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest._index = fullData.length;
            }
            expandMaps[rowid] = 1;
            fullData.push(row);
          }
        }, { children: childrenField });
        internalData.afterFullData = fullData;
        updateScrollYStatus(fullData);
        return fullData;
      }
      return internalData.afterFullData;
    };
    const updateAfterFullData = () => {
      const { treeConfig } = props;
      const { isRowGroupStatus } = reactData;
      const { tableFullColumn, tableFullData, tableFullTreeData, tableFullGroupData } = internalData;
      const filterOpts = computeFilterOpts.value;
      const sortOpts = computeSortOpts.value;
      const aggregateOpts = computeAggregateOpts.value;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const { transform, rowField, parentField, mapChildrenField } = treeOpts;
      const { isEvery, remote: allRemoteFilter, filterMethod: allFilterMethod } = filterOpts;
      const { remote: allRemoteSort, sortMethod: allSortMethod, multiple: sortMultiple, chronological } = sortOpts;
      let tableData = [];
      let tableTree = [];
      if (!allRemoteFilter || !allRemoteSort) {
        const filterColumns = [];
        let orderColumns = [];
        tableFullColumn.forEach((column) => {
          const { field, sortable, order, filters } = column;
          if (!allRemoteFilter && filters && filters.length) {
            const valueList = [];
            const itemList = [];
            filters.forEach((item) => {
              if (item.checked) {
                itemList.push(item);
                valueList.push(item.value);
              }
            });
            if (itemList.length) {
              filterColumns.push({ column, valueList, itemList });
            }
          }
          if (!allRemoteSort && sortable && order) {
            orderColumns.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (sortMultiple && chronological && orderColumns.length > 1) {
          orderColumns = import_xe_utils18.default.orderBy(orderColumns, "sortTime");
        }
        if (!allRemoteFilter && filterColumns.length) {
          const handleFilter = (row) => {
            return filterColumns.every(({ column, valueList, itemList }) => {
              const { filterMethod, filterRender } = column;
              const compConf = isEnableConf(filterRender) ? renderer9.get(filterRender.name) : null;
              const compFilterMethod = compConf ? compConf.tableFilterMethod || compConf.filterMethod : null;
              const tdFilterMethod = compConf ? compConf.tableFilterDefaultMethod || compConf.defaultTableFilterMethod || compConf.defaultFilterMethod : null;
              const cellValue = getCellValue(row, column);
              if (filterMethod) {
                return itemList.some((item) => filterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              } else if (compFilterMethod) {
                return itemList.some((item) => compFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              } else if (allFilterMethod) {
                return allFilterMethod({ $table: $xeTable, options: itemList, values: valueList, cellValue, row, column });
              } else if (tdFilterMethod) {
                return itemList.some((item) => tdFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              }
              return valueList.indexOf(import_xe_utils18.default.get(row, column.field)) > -1;
            });
          };
          if (isRowGroupStatus) {
            tableTree = import_xe_utils18.default.searchTree(tableFullGroupData, handleFilter, {
              original: true,
              isEvery: true,
              children: aggregateOpts.mapChildrenField,
              mapChildren: aggregateOpts.childrenField
            });
            tableData = tableTree;
          } else if (treeConfig && transform) {
            tableTree = import_xe_utils18.default.searchTree(tableFullTreeData, handleFilter, {
              original: true,
              isEvery,
              children: mapChildrenField,
              mapChildren: childrenField
            });
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.filter(handleFilter) : tableFullData.filter(handleFilter);
            tableTree = tableData;
          }
        } else {
          if (isRowGroupStatus) {
            tableTree = import_xe_utils18.default.searchTree(tableFullGroupData, () => true, {
              original: true,
              isEvery: true,
              children: aggregateOpts.mapChildrenField,
              mapChildren: aggregateOpts.childrenField
            });
            tableData = tableTree;
          } else if (treeConfig && transform) {
            tableTree = import_xe_utils18.default.searchTree(tableFullTreeData, () => true, {
              original: true,
              isEvery,
              children: mapChildrenField,
              mapChildren: childrenField
            });
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
            tableTree = tableData;
          }
        }
        if (!allRemoteSort && orderColumns.length) {
          if (isRowGroupStatus) {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableTree, sortList: orderColumns, $table: $xeTable });
              tableTree = import_xe_utils18.default.isArray(sortRests) ? sortRests : tableTree;
            } else {
              const treeList = import_xe_utils18.default.toTreeArray(tableTree, {
                key: aggregateOpts.rowField,
                parentKey: aggregateOpts.parentField,
                children: aggregateOpts.mapChildrenField
              });
              tableTree = import_xe_utils18.default.toArrayTree(import_xe_utils18.default.orderBy(treeList, orderColumns.map(({ column, order }) => [getOrderField(column), order])), {
                key: aggregateOpts.rowField,
                parentKey: aggregateOpts.parentField,
                children: aggregateOpts.childrenField,
                mapChildren: aggregateOpts.mapChildrenField
              });
            }
            tableData = tableTree;
          } else if (treeConfig && transform) {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableTree, sortList: orderColumns, $table: $xeTable });
              tableTree = import_xe_utils18.default.isArray(sortRests) ? sortRests : tableTree;
            } else {
              const treeList = import_xe_utils18.default.toTreeArray(tableTree, {
                children: mapChildrenField
              });
              tableTree = import_xe_utils18.default.toArrayTree(import_xe_utils18.default.orderBy(treeList, orderColumns.map(({ column, order }) => [getOrderField(column), order])), {
                key: rowField,
                parentKey: parentField,
                children: childrenField,
                mapChildren: mapChildrenField
              });
            }
            tableData = tableTree;
          } else {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableData, sortList: orderColumns, $table: $xeTable });
              tableData = import_xe_utils18.default.isArray(sortRests) ? sortRests : tableData;
            } else {
              tableData = import_xe_utils18.default.orderBy(tableData, orderColumns.map(({ column, order }) => [getOrderField(column), order]));
            }
            tableTree = tableData;
          }
        }
      } else {
        if (isRowGroupStatus) {
          tableTree = import_xe_utils18.default.searchTree(tableFullGroupData, () => true, {
            original: true,
            isEvery: true,
            children: aggregateOpts.mapChildrenField,
            mapChildren: aggregateOpts.childrenField
          });
          tableData = tableTree;
        } else if (treeConfig && transform) {
          tableTree = import_xe_utils18.default.searchTree(tableFullTreeData, () => true, {
            original: true,
            isEvery,
            children: mapChildrenField,
            mapChildren: childrenField
          });
          tableData = tableTree;
        } else {
          tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
          tableTree = tableData;
        }
      }
      internalData.afterFullData = tableData;
      internalData.afterTreeFullData = tableTree;
      internalData.afterGroupFullData = tableTree;
      updateAfterDataIndex();
    };
    const updateStyle = () => {
      const { mouseConfig } = props;
      const { isGroup, currentRow, tableColumn, overflowX, scrollbarWidth, overflowY, scrollbarHeight, scrollXWidth, columnStore, editStore, isColLoading } = reactData;
      const { visibleColumn, tableHeight, elemStore, customHeight, customMinHeight, customMaxHeight, tHeaderHeight, tFooterHeight } = internalData;
      const $xeGanttView = internalData.xeGanttView;
      const el = refElem.value;
      if (!el || internalData.tBodyHeight && !el.clientHeight) {
        return;
      }
      const containerList = ["main", "left", "right"];
      const { leftList, rightList } = columnStore;
      let osbWidth = overflowY ? scrollbarWidth : 0;
      let osbHeight = overflowX ? scrollbarHeight : 0;
      const emptyPlaceholderElem = refEmptyPlaceholder.value;
      const isHeaderRenderOptimize = computeIsHeaderRenderOptimize.value;
      const isBodyRenderOptimize = computeIsBodyRenderOptimize.value;
      const isFooterRenderOptimize = computeIsFooterRenderOptimize.value;
      const scrollbarOpts = computeScrollbarOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const bodyWrapperElem = getRefElem(elemStore["main-body-wrapper"]);
      const bodyTableElem = getRefElem(elemStore["main-body-table"]);
      if (emptyPlaceholderElem) {
        emptyPlaceholderElem.style.top = `${tHeaderHeight}px`;
        emptyPlaceholderElem.style.height = bodyWrapperElem ? `${bodyWrapperElem.offsetHeight - osbHeight}px` : "";
      }
      const scrollbarXConf = scrollbarOpts.x || {};
      const scrollbarYConf = scrollbarOpts.y || {};
      const scrollbarYToLeft = computeScrollbarYToLeft.value;
      let xScrollbarVisible = overflowX ? "visible" : "hidden";
      if (scrollbarXConf.visible === "visible" || $xeGanttView) {
        osbHeight = scrollbarHeight;
        xScrollbarVisible = "visible";
      } else if (scrollbarXConf.visible === "hidden" || scrollbarXConf.visible === false) {
        osbHeight = 0;
        xScrollbarVisible = "hidden";
      }
      let yScrollbarVisible = overflowY ? "visible" : "hidden";
      if (scrollbarYConf.visible === "hidden" || scrollbarYConf.visible === false || $xeGanttView && !scrollbarYToLeft) {
        osbWidth = 0;
        yScrollbarVisible = "hidden";
      } else if (scrollbarYConf.visible === "visible") {
        osbWidth = scrollbarWidth;
        yScrollbarVisible = "visible";
      }
      let tbHeight = 0;
      let bodyMaxHeight = 0;
      const bodyMinHeight = customMinHeight - tHeaderHeight - tFooterHeight - osbHeight;
      if (customMaxHeight) {
        bodyMaxHeight = Math.max(bodyMinHeight, customMaxHeight - tHeaderHeight - tFooterHeight - osbHeight);
      }
      if (customHeight) {
        tbHeight = customHeight - tHeaderHeight - tFooterHeight - osbHeight;
      }
      if (!tbHeight) {
        if (bodyTableElem) {
          tbHeight = bodyTableElem.clientHeight;
        }
      }
      if (tbHeight) {
        if (bodyMaxHeight) {
          tbHeight = Math.min(bodyMaxHeight, tbHeight);
        }
        tbHeight = Math.max(bodyMinHeight, tbHeight);
      }
      const xLeftCornerEl = refScrollXLeftCornerElem.value;
      const xRightCornerEl = refScrollXRightCornerElem.value;
      const scrollXVirtualEl = refScrollXVirtualElem.value;
      if (scrollXVirtualEl) {
        scrollXVirtualEl.style.height = `${osbHeight}px`;
        scrollXVirtualEl.style.visibility = xScrollbarVisible;
      }
      const xWrapperEl = refScrollXWrapperElem.value;
      if (xWrapperEl) {
        xWrapperEl.style.width = `${el.clientWidth - osbWidth}px`;
        if (scrollbarYToLeft) {
          xWrapperEl.style.left = `${osbWidth}px`;
        } else {
          xWrapperEl.style.left = "";
        }
      }
      if (xLeftCornerEl) {
        if (scrollbarYToLeft) {
          xLeftCornerEl.style.width = `${osbWidth}px`;
          xLeftCornerEl.style.display = overflowY && osbWidth ? "block" : "";
        } else {
          xLeftCornerEl.style.display = "";
        }
      }
      if (xRightCornerEl) {
        if (scrollbarYToLeft) {
          xRightCornerEl.style.display = "";
        } else {
          xRightCornerEl.style.width = `${osbWidth}px`;
          xRightCornerEl.style.display = xScrollbarVisible === "visible" ? "block" : "";
        }
      }
      const scrollYVirtualEl = refScrollYVirtualElem.value;
      if (scrollYVirtualEl) {
        scrollYVirtualEl.style.width = `${osbWidth}px`;
        scrollYVirtualEl.style.height = `${tbHeight + tHeaderHeight + tFooterHeight}px`;
        scrollYVirtualEl.style.visibility = yScrollbarVisible;
      }
      const yTopCornerEl = refScrollYTopCornerElem.value;
      if (yTopCornerEl) {
        yTopCornerEl.style.height = `${tHeaderHeight}px`;
        yTopCornerEl.style.display = tHeaderHeight && yScrollbarVisible === "visible" ? "block" : "";
      }
      const yWrapperEl = refScrollYWrapperElem.value;
      if (yWrapperEl) {
        yWrapperEl.style.height = `${tbHeight}px`;
        yWrapperEl.style.top = `${tHeaderHeight}px`;
      }
      const yBottomCornerEl = refScrollYBottomCornerElem.value;
      if (yBottomCornerEl) {
        yBottomCornerEl.style.height = `${tFooterHeight}px`;
        yBottomCornerEl.style.top = `${tHeaderHeight + tbHeight}px`;
        yBottomCornerEl.style.display = tFooterHeight && yScrollbarVisible === "visible" ? "block" : "";
      }
      const rowExpandEl = refRowExpandElem.value;
      if (rowExpandEl) {
        rowExpandEl.style.height = `${tbHeight}px`;
        rowExpandEl.style.top = `${tHeaderHeight}px`;
      }
      internalData.tBodyHeight = tbHeight;
      containerList.forEach((name, index) => {
        const fixedType = index > 0 ? name : "";
        const layoutList = ["header", "body", "footer"];
        const isFixedLeft = fixedType === "left";
        let fixedColumn = [];
        let fixedWrapperElem;
        if (fixedType) {
          fixedColumn = isFixedLeft ? leftList : rightList;
          fixedWrapperElem = isFixedLeft ? refLeftContainer.value : refRightContainer.value;
        }
        layoutList.forEach((layout) => {
          const wrapperElem = getRefElem(elemStore[`${name}-${layout}-wrapper`]);
          const currScrollElem = getRefElem(elemStore[`${name}-${layout}-scroll`]);
          const tableElem = getRefElem(elemStore[`${name}-${layout}-table`]);
          if (layout === "header") {
            let renderColumnList = tableColumn;
            const isOptimizeMode = isHeaderRenderOptimize;
            if (isGroup) {
              renderColumnList = visibleColumn;
            } else {
              if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
                renderColumnList = visibleColumn;
              }
              if (fixedType) {
                if (isOptimizeMode) {
                  renderColumnList = fixedColumn || [];
                }
              }
            }
            const tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (fixedType) {
              if (isGroup) {
                if (wrapperElem) {
                  wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : "";
                }
              } else {
                if (isOptimizeMode) {
                  if (wrapperElem) {
                    wrapperElem.style.width = tWidth ? `${tWidth}px` : "";
                  }
                } else {
                  if (wrapperElem) {
                    wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : "";
                  }
                }
              }
            }
            if (currScrollElem) {
              currScrollElem.style.height = `${tHeaderHeight}px`;
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : "";
            }
          } else if (layout === "body") {
            if (currScrollElem) {
              currScrollElem.style.maxHeight = customMaxHeight ? `${bodyMaxHeight}px` : "";
              currScrollElem.style.height = customHeight ? `${tbHeight}px` : "";
              currScrollElem.style.minHeight = `${bodyMinHeight}px`;
            }
            if (fixedWrapperElem) {
              if (wrapperElem) {
                wrapperElem.style.top = `${tHeaderHeight}px`;
              }
              fixedWrapperElem.style.height = `${customHeight > 0 ? customHeight : tableHeight + tHeaderHeight + tFooterHeight + osbHeight}px`;
              fixedWrapperElem.style.width = `${fixedColumn.reduce((previous, column) => previous + column.renderWidth, 0)}px`;
            }
            let renderColumnList = tableColumn;
            const isOptimizeMode = isBodyRenderOptimize;
            if (fixedType) {
              renderColumnList = visibleColumn;
              if (isOptimizeMode) {
                renderColumnList = fixedColumn || [];
              }
            }
            const tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (fixedType) {
              if (isOptimizeMode) {
                if (wrapperElem) {
                  wrapperElem.style.width = tWidth ? `${tWidth}px` : "";
                }
              } else {
                if (wrapperElem) {
                  wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : "";
                }
              }
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : "";
              tableElem.style.paddingRight = osbWidth && fixedType && (browseObj.firefox || browseObj.safari) ? `${osbWidth}px` : "";
            }
            const emptyBlockElem = getRefElem(elemStore[`${name}-${layout}-emptyBlock`]);
            if (emptyBlockElem) {
              emptyBlockElem.style.width = tWidth ? `${tWidth}px` : "";
            }
          } else if (layout === "footer") {
            let renderColumnList = tableColumn;
            const isOptimizeMode = isFooterRenderOptimize;
            if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
              renderColumnList = visibleColumn;
            }
            if (fixedType) {
              if (isOptimizeMode) {
                renderColumnList = fixedColumn || [];
              }
            }
            const tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (fixedType) {
              if (isOptimizeMode) {
                if (wrapperElem) {
                  wrapperElem.style.width = tWidth ? `${tWidth}px` : "";
                }
              } else {
                if (wrapperElem) {
                  wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : "";
                }
              }
            }
            if (currScrollElem) {
              currScrollElem.style.height = `${tFooterHeight}px`;
              if (fixedWrapperElem) {
                if (wrapperElem) {
                  wrapperElem.style.top = `${customHeight > 0 ? customHeight - tFooterHeight - osbHeight : tableHeight + tHeaderHeight}px`;
                }
              }
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : "";
            }
          }
        });
      });
      if (currentRow) {
        $xeTable.setCurrentRow(currentRow);
      }
      if (mouseConfig && mouseOpts.selected && editStore.selected.row && editStore.selected.column) {
        $xeTable.addCellSelectedClass();
      }
      if ($xeGanttView && $xeGanttView.handleUpdateStyle) {
        $xeGanttView.handleUpdateStyle();
      }
      return nextTick();
    };
    const checkValidate = (type) => {
      if ($xeTable.triggerValidate) {
        return $xeTable.triggerValidate(type);
      }
      return nextTick();
    };
    const handleChangeCell = (evnt, params) => {
      checkValidate("blur").catch((e) => e).then(() => {
        $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e) => e);
      });
    };
    const handleDefaultSort = () => {
      const { sortConfig } = props;
      if (sortConfig) {
        const sortOpts = computeSortOpts.value;
        let { defaultSort } = sortOpts;
        if (defaultSort) {
          if (!import_xe_utils18.default.isArray(defaultSort)) {
            defaultSort = [defaultSort];
          }
          if (defaultSort.length) {
            (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach((item, index) => {
              const { field, order } = item;
              if (field && order) {
                const column = $xeTable.getColumnByField(field);
                if (column && column.sortable) {
                  column.order = order;
                  column.sortTime = Date.now() + index;
                }
              }
            });
            if (!sortOpts.remote) {
              $xeTable.handleTableData(true).then(updateStyle);
            }
          }
        }
      }
    };
    const handleDefaultSelectionChecked = () => {
      const { checkboxConfig } = props;
      if (checkboxConfig) {
        const { fullDataRowIdData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkAll, checkRowKeys } = checkboxOpts;
        if (checkAll) {
          handleCheckedAllCheckboxRow(true, true);
        } else if (checkRowKeys) {
          const defSelection = [];
          checkRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defSelection.push(fullDataRowIdData[rowid].row);
            }
          });
          handleCheckedCheckboxRow(defSelection, true, true);
        }
      }
    };
    const handleDefaultRadioChecked = () => {
      const { radioConfig } = props;
      if (radioConfig) {
        const { fullDataRowIdData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const { checkRowKey: rowid, reserve } = radioOpts;
        if (rowid) {
          if (fullDataRowIdData[rowid]) {
            handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
          }
          if (reserve) {
            const rowkey = getRowkey($xeTable);
            internalData.radioReserveRow = { [rowkey]: rowid };
          }
        }
      }
    };
    const handleDefaultRowExpand = () => {
      const { expandConfig } = props;
      if (expandConfig) {
        const { fullDataRowIdData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { expandAll, expandRowKeys } = expandOpts;
        if (expandAll) {
          $xeTable.setAllRowExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          expandRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defExpandeds.push(fullDataRowIdData[rowid].row);
            }
          });
          $xeTable.setRowExpand(defExpandeds, true);
        }
      }
    };
    const handleRadioReserveRow = (row) => {
      const radioOpts = computeRadioOpts.value;
      if (radioOpts.reserve) {
        internalData.radioReserveRow = row;
      }
    };
    const handleCheckboxReserveRow = (row, checked) => {
      const { checkboxReserveRowMap } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      if (checkboxOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (checked) {
          checkboxReserveRowMap[rowid] = row;
        } else if (checkboxReserveRowMap[rowid]) {
          delete checkboxReserveRowMap[rowid];
        }
      }
    };
    const handleCheckedRadioRow = (row, isForce) => {
      const radioOpts = computeRadioOpts.value;
      const { checkMethod } = radioOpts;
      if (row && (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row })))) {
        reactData.selectRadioRow = row;
        handleRadioReserveRow(row);
      }
      return nextTick();
    };
    const handleCheckedCheckboxRow = (rows, value, isForce) => {
      if (rows && !import_xe_utils18.default.isArray(rows)) {
        rows = [rows];
      }
      $xeTable.handleBatchSelectRows(rows, !!value, isForce);
      $xeTable.checkSelectionStatus();
      return nextTick();
    };
    const handleCheckedAllCheckboxRow = (checked, isForce) => {
      const { treeConfig } = props;
      const { isRowGroupStatus } = reactData;
      const { afterFullData, afterTreeFullData, afterGroupFullData, checkboxReserveRowMap, selectCheckboxMaps } = internalData;
      const treeOpts = computeTreeOpts.value;
      const aggregateOpts = computeAggregateOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkField, reserve, checkMethod } = checkboxOpts;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
      const selectRowMaps = {};
      if (checkField) {
        const checkValFn = (row) => {
          if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
            if (checked) {
              selectRowMaps[handleGetRowId(row)] = row;
            }
            import_xe_utils18.default.set(row, checkField, checked);
          }
          if ((treeConfig || isRowGroupStatus) && indeterminateField) {
            import_xe_utils18.default.set(row, indeterminateField, false);
          }
        };
        if (treeConfig || isRowGroupStatus) {
          import_xe_utils18.default.eachTree(afterFullData, checkValFn, { children: childrenField });
        } else {
          afterFullData.forEach(checkValFn);
        }
      } else {
        if (isRowGroupStatus) {
          if (checked) {
            import_xe_utils18.default.eachTree(afterGroupFullData, (row) => {
              if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
                const rowid = handleGetRowId(row);
                selectRowMaps[rowid] = row;
              }
            }, { children: aggregateOpts.mapChildrenField });
          } else {
            if (!isForce && checkMethod) {
              import_xe_utils18.default.eachTree(afterGroupFullData, (row) => {
                const rowid = handleGetRowId(row);
                if (checkMethod({ $table: $xeTable, row }) ? false : selectCheckboxMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              }, { children: aggregateOpts.mapChildrenField });
            }
          }
        } else if (treeConfig) {
          if (checked) {
            import_xe_utils18.default.eachTree(afterTreeFullData, (row) => {
              if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
                const rowid = handleGetRowId(row);
                selectRowMaps[rowid] = row;
              }
            }, { children: childrenField });
          } else {
            if (!isForce && checkMethod) {
              import_xe_utils18.default.eachTree(afterTreeFullData, (row) => {
                const rowid = handleGetRowId(row);
                if (checkMethod({ $table: $xeTable, row }) ? false : selectCheckboxMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              }, { children: childrenField });
            }
          }
        } else {
          if (checked) {
            if (!isForce && checkMethod) {
              afterFullData.forEach((row) => {
                const rowid = handleGetRowId(row);
                if (selectCheckboxMaps[rowid] || checkMethod({ $table: $xeTable, row })) {
                  selectRowMaps[rowid] = row;
                }
              });
            } else {
              afterFullData.forEach((row) => {
                const rowid = handleGetRowId(row);
                selectRowMaps[rowid] = row;
              });
            }
          } else {
            if (!isForce && checkMethod) {
              afterFullData.forEach((row) => {
                const rowid = handleGetRowId(row);
                if (checkMethod({ $table: $xeTable, row }) ? false : selectCheckboxMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              });
            }
          }
        }
      }
      if (reserve) {
        if (checked) {
          import_xe_utils18.default.each(selectRowMaps, (row, rowid) => {
            checkboxReserveRowMap[rowid] = row;
          });
        } else {
          afterFullData.forEach((row) => handleCheckboxReserveRow(row, false));
        }
      }
      reactData.updateCheckboxFlag++;
      internalData.selectCheckboxMaps = checkField ? {} : selectRowMaps;
      reactData.isAllSelected = checked;
      reactData.isIndeterminate = false;
      internalData.treeIndeterminateRowMaps = {};
      $xeTable.checkSelectionStatus();
      return nextTick();
    };
    const handleReserveStatus = () => {
      const { treeConfig } = props;
      const { expandColumn, currentRow, selectRadioRow } = reactData;
      const { fullDataRowIdData, fullAllDataRowIdData, radioReserveRow, selectCheckboxMaps, treeExpandedMaps, rowExpandedMaps } = internalData;
      const expandOpts = computeExpandOpts.value;
      const treeOpts = computeTreeOpts.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      if (selectRadioRow && !fullAllDataRowIdData[getRowid($xeTable, selectRadioRow)]) {
        reactData.selectRadioRow = null;
      }
      if (radioOpts.reserve && radioReserveRow) {
        const rowid = getRowid($xeTable, radioReserveRow);
        if (fullDataRowIdData[rowid]) {
          handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
        }
      }
      internalData.selectCheckboxMaps = getRecoverRowMaps(selectCheckboxMaps);
      reactData.updateCheckboxFlag++;
      if (checkboxOpts.reserve) {
        handleCheckedCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap), true, true);
      }
      if (currentRow && !fullAllDataRowIdData[getRowid($xeTable, currentRow)]) {
        reactData.currentRow = null;
      }
      internalData.rowExpandedMaps = expandColumn ? getRecoverRowMaps(rowExpandedMaps) : {};
      reactData.rowExpandedFlag++;
      if (expandColumn && expandOpts.reserve) {
        $xeTable.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap), true);
      }
      internalData.treeExpandedMaps = treeConfig ? getRecoverRowMaps(treeExpandedMaps) : {};
      reactData.treeExpandedFlag++;
      if (treeConfig && treeOpts.reserve) {
        $xeTable.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap), true);
      }
    };
    const handleDefaultTreeExpand = () => {
      const { treeConfig } = props;
      if (treeConfig) {
        const { fullAllDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { expandAll, expandRowKeys } = treeOpts;
        if (expandAll) {
          $xeTable.setAllTreeExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          expandRowKeys.forEach((rowid) => {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              defExpandeds.push(rowRest.row);
            }
          });
          $xeTable.setTreeExpand(defExpandeds, true);
        }
      }
    };
    const handleAsyncTreeExpandChilds = (row) => {
      const treeOpts = computeTreeOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { transform, loadMethod } = treeOpts;
      const { checkStrictly } = checkboxOpts;
      return new Promise((resolve) => {
        if (loadMethod) {
          const { fullAllDataRowIdData, treeExpandLazyLoadedMaps } = internalData;
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          treeExpandLazyLoadedMaps[rowid] = row;
          Promise.resolve(loadMethod({ $table: $xeTable, row })).then((childRecords) => {
            if (rowRest) {
              rowRest.treeLoaded = true;
            }
            if (treeExpandLazyLoadedMaps[rowid]) {
              delete treeExpandLazyLoadedMaps[rowid];
            }
            if (!import_xe_utils18.default.isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return $xeTable.loadTreeChildren(row, childRecords).then((childRows) => {
                const { treeExpandedMaps } = internalData;
                if (childRows.length && !treeExpandedMaps[rowid]) {
                  treeExpandedMaps[rowid] = row;
                }
                reactData.treeExpandedFlag++;
                if (!checkStrictly && $xeTable.isCheckedByCheckboxRow(row)) {
                  handleCheckedCheckboxRow(childRows, true);
                }
                return nextTick().then(() => {
                  if (transform) {
                    $xeTable.handleTableData();
                    updateAfterDataIndex();
                    return nextTick();
                  }
                });
              });
            }
          }).catch(() => {
            const { treeExpandLazyLoadedMaps: treeExpandLazyLoadedMaps2 } = internalData;
            if (rowRest) {
              rowRest.treeLoaded = false;
            }
            if (treeExpandLazyLoadedMaps2[rowid]) {
              delete treeExpandLazyLoadedMaps2[rowid];
            }
          }).finally(() => {
            reactData.treeExpandedFlag++;
            nextTick().then(() => $xeTable.recalculate()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleTreeExpandReserve = (row, expanded) => {
      const { treeExpandedReserveRowMap } = internalData;
      const treeOpts = computeTreeOpts.value;
      if (treeOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (expanded) {
          treeExpandedReserveRowMap[rowid] = row;
        } else if (treeExpandedReserveRowMap[rowid]) {
          delete treeExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleAsyncRowExpand = (row) => {
      return new Promise((resolve) => {
        const expandOpts = computeExpandOpts.value;
        const { loadMethod } = expandOpts;
        if (loadMethod) {
          const { fullAllDataRowIdData, rowExpandLazyLoadedMaps } = internalData;
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          rowExpandLazyLoadedMaps[rowid] = row;
          loadMethod({ $table: $xeTable, row, rowIndex: $xeTable.getRowIndex(row), $rowIndex: $xeTable.getVMRowIndex(row) }).then(() => {
            const { rowExpandedMaps } = internalData;
            if (rowRest) {
              rowRest.expandLoaded = true;
            }
            rowExpandedMaps[rowid] = row;
            reactData.rowExpandedFlag++;
          }).catch(() => {
            if (rowRest) {
              rowRest.expandLoaded = false;
            }
          }).finally(() => {
            const { rowExpandLazyLoadedMaps: rowExpandLazyLoadedMaps2 } = internalData;
            if (rowExpandLazyLoadedMaps2[rowid]) {
              delete rowExpandLazyLoadedMaps2[rowid];
            }
            reactData.rowExpandedFlag++;
            nextTick().then(() => $xeTable.recalculate()).then(() => $xeTable.updateCellAreas()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleRowExpandReserve = (row, expanded) => {
      const { rowExpandedReserveRowMap } = internalData;
      const expandOpts = computeExpandOpts.value;
      if (expandOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (expanded) {
          rowExpandedReserveRowMap[rowid] = row;
        } else if (rowExpandedReserveRowMap[rowid]) {
          delete rowExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleDefaultMergeCells = () => {
      const { mergeCells } = props;
      if (mergeCells) {
        $xeTable.setMergeCells(mergeCells);
      }
    };
    const handleDefaultMergeHeaderItems = () => {
      const { mergeHeaderCells } = props;
      if (mergeHeaderCells) {
        $xeTable.setMergeHeaderCells(mergeHeaderCells);
      }
    };
    const handleDefaultMergeFooterItems = () => {
      const { mergeFooterCells, mergeFooterItems } = props;
      const mFooterCells = mergeFooterCells || mergeFooterItems;
      if (mFooterCells) {
        $xeTable.setMergeFooterCells(mFooterCells);
      }
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollXLoad, scrollYLoad } = reactData;
        const { scrollXStore, scrollYStore } = internalData;
        const virtualYOpts = computeVirtualYOpts.value;
        const virtualXOpts = computeVirtualXOpts.value;
        if (scrollXLoad) {
          const { toVisibleIndex: toXVisibleIndex, visibleSize: visibleXSize } = handleVirtualXVisible();
          const offsetXSize = Math.max(0, virtualXOpts.oSize ? import_xe_utils18.default.toNumber(virtualXOpts.oSize) : 0);
          scrollXStore.preloadSize = import_xe_utils18.default.toNumber(virtualXOpts.preSize);
          scrollXStore.offsetSize = offsetXSize;
          scrollXStore.visibleSize = visibleXSize;
          scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);
          scrollXStore.visibleStartIndex = Math.max(scrollXStore.startIndex, toXVisibleIndex);
          scrollXStore.visibleEndIndex = Math.min(scrollXStore.endIndex, toXVisibleIndex + visibleXSize);
          $xeTable.updateScrollXData().then(() => {
            loadScrollXData();
          });
        } else {
          $xeTable.updateScrollXSpace();
        }
        const rowHeight = computeRowHeight();
        scrollYStore.rowHeight = rowHeight;
        reactData.rowHeight = rowHeight;
        const { toVisibleIndex: toYVisibleIndex, visibleSize: visibleYSize } = handleVirtualYVisible();
        if (scrollYLoad) {
          const offsetYSize = Math.max(0, virtualYOpts.oSize ? import_xe_utils18.default.toNumber(virtualYOpts.oSize) : 0);
          scrollYStore.preloadSize = import_xe_utils18.default.toNumber(virtualYOpts.preSize);
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
          scrollYStore.visibleStartIndex = Math.max(scrollYStore.startIndex, toYVisibleIndex);
          scrollYStore.visibleEndIndex = Math.min(scrollYStore.endIndex, toYVisibleIndex + visibleYSize);
          $xeTable.updateScrollYData().then(() => {
            loadScrollYData();
          });
        } else {
          $xeTable.updateScrollYSpace();
        }
      });
    };
    const calcScrollbar = () => {
      const { scrollXWidth, scrollYHeight } = reactData;
      const { elemStore } = internalData;
      const scrollbarOpts = computeScrollbarOpts.value;
      const bodyWrapperElem = getRefElem(elemStore["main-body-wrapper"]);
      const headerTableElem = getRefElem(elemStore["main-header-table"]);
      const footerTableElem = getRefElem(elemStore["main-footer-table"]);
      const xHandleEl = refScrollXHandleElem.value;
      const yHandleEl = refScrollYHandleElem.value;
      let overflowY = false;
      let overflowX = false;
      if (bodyWrapperElem) {
        overflowY = scrollYHeight > bodyWrapperElem.clientHeight;
        if (yHandleEl) {
          reactData.scrollbarWidth = scrollbarOpts.width || yHandleEl.offsetWidth - yHandleEl.clientWidth || 14;
        }
        reactData.overflowY = overflowY;
        overflowX = scrollXWidth > bodyWrapperElem.clientWidth;
        if (xHandleEl) {
          reactData.scrollbarHeight = scrollbarOpts.height || xHandleEl.offsetHeight - xHandleEl.clientHeight || 14;
        }
        const hHeight = headerTableElem ? headerTableElem.clientHeight : 0;
        const fHeight = footerTableElem ? footerTableElem.clientHeight : 0;
        internalData.tableHeight = bodyWrapperElem.offsetHeight;
        internalData.tHeaderHeight = hHeight;
        internalData.tFooterHeight = fHeight;
        reactData.overflowX = overflowX;
        reactData.parentHeight = Math.max(hHeight + fHeight + 20, $xeTable.getParentHeight());
      }
      if (overflowX) {
        $xeTable.checkScrolling();
      }
    };
    const handleRecalculateStyle = (reFull, reWidth, reHeight) => {
      const el = refElem.value;
      internalData.rceRunTime = Date.now();
      if (!el || !el.clientWidth) {
        return nextTick();
      }
      const varEl = refVarElem.value;
      if (varEl) {
        const [defEl, mediumEl, smallEl, miniEl] = varEl.children;
        calcVarRowHeightConfig("default", defEl);
        calcVarRowHeightConfig("medium", mediumEl);
        calcVarRowHeightConfig("small", smallEl);
        calcVarRowHeightConfig("mini", miniEl);
      }
      if (reWidth) {
        calcCellWidth();
      }
      if (reFull) {
        autoCellWidth();
      }
      calcScrollbar();
      updateStyle();
      updateRowExpandStyle();
      if (reFull) {
        updateTreeLineStyle();
      }
      return computeScrollLoad().then(() => {
        if (reWidth) {
          calcCellWidth();
        }
        if (reFull) {
          autoCellWidth();
        }
        if (reHeight) {
          calcCellHeight();
        }
        updateStyle();
        calcScrollbar();
        if (reFull) {
          updateRowOffsetTop();
        }
        updateRowExpandStyle();
        if (reFull) {
          updateTreeLineStyle();
        }
        if (reFull) {
          return computeScrollLoad();
        }
      });
    };
    const handleLazyRecalculate = (reFull, reWidth, reHeight) => {
      return new Promise((resolve) => {
        const $xeGanttView = internalData.xeGanttView;
        const { rceTimeout, rceRunTime } = internalData;
        const resizeOpts = computeResizeOpts.value;
        const refreshDelay = resizeOpts.refreshDelay || 20;
        const el = refElem.value;
        if (el && el.clientWidth) {
          autoCellWidth();
          updateRowExpandStyle();
        }
        if (rceTimeout) {
          clearTimeout(rceTimeout);
          if (rceRunTime && rceRunTime + (refreshDelay - 5) < Date.now()) {
            resolve(handleRecalculateStyle(reFull, reWidth, reHeight));
          } else {
            nextTick(() => {
              resolve();
            });
          }
        } else {
          resolve(handleRecalculateStyle(reFull, reWidth, reHeight));
        }
        if ($xeGanttView && $xeGanttView.handleLazyRecalculate) {
          $xeGanttView.handleLazyRecalculate();
        }
        internalData.rceTimeout = setTimeout(() => {
          internalData.rceTimeout = void 0;
          handleRecalculateStyle(reFull, reWidth, reHeight);
        }, refreshDelay);
      });
    };
    const handleResizeEvent = () => {
      handleLazyRecalculate(true, true, true);
    };
    const handleUpdateAggValues = () => {
      const { visibleColumn } = internalData;
      const aggCols = [];
      visibleColumn.forEach((column) => {
        if (column.aggFunc) {
          aggCols.push(column);
        }
      });
      reactData.aggHandleAggColumns = aggCols;
    };
    const handleUpdateRowGroup = (groupFields) => {
      const aggGroupFields = [];
      const aggGroupConfs = [];
      if (groupFields) {
        (import_xe_utils18.default.isArray(groupFields) ? groupFields : [groupFields]).forEach((field) => {
          aggGroupFields.push(field);
          aggGroupConfs.push({
            field
          });
        });
      }
      reactData.rowGroupList = aggGroupConfs;
      reactData.aggHandleFields = aggGroupFields;
      handleUpdateAggValues();
    };
    const handleeGroupSummary = (aggList) => {
      const aggregateOpts = computeAggregateOpts.value;
      const { mapChildrenField } = aggregateOpts;
      if (mapChildrenField) {
        import_xe_utils18.default.lastEach(aggList, (aggRow) => {
          let count = 0;
          import_xe_utils18.default.each(aggRow[mapChildrenField], (row) => {
            if (row.isAggregate) {
              count += row.childCount || 0;
            } else {
              count++;
            }
          });
          aggRow.childCount = count;
        });
        if ($xeTable.handlePivotTableAggregateData) {
          $xeTable.handlePivotTableAggregateData(aggList);
        }
      }
    };
    const updateGroupData = () => {
      const { aggregateConfig, rowGroupConfig } = props;
      const { isRowGroupStatus } = reactData;
      const { tableFullGroupData } = internalData;
      const aggregateOpts = computeAggregateOpts.value;
      const { mapChildrenField } = aggregateOpts;
      if ((aggregateConfig || rowGroupConfig) && isRowGroupStatus) {
        const aggList = [];
        import_xe_utils18.default.eachTree(tableFullGroupData, (row) => {
          if (row.isAggregate) {
            aggList.push(row);
          }
        }, { children: mapChildrenField });
        handleeGroupSummary(aggList);
      }
    };
    const handleGroupData = (list, rowGroups) => {
      let fullData = list;
      let treeData = list;
      if (rowGroups) {
        const aggregateOpts = computeAggregateOpts.value;
        const { rowField, parentField, childrenField, mapChildrenField } = aggregateOpts;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        const rgItem = rowGroups[0];
        if (rgItem && rowField && parentField && childrenField && mapChildrenField) {
          fullData = [];
          treeData = [];
          const groupField = rgItem.field;
          const groupColumn = $xeTable.getColumnByField(groupField);
          const groupMaps = {};
          const aggList = [];
          const rowkey = getRowkey($xeTable);
          list.forEach((row) => {
            const cellValue = groupColumn ? $xeTable.getCellLabel(row, groupColumn) : import_xe_utils18.default.get(row, groupField);
            const groupValue = import_xe_utils18.default.eqNull(cellValue) ? "" : cellValue;
            let childList = groupMaps[groupValue];
            if (!childList) {
              childList = [];
              groupMaps[groupValue] = childList;
            }
            if (row.isAggregate) {
              row.isAggregate = void 0;
            }
            childList.push(row);
          });
          import_xe_utils18.default.objectEach(groupMaps, (childList, groupValue) => {
            const { fullData: childFullData, treeData: childTreeData } = handleGroupData(childList, rowGroups.slice(1));
            const aggRow = {
              isAggregate: true,
              aggData: {},
              groupContent: groupValue,
              groupField,
              childCount: 0,
              [rowField]: getRowUniqueId(),
              [parentField]: null,
              [rowkey]: getRowUniqueId(),
              [childrenField]: childTreeData,
              [mapChildrenField]: childTreeData
            };
            if (checkField) {
              aggRow[checkField] = false;
            }
            if (indeterminateField) {
              aggRow[indeterminateField] = false;
            }
            aggList.push(aggRow);
            treeData.push(aggRow);
            fullData.push(aggRow);
            if (childFullData.length) {
              fullData.push(...childFullData);
            }
          });
          handleeGroupSummary(aggList);
        }
      }
      return {
        treeData,
        fullData
      };
    };
    const initData = () => {
      const { data } = props;
      loadTableData(data || [], true).then(() => {
        if (data && data.length) {
          internalData.inited = true;
          internalData.initStatus = true;
          handleLoadDefaults();
        }
        handleInitDefaults();
        updateStyle();
        if (!reactData.isAllOverflow) {
          calcCellHeight();
          updateRowOffsetTop();
        }
      });
    };
    const loadTableData = (datas, isReset) => {
      const { keepSource, treeConfig, rowGroupConfig, aggregateConfig } = props;
      const { rowGroupList, scrollYLoad: oldScrollYLoad } = reactData;
      const { scrollYStore, scrollXStore, lastScrollLeft, lastScrollTop } = internalData;
      const rowOpts = computeRowOpts.value;
      const treeOpts = computeTreeOpts.value;
      const expandOpts = computeExpandOpts.value;
      const { transform } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      let treeData = [];
      let fullData = reactive(datas ? datas.slice(0) : []);
      if (fullData.length > supportMaxRow) {
        errLog("vxe.error.errMaxRow", [supportMaxRow]);
      }
      if (treeConfig && rowGroupList.length) {
        errLog("vxe.error.noTree", ["aggregate-config"]);
        return nextTick();
      }
      if (rowOpts.drag && rowGroupList.length) {
        errLog("vxe.error.errConflicts", ["row-config.drag", "aggregate-config"]);
        return nextTick();
      }
      let isRGroup = false;
      if (treeConfig) {
        if (transform) {
          if (!treeOpts.rowField) {
            errLog("vxe.error.reqProp", ["tree-config.rowField"]);
          }
          if (!treeOpts.parentField) {
            errLog("vxe.error.reqProp", ["tree-config.parentField"]);
          }
          if (!childrenField) {
            errLog("vxe.error.reqProp", ["tree-config.childrenField"]);
          }
          if (!treeOpts.mapChildrenField) {
            errLog("vxe.error.reqProp", ["tree-config.mapChildrenField"]);
          }
          if (childrenField === treeOpts.mapChildrenField) {
            errLog("vxe.error.errConflicts", ["tree-config.childrenField", "tree-config.mapChildrenField"]);
          }
          treeData = import_xe_utils18.default.toArrayTree(fullData, {
            key: treeOpts.rowField,
            parentKey: treeOpts.parentField,
            children: childrenField,
            mapChildren: treeOpts.mapChildrenField
          });
          fullData = treeData.slice(0);
        } else {
          treeData = fullData.slice(0);
        }
      } else if ((aggregateConfig || rowGroupConfig) && rowGroupList.length) {
        const groupRest = handleGroupData(fullData, rowGroupList);
        treeData = groupRest.treeData;
        fullData = groupRest.fullData;
        isRGroup = true;
      }
      reactData.isRowGroupStatus = isRGroup;
      scrollYStore.startIndex = 0;
      scrollYStore.endIndex = 1;
      scrollXStore.startIndex = 0;
      scrollXStore.endIndex = 1;
      internalData.cvCacheMaps = {};
      reactData.isRowLoading = true;
      reactData.scrollVMLoading = false;
      reactData.treeExpandedFlag++;
      reactData.rowExpandedFlag++;
      internalData.insertRowMaps = {};
      reactData.insertRowFlag++;
      internalData.removeRowMaps = {};
      reactData.removeRowFlag++;
      const sYLoad = updateScrollYStatus(fullData);
      internalData.tableFullData = fullData;
      internalData.tableFullTreeData = isRGroup ? [] : treeData;
      internalData.tableFullGroupData = isRGroup ? treeData : [];
      $xeTable.cacheRowMap(isReset);
      internalData.tableSynchData = datas;
      if (isReset) {
        internalData.isResizeCellHeight = false;
      }
      if (keepSource) {
        $xeTable.cacheSourceMap(fullData);
      }
      if ($xeTable.clearCellAreas && props.mouseConfig) {
        $xeTable.clearCellAreas();
        $xeTable.clearCopyCellArea();
      }
      $xeTable.clearMergeCells();
      $xeTable.clearMergeFooterItems();
      $xeTable.handleTableData(true);
      $xeTable.updateFooter();
      $xeTable.handleUpdateBodyMerge();
      return nextTick().then(() => {
        updateHeight();
        updateStyle();
      }).then(() => {
        computeScrollLoad();
      }).then(() => {
        const virtualYOpts = computeVirtualYOpts.value;
        if (sYLoad) {
          scrollYStore.endIndex = scrollYStore.visibleSize;
        }
        if (sYLoad) {
          if (reactData.expandColumn && expandOpts.mode !== "fixed") {
            errLog("vxe.error.notConflictProp", ['column.type="expand', 'expand-config.mode="fixed"']);
          }
          if (virtualYOpts.mode === "scroll" && expandOpts.mode === "fixed") {
            warnLog("vxe.error.notConflictProp", ["virtual-y-config.mode=scroll", "expand-config.mode=inside"]);
          }
          if (!(props.height || props.maxHeight)) {
            errLog("vxe.error.reqProp", ["height | max-height | virtual-y-config={enabled: false}"]);
          }
        }
        handleReserveStatus();
        $xeTable.checkSelectionStatus();
        $xeTable.dispatchEvent("data-change", {
          visibleColumn: internalData.visibleColumn,
          visibleData: internalData.afterFullData
        }, null);
        return new Promise((resolve) => {
          nextTick().then(() => handleRecalculateStyle(false, false, false)).then(() => {
            handleRecalculateStyle(false, true, true);
            updateRowOffsetTop();
          }).then(() => {
            let targetScrollLeft = lastScrollLeft;
            let targetScrollTop = lastScrollTop;
            const virtualXOpts = computeVirtualXOpts.value;
            const virtualYOpts2 = computeVirtualYOpts.value;
            if (virtualXOpts.scrollToLeftOnChange) {
              targetScrollLeft = 0;
            }
            if (virtualYOpts2.scrollToTopOnChange) {
              targetScrollTop = 0;
            }
            reactData.isRowLoading = false;
            handleRecalculateStyle(false, false, false);
            updateTreeLineStyle();
            if (!props.showOverflow) {
              setTimeout(() => {
                handleLazyRecalculate(false, true, true);
                setTimeout(() => handleLazyRecalculate(false, true, true), 3e3);
              }, 2e3);
            }
            if (oldScrollYLoad === sYLoad) {
              restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop).then(() => {
                handleRecalculateStyle(false, true, true);
                updateRowOffsetTop();
                updateTreeLineStyle();
                resolve();
              });
            } else {
              setTimeout(() => {
                restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop).then(() => {
                  handleRecalculateStyle(false, true, true);
                  updateRowOffsetTop();
                  updateTreeLineStyle();
                  resolve();
                });
              });
            }
          });
        });
      });
    };
    const handleLoadDefaults = () => {
      handleDefaultSelectionChecked();
      handleDefaultRadioChecked();
      handleDefaultRowExpand();
      handleDefaultTreeExpand();
      handleDefaultRowGroupExpand();
      handleDefaultMergeCells();
      handleDefaultMergeHeaderItems();
      handleDefaultMergeFooterItems();
      nextTick(() => setTimeout(() => $xeTable.recalculate()));
    };
    const handleInitDefaults = () => {
      handleDefaultSort();
    };
    const handleTableColumn = () => {
      const { scrollXLoad } = reactData;
      const { visibleColumn, scrollXStore, fullColumnIdData } = internalData;
      const tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);
      tableColumn.forEach((column, $index) => {
        const colid = column.id;
        const colRest = fullColumnIdData[colid];
        if (colRest) {
          colRest.$index = $index;
        }
      });
      reactData.tableColumn = tableColumn;
    };
    const handleUpdateColumn = () => {
      const columnList = import_xe_utils18.default.orderBy(internalData.collectColumn, "renderSortNumber");
      internalData.collectColumn = columnList;
      const tableFullColumn = getColumnList(columnList);
      internalData.tableFullColumn = tableFullColumn;
      cacheColumnMap();
    };
    const loadScrollXData = () => {
      const { isScrollXBig } = reactData;
      const { mergeBodyList, mergeFooterList, scrollXStore } = internalData;
      const { preloadSize, startIndex, endIndex, offsetSize } = scrollXStore;
      const { toVisibleIndex, visibleSize } = handleVirtualXVisible();
      const offsetItem = {
        startIndex: Math.max(0, isScrollXBig ? toVisibleIndex - 1 : toVisibleIndex - 1 - offsetSize - preloadSize),
        endIndex: isScrollXBig ? toVisibleIndex + visibleSize : toVisibleIndex + visibleSize + offsetSize + preloadSize
      };
      scrollXStore.visibleStartIndex = toVisibleIndex - 1;
      scrollXStore.visibleEndIndex = toVisibleIndex + visibleSize + 1;
      calculateMergerOffsetIndex(mergeBodyList.concat(mergeFooterList), offsetItem, "col");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollXStore.startIndex = offsetStartIndex;
          scrollXStore.endIndex = offsetEndIndex;
          $xeTable.updateScrollXData();
        }
      }
      $xeTable.closeTooltip();
    };
    const parseColumns = (isReset) => {
      const leftList = [];
      const centerList = [];
      const rightList = [];
      const { isGroup, columnStore } = reactData;
      const { collectColumn, tableFullColumn, scrollXStore, fullColumnIdData } = internalData;
      if (isGroup) {
        const leftGroupList = [];
        const centerGroupList = [];
        const rightGroupList = [];
        import_xe_utils18.default.eachTree(collectColumn, (column, index, items, path, parentColumn) => {
          const isColGroup = hasChildrenList(column);
          if (parentColumn && parentColumn.fixed) {
            column.fixed = parentColumn.fixed;
          }
          if (parentColumn && (column.fixed || "") !== (parentColumn.fixed || "")) {
            errLog("vxe.error.groupFixed");
          }
          if (isColGroup) {
            column.visible = !!import_xe_utils18.default.findTree(column.children, (subColumn) => hasChildrenList(subColumn) ? false : subColumn.visible);
          } else if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
        collectColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftGroupList.push(column);
            } else if (column.fixed === "right") {
              rightGroupList.push(column);
            } else {
              centerGroupList.push(column);
            }
          }
        });
        reactData.tableGroupColumn = leftGroupList.concat(centerGroupList).concat(rightGroupList);
      } else {
        tableFullColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
      }
      const visibleColumn = leftList.concat(centerList).concat(rightList);
      internalData.visibleColumn = visibleColumn;
      updateColumnOffsetLeft();
      const sXLoad = updateScrollXStatus();
      reactData.hasFixedColumn = leftList.length > 0 || rightList.length > 0;
      Object.assign(columnStore, { leftList, centerList, rightList });
      if (sXLoad) {
        if (props.spanMethod) {
          warnLog("vxe.error.scrollErrProp", ["span-method"]);
        }
        if (props.footerSpanMethod) {
          warnLog("vxe.error.scrollErrProp", ["footer-span-method"]);
        }
        if (isReset) {
          const { visibleSize } = handleVirtualXVisible();
          scrollXStore.startIndex = 0;
          scrollXStore.endIndex = visibleSize;
          scrollXStore.visibleSize = visibleSize;
          scrollXStore.visibleStartIndex = 0;
          scrollXStore.visibleEndIndex = visibleSize;
        }
      }
      if (visibleColumn.length !== internalData.visibleColumn.length || !internalData.visibleColumn.every((column, index) => column === visibleColumn[index])) {
        $xeTable.clearMergeCells();
        $xeTable.clearMergeFooterItems();
      }
      visibleColumn.forEach((column, index) => {
        const colid = column.id;
        const colRest = fullColumnIdData[colid];
        if (colRest) {
          colRest._index = index;
        }
      });
      handleTableColumn();
      handleUpdateAggValues();
      if (isReset) {
        updateColumnOffsetLeft();
        return $xeTable.updateFooter().then(() => {
          return $xeTable.recalculate();
        }).then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate();
        });
      }
      return $xeTable.updateFooter();
    };
    const initColumnHierarchy = () => {
      const { collectColumn } = internalData;
      const fullColIdData = {};
      const fullColFieldData = {};
      let sortIndex = 1;
      import_xe_utils18.default.eachTree(collectColumn, (column, index, items, path, parentColumn) => {
        const { id: colid, field } = column;
        const parentId = parentColumn ? parentColumn.id : null;
        const rest = { $index: -1, _index: -1, column, colid, index, items, parent: parentColumn || null, width: 0, oLeft: 0 };
        column.parentId = parentId;
        column.defaultParentId = parentId;
        column.sortNumber = sortIndex;
        column.renderSortNumber = sortIndex;
        sortIndex++;
        if (field) {
          if (fullColFieldData[field]) {
            errLog("vxe.error.colRepet", ["field", field]);
          }
          fullColFieldData[field] = rest;
        }
        fullColIdData[colid] = rest;
      });
      internalData.fullColumnIdData = fullColIdData;
      internalData.fullColumnFieldData = fullColFieldData;
    };
    const handleInitColumn = (collectColumn) => {
      const expandOpts = computeExpandOpts.value;
      internalData.collectColumn = collectColumn;
      const tableFullColumn = getColumnList(collectColumn);
      internalData.tableFullColumn = tableFullColumn;
      reactData.isColLoading = true;
      initColumnHierarchy();
      return Promise.resolve(restoreCustomStorage()).then(() => {
        const { scrollXLoad, scrollYLoad, expandColumn } = reactData;
        cacheColumnMap();
        parseColumns(true).then(() => {
          if (reactData.scrollXLoad) {
            loadScrollXData();
          }
        });
        $xeTable.clearMergeCells();
        $xeTable.clearMergeFooterItems();
        $xeTable.handleTableData(true);
        $xeTable.handleAggregateSummaryData();
        if ((scrollXLoad || scrollYLoad) && (expandColumn && expandOpts.mode !== "fixed")) {
          warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
        }
        return nextTick().then(() => {
          if ($xeToolbar) {
            $xeToolbar.syncUpdate({
              collectColumn: internalData.collectColumn,
              $table: $xeTable
            });
          }
          if ($xeTable.handleUpdateCustomColumn) {
            $xeTable.handleUpdateCustomColumn();
          }
          const columnOpts = computeColumnOpts.value;
          if (props.showCustomHeader && reactData.isGroup && (columnOpts.resizable || props.resizable)) {
            warnLog("vxe.error.notConflictProp", ["show-custom-header & colgroup", "column-config.resizable=false"]);
          }
          reactData.isColLoading = false;
          return handleLazyRecalculate(false, true, true);
        });
      });
    };
    const updateScrollXStatus = (fullColumn) => {
      const virtualXOpts = computeVirtualXOpts.value;
      const allCols = fullColumn || internalData.tableFullColumn;
      const scrollXLoad = !!virtualXOpts.enabled && virtualXOpts.gt > -1 && (virtualXOpts.gt === 0 || virtualXOpts.gt < allCols.length);
      reactData.scrollXLoad = scrollXLoad;
      return scrollXLoad;
    };
    const updateScrollYStatus = (fullData) => {
      const { treeConfig } = props;
      const $xeGanttView = internalData.xeGanttView;
      const virtualYOpts = computeVirtualYOpts.value;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const allList = fullData || internalData.tableFullData;
      const scrollYLoad = (transform || !treeConfig) && !!virtualYOpts.enabled && virtualYOpts.gt > -1 && (virtualYOpts.gt === 0 || virtualYOpts.gt < allList.length);
      reactData.scrollYLoad = scrollYLoad;
      if ($xeGanttView && $xeGanttView.handleUpdateSYStatus) {
        $xeGanttView.handleUpdateSYStatus(scrollYLoad);
      }
      return scrollYLoad;
    };
    const handleBaseTreeExpand = (rows, expanded) => {
      const { treeNodeColumn } = reactData;
      const { fullAllDataRowIdData, tableFullTreeData, treeExpandedMaps, treeExpandLazyLoadedMaps } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { reserve, lazy, accordion, toggleMethod } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
      const result = [];
      const columnIndex = $xeTable.getColumnIndex(treeNodeColumn);
      const $columnIndex = $xeTable.getVMColumnIndex(treeNodeColumn);
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      let validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xeTable, expanded, column: treeNodeColumn, columnIndex, $columnIndex, row })) : rows;
      if (accordion) {
        validRows = validRows.length ? [validRows[validRows.length - 1]] : [];
        const matchObj = import_xe_utils18.default.findTree(tableFullTreeData, (item) => item === validRows[0], { children: childrenField });
        if (matchObj) {
          matchObj.items.forEach((item) => {
            const rowid = handleGetRowId(item);
            if (treeExpandedMaps[rowid]) {
              delete treeExpandedMaps[rowid];
            }
          });
        }
      }
      if (expanded) {
        validRows.forEach((row) => {
          const rowid = handleGetRowId(row);
          if (!treeExpandedMaps[rowid]) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const isLoad = lazy && row[hasChildField] && !rowRest.treeLoaded && !treeExpandLazyLoadedMaps[rowid];
              if (isLoad) {
                result.push(handleAsyncTreeExpandChilds(row));
              } else {
                if (row[childrenField] && row[childrenField].length) {
                  treeExpandedMaps[rowid] = row;
                }
              }
            }
          }
        });
      } else {
        validRows.forEach((item) => {
          const rowid = handleGetRowId(item);
          if (treeExpandedMaps[rowid]) {
            delete treeExpandedMaps[rowid];
          }
        });
      }
      if (reserve) {
        validRows.forEach((row) => handleTreeExpandReserve(row, expanded));
      }
      reactData.treeExpandedFlag++;
      return Promise.all(result).then(() => {
        updateTreeLineStyle();
        return $xeTable.recalculate();
      });
    };
    const handleVirtualTreeExpand = (rows, expanded) => {
      const { lastScrollLeft, lastScrollTop } = internalData;
      return handleBaseTreeExpand(rows, expanded).then(() => {
        handleVirtualTreeToList();
        $xeTable.handleTableData();
        reactData.treeExpandedFlag++;
        updateAfterDataIndex();
        return nextTick();
      }).then(() => {
        return handleRecalculateStyle(true, true, true);
      }).then(() => {
        restoreScrollLocation($xeTable, lastScrollLeft, lastScrollTop);
        updateTreeLineStyle();
        setTimeout(() => {
          $xeTable.updateCellAreas();
        }, 30);
      });
    };
    const handleRowGroupBaseExpand = (rows, expanded) => {
      const { fullAllDataRowIdData, tableFullGroupData, rowGroupExpandedMaps } = internalData;
      const aggregateOpts = computeAggregateOpts.value;
      const { mapChildrenField, accordion } = aggregateOpts;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      let validRows = rows;
      if (mapChildrenField) {
        if (accordion) {
          validRows = validRows.length ? [validRows[validRows.length - 1]] : [];
          const matchObj = import_xe_utils18.default.findTree(tableFullGroupData, (item) => getRowid($xeTable, item) === getRowid($xeTable, validRows[0]), { children: mapChildrenField });
          if (matchObj) {
            matchObj.items.forEach((item) => {
              const rowid = handleGetRowId(item);
              if (rowGroupExpandedMaps[rowid]) {
                delete rowGroupExpandedMaps[rowid];
              }
            });
          }
        }
        if (expanded) {
          validRows.forEach((row) => {
            const rowid = handleGetRowId(row);
            if (!rowGroupExpandedMaps[rowid]) {
              const rowRest = fullAllDataRowIdData[rowid];
              if (rowRest) {
                if (row[mapChildrenField] && row[mapChildrenField].length) {
                  rowGroupExpandedMaps[rowid] = row;
                }
              }
            }
          });
        } else {
          validRows.forEach((item) => {
            const rowid = handleGetRowId(item);
            if (rowGroupExpandedMaps[rowid]) {
              delete rowGroupExpandedMaps[rowid];
            }
          });
        }
      }
      reactData.rowGroupExpandedFlag++;
      return $xeTable.recalculate();
    };
    const handleRowGroupVirtualExpand = (rows, expanded) => {
      return handleRowGroupBaseExpand(rows, expanded).then(() => {
        handleVirtualTreeToList();
        $xeTable.handleTableData();
        reactData.rowGroupExpandedFlag++;
        updateAfterDataIndex();
        return nextTick();
      }).then(() => {
        return handleLazyRecalculate(true, true, true);
      }).then(() => {
        setTimeout(() => {
          $xeTable.updateCellAreas();
        }, 30);
      });
    };
    const handleDefaultRowGroupExpand = () => {
      const { isRowGroupStatus } = reactData;
      if (isRowGroupStatus) {
        const aggregateOpts = computeAggregateOpts.value;
        const { expandAll, expandGroupFields } = aggregateOpts;
        if (expandAll) {
          $xeTable.setAllRowGroupExpand(true);
        } else if (expandGroupFields && expandGroupFields.length) {
          $xeTable.setRowGroupExpandByField(expandGroupFields, true);
        }
      }
    };
    const handleCheckAllEvent = (evnt, value) => {
      handleCheckedAllCheckboxRow(value);
      if (evnt) {
        dispatchEvent("checkbox-all", {
          records: () => $xeTable.getCheckboxRecords(),
          reserves: () => $xeTable.getCheckboxReserveRecords(),
          indeterminates: () => $xeTable.getCheckboxIndeterminateRecords(),
          checked: value
        }, evnt);
      }
    };
    const loadScrollYData = () => {
      const { isAllOverflow, isScrollYBig } = reactData;
      const { mergeBodyList, scrollYStore } = internalData;
      const { preloadSize, startIndex, endIndex, offsetSize } = scrollYStore;
      const autoOffsetYSize = isAllOverflow ? offsetSize : offsetSize + 1;
      const { toVisibleIndex, visibleSize } = handleVirtualYVisible();
      const offsetItem = {
        startIndex: Math.max(0, isScrollYBig ? toVisibleIndex - 1 : toVisibleIndex - 1 - offsetSize - preloadSize),
        endIndex: isScrollYBig ? toVisibleIndex + visibleSize : toVisibleIndex + visibleSize + autoOffsetYSize + preloadSize
      };
      scrollYStore.visibleStartIndex = toVisibleIndex - 1;
      scrollYStore.visibleEndIndex = toVisibleIndex + visibleSize + 1;
      calculateMergerOffsetIndex(mergeBodyList, offsetItem, "row");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          $xeTable.updateScrollYData();
        }
      }
    };
    const createGetRowCacheProp = (prop) => {
      return function(row) {
        const { fullAllDataRowIdData } = internalData;
        if (row) {
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            return rowRest[prop];
          }
        }
        return -1;
      };
    };
    const createGetColumnCacheProp = (prop) => {
      return function(column) {
        const { fullColumnIdData } = internalData;
        if (column) {
          const colRest = fullColumnIdData[column.id];
          if (colRest) {
            return colRest[prop];
          }
        }
        return -1;
      };
    };
    const lazyScrollXData = () => {
      const { lxTimeout, lxRunTime, scrollXStore } = internalData;
      const { visibleSize } = scrollXStore;
      const fpsTime = visibleSize > 26 ? 26 : visibleSize > 16 ? 14 : 6;
      if (lxTimeout) {
        clearTimeout(lxTimeout);
      }
      if (!lxRunTime || lxRunTime + fpsTime < Date.now()) {
        internalData.lxRunTime = Date.now();
        loadScrollXData();
      }
      internalData.lxTimeout = setTimeout(() => {
        internalData.lxTimeout = void 0;
        internalData.lxRunTime = void 0;
        loadScrollXData();
      }, fpsTime);
    };
    const lazyScrollYData = () => {
      const { lyTimeout, lyRunTime, scrollYStore } = internalData;
      const { visibleSize } = scrollYStore;
      const fpsTime = visibleSize > 30 ? 32 : visibleSize > 20 ? 18 : 8;
      if (lyTimeout) {
        clearTimeout(lyTimeout);
      }
      if (!lyRunTime || lyRunTime + fpsTime < Date.now()) {
        internalData.lyRunTime = Date.now();
        loadScrollYData();
      }
      internalData.lyTimeout = setTimeout(() => {
        internalData.lyTimeout = void 0;
        internalData.lyRunTime = void 0;
        loadScrollYData();
      }, fpsTime);
    };
    const checkLastSyncScroll = (isRollX, isRollY) => {
      const { lcsTimeout } = internalData;
      reactData.lazScrollLoading = true;
      if (lcsTimeout) {
        clearTimeout(lcsTimeout);
      }
      internalData.lcsTimeout = setTimeout(() => {
        const { scrollXLoad, scrollYLoad, isAllOverflow } = reactData;
        internalData.lcsRunTime = Date.now();
        internalData.lcsTimeout = void 0;
        internalData.intoRunScroll = false;
        internalData.inVirtualScroll = false;
        internalData.inWheelScroll = false;
        internalData.inHeaderScroll = false;
        internalData.inBodyScroll = false;
        internalData.inFooterScroll = false;
        reactData.lazScrollLoading = false;
        internalData.scrollRenderType = "";
        if (!isAllOverflow) {
          calcCellHeight();
          updateRowOffsetTop();
        }
        if (isRollX && scrollXLoad) {
          $xeTable.updateScrollXData();
        }
        if (isRollY && scrollYLoad) {
          $xeTable.updateScrollYData().then(() => {
            if (!isAllOverflow) {
              calcCellHeight();
              updateRowOffsetTop();
            }
            $xeTable.updateScrollYSpace();
          });
        }
        updateRowExpandStyle();
        $xeTable.updateCellAreas();
      }, 200);
    };
    const getWheelSpeed = (lastScrollTime) => {
      let multiple = 1;
      const currTime = Date.now();
      if (lastScrollTime + 25 > currTime) {
        multiple = 1.18;
      } else if (lastScrollTime + 30 > currTime) {
        multiple = 1.15;
      } else if (lastScrollTime + 40 > currTime) {
        multiple = 1.12;
      } else if (lastScrollTime + 55 > currTime) {
        multiple = 1.09;
      } else if (lastScrollTime + 75 > currTime) {
        multiple = 1.06;
      } else if (lastScrollTime + 100 > currTime) {
        multiple = 1.03;
      }
      return multiple;
    };
    const wheelScrollLeftTo = (scrollLeft, cb) => {
      requestAnimationFrame(() => {
        cb(scrollLeft);
      });
    };
    const wheelScrollTopTo = (diffNum, cb) => {
      const duration = Math.abs(diffNum);
      const startTime = performance.now();
      let countTop = 0;
      const step = (timestamp) => {
        let progress = (timestamp - startTime) / duration;
        if (progress < 0) {
          progress = 0;
        } else if (progress > 1) {
          progress = 1;
        }
        const easedProgress = Math.pow(progress, 2);
        const offsetTop = Math.floor(diffNum * easedProgress) - countTop;
        countTop += offsetTop;
        cb(offsetTop);
        if (progress < 1) {
          requestAnimationFrame(step);
        }
      };
      requestAnimationFrame(step);
    };
    const syncGanttScrollTop = (scrollTop) => {
      const $xeGanttView = internalData.xeGanttView;
      if ($xeGanttView) {
        const ganttInternalData = $xeGanttView.internalData;
        const { elemStore: ganttElemStore } = ganttInternalData;
        const ganttBodyScrollElem = getRefElem(ganttElemStore["main-body-scroll"]);
        if (ganttBodyScrollElem) {
          ganttBodyScrollElem.scrollTop = scrollTop;
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt }, params));
    };
    const handleScrollToRowColumn = (fieldOrColumn, row) => {
      const { fullColumnIdData } = internalData;
      const column = handleFieldOrColumn($xeTable, fieldOrColumn);
      if (column && fullColumnIdData[column.id]) {
        return colToVisible($xeTable, column, row);
      }
      return nextTick();
    };
    const handleUpdateResize = () => {
      const el = refElem.value;
      if (el && el.clientWidth && el.clientHeight) {
        $xeTable.recalculate();
      }
    };
    const handleUpdateColResize = (evnt, params) => {
      $xeTable.analyColumnWidth();
      $xeTable.recalculate().then(() => {
        $xeTable.saveCustomStore("update:width");
        $xeTable.updateCellAreas();
        $xeTable.dispatchEvent("column-resizable-change", params, evnt);
        $xeTable.dispatchEvent("resizable-change", params, evnt);
        setTimeout(() => $xeTable.recalculate(true), 300);
      });
    };
    const handleUpdateRowResize = (evnt, params) => {
      reactData.resizeHeightFlag++;
      $xeTable.recalculate().then(() => {
        $xeTable.updateCellAreas();
        $xeTable.dispatchEvent("row-resizable-change", params, evnt);
        setTimeout(() => $xeTable.recalculate(true), 300);
      });
    };
    const updateColumnOffsetLeft = () => {
      const { visibleColumn, fullColumnIdData } = internalData;
      let offsetLeft = 0;
      for (let cIndex = 0, rLen = visibleColumn.length; cIndex < rLen; cIndex++) {
        const column = visibleColumn[cIndex];
        const colid = column.id;
        const colRest = fullColumnIdData[colid];
        if (colRest) {
          colRest.oLeft = offsetLeft;
        }
        offsetLeft += column.renderWidth;
      }
    };
    const updateRowOffsetTop = () => {
      const { expandColumn } = reactData;
      const { afterFullData, fullAllDataRowIdData, rowExpandedMaps } = internalData;
      const expandOpts = computeExpandOpts.value;
      const rowOpts = computeRowOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      let offsetTop = 0;
      for (let rIndex = 0, rLen = afterFullData.length; rIndex < rLen; rIndex++) {
        const row = afterFullData[rIndex];
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid] || {};
        rowRest.oTop = offsetTop;
        offsetTop += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
        if (expandColumn && rowExpandedMaps[rowid]) {
          offsetTop += rowRest.expandHeight || expandOpts.height || 0;
        }
      }
    };
    const updateRowExpandStyle = () => {
      const { expandColumn, scrollYLoad, scrollYTop, isScrollYBig } = reactData;
      const expandOpts = computeExpandOpts.value;
      const rowOpts = computeRowOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const { mode } = expandOpts;
      if (expandColumn && mode === "fixed") {
        const { elemStore, fullAllDataRowIdData } = internalData;
        const rowExpandEl = refRowExpandElem.value;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        if (rowExpandEl && bodyScrollElem) {
          let isUpdateHeight = false;
          import_xe_utils18.default.arrayEach(rowExpandEl.children, (reEl) => {
            const expandEl = reEl;
            const rowid = expandEl.getAttribute("rowid") || "";
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const expandHeight = expandEl.offsetHeight + 1;
              const trEl = bodyScrollElem.querySelector(`.vxe-body--row[rowid="${rowid}"]`);
              let offsetTop = 0;
              if (scrollYLoad) {
                if (isScrollYBig && trEl) {
                  offsetTop = trEl.offsetTop + trEl.offsetHeight;
                } else {
                  offsetTop = rowRest.oTop + (rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight);
                }
              } else {
                if (trEl) {
                  offsetTop = trEl.offsetTop + trEl.offsetHeight;
                }
              }
              if (isScrollYBig) {
                offsetTop += scrollYTop;
              }
              expandEl.style.top = toCssUnit(offsetTop);
              if (!isUpdateHeight) {
                if (rowRest.expandHeight !== expandHeight) {
                  isUpdateHeight = true;
                }
              }
              rowRest.expandHeight = expandHeight;
            }
          });
          if (isUpdateHeight) {
            reactData.rowExpandHeightFlag++;
            nextTick(() => {
              updateRowOffsetTop();
            });
          }
        }
      }
    };
    const updateTreeLineStyle = () => {
      const { treeConfig } = props;
      if (!treeConfig) {
        return;
      }
      const { tableData } = reactData;
      const { fullAllDataRowIdData, treeExpandedMaps } = internalData;
      const cellOpts = computeCellOpts.value;
      const rowOpts = computeRowOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const treeOpts = computeTreeOpts.value;
      const { transform, mapChildrenField } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      const expParentList = [];
      const handleNodeRow = (row, rIndex, rows) => {
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid] || {};
        const childList = row[transform ? mapChildrenField : childrenField];
        const prevRow = rows[rIndex - 1] || null;
        const nextRow = rows[rIndex + 1] || null;
        if (childList && childList.length && treeExpandedMaps[rowid]) {
          expParentList.push({ row, prevRow, nextRow });
          childList.forEach((childRow, crIndex) => {
            const childRowid = handleGetRowId(childRow);
            if (treeExpandedMaps[childRowid]) {
              handleNodeRow(childRow, crIndex, childList);
            }
          });
        } else {
          if (nextRow) {
            const nextRowid = handleGetRowId(nextRow);
            const nextRowRest = fullAllDataRowIdData[nextRowid] || {};
            const currCellHeight = getCellRestHeight(rowRest, cellOpts, rowOpts, defaultRowHeight);
            const nextCellHeight = getCellRestHeight(nextRowRest, cellOpts, rowOpts, defaultRowHeight);
            rowRest.oHeight = currCellHeight;
            rowRest.lineHeight = Math.floor(currCellHeight / 2 + nextCellHeight / 2);
          } else {
            rowRest.oHeight = 0;
            rowRest.lineHeight = 0;
          }
        }
      };
      tableData.forEach((row, rIndex) => {
        handleNodeRow(row, rIndex, tableData);
      });
      import_xe_utils18.default.lastArrayEach(expParentList, ({ row, nextRow }) => {
        const rowid = handleGetRowId(row);
        const childList = row[transform ? mapChildrenField : childrenField];
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          const currCellHeight = getCellRestHeight(rowRest, cellOpts, rowOpts, defaultRowHeight);
          let countOffsetHeight = currCellHeight;
          let countLineHeight = 0;
          childList.forEach((childRow) => {
            const childRowid = handleGetRowId(childRow);
            const childRowRest = fullAllDataRowIdData[childRowid] || {};
            const childList2 = childRow[transform ? mapChildrenField : childrenField];
            if (treeExpandedMaps[childRowid] && childList2 && childList2.length) {
              countOffsetHeight += childRowRest.oHeight || 0;
              countLineHeight += childRowRest.oHeight || 0;
            } else {
              const cellHeight = getCellRestHeight(childRowRest, cellOpts, rowOpts, defaultRowHeight);
              childRowRest.oHeight = cellHeight;
              childRowRest.lineHeight = cellHeight;
              countOffsetHeight += cellHeight;
              countLineHeight += cellHeight;
            }
          });
          if (nextRow) {
            const nextRowid = handleGetRowId(nextRow);
            const nextRowRest = fullAllDataRowIdData[nextRowid] || {};
            const currCellHeight2 = getCellRestHeight(rowRest, cellOpts, rowOpts, defaultRowHeight);
            const nextCellHeight = getCellRestHeight(nextRowRest, cellOpts, rowOpts, defaultRowHeight);
            countOffsetHeight += currCellHeight2;
            countLineHeight += Math.floor(currCellHeight2 / 2 + nextCellHeight / 2);
          }
          rowRest.lineHeight = countLineHeight;
          rowRest.oHeight = countOffsetHeight;
        }
      });
    };
    const handleRowExpandScroll = () => {
      const { elemStore } = internalData;
      const rowExpandEl = refRowExpandElem.value;
      const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
      if (rowExpandEl && bodyScrollElem) {
        rowExpandEl.scrollTop = bodyScrollElem.scrollTop;
      }
    };
    tableMethods = {
      dispatchEvent,
      getEl() {
        return refElem.value;
      },
      /**
       * 重置表格的一切数据状态
       */
      clearAll() {
        return clearTableAllStatus($xeTable);
      },
      /**
       * 同步 data 数据（即将废弃）
       * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑
       * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到
       */
      syncData() {
        errLog("vxe.error.delFunc", ["syncData", "getData"]);
        return nextTick().then(() => {
          reactData.tableData = [];
          emit("update:data", internalData.tableFullData);
          return nextTick();
        });
      },
      /**
       * 手动处理数据，用于手动排序与筛选
       * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到
       */
      updateData() {
        const { scrollXLoad, scrollYLoad } = reactData;
        return $xeTable.handleTableData(true).then(() => {
          $xeTable.updateFooter();
          if (scrollXLoad || scrollYLoad) {
            if (scrollXLoad) {
              $xeTable.updateScrollXSpace();
            }
            if (scrollYLoad) {
              $xeTable.updateScrollYSpace();
            }
            return $xeTable.refreshScroll();
          }
        }).then(() => {
          $xeTable.updateCellAreas();
          return handleLazyRecalculate(true, true, true);
        }).then(() => {
          setTimeout(() => handleLazyRecalculate(false, true, true), 50);
        });
      },
      /**
       * 重新加载数据，不会清空表格状态
       * @param {Array} datas 数据
       */
      loadData(datas) {
        const { initStatus } = internalData;
        return loadTableData(datas, false).then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          if (!initStatus) {
            handleLoadDefaults();
          }
          return handleLazyRecalculate(false, true, true);
        });
      },
      /**
       * 重新加载数据，会清空表格状态
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        return $xeTable.clearAll().then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          return loadTableData(datas, true);
        }).then(() => {
          handleLoadDefaults();
          return handleLazyRecalculate(false, true, true);
        });
      },
      /**
       * 修改行数据
       */
      setRow(rows, record) {
        if (rows && record) {
          let rest = rows;
          if (!import_xe_utils18.default.isArray(rows)) {
            rest = [rows];
          }
          const rowkey = getRowkey($xeTable);
          rest.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            const newRecord = import_xe_utils18.default.clone(Object.assign({}, record), true);
            import_xe_utils18.default.set(newRecord, rowkey, rowid);
            Object.assign(row, newRecord);
          });
        }
        return nextTick();
      },
      /**
       * 局部加载行数据并恢复到初始状态
       * 对于行数据需要局部更改的场景中可能会用到
       * @param {Row} row 行对象
       * @param {Object} record 新数据
       * @param {String} field 字段名
       */
      reloadRow(row, record, field) {
        const { keepSource } = props;
        const { tableData } = reactData;
        const { sourceDataRowIdData } = internalData;
        if (keepSource) {
          if ($xeTable.isAggregateRecord(row)) {
            return nextTick();
          }
          const oRow = sourceDataRowIdData[getRowid($xeTable, row)];
          if (oRow && row) {
            if (field) {
              const newValue = import_xe_utils18.default.clone(import_xe_utils18.default.get(record || row, field), true);
              import_xe_utils18.default.set(row, field, newValue);
              import_xe_utils18.default.set(oRow, field, newValue);
            } else {
              const rowkey = getRowkey($xeTable);
              const rowid = getRowid($xeTable, row);
              const newRecord = import_xe_utils18.default.clone(Object.assign({}, record), true);
              import_xe_utils18.default.set(newRecord, rowkey, rowid);
              import_xe_utils18.default.destructuring(oRow, Object.assign(row, newRecord));
            }
          }
          reactData.tableData = tableData.slice(0);
        } else {
          errLog("vxe.error.reqProp", ["keep-source"]);
        }
        return nextTick();
      },
      getParams() {
        return props.params;
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadTreeChildren(row, childRecords) {
        const { keepSource } = props;
        const { tableSourceData, fullDataRowIdData, fullAllDataRowIdData, sourceDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const parentRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        const parentLevel = parentRest ? parentRest.level : 0;
        return tableMethods.createData(childRecords).then((rows) => {
          if (keepSource) {
            const rowid = getRowid($xeTable, row);
            const matchObj = import_xe_utils18.default.findTree(tableSourceData, (item) => rowid === getRowid($xeTable, item), { children: childrenField });
            if (matchObj) {
              matchObj.item[childrenField] = import_xe_utils18.default.clone(rows, true);
            }
            rows.forEach((childRow) => {
              const rowid2 = getRowid($xeTable, childRow);
              sourceDataRowIdData[rowid2] = import_xe_utils18.default.clone(childRow, true);
            });
          }
          import_xe_utils18.default.eachTree(rows, (childRow, index, items, path, parentItem, nodes) => {
            const rowid = getRowid($xeTable, childRow);
            const parentRow = parentItem || parentRest.row;
            const rest = { row: childRow, rowid, seq: -1, index, _index: -1, $index: -1, treeIndex: -1, _tIndex: -1, items, parent: parentRow, level: parentLevel + nodes.length, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
          }, { children: childrenField });
          row[childrenField] = rows;
          if (transform) {
            row[mapChildrenField] = import_xe_utils18.default.clone(rows, false);
          }
          updateAfterDataIndex();
          return rows;
        });
      },
      /**
       * 加载列配置
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      loadColumn(columns) {
        const { lastScrollLeft, lastScrollTop } = internalData;
        const collectColumn = import_xe_utils18.default.mapTree(columns, (column) => reactive(cell_default.createColumn($xeTable, column)));
        return handleInitColumn(collectColumn).then(() => {
          let targetScrollLeft = lastScrollLeft;
          let targetScrollTop = lastScrollTop;
          const virtualXOpts = computeVirtualXOpts.value;
          const virtualYOpts = computeVirtualYOpts.value;
          if (virtualXOpts.scrollToLeftOnChange) {
            targetScrollLeft = 0;
          }
          if (virtualYOpts.scrollToTopOnChange) {
            targetScrollTop = 0;
          }
          restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop);
        });
      },
      /**
       * 加载列配置并恢复到初始状态
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      reloadColumn(columns) {
        return tableMethods.clearAll().then(() => {
          return tableMethods.loadColumn(columns);
        });
      },
      /**
       * 根据 tr 元素获取对应的 row 信息
       * @param {Element} tr 元素
       */
      getRowNode(tr) {
        if (tr) {
          const { fullAllDataRowIdData } = internalData;
          const rowid = tr.getAttribute("rowid");
          if (rowid) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              return {
                rowid: rowRest.rowid,
                item: rowRest.row,
                index: rowRest.index,
                items: rowRest.items,
                parent: rowRest.parent
              };
            }
          }
        }
        return null;
      },
      /**
       * 根据 th/td 元素获取对应的 column 信息
       * @param {Element} cell 元素
       */
      getColumnNode(cell) {
        if (cell) {
          const { fullColumnIdData } = internalData;
          const colid = cell.getAttribute("colid");
          if (colid) {
            const colRest = fullColumnIdData[colid];
            if (colRest) {
              return {
                colid: colRest.colid,
                item: colRest.column,
                index: colRest.index,
                items: colRest.items,
                parent: colRest.parent
              };
            }
          }
        }
        return null;
      },
      /**
       * 根据 row 获取序号
       * @param {Row} row 行对象
       */
      getRowSeq: createGetRowCacheProp("seq"),
      /**
       * 根据 row 获取相对于 data 中的索引
       * @param {Row} row 行对象
       */
      getRowIndex: createGetRowCacheProp("index"),
      /**
       * 根据 row 获取相对于当前数据中的索引
       * @param {Row} row 行对象
       */
      getVTRowIndex: createGetRowCacheProp("_index"),
      /**
       * 根据 row 获取渲染中的虚拟索引
       * @param {Row} row 行对象
       */
      getVMRowIndex: createGetRowCacheProp("$index"),
      /**
       * 根据 column 获取相对于 columns 中的索引
       * @param {ColumnInfo} column 列配置
       */
      getColumnIndex: createGetColumnCacheProp("index"),
      /**
       * 根据 column 获取相对于当前表格列中的索引
       * @param {ColumnInfo} column 列配置
       */
      getVTColumnIndex: createGetColumnCacheProp("_index"),
      /**
       * 根据 column 获取渲染中的虚拟索引
       * @param {ColumnInfo} column 列配置
       */
      getVMColumnIndex: createGetColumnCacheProp("$index"),
      /**
       * 创建 data 对象
       * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义
       * @param {Array} records 新数据
       */
      createData(records) {
        return nextTick().then(() => {
          return reactive(tablePrivateMethods.defineField(records));
        });
      },
      /**
       * 创建 Row|Rows 对象
       * 对于某些特殊场景需要对数据进行手动插入时可能会用到
       * @param {Array/Object} records 新数据
       */
      createRow(records) {
        const isArr = import_xe_utils18.default.isArray(records);
        if (!isArr) {
          records = [records || {}];
        }
        return tableMethods.createData(records).then((rows) => isArr ? rows : rows[0]);
      },
      /**
       * 还原数据
       * 如果不传任何参数，则还原整个表格
       * 如果传 row 则还原一行
       * 如果传 rows 则还原多行
       * 如果还额外传了 field 则还原指定的单元格数据
       */
      revertData(rows, field) {
        const { keepSource, treeConfig } = props;
        const { fullAllDataRowIdData, fullDataRowIdData, tableSourceData, sourceDataRowIdData, tableFullData, afterFullData, removeRowMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform } = treeOpts;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        if (!keepSource) {
          errLog("vxe.error.reqProp", ["keep-source"]);
          return nextTick();
        }
        let targetRows = rows;
        if (rows) {
          if (!import_xe_utils18.default.isArray(rows)) {
            targetRows = [rows];
          }
        } else {
          targetRows = import_xe_utils18.default.toArray($xeTable.getUpdateRecords());
        }
        let reDelFlag = false;
        if (targetRows.length) {
          targetRows.forEach((item) => {
            const rowid = handleGetRowId(item);
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const row = rowRest.row;
              if (!$xeTable.isInsertByRow(row)) {
                const oRow = sourceDataRowIdData[rowid];
                if (oRow && row) {
                  if (field) {
                    import_xe_utils18.default.set(row, field, import_xe_utils18.default.clone(import_xe_utils18.default.get(oRow, field), true));
                  } else {
                    import_xe_utils18.default.destructuring(row, import_xe_utils18.default.clone(oRow, true));
                  }
                  if (!fullDataRowIdData[rowid] && $xeTable.isRemoveByRow(row)) {
                    if (removeRowMaps[rowid]) {
                      delete removeRowMaps[rowid];
                    }
                    tableFullData.unshift(row);
                    afterFullData.unshift(row);
                    reDelFlag = true;
                  }
                }
              }
            }
          });
        }
        if (rows) {
          if (reDelFlag) {
            reactData.removeRowFlag++;
            $xeTable.updateFooter();
            $xeTable.cacheRowMap(false);
            $xeTable.handleTableData(treeConfig && transform);
            if (!(treeConfig && transform)) {
              $xeTable.updateAfterDataIndex();
            }
            $xeTable.checkSelectionStatus();
            if (reactData.scrollYLoad) {
              $xeTable.updateScrollYSpace();
            }
          }
          return nextTick().then(() => {
            $xeTable.updateCellAreas();
            return handleLazyRecalculate(false, true, true);
          });
        }
        return $xeTable.reloadData(tableSourceData);
      },
      /**
       * 清空单元格内容
       * 如果不创参数，则清空整个表格内容
       * 如果传 row 则清空一行内容
       * 如果传 rows 则清空多行内容
       * 如果还额外传了 field 则清空指定单元格内容
       * @param {Array/Row} rows 行数据
       * @param {String} field 字段名
       */
      clearData(rows, field) {
        const { tableFullData, visibleColumn } = internalData;
        if (!arguments.length) {
          rows = tableFullData;
        } else if (rows && !import_xe_utils18.default.isArray(rows)) {
          rows = [rows];
        }
        if (field) {
          rows.forEach((row) => import_xe_utils18.default.set(row, field, null));
        } else {
          rows.forEach((row) => {
            visibleColumn.forEach((column) => {
              if (column.field) {
                setCellValue(row, column, null);
              }
            });
          });
        }
        return nextTick();
      },
      getCellElement(row, fieldOrColumn) {
        const { elemStore } = internalData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (!column) {
          return null;
        }
        const rowid = getRowid($xeTable, row);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        let bodyElem;
        if (column) {
          if (column.fixed) {
            if (column.fixed === "left") {
              if (leftScrollElem) {
                bodyElem = leftScrollElem;
              }
            } else {
              if (rightScrollElem) {
                bodyElem = rightScrollElem;
              }
            }
          }
          if (!bodyElem) {
            bodyElem = bodyScrollElem;
          }
          if (bodyElem) {
            return bodyElem.querySelector(`.vxe-body--row[rowid="${rowid}"] .${column.id}`);
          }
        }
        return null;
      },
      getCellLabel(row, fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (!column) {
          return null;
        }
        const { formatter } = column;
        const cellValue = getCellValue(row, column);
        let cellLabel = cellValue;
        if (formatter) {
          let formatData;
          const { fullAllDataRowIdData } = internalData;
          const rowid = getRowid($xeTable, row);
          const colid = column.id;
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            formatData = rowRest.formatData;
            if (!formatData) {
              formatData = fullAllDataRowIdData[rowid].formatData = {};
            }
            if (rowRest && formatData[colid]) {
              if (formatData[colid].value === cellValue) {
                return formatData[colid].label;
              }
            }
          }
          const formatParams = {
            cellValue,
            row,
            rowIndex: $xeTable.getRowIndex(row),
            column,
            columnIndex: $xeTable.getColumnIndex(column)
          };
          if (import_xe_utils18.default.isString(formatter)) {
            const gFormatOpts = formats.get(formatter);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams) : "";
          } else if (import_xe_utils18.default.isArray(formatter)) {
            const gFormatOpts = formats.get(formatter[0]);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams, ...formatter.slice(1)) : "";
          } else {
            cellLabel = formatter(formatParams);
          }
          if (formatData) {
            formatData[colid] = { value: cellValue, label: cellLabel };
          }
        }
        return cellLabel;
      },
      getFooterCellLabel(row, fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (!column) {
          return null;
        }
        const { footerFormatter } = column;
        const _columnIndex = $xeTable.getVTColumnIndex(column);
        let itemValue = "";
        if (import_xe_utils18.default.isArray(row)) {
          itemValue = row[_columnIndex];
        } else {
          itemValue = import_xe_utils18.default.get(row, column.field);
        }
        let cellLabel = itemValue;
        if (footerFormatter) {
          let formatData;
          const { footerTableData } = reactData;
          const { footerFullDataRowData } = internalData;
          const colid = column.id;
          const $rowIndex = footerTableData.indexOf(row);
          let rowRest = null;
          if ($rowIndex > -1) {
            rowRest = footerFullDataRowData[$rowIndex];
            if (!rowRest) {
              rowRest = footerFullDataRowData[$rowIndex] = {};
            }
            formatData = rowRest.formatData;
            if (!formatData) {
              formatData = footerFullDataRowData[$rowIndex].formatData = {};
            }
            if (rowRest && formatData[colid]) {
              if (formatData[colid].value === itemValue) {
                return formatData[colid].label;
              }
            }
          }
          const footerFormatParams = {
            cellValue: itemValue,
            itemValue,
            row,
            items: row,
            $rowIndex,
            column,
            _columnIndex,
            columnIndex: $xeTable.getColumnIndex(column)
          };
          if (import_xe_utils18.default.isString(footerFormatter)) {
            const gFormatOpts = formats.get(footerFormatter);
            const fcFormatMethod = gFormatOpts ? gFormatOpts.tableFooterCellFormatMethod : null;
            cellLabel = fcFormatMethod ? fcFormatMethod(footerFormatParams) : "";
          } else if (import_xe_utils18.default.isArray(footerFormatter)) {
            const gFormatOpts = formats.get(footerFormatter[0]);
            const fcFormatMethod = gFormatOpts ? gFormatOpts.tableFooterCellFormatMethod : null;
            cellLabel = fcFormatMethod ? fcFormatMethod(footerFormatParams, ...footerFormatter.slice(1)) : "";
          } else {
            cellLabel = footerFormatter(footerFormatParams);
          }
          if (formatData) {
            formatData[colid] = { value: itemValue, label: cellLabel };
          }
        }
        return cellLabel;
      },
      /**
       * 检查是否为临时行数据
       */
      isInsertByRow(row) {
        const rowid = getRowid($xeTable, row);
        return !!reactData.insertRowFlag && !!internalData.insertRowMaps[rowid];
      },
      isRemoveByRow(row) {
        const rowid = getRowid($xeTable, row);
        return !!reactData.removeRowFlag && !!internalData.removeRowMaps[rowid];
      },
      /**
       * 删除所有新增的临时数据
       */
      removeInsertRow() {
        const { insertRowMaps } = internalData;
        return $xeTable.remove(import_xe_utils18.default.values(insertRowMaps));
      },
      /**
       * 检查行或列数据是否发生改变
       */
      isUpdateByRow(rowidOrRow, field) {
        const { keepSource } = props;
        const { tableFullColumn, fullDataRowIdData, sourceDataRowIdData } = internalData;
        if (keepSource) {
          const rowid = import_xe_utils18.default.isString(rowidOrRow) || import_xe_utils18.default.isNumber(rowidOrRow) ? rowidOrRow : getRowid($xeTable, rowidOrRow);
          const rowRest = fullDataRowIdData[rowid];
          if (!rowRest) {
            return false;
          }
          const row = rowRest.row;
          const oRow = sourceDataRowIdData[rowid];
          if (oRow) {
            if (arguments.length > 1) {
              return !eqCellValue(oRow, row, field);
            }
            for (let index = 0, len = tableFullColumn.length; index < len; index++) {
              const property = tableFullColumn[index].field;
              if (property && !eqCellValue(oRow, row, property)) {
                return true;
              }
            }
          }
        }
        return false;
      },
      /**
       * 获取表格的可视列，也可以指定索引获取列
       * @param {Number} columnIndex 索引
       */
      getColumns(columnIndex) {
        const { visibleColumn } = internalData;
        return import_xe_utils18.default.isUndefined(columnIndex) ? visibleColumn.slice(0) : visibleColumn[columnIndex];
      },
      /**
       * 根据列获取列的唯一主键
       */
      getColid(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        return column ? column.id : null;
      },
      /**
       * 根据列的唯一主键获取列
       * @param {String} colid 列主键
       */
      getColumnById(colid) {
        const { fullColumnIdData } = internalData;
        return colid && fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;
      },
      /**
       * 根据列的字段名获取列
       * @param {String} field 字段名
       */
      getColumnByField(field) {
        const fullColumnFieldData = internalData.fullColumnFieldData;
        return field && fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;
      },
      getParentColumn(fieldOrColumn) {
        const { fullColumnIdData } = internalData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        return column && column.parentId && fullColumnIdData[column.parentId] ? fullColumnIdData[column.parentId].column : null;
      },
      /**
       * 获取当前表格的列
       * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列
       */
      getTableColumn() {
        return {
          collectColumn: internalData.collectColumn.slice(0),
          fullColumn: internalData.tableFullColumn.slice(0),
          visibleColumn: internalData.visibleColumn.slice(0),
          tableColumn: reactData.tableColumn.slice(0)
        };
      },
      /**
       * 移动列到指定列的位置
       * @param fieldOrColumn
       * @param targetFieldOrColumn
       * @param options
       */
      moveColumnTo(fieldOrColumn, targetFieldOrColumn, options) {
        const { fullColumnIdData, visibleColumn } = internalData;
        const { dragToChild, dragPos, isCrossDrag } = Object.assign({}, options);
        const dragCol = handleFieldOrColumn($xeTable, fieldOrColumn);
        let prevDragCol = null;
        const colRest = dragCol ? fullColumnIdData[dragCol.id] : null;
        let defPos = "left";
        if (import_xe_utils18.default.isNumber(targetFieldOrColumn)) {
          if (colRest && targetFieldOrColumn) {
            let currList = colRest.items;
            let offsetIndex = colRest._index + targetFieldOrColumn;
            if (isCrossDrag) {
              currList = visibleColumn;
              offsetIndex = colRest._index + targetFieldOrColumn;
            }
            if (offsetIndex > 0 && offsetIndex < currList.length - 1) {
              prevDragCol = currList[offsetIndex];
            }
            if (targetFieldOrColumn > 0) {
              defPos = "right";
            }
          }
        } else {
          prevDragCol = handleFieldOrColumn($xeTable, targetFieldOrColumn);
          const targetColRest = prevDragCol ? fullColumnIdData[prevDragCol.id] : null;
          if (colRest && targetColRest) {
            if (targetColRest._index > colRest._index) {
              defPos = "right";
            }
          }
        }
        return $xeTable.handleColDragSwapEvent(null, true, dragCol, prevDragCol, dragPos || defPos, dragToChild === true);
      },
      /**
       * 移动行到指定行的位置
       * @param rowidOrRow
       * @param targetRowidOrRow
       * @param options
       */
      moveRowTo(rowidOrRow, targetRowidOrRow, options) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData, afterFullData } = internalData;
        const { dragToChild, dragPos, isCrossDrag } = Object.assign({}, options);
        const treeOpts = computeTreeOpts.value;
        const dragRow = handleRowidOrRow($xeTable, rowidOrRow);
        let prevDragRow = null;
        let defPos = "top";
        const rowRest = dragRow ? fullAllDataRowIdData[getRowid($xeTable, dragRow)] : null;
        if (import_xe_utils18.default.isNumber(targetRowidOrRow)) {
          if (rowRest && targetRowidOrRow) {
            let currList = afterFullData;
            let offsetIndex = rowRest._index + targetRowidOrRow;
            if (treeConfig) {
              currList = rowRest.items;
              if (treeOpts.transform) {
                offsetIndex = rowRest.treeIndex + targetRowidOrRow;
                if (isCrossDrag) {
                  currList = afterFullData;
                  offsetIndex = rowRest._index + targetRowidOrRow;
                }
              }
            }
            if (offsetIndex >= 0 && offsetIndex <= currList.length - 1) {
              prevDragRow = currList[offsetIndex];
            }
            if (targetRowidOrRow > 0) {
              defPos = "bottom";
            }
          }
        } else {
          prevDragRow = handleRowidOrRow($xeTable, targetRowidOrRow);
          const targetRowRest = prevDragRow ? fullAllDataRowIdData[getRowid($xeTable, prevDragRow)] : null;
          if (rowRest && targetRowRest) {
            if (targetRowRest._index > rowRest._index) {
              defPos = "bottom";
            }
          }
        }
        const rest = $xeTable.handleRowDragSwapEvent(null, true, dragRow, prevDragRow, dragPos || defPos, dragToChild === true);
        return rest;
      },
      /**
       * 获取表格的全量列
       */
      getFullColumns() {
        const { collectColumn } = internalData;
        return collectColumn.slice(0);
      },
      /**
       * 获取数据，和 data 的行为一致，也可以指定索引获取数据
       */
      getData(rowIndex) {
        const tableSynchData = props.data || internalData.tableSynchData;
        return import_xe_utils18.default.isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];
      },
      /**
       * 用于多选行，获取已选中的数据
       */
      getCheckboxRecords(isFull) {
        const { treeConfig } = props;
        const { updateCheckboxFlag } = reactData;
        const { tableFullData, afterFullData, tableFullTreeData, fullDataRowIdData, afterFullRowMaps, selectCheckboxMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const { checkField } = checkboxOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let rowList = [];
        if (updateCheckboxFlag) {
          if (checkField) {
            if (treeConfig) {
              const currTableData = isFull ? transform ? tableFullTreeData : tableFullData : transform ? tableFullTreeData : afterFullData;
              rowList = import_xe_utils18.default.filterTree(currTableData, (row) => import_xe_utils18.default.get(row, checkField), { children: transform ? mapChildrenField : childrenField });
            } else {
              const currTableData = isFull ? tableFullData : afterFullData;
              rowList = currTableData.filter((row) => import_xe_utils18.default.get(row, checkField));
            }
          } else {
            const currMaps = isFull || treeConfig && !transform ? fullDataRowIdData : afterFullRowMaps;
            import_xe_utils18.default.each(selectCheckboxMaps, (row, rowid) => {
              if (currMaps[rowid]) {
                rowList.push(fullDataRowIdData[rowid].row);
              }
            });
          }
        }
        return rowList;
      },
      /**
       * 只对 tree-config 有效，获取行的子级
       */
      getTreeRowChildren(rowOrRowid) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (import_xe_utils18.default.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xeTable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullAllDataRowIdData[rowid];
            const row = rest ? rest.row : null;
            if (row) {
              return row[transform ? mapChildrenField : childrenField] || [];
            }
          }
        }
        return [];
      },
      /**
       * 只对 tree-config 有效，用于树形结构，获取指定行的层级
       */
      getTreeRowLevel(rowOrRowid) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData } = internalData;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (import_xe_utils18.default.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xeTable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullAllDataRowIdData[rowid];
            if (rest) {
              return rest.level;
            }
          }
        }
        return -1;
      },
      /**
       * 只对 tree-config 有效，获取行的父级
       */
      getTreeParentRow(rowOrRowid) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData } = internalData;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (import_xe_utils18.default.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xeTable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullAllDataRowIdData[rowid];
            if (rest) {
              return rest.parent;
            }
          }
        }
        return null;
      },
      getParentRow(rowOrRowid) {
        warnLog("vxe.error.delFunc", ["getParentRow", "getTreeParentRow"]);
        return $xeTable.getTreeParentRow(rowOrRowid);
      },
      /**
       * 根据行的唯一主键获取行
       * @param {String/Number} rowid 行主键
       */
      getRowById(cellValue) {
        const { fullAllDataRowIdData } = internalData;
        const rowid = import_xe_utils18.default.eqNull(cellValue) ? "" : encodeURIComponent(cellValue || "");
        return fullAllDataRowIdData[rowid] ? fullAllDataRowIdData[rowid].row : null;
      },
      /**
       * 根据行获取行的唯一主键
       * @param {Row} row 行对象
       */
      getRowid(row) {
        return getRowid($xeTable, row);
      },
      /**
       * 获取处理后的表格数据
       * 如果存在筛选条件，继续处理
       * 如果存在排序，继续处理
       */
      getTableData() {
        const { tableData, footerTableData } = reactData;
        const { tableFullData, afterFullData, tableFullTreeData } = internalData;
        return {
          fullData: props.treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0),
          visibleData: afterFullData.slice(0),
          tableData: tableData.slice(0),
          footerData: footerTableData.slice(0)
        };
      },
      /**
       * 获取表格的全量数据，如果是 tree-config 则返回带层级的树结构
       */
      getFullData() {
        const { treeConfig } = props;
        const { tableFullData, tableFullTreeData } = internalData;
        if (treeConfig) {
          const treeOpts = computeTreeOpts.value;
          const { transform, mapChildrenField, rowField, parentField } = treeOpts;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          if (transform) {
            return import_xe_utils18.default.toArrayTree(import_xe_utils18.default.toTreeArray(tableFullTreeData, {
              children: mapChildrenField
            }), {
              key: rowField,
              parentKey: parentField,
              children: childrenField,
              mapChildren: mapChildrenField
            });
          }
          return tableFullTreeData.slice(0);
        }
        return tableFullData.slice(0);
      },
      /**
       * 设置为固定列
       */
      setColumnFixed(fieldOrColumn, fixed) {
        let status = false;
        const cols = import_xe_utils18.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        const columnOpts = computeColumnOpts.value;
        const isMaxFixedColumn = computeIsMaxFixedColumn.value;
        for (let i = 0; i < cols.length; i++) {
          const item = cols[i];
          const column = handleFieldOrColumn($xeTable, item);
          const targetColumn = getRootColumn($xeTable, column);
          if (targetColumn && targetColumn.fixed !== fixed) {
            if (!targetColumn.fixed && isMaxFixedColumn) {
              if (VxeUI.modal) {
                VxeUI.modal.message({
                  status: "error",
                  content: getI18n10("vxe.table.maxFixedCol", [columnOpts.maxFixedSize])
                });
              }
              return nextTick();
            }
            import_xe_utils18.default.eachTree([targetColumn], (column2) => {
              column2.fixed = fixed;
              column2.renderFixed = fixed;
            });
            tablePrivateMethods.saveCustomStore("update:fixed");
            if (!status) {
              status = true;
            }
          }
        }
        if (status) {
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 取消指定固定列
       */
      clearColumnFixed(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils18.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          const targetColumn = getRootColumn($xeTable, column);
          if (targetColumn && targetColumn.fixed) {
            import_xe_utils18.default.eachTree([targetColumn], (column2) => {
              column2.fixed = null;
              column2.renderFixed = null;
            });
            tablePrivateMethods.saveCustomStore("update:fixed");
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 隐藏指定列
       */
      hideColumn(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils18.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          if (column && column.visible) {
            column.visible = false;
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      /**
       * 显示指定列
       */
      showColumn(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils18.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          if (column && !column.visible) {
            column.visible = true;
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      setColumnWidth(fieldOrColumn, width) {
        const { elemStore } = internalData;
        let status = false;
        const cols = import_xe_utils18.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        let cWidth = import_xe_utils18.default.toInteger(width);
        if (isScale(width)) {
          const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
          const bodyWidth = bodyScrollElem ? bodyScrollElem.clientWidth - 1 : 0;
          cWidth = Math.floor(cWidth * bodyWidth);
        }
        if (cWidth) {
          cols.forEach((item) => {
            const column = handleFieldOrColumn($xeTable, item);
            if (column) {
              column.resizeWidth = cWidth;
              if (!status) {
                status = true;
              }
            }
          });
          if (status) {
            return $xeTable.refreshColumn().then(() => {
              return { status };
            });
          }
        }
        return nextTick().then(() => {
          return { status };
        });
      },
      getColumnWidth(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          return column.renderWidth;
        }
        return 0;
      },
      /**
       * 手动重置列的显示隐藏、列宽拖动的状态、固定列、排序列；
       * 如果为 true 则重置所有状态
       * 如果已关联工具栏，则会同步更新
       */
      resetColumn(options) {
        warnLog("vxe.error.delFunc", ["resetColumn", "resetCustom"]);
        return $xeTable.resetCustom(options);
      },
      /**
       * 刷新列信息
       * 将固定的列左边、右边分别靠边
       * 如果传 true 则会检查列顺序并排序
       */
      refreshColumn(initSort) {
        if (initSort) {
          handleUpdateColumn();
        }
        return parseColumns(true).then(() => {
          return $xeTable.refreshScroll();
        }).then(() => {
          return handleLazyRecalculate(false, true, true);
        });
      },
      setRowHeightConf(heightConf) {
        const { fullAllDataRowIdData } = internalData;
        let status = false;
        if (heightConf) {
          import_xe_utils18.default.each(heightConf, (height, rowid) => {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const rHeight = import_xe_utils18.default.toInteger(height);
              if (rHeight) {
                rowRest.resizeHeight = rHeight;
                if (!status) {
                  status = true;
                }
              }
            }
          });
          if (status) {
            internalData.isResizeCellHeight = true;
            reactData.resizeHeightFlag++;
          }
        }
        return nextTick().then(() => {
          updateRowOffsetTop();
          return { status };
        });
      },
      getRowHeightConf(isFull) {
        const { fullAllDataRowIdData, afterFullData } = internalData;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        const defaultRowHeight = computeDefaultRowHeight.value;
        const rest = {};
        afterFullData.forEach((row) => {
          const rowid = handleGetRowId(row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            const resizeHeight = rowRest.resizeHeight;
            if (resizeHeight || isFull) {
              const currCellHeight = resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
              rest[rowid] = currCellHeight;
            }
          }
        });
        return rest;
      },
      recalcRowHeight(rowOrId) {
        const { fullAllDataRowIdData } = internalData;
        const rows = import_xe_utils18.default.isArray(rowOrId) ? rowOrId : [rowOrId];
        const el = refElem.value;
        if (el) {
          const { handleGetRowId } = createHandleGetRowId($xeTable);
          el.setAttribute("data-calc-row", "Y");
          rows.forEach((row) => {
            const rowid = import_xe_utils18.default.isString(row) || import_xe_utils18.default.isNumber(row) ? row : handleGetRowId(row);
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest.resizeHeight = calcCellAutoHeight(rowRest, el);
            }
            el.removeAttribute("data-calc-row");
          });
          reactData.calcCellHeightFlag++;
        }
        return nextTick();
      },
      setRowHeight(rowOrId, height) {
        const { fullAllDataRowIdData } = internalData;
        let status = false;
        const rows = import_xe_utils18.default.isArray(rowOrId) ? rowOrId : [rowOrId];
        let rHeight = import_xe_utils18.default.toInteger(height);
        if (isScale(height)) {
          const tableBody = refTableBody.value;
          const bodyElem = tableBody ? tableBody.$el : null;
          const bodyHeight = bodyElem ? bodyElem.clientHeight - 1 : 0;
          rHeight = Math.floor(rHeight * bodyHeight);
        }
        if (rHeight) {
          const { handleGetRowId } = createHandleGetRowId($xeTable);
          rows.forEach((row) => {
            const rowid = import_xe_utils18.default.isString(row) || import_xe_utils18.default.isNumber(row) ? row : handleGetRowId(row);
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest.resizeHeight = rHeight;
              if (!status) {
                status = true;
              }
            }
          });
          if (status) {
            internalData.isResizeCellHeight = true;
            reactData.resizeHeightFlag++;
          }
        }
        return nextTick().then(() => {
          return { status };
        });
      },
      getRowHeight(rowOrId) {
        const { fullAllDataRowIdData } = internalData;
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        const defaultRowHeight = computeDefaultRowHeight.value;
        const rowid = import_xe_utils18.default.isString(rowOrId) || import_xe_utils18.default.isNumber(rowOrId) ? rowOrId : getRowid($xeTable, rowOrId);
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          return rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
        }
        return 0;
      },
      /**
       * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）
       */
      refreshScroll() {
        const { elemStore, lastScrollLeft, lastScrollTop } = internalData;
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        return new Promise((resolve) => {
          if (lastScrollLeft || lastScrollTop) {
            return restoreScrollLocation($xeTable, lastScrollLeft, lastScrollTop).then(() => {
              setTimeout(resolve, 10);
            });
          }
          internalData.intoRunScroll = true;
          setScrollTop(yHandleEl, lastScrollTop);
          setScrollTop(bodyScrollElem, lastScrollTop);
          setScrollTop(leftScrollElem, lastScrollTop);
          setScrollTop(rightScrollElem, lastScrollTop);
          setScrollLeft(xHandleEl, lastScrollLeft);
          setScrollLeft(bodyScrollElem, lastScrollLeft);
          setScrollLeft(headerScrollElem, lastScrollLeft);
          setScrollLeft(footerScrollElem, lastScrollLeft);
          setTimeout(() => {
            internalData.intoRunScroll = false;
            resolve();
          }, 10);
        });
      },
      /**
       * 重新渲染布局
       * 刷新布局
       */
      recalculate(reFull) {
        const isForce = !!reFull;
        return handleLazyRecalculate(isForce, isForce, isForce);
      },
      openTooltip(target, content) {
        const $commTip = refCommTooltip.value;
        if ($commTip && $commTip.open) {
          return $commTip.open(target, content);
        }
        return nextTick();
      },
      /**
       * 关闭 tooltip
       */
      closeTooltip() {
        const { tooltipStore } = reactData;
        const $tooltip = refTooltip.value;
        const $commTip = refCommTooltip.value;
        if (tooltipStore.visible) {
          Object.assign(tooltipStore, {
            row: null,
            column: null,
            content: null,
            visible: false,
            type: null,
            currOpts: {}
          });
          if ($tooltip && $tooltip.close) {
            $tooltip.close();
          }
        }
        if ($commTip && $commTip.close) {
          $commTip.close();
        }
        return nextTick();
      },
      /**
       * 判断列头复选框是否被选中
       */
      isAllCheckboxChecked() {
        return reactData.isAllSelected;
      },
      /**
       * 判断列头复选框是否被半选
       */
      isAllCheckboxIndeterminate() {
        return !reactData.isAllSelected && reactData.isIndeterminate;
      },
      /**
       * 获取复选框半选状态的行数据
       */
      getCheckboxIndeterminateRecords(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData, treeIndeterminateRowMaps } = internalData;
        if (treeConfig) {
          const fullRest = [];
          const defRest = [];
          import_xe_utils18.default.each(treeIndeterminateRowMaps, (item, rowid) => {
            if (item) {
              fullRest.push(item);
              if (fullDataRowIdData[rowid]) {
                defRest.push(item);
              }
            }
          });
          if (isFull) {
            return fullRest;
          }
          return defRest;
        }
        return [];
      },
      /**
       * 用于多选行，设置行为选中状态，第二个参数为选中与否
       * @param {Array/Row} rows 行数据
       * @param {Boolean} value 是否选中
       */
      setCheckboxRow(rows, checked) {
        if (rows && !import_xe_utils18.default.isArray(rows)) {
          rows = [rows];
        }
        return handleCheckedCheckboxRow(rows, checked, true);
      },
      setCheckboxRowKey(keys, checked) {
        const { fullAllDataRowIdData } = internalData;
        if (!import_xe_utils18.default.isArray(keys)) {
          keys = [keys];
        }
        const rows = [];
        keys.forEach((rowid) => {
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            rows.push(rowRest.row);
          }
        });
        return handleCheckedCheckboxRow(rows, checked, true);
      },
      isCheckedByCheckboxRow(row) {
        const { updateCheckboxFlag } = reactData;
        const { selectCheckboxMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        if (checkField) {
          return import_xe_utils18.default.get(row, checkField);
        }
        return !!updateCheckboxFlag && !!selectCheckboxMaps[getRowid($xeTable, row)];
      },
      isCheckedByCheckboxRowKey(rowid) {
        const { updateCheckboxFlag } = reactData;
        const { fullAllDataRowIdData, selectCheckboxMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        if (checkField) {
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            return import_xe_utils18.default.get(rowRest.row, checkField);
          }
          return false;
        }
        return !!updateCheckboxFlag && !!selectCheckboxMaps[rowid];
      },
      isIndeterminateByCheckboxRow(row) {
        const { treeIndeterminateRowMaps } = internalData;
        return !!treeIndeterminateRowMaps[getRowid($xeTable, row)] && !$xeTable.isCheckedByCheckboxRow(row);
      },
      isIndeterminateByCheckboxRowKey(rowid) {
        const { treeIndeterminateRowMaps } = internalData;
        return !!treeIndeterminateRowMaps[rowid] && !$xeTable.isCheckedByCheckboxRowKey(rowid);
      },
      /**
       * 多选，切换某一行的选中状态
       */
      toggleCheckboxRow(row) {
        const { selectCheckboxMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        const checked = checkField ? !import_xe_utils18.default.get(row, checkField) : !selectCheckboxMaps[getRowid($xeTable, row)];
        tablePrivateMethods.handleBatchSelectRows([row], checked, true);
        tablePrivateMethods.checkSelectionStatus();
        return nextTick();
      },
      /**
       * 用于多选行，设置所有行的选中状态
       * @param {Boolean} value 是否选中
       */
      setAllCheckboxRow(value) {
        return handleCheckedAllCheckboxRow(value, true);
      },
      /**
       * 获取单选框保留选中的行
       */
      getRadioReserveRecord(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData, radioReserveRow, afterFullData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (radioOpts.reserve && radioReserveRow) {
          const rowid = getRowid($xeTable, radioReserveRow);
          if (isFull) {
            if (!fullDataRowIdData[rowid]) {
              return radioReserveRow;
            }
          } else {
            const rowkey = getRowkey($xeTable);
            if (treeConfig) {
              const matchObj = import_xe_utils18.default.findTree(afterFullData, (row) => rowid === import_xe_utils18.default.get(row, rowkey), { children: childrenField });
              if (matchObj) {
                return radioReserveRow;
              }
            } else {
              if (!afterFullData.some((row) => rowid === import_xe_utils18.default.get(row, rowkey))) {
                return radioReserveRow;
              }
            }
          }
        }
        return null;
      },
      clearRadioReserve() {
        internalData.radioReserveRow = null;
        return nextTick();
      },
      /**
       * 获取复选框保留选中的行
       */
      getCheckboxReserveRecords(isFull) {
        const { treeConfig } = props;
        const { afterFullData, fullDataRowIdData, checkboxReserveRowMap } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const reserveSelection = [];
        if (checkboxOpts.reserve) {
          const { handleGetRowId } = createHandleGetRowId($xeTable);
          const afterFullIdMaps = {};
          if (treeConfig) {
            import_xe_utils18.default.eachTree(afterFullData, (row) => {
              afterFullIdMaps[handleGetRowId(row)] = 1;
            }, { children: childrenField });
          } else {
            afterFullData.forEach((row) => {
              afterFullIdMaps[handleGetRowId(row)] = 1;
            });
          }
          import_xe_utils18.default.each(checkboxReserveRowMap, (oldRow, oldRowid) => {
            if (oldRow) {
              if (isFull) {
                if (!fullDataRowIdData[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              } else {
                if (!afterFullIdMaps[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              }
            }
          });
        }
        return reserveSelection;
      },
      clearCheckboxReserve() {
        internalData.checkboxReserveRowMap = {};
        return nextTick();
      },
      /**
       * 多选，切换所有行的选中状态
       */
      toggleAllCheckboxRow() {
        handleCheckAllEvent(null, !reactData.isAllSelected);
        return nextTick();
      },
      /**
       * 用于多选行，手动清空用户的选择
       * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态
       */
      clearCheckboxRow() {
        const { treeConfig } = props;
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, reserve } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (checkField) {
          const handleClearChecked = (item) => {
            if (treeConfig && indeterminateField) {
              import_xe_utils18.default.set(item, indeterminateField, false);
            }
            import_xe_utils18.default.set(item, checkField, false);
          };
          if (treeConfig) {
            import_xe_utils18.default.eachTree(tableFullData, handleClearChecked, { children: childrenField });
          } else {
            tableFullData.forEach(handleClearChecked);
          }
        }
        if (reserve) {
          tableFullData.forEach((row) => handleCheckboxReserveRow(row, false));
        }
        reactData.isAllSelected = false;
        reactData.isIndeterminate = false;
        internalData.selectCheckboxMaps = {};
        internalData.treeIndeterminateRowMaps = {};
        reactData.updateCheckboxFlag++;
        return nextTick();
      },
      /**
       * 用于当前行，设置某一行为高亮状态
       * @param {Row} row 行对象
       */
      setCurrentRow(row) {
        const $xeGanttView = internalData.xeGanttView;
        const rowOpts = computeRowOpts.value;
        const el = refElem.value;
        tableMethods.clearCurrentRow();
        reactData.currentRow = row;
        if (rowOpts.isCurrent || props.highlightCurrentRow) {
          if (el) {
            import_xe_utils18.default.arrayEach(el.querySelectorAll(`[rowid="${getRowid($xeTable, row)}"]`), (elem) => addClass(elem, "row--current"));
          }
        }
        if ($xeGanttView && $xeGanttView.handleUpdateCurrentRow) {
          $xeGanttView.handleUpdateCurrentRow(row);
        }
        return nextTick();
      },
      isCheckedByRadioRow(row) {
        const { selectRadioRow } = reactData;
        if (row && selectRadioRow) {
          return $xeTable.eqRow(selectRadioRow, row);
        }
        return false;
      },
      isCheckedByRadioRowKey(key) {
        const { selectRadioRow } = reactData;
        if (selectRadioRow) {
          return key === getRowid($xeTable, selectRadioRow);
        }
        return false;
      },
      /**
       * 用于单选行，设置某一行为选中状态
       * @param {Row} row 行对象
       */
      setRadioRow(row) {
        return handleCheckedRadioRow(row, true);
      },
      /**
       * 用于单选行，设置某一行为选中状态
       * @param key 行主键
       */
      setRadioRowKey(rowid) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          return handleCheckedRadioRow(rowRest.row, true);
        }
        return nextTick();
      },
      /**
       * 用于当前行，手动清空当前高亮的状态
       */
      clearCurrentRow() {
        const $xeGanttView = internalData.xeGanttView;
        const el = refElem.value;
        reactData.currentRow = null;
        internalData.hoverRow = null;
        if (el) {
          import_xe_utils18.default.arrayEach(el.querySelectorAll(".row--current"), (elem) => removeClass(elem, "row--current"));
        }
        if ($xeGanttView && $xeGanttView.handleUpdateCurrentRow) {
          $xeGanttView.handleUpdateCurrentRow();
        }
        return nextTick();
      },
      /**
       * 用于单选行，手动清空用户的选择
       */
      clearRadioRow() {
        reactData.selectRadioRow = null;
        return nextTick();
      },
      /**
       * 用于当前行，获取当前行的数据
       */
      getCurrentRecord(isFull) {
        const { currentRow } = reactData;
        const { fullDataRowIdData, afterFullRowMaps } = internalData;
        const rowOpts = computeRowOpts.value;
        if (rowOpts.isCurrent || props.highlightCurrentRow) {
          const rowid = getRowid($xeTable, currentRow);
          if (isFull) {
            if (fullDataRowIdData[rowid]) {
              return currentRow;
            }
          } else {
            if (afterFullRowMaps[rowid]) {
              return currentRow;
            }
          }
        }
        return null;
      },
      /**
       * 用于单选行，获取当已选中的数据
       */
      getRadioRecord(isFull) {
        const { fullDataRowIdData, afterFullRowMaps } = internalData;
        const { selectRadioRow } = reactData;
        if (selectRadioRow) {
          const rowid = getRowid($xeTable, selectRadioRow);
          if (isFull) {
            if (fullDataRowIdData[rowid]) {
              return selectRadioRow;
            }
          } else {
            if (afterFullRowMaps[rowid]) {
              return selectRadioRow;
            }
          }
        }
        return null;
      },
      getCurrentColumn() {
        const columnOpts = computeColumnOpts.value;
        return columnOpts.isCurrent || props.highlightCurrentColumn ? reactData.currentColumn : null;
      },
      /**
       * 用于当前列，设置某列行为高亮状态
       */
      setCurrentColumn(fieldOrColumn) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        const isMouseSelected = mouseConfig && mouseOpts.selected;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          $xeTable.clearCurrentColumn();
          reactData.currentColumn = column;
        }
        return nextTick().then(() => {
          if (isMouseSelected) {
            $xeTable.addCellSelectedClass();
          }
        });
      },
      /**
       * 用于当前列，手动清空当前高亮的状态
       */
      clearCurrentColumn() {
        reactData.currentColumn = null;
        return nextTick();
      },
      setPendingRow(rows, status) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const { pendingRowMaps } = internalData;
        if (rows && !import_xe_utils18.default.isArray(rows)) {
          rows = [rows];
        }
        if (status) {
          rows.forEach((row) => {
            const rowid = handleGetRowId(row);
            if (rowid && !pendingRowMaps[rowid]) {
              pendingRowMaps[rowid] = row;
            }
          });
        } else {
          rows.forEach((row) => {
            const rowid = handleGetRowId(row);
            if (rowid && pendingRowMaps[rowid]) {
              delete pendingRowMaps[rowid];
            }
          });
        }
        reactData.pendingRowFlag++;
        return nextTick();
      },
      togglePendingRow(rows) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const { pendingRowMaps } = internalData;
        if (rows && !import_xe_utils18.default.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach((row) => {
          const rowid = handleGetRowId(row);
          if (rowid) {
            if (pendingRowMaps[rowid]) {
              delete pendingRowMaps[rowid];
            } else {
              pendingRowMaps[rowid] = row;
            }
          }
        });
        reactData.pendingRowFlag++;
        return nextTick();
      },
      hasPendingByRow(row) {
        return tableMethods.isPendingByRow(row);
      },
      isPendingByRow(row) {
        const { pendingRowMaps } = internalData;
        const rowid = getRowid($xeTable, row);
        return !!pendingRowMaps[rowid];
      },
      getPendingRecords() {
        const { fullAllDataRowIdData, pendingRowMaps } = internalData;
        const insertRecords = [];
        import_xe_utils18.default.each(pendingRowMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      clearPendingRow() {
        internalData.pendingRowMaps = {};
        reactData.pendingRowFlag++;
        return nextTick();
      },
      sort(sortConfs, sortOrder) {
        const sortOpts = computeSortOpts.value;
        const { multiple, remote, orders } = sortOpts;
        if (sortConfs) {
          if (import_xe_utils18.default.isString(sortConfs)) {
            sortConfs = [
              { field: sortConfs, order: sortOrder }
            ];
          }
        }
        if (!import_xe_utils18.default.isArray(sortConfs)) {
          sortConfs = [sortConfs];
        }
        if (sortConfs.length) {
          if (!multiple) {
            clearAllSort();
          }
          (multiple ? sortConfs : [sortConfs[0]]).forEach((confs, index) => {
            let { field, order } = confs;
            let column = field;
            if (import_xe_utils18.default.isString(field)) {
              column = tableMethods.getColumnByField(field);
            }
            if (column && column.sortable) {
              if (orders && orders.indexOf(order) === -1) {
                order = getNextSortOrder(column);
              }
              if (column.order !== order) {
                column.order = order;
              }
              column.sortTime = Date.now() + index;
            }
          });
          if (!remote) {
            tablePrivateMethods.handleTableData(true);
          }
          return nextTick().then(() => {
            updateRowOffsetTop();
            tableMethods.updateCellAreas();
            return updateStyle();
          });
        }
        return nextTick();
      },
      setSort(sortConfs, isUpdate) {
        return handleSortEvent(null, sortConfs, isUpdate);
      },
      setSortByEvent(evnt, sortConfs) {
        return handleSortEvent(evnt, sortConfs, true);
      },
      /**
       * 清空指定列的排序条件
       * 如果为空则清空所有列的排序条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearSort(fieldOrColumn) {
        const sortOpts = computeSortOpts.value;
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          if (column) {
            column.order = null;
          }
        } else {
          clearAllSort();
        }
        if (!sortOpts.remote) {
          $xeTable.handleTableData(true);
        }
        return nextTick().then(() => {
          updateRowOffsetTop();
          return updateStyle();
        });
      },
      clearSortByEvent(evnt, fieldOrColumn) {
        const { tableFullColumn } = internalData;
        const sortOpts = computeSortOpts.value;
        const { multiple } = sortOpts;
        const sortCols = [];
        let column = null;
        if (evnt) {
          if (fieldOrColumn) {
            column = handleFieldOrColumn($xeTable, fieldOrColumn);
            if (column) {
              column.order = null;
            }
          } else {
            tableFullColumn.forEach((column2) => {
              if (column2.order) {
                column2.order = null;
                sortCols.push(column2);
              }
            });
          }
          if (!sortOpts.remote) {
            $xeTable.handleTableData(true);
          }
          if (!multiple) {
            column = sortCols[0];
          }
          if (column) {
            $xeTable.handleColumnSortEvent(evnt, column);
          }
          if (multiple && sortCols.length) {
            const params = { $table: $xeTable, $event: evnt, cols: sortCols, sortList: [] };
            dispatchEvent("clear-all-sort", params, evnt);
          }
        }
        return nextTick().then(() => {
          updateRowOffsetTop();
          return updateStyle();
        });
      },
      isSort(fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          return column ? column.sortable && !!column.order : false;
        }
        return tableMethods.getSortColumns().length > 0;
      },
      getSortColumns() {
        const sortOpts = computeSortOpts.value;
        const { multiple, chronological } = sortOpts;
        const sortList = [];
        const { tableFullColumn } = internalData;
        tableFullColumn.forEach((column) => {
          const { field, order } = column;
          if (column.sortable && order) {
            sortList.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (multiple && chronological && sortList.length > 1) {
          return import_xe_utils18.default.orderBy(sortList, "sortTime");
        }
        return sortList;
      },
      setFilterByEvent(evnt, fieldOrColumn, options) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && column.filters) {
          column.filters = toFilters(options || [], column.id);
          return $xeTable.handleColumnConfirmFilter(column, evnt);
        }
        return nextTick();
      },
      /**
       * 关闭筛选
       * @param {Event} evnt 事件
       */
      closeFilter() {
        const { filterStore } = reactData;
        const { column, visible } = filterStore;
        filterStore.isAllSelected = false;
        filterStore.isIndeterminate = false;
        filterStore.visible = false;
        if (visible) {
          const field = column ? column.field : null;
          dispatchEvent("filter-visible", {
            column,
            property: field,
            field,
            filterList: () => $xeTable.getCheckedFilters(),
            visible: false
          }, null);
        }
        return nextTick();
      },
      /**
       * 判断指定列是否为筛选状态，如果为空则判断所有列
       * @param {String} fieldOrColumn 字段名
       */
      isActiveFilterByColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          return column.filters && column.filters.some((option) => option.checked);
        }
        return $xeTable.getCheckedFilters().length > 0;
      },
      isFilter(fieldOrColumn) {
        return tableMethods.isActiveFilterByColumn(fieldOrColumn);
      },
      clearFilterByEvent(evnt, fieldOrColumn) {
        const { filterStore } = reactData;
        const { tableFullColumn } = internalData;
        const filterOpts = computeFilterOpts.value;
        const { multiple } = filterOpts;
        const filterCols = [];
        let column = null;
        if (fieldOrColumn) {
          column = handleFieldOrColumn($xeTable, fieldOrColumn);
          if (column) {
            $xeTable.handleClearFilter(column);
          }
        } else {
          tableFullColumn.forEach((column2) => {
            if (column2.filters) {
              filterCols.push(column2);
              $xeTable.handleClearFilter(column2);
            }
          });
        }
        if (!fieldOrColumn || column !== filterStore.column) {
          Object.assign(filterStore, {
            isAllSelected: false,
            isIndeterminate: false,
            style: null,
            options: [],
            column: null,
            multiple: false,
            visible: false
          });
        }
        if (!filterOpts.remote) {
          $xeTable.updateData();
        }
        if (!multiple) {
          column = filterCols[0];
        }
        if (column) {
          const filterList = () => $xeTable.getCheckedFilters();
          const values = [];
          const datas = [];
          column.filters.forEach((item) => {
            if (item.checked) {
              values.push(item.value);
              datas.push(item.data);
            }
          });
          const params = {
            $table: $xeTable,
            $event: evnt,
            column,
            field: column.field,
            property: column.field,
            values,
            datas,
            filters: filterList,
            filterList
          };
          $xeTable.dispatchEvent("filter-change", params, evnt);
          $xeTable.dispatchEvent("clear-filter", params, evnt);
        }
        if (multiple && filterCols.length) {
          const params = { $table: $xeTable, $event: evnt, cols: filterCols, filterList: [] };
          dispatchEvent("clear-all-filter", params, evnt);
        }
        return nextTick();
      },
      /**
       * 判断展开行是否懒加载完成
       * @param {Row} row 行对象
       */
      isRowExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        return rowRest && !!rowRest.expandLoaded;
      },
      clearRowExpandLoaded(row) {
        const { fullAllDataRowIdData, rowExpandLazyLoadedMaps } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xeTable, row);
        const rowRest = fullAllDataRowIdData[rowid];
        if (lazy && rowRest) {
          rowRest.expandLoaded = false;
          delete rowExpandLazyLoadedMaps[rowid];
        }
        reactData.rowExpandedFlag++;
        return nextTick();
      },
      /**
       * 重新懒加载展开行，并展开内容
       * @param {Row} row 行对象
       */
      reloadRowExpand(row) {
        const { rowExpandLazyLoadedMaps } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xeTable, row);
        if (lazy && !rowExpandLazyLoadedMaps[rowid]) {
          $xeTable.clearRowExpandLoaded(row).then(() => handleAsyncRowExpand(row));
        }
        return nextTick();
      },
      reloadExpandContent(row) {
        warnLog("vxe.error.delFunc", ["reloadExpandContent", "reloadRowExpand"]);
        return $xeTable.reloadRowExpand(row);
      },
      /**
       * 切换展开行
       */
      toggleRowExpand(row) {
        return $xeTable.setRowExpand(row, !$xeTable.isRowExpandByRow(row));
      },
      /**
       * 设置所有行的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllRowExpand(expanded) {
        const treeOpts = computeTreeOpts.value;
        const { tableFullData, tableFullTreeData } = internalData;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let expandedRows = [];
        if (props.treeConfig) {
          import_xe_utils18.default.eachTree(tableFullTreeData, (row) => {
            expandedRows.push(row);
          }, { children: childrenField });
        } else {
          expandedRows = tableFullData;
        }
        return tableMethods.setRowExpand(expandedRows, expanded);
      },
      /**
       * 设置展开行，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setRowExpand(rows, expanded) {
        const { expandColumn } = reactData;
        let { fullAllDataRowIdData, rowExpandedMaps, rowExpandLazyLoadedMaps } = internalData;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const expandOpts = computeExpandOpts.value;
        const { reserve, lazy, accordion, toggleMethod } = expandOpts;
        const lazyRests = [];
        const columnIndex = expandColumn ? $xeTable.getColumnIndex(expandColumn) : -1;
        const $columnIndex = expandColumn ? $xeTable.getVMColumnIndex(expandColumn) : -1;
        if (rows) {
          if (!import_xe_utils18.default.isArray(rows)) {
            rows = [rows];
          }
          if (accordion) {
            rowExpandedMaps = {};
            internalData.rowExpandedMaps = rowExpandedMaps;
            rows = rows.slice(rows.length - 1, rows.length);
          }
          const validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xeTable, expanded, column: expandColumn, columnIndex, $columnIndex, row, rowIndex: $xeTable.getRowIndex(row), $rowIndex: $xeTable.getVMRowIndex(row) })) : rows;
          if (expanded) {
            validRows.forEach((row) => {
              const rowid = handleGetRowId(row);
              if (!rowExpandedMaps[rowid]) {
                const rowRest = fullAllDataRowIdData[rowid];
                const isLoad = lazy && !rowRest.expandLoaded && !rowExpandLazyLoadedMaps[rowid];
                if (isLoad) {
                  lazyRests.push(handleAsyncRowExpand(row));
                } else {
                  rowExpandedMaps[rowid] = row;
                }
              }
            });
          } else {
            validRows.forEach((item) => {
              const rowid = handleGetRowId(item);
              if (rowExpandedMaps[rowid]) {
                delete rowExpandedMaps[rowid];
              }
            });
          }
          if (reserve) {
            validRows.forEach((row) => handleRowExpandReserve(row, expanded));
          }
        }
        reactData.rowExpandedFlag++;
        return Promise.all(lazyRests).then(() => nextTick()).then(() => handleLazyRecalculate(true, true, true)).then(() => {
          updateRowOffsetTop();
          updateRowExpandStyle();
          handleRowExpandScroll();
          return $xeTable.updateCellAreas();
        });
      },
      /**
       * 判断行是否为展开状态
       * @param {Row} row 行对象
       */
      isRowExpandByRow(row) {
        const { rowExpandedFlag } = reactData;
        const { rowExpandedMaps } = internalData;
        const rowid = getRowid($xeTable, row);
        return !!rowExpandedFlag && !!rowExpandedMaps[rowid];
      },
      isExpandByRow(row) {
        warnLog("vxe.error.delFunc", ["isExpandByRow", "isRowExpandByRow"]);
        return tableMethods.isRowExpandByRow(row);
      },
      /**
       * 手动清空展开行状态，数据会恢复成未展开的状态
       */
      clearRowExpand() {
        const { tableFullData, scrollYStore } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { reserve } = expandOpts;
        const expList = $xeTable.getRowExpandRecords();
        internalData.rowExpandedMaps = {};
        if (reserve) {
          tableFullData.forEach((row) => handleRowExpandReserve(row, false));
        }
        reactData.rowExpandedFlag++;
        scrollYStore.startIndex = 0;
        scrollYStore.endIndex = 1;
        return nextTick().then(() => {
          if (expList.length) {
            return handleLazyRecalculate(true, true, true);
          }
        }).then(() => {
          updateRowOffsetTop();
          updateRowExpandStyle();
          handleRowExpandScroll();
          return $xeTable.updateCellAreas();
        });
      },
      clearRowExpandReserve() {
        internalData.rowExpandedReserveRowMap = {};
        return nextTick();
      },
      getRowExpandRecords() {
        const rest = [];
        import_xe_utils18.default.each(internalData.rowExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      setRowGroups(fieldOrColumns) {
        const { aggregateConfig, rowGroupConfig } = props;
        const aggregateOpts = computeAggregateOpts.value;
        const { maxGroupSize } = aggregateOpts;
        if (!(aggregateConfig || rowGroupConfig)) {
          errLog("vxe.error.reqProp", ["aggregate-config"]);
          return nextTick();
        }
        const confList = fieldOrColumns ? import_xe_utils18.default.isArray(fieldOrColumns) ? fieldOrColumns : [fieldOrColumns] : [];
        if (maxGroupSize && confList.length > maxGroupSize) {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              status: "error",
              content: getI18n10("vxe.table.maxGroupCol", [maxGroupSize])
            });
          }
          return nextTick();
        }
        if (confList.length) {
          handleUpdateRowGroup(confList.map((fieldOrColumn) => {
            return import_xe_utils18.default.isString(fieldOrColumn) ? fieldOrColumn : fieldOrColumn.field;
          }));
          return loadTableData(internalData.tableSynchData, true);
        }
        return nextTick();
      },
      getRowGroups() {
        const { aggregateConfig, rowGroupConfig } = props;
        const { fullColumnFieldData } = internalData;
        if (aggregateConfig || rowGroupConfig) {
          const { rowGroupList } = reactData;
          return rowGroupList.map(({ field }) => {
            const colRet = fullColumnFieldData[field];
            if (colRet) {
              return colRet.column;
            }
            return { field };
          });
        }
        return [];
      },
      getRowGroupFields() {
        return $xeTable.getRowGroups().map((item) => item.field);
      },
      clearRowGroups() {
        const { aggregateConfig, rowGroupConfig } = props;
        if (!(aggregateConfig || rowGroupConfig)) {
          errLog("vxe.error.reqProp", ["aggregate-config"]);
          return nextTick();
        }
        handleUpdateRowGroup([]);
        return loadTableData(internalData.tableSynchData, true);
      },
      isRowGroupRecord(row) {
        warnLog("vxe.error.delFunc", ["isRowGroupRecord", "isAggregateRecord"]);
        return $xeTable.isAggregateRecord(row);
      },
      isRowGroupExpandByRow(row) {
        warnLog("vxe.error.delFunc", ["isRowGroupExpandByRow", "isAggregateExpandByRow"]);
        return $xeTable.isAggregateExpandByRow(row);
      },
      isAggregateRecord(row) {
        const { isRowGroupStatus } = reactData;
        return isRowGroupStatus && row.isAggregate;
      },
      getAggregateContentByRow(row) {
        const { isRowGroupStatus } = reactData;
        return isRowGroupStatus && row && row.isAggregate ? row.groupContent : "";
      },
      getAggregateRowChildren(row) {
        const aggregateOpts = computeAggregateOpts.value;
        const { childrenField, mapChildrenField } = aggregateOpts;
        const { isRowGroupStatus } = reactData;
        return isRowGroupStatus && row && row.isAggregate && childrenField && mapChildrenField ? row[mapChildrenField] || [] : [];
      },
      isAggregateExpandByRow(row) {
        const { rowGroupExpandedFlag } = reactData;
        const { rowGroupExpandedMaps } = internalData;
        return !!rowGroupExpandedFlag && !!rowGroupExpandedMaps[getRowid($xeTable, row)];
      },
      setRowGroupExpand(rows, expanded) {
        if (rows) {
          if (!import_xe_utils18.default.isArray(rows)) {
            rows = [rows];
          }
          return handleRowGroupVirtualExpand(rows, expanded);
        }
        return nextTick();
      },
      setRowGroupExpandByField(groupFields, expanded) {
        const { isRowGroupStatus } = reactData;
        const aggregateOpts = computeAggregateOpts.value;
        const { childrenField } = aggregateOpts;
        if (groupFields) {
          if (!import_xe_utils18.default.isArray(groupFields)) {
            groupFields = [groupFields];
          }
          if (isRowGroupStatus) {
            const rows = [];
            const gfKeys = {};
            groupFields.forEach((groupField) => {
              gfKeys[groupField] = true;
            });
            import_xe_utils18.default.eachTree(internalData.afterGroupFullData, (row) => {
              if (row.isAggregate && gfKeys[row.groupField]) {
                rows.push(row);
              }
            }, { children: childrenField });
            if (rows.length) {
              return handleRowGroupVirtualExpand(rows, expanded);
            }
          }
        }
        return nextTick();
      },
      setAllRowGroupExpand(expanded) {
        const { tableFullGroupData } = internalData;
        const aggregateOpts = computeAggregateOpts.value;
        const { mapChildrenField } = aggregateOpts;
        const rgExpandedMaps = {};
        if (expanded && mapChildrenField) {
          import_xe_utils18.default.eachTree(tableFullGroupData, (row) => {
            if (row[mapChildrenField] && row[mapChildrenField].length) {
              rgExpandedMaps[getRowid($xeTable, row)] = row;
            }
          }, { children: mapChildrenField });
        }
        internalData.rowGroupExpandedMaps = rgExpandedMaps;
        handleVirtualTreeToList();
        $xeTable.handleTableData();
        updateAfterDataIndex();
        reactData.rowGroupExpandedFlag++;
        return handleLazyRecalculate(true, true, true);
      },
      clearRowGroupExpand() {
        internalData.rowGroupExpandedMaps = {};
        handleVirtualTreeToList();
        $xeTable.handleTableData();
        updateAfterDataIndex();
        reactData.rowGroupExpandedFlag++;
        return handleLazyRecalculate(true, true, true);
      },
      getTreeExpandRecords() {
        const rest = [];
        import_xe_utils18.default.each(internalData.treeExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      /**
       * 判断树节点是否懒加载完成
       * @param {Row} row 行对象
       */
      isTreeExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        return rowRest && !!rowRest.treeLoaded;
      },
      clearTreeExpandLoaded(rows) {
        const { fullAllDataRowIdData, treeExpandedMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform } = treeOpts;
        if (rows) {
          if (!import_xe_utils18.default.isArray(rows)) {
            rows = [rows];
          }
          rows.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest.treeLoaded = false;
              if (treeExpandedMaps[rowid]) {
                delete treeExpandedMaps[rowid];
              }
            }
          });
        } else {
          import_xe_utils18.default.each(fullAllDataRowIdData, (rowRest) => {
            rowRest.treeLoaded = false;
          });
        }
        internalData.treeExpandedMaps = {};
        if (transform) {
          handleVirtualTreeToList();
          $xeTable.handleTableData();
        }
        reactData.treeExpandedFlag++;
        return nextTick();
      },
      /**
       * 重新懒加载树节点，并展开该节点
       * @param {Row} row 行对象
       */
      reloadTreeExpand(row) {
        const { treeExpandLazyLoadedMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const { transform, lazy } = treeOpts;
        const rowid = getRowid($xeTable, row);
        if (lazy && row[hasChildField] && !treeExpandLazyLoadedMaps[rowid]) {
          return $xeTable.clearTreeExpandLoaded(row).then(() => {
            return handleAsyncTreeExpandChilds(row);
          }).then(() => {
            if (transform) {
              handleVirtualTreeToList();
              $xeTable.handleTableData();
            }
            reactData.treeExpandedFlag++;
          }).then(() => {
            return $xeTable.recalculate();
          });
        }
        return nextTick();
      },
      reloadTreeChilds(row) {
        warnLog("vxe.error.delFunc", ["reloadTreeChilds", "reloadTreeExpand"]);
        return $xeTable.reloadTreeExpand(row);
      },
      /**
       * 切换/展开树节点
       */
      toggleTreeExpand(row) {
        return $xeTable.setTreeExpand(row, !$xeTable.isTreeExpandByRow(row));
      },
      /**
       * 设置所有树节点的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllTreeExpand(expanded) {
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, lazy } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const expandeds = [];
        import_xe_utils18.default.eachTree(tableFullData, (row) => {
          const rowChildren = row[childrenField];
          if (lazy || rowChildren && rowChildren.length) {
            expandeds.push(row);
          }
        }, { children: childrenField });
        return $xeTable.setTreeExpand(expandeds, expanded).then(() => {
          if (transform) {
            handleVirtualTreeToList();
            reactData.treeExpandedFlag++;
            return $xeTable.recalculate();
          }
        });
      },
      /**
       * 设置展开树形节点，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setTreeExpand(rows, expanded) {
        const treeOpts = computeTreeOpts.value;
        const { transform } = treeOpts;
        if (rows) {
          if (!import_xe_utils18.default.isArray(rows)) {
            rows = [rows];
          }
          if (rows.length) {
            if (transform) {
              return handleVirtualTreeExpand(rows, expanded);
            } else {
              return handleBaseTreeExpand(rows, expanded);
            }
          }
        }
        return nextTick();
      },
      /**
       * 判断行是否为树形节点展开状态
       * @param {Row} row 行对象
       */
      isTreeExpandByRow(row) {
        const { treeExpandedFlag } = reactData;
        const { treeExpandedMaps } = internalData;
        return !!treeExpandedFlag && !!treeExpandedMaps[getRowid($xeTable, row)];
      },
      /**
       * 手动清空树形节点的展开状态，数据会恢复成未展开的状态
       */
      clearTreeExpand() {
        const { tableFullTreeData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { transform, reserve } = treeOpts;
        const expList = $xeTable.getTreeExpandRecords();
        internalData.treeExpandedMaps = {};
        if (reserve) {
          import_xe_utils18.default.eachTree(tableFullTreeData, (row) => handleTreeExpandReserve(row, false), { children: childrenField });
        }
        return $xeTable.handleTableData().then(() => {
          if (transform) {
            handleVirtualTreeToList();
            $xeTable.handleTableData();
          }
          reactData.treeExpandedFlag++;
        }).then(() => {
          updateTreeLineStyle();
          if (expList.length) {
            return $xeTable.recalculate();
          }
        });
      },
      clearTreeExpandReserve() {
        internalData.treeExpandedReserveRowMap = {};
        return nextTick();
      },
      /**
       * 获取表格的滚动状态
       */
      getScroll() {
        return $xeTable.getScrollData();
      },
      /**
       * 获取表格的滚动数据
       */
      getScrollData() {
        const { scrollXLoad, scrollYLoad, scrollbarHeight, scrollbarWidth } = reactData;
        const { elemStore } = internalData;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const scrollTop = bodyScrollElem ? bodyScrollElem.scrollTop : 0;
        const scrollLeft = bodyScrollElem ? bodyScrollElem.scrollLeft : 0;
        const clientHeight = bodyScrollElem ? bodyScrollElem.clientHeight : 0;
        const clientWidth = bodyScrollElem ? bodyScrollElem.clientWidth : 0;
        const scrollHeight = bodyScrollElem ? bodyScrollElem.scrollHeight : 0;
        const scrollWidth = bodyScrollElem ? bodyScrollElem.scrollWidth : 0;
        const isTop = scrollTop <= 0;
        const isBottom = scrollTop + clientHeight >= scrollHeight;
        const isLeft = scrollLeft <= 0;
        const isRight = scrollLeft + clientWidth >= scrollWidth;
        return {
          virtualX: scrollXLoad,
          virtualY: scrollYLoad,
          isTop,
          isBottom,
          isLeft,
          isRight,
          scrollbarHeight,
          scrollbarWidth,
          scrollTop,
          scrollLeft,
          scrollHeight,
          scrollWidth,
          clientHeight,
          clientWidth
        };
      },
      /**
       * 如果有滚动条，则滚动到对应的位置
       */
      scrollTo(scrollLeft, scrollTop) {
        const { elemStore } = internalData;
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        internalData.intoRunScroll = true;
        if (scrollLeft) {
          if (!import_xe_utils18.default.isNumber(scrollLeft)) {
            scrollTop = scrollLeft.top;
            scrollLeft = scrollLeft.left;
          }
        }
        if (import_xe_utils18.default.isNumber(scrollLeft)) {
          setScrollLeft(xHandleEl, scrollLeft);
          setScrollLeft(bodyScrollElem, scrollLeft);
          setScrollLeft(headerScrollElem, scrollLeft);
          setScrollLeft(footerScrollElem, scrollLeft);
          loadScrollXData();
        }
        if (import_xe_utils18.default.isNumber(scrollTop)) {
          setScrollTop(yHandleEl, scrollTop);
          setScrollTop(bodyScrollElem, scrollTop);
          setScrollTop(leftScrollElem, scrollTop);
          setScrollTop(rightScrollElem, scrollTop);
          loadScrollYData();
        }
        if (reactData.scrollXLoad || reactData.scrollYLoad) {
          return new Promise((resolve) => {
            setTimeout(() => {
              nextTick(() => {
                internalData.intoRunScroll = false;
                resolve();
              });
            }, 30);
          });
        }
        return nextTick().then(() => {
          internalData.intoRunScroll = false;
        });
      },
      /**
       * 如果有滚动条，则滚动到对应的行
       * @param {Row} row 行对象
       * @param {ColumnInfo} fieldOrColumn 列配置
       */
      scrollToRow(row, fieldOrColumn) {
        const { isAllOverflow, scrollYLoad, scrollXLoad } = reactData;
        const rest = [];
        if (row) {
          if (props.treeConfig) {
            rest.push($xeTable.scrollToTreeRow(row));
          } else {
            rest.push(rowToVisible($xeTable, row));
          }
        }
        if (fieldOrColumn) {
          rest.push(handleScrollToRowColumn(fieldOrColumn, row));
        }
        return Promise.all(rest).then(() => {
          if (row) {
            if (!isAllOverflow && (scrollYLoad || scrollXLoad)) {
              calcCellHeight();
              calcCellWidth();
            }
            return nextTick();
          }
        });
      },
      /**
       * 如果有滚动条，则滚动到对应的列
       */
      scrollToColumn(fieldOrColumn) {
        const { fullColumnIdData } = internalData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && fullColumnIdData[column.id]) {
          return colToVisible($xeTable, column);
        }
        return nextTick();
      },
      /**
       * 手动清除滚动相关信息，还原到初始状态
       */
      clearScroll() {
        const { elemStore, scrollXStore, scrollYStore } = internalData;
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        internalData.intoRunScroll = true;
        setScrollLeft(xHandleEl, 0);
        setScrollLeft(bodyScrollElem, 0);
        setScrollLeft(headerScrollElem, 0);
        setScrollLeft(footerScrollElem, 0);
        setScrollTop(yHandleEl, 0);
        setScrollTop(bodyScrollElem, 0);
        setScrollTop(leftScrollElem, 0);
        setScrollTop(rightScrollElem, 0);
        scrollXStore.startIndex = 0;
        scrollXStore.visibleStartIndex = 0;
        scrollXStore.endIndex = scrollXStore.visibleSize;
        scrollXStore.visibleEndIndex = scrollXStore.visibleSize;
        scrollYStore.startIndex = 0;
        scrollYStore.visibleStartIndex = 0;
        scrollYStore.endIndex = scrollYStore.visibleSize;
        scrollYStore.visibleEndIndex = scrollYStore.visibleSize;
        return nextTick().then(() => {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          internalData.intoRunScroll = false;
        });
      },
      /**
       * 更新表尾合计
       */
      updateFooter() {
        const { showFooter, footerData, footerMethod } = props;
        const { visibleColumn, afterFullData } = internalData;
        let footData = [];
        if (showFooter && footerData && footerData.length) {
          footData = footerData.slice(0);
        } else if (showFooter && footerMethod) {
          footData = visibleColumn.length ? footerMethod({ columns: visibleColumn, data: afterFullData, $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt }) : [];
        }
        reactData.footerTableData = footData;
        $xeTable.handleUpdateFooterMerge();
        $xeTable.dispatchEvent("footer-data-change", {
          visibleColumn: internalData.visibleColumn,
          footData
        }, null);
        return nextTick();
      },
      /**
       * 更新列状态 updateStatus({ row, column }, cellValue)
       * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态
       * 如果单元格配置了校验规则，则会进行校验
       */
      updateStatus(slotParams, cellValue) {
        return nextTick().then(() => {
          const { editRules } = props;
          if (slotParams && editRules) {
            return $xeTable.handleCellRuleUpdateStatus("change", slotParams, cellValue);
          }
        });
      },
      /**
       * 设置合并单元格 [{ row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }]
       */
      setMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        handleBodyMerge(merges);
        $xeTable.handleUpdateBodyMerge();
        return nextTick().then(() => {
          const { expandColumn } = reactData;
          const { mergeBodyList } = internalData;
          if (expandColumn && mergeBodyList.length) {
            warnLog("vxe.error.errConflicts", ["type=expand", "merge-cells | span-method"]);
          }
          $xeTable.updateCellAreas();
          return updateStyle();
        });
      },
      /**
       * 移除单元格合并 [{row:Row|number, col:ColumnInfo|number}]
       */
      removeMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        const rest = removeBodyMerges(merges);
        $xeTable.handleUpdateBodyMerge();
        return nextTick().then(() => {
          $xeTable.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 获取所有被合并的单元格
       */
      getMergeCells() {
        return internalData.mergeBodyList.slice(0);
      },
      /**
       * 清除所有单元格合并
       */
      clearMergeCells() {
        internalData.mergeBodyList = [];
        internalData.mergeBodyMaps = {};
        internalData.mergeBodyCellMaps = {};
        reactData.mergeBodyFlag++;
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      setMergeHeaderCells(merges) {
        handleHeaderMerge(merges);
        $xeTable.handleUpdateHeaderMerge();
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      /**
       * 移除表头单元格合并 [{row:Row|number, col:ColumnInfo|number}]
       */
      removeMergeHeaderCells(merges) {
        const rest = removeHeaderMerges(merges);
        $xeTable.handleUpdateHeaderMerge();
        return nextTick().then(() => {
          updateStyle();
          return rest;
        });
      },
      /**
       * 获取所有被合并的表头单元格
       */
      getMergeHeaderCells() {
        return internalData.mergeHeaderList.slice(0);
      },
      /**
       * 清除所有表头单元格合并
       */
      clearMergeHeaderCells() {
        internalData.mergeHeaderList = [];
        internalData.mergeHeaderMaps = {};
        internalData.mergeHeaderCellMaps = {};
        reactData.mergeHeadFlag++;
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      setMergeFooterCells(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-cells | merge-footer-items", "footer-span-method"]);
        }
        handleFooterMerge(merges);
        $xeTable.handleUpdateFooterMerge();
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      setMergeFooterItems(merges) {
        return $xeTable.setMergeFooterCells(merges);
      },
      removeMergeFooterCells(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-cells | merge-footer-items", "footer-span-method"]);
        }
        const rest = removeFooterMerges(merges);
        $xeTable.handleUpdateFooterMerge();
        return nextTick().then(() => {
          updateStyle();
          return rest;
        });
      },
      removeMergeFooterItems(merges) {
        return $xeTable.removeMergeFooterCells(merges);
      },
      /**
       * 获取所有被合并的表尾
       */
      getMergeFooterCells() {
        return internalData.mergeFooterList.slice(0);
      },
      getMergeFooterItems() {
        return $xeTable.getMergeFooterCells();
      },
      /**
       * 清除所有表尾合并
       */
      clearMergeFooterCells() {
        internalData.mergeFooterList = [];
        internalData.mergeFooterMaps = {};
        internalData.mergeFooterCellMaps = {};
        reactData.mergeFootFlag++;
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      clearMergeFooterItems() {
        return $xeTable.clearMergeFooterCells();
      },
      updateCellAreas() {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        if (mouseConfig && mouseOpts.area && $xeTable.handleRecalculateCellAreaEvent) {
          return $xeTable.handleRecalculateCellAreaEvent();
        }
        return nextTick();
      },
      getCustomStoreData() {
        const { id } = props;
        const customOpts = computeCustomOpts.value;
        const { isRowGroupStatus, rowGroupList } = reactData;
        const { fullColumnFieldData, collectColumn } = internalData;
        const { storage, checkMethod, storeOptions } = customOpts;
        const isAllCustom = storage === true;
        const storageOpts = Object.assign({}, isAllCustom ? {} : storage || {}, storeOptions);
        const isCustomResizable = hangleStorageDefaultValue(storageOpts.resizable, isAllCustom);
        const isCustomVisible = hangleStorageDefaultValue(storageOpts.visible, isAllCustom);
        const isCustomFixed = hangleStorageDefaultValue(storageOpts.fixed, isAllCustom);
        const isCustomSort = hangleStorageDefaultValue(storageOpts.sort, isAllCustom);
        const isCustomAggGroup = hangleStorageDefaultValue(storageOpts.aggGroup, isAllCustom);
        const isCustomAggFunc = hangleStorageDefaultValue(storageOpts.aggFunc, isAllCustom);
        const resizableData = {};
        const sortData = [];
        const visibleData = {};
        const fixedData = {};
        const aggGroupData = {};
        const aggFuncData = {};
        const storeData = {
          resizableData: void 0,
          sortData: void 0,
          visibleData: void 0,
          fixedData: void 0,
          aggGroupData: void 0,
          aggFuncData: void 0
        };
        if (!id) {
          if (storage) {
            errLog("vxe.error.reqProp", ["id"]);
          }
          return storeData;
        }
        let hasResizable = 0;
        let hasSort = 0;
        let hasFixed = 0;
        let hasVisible = 0;
        let hasAggFunc = 0;
        const sortMaps = {};
        import_xe_utils18.default.eachTree(collectColumn, (column, index, items, path, parentColumn) => {
          const colKey = column.getKey();
          if (!colKey) {
            errLog("vxe.error.reqProp", [`${column.getTitle() || column.type || ""} -> column.field=?`]);
            return;
          }
          if (parentColumn) {
            if (isCustomSort) {
              const pColKey = parentColumn.getKey();
              const psObj = sortMaps[pColKey];
              hasSort = 1;
              if (psObj) {
                const sObj = { k: colKey };
                sortMaps[colKey] = sObj;
                if (!psObj.c) {
                  psObj.c = [];
                }
                psObj.c.push(sObj);
              }
            }
          } else {
            if (isCustomSort) {
              hasSort = 1;
              const sObj = { k: colKey };
              sortMaps[colKey] = sObj;
              sortData.push(sObj);
            }
            if (isCustomFixed && (column.fixed || "") !== (column.defaultFixed || "")) {
              hasFixed = 1;
              fixedData[colKey] = column.fixed;
            }
          }
          if (isCustomResizable && column.resizeWidth) {
            hasResizable = 1;
            resizableData[colKey] = column.renderWidth;
          }
          if (isCustomVisible && (!checkMethod || checkMethod({ $table: $xeTable, column }))) {
            if (!column.visible && column.defaultVisible) {
              hasVisible = 1;
              visibleData[colKey] = false;
            } else if (column.visible && !column.defaultVisible) {
              hasVisible = 1;
              visibleData[colKey] = true;
            }
          }
          if (isCustomAggFunc && (column.aggFunc || "") !== (column.defaultAggFunc || "")) {
            hasAggFunc = 1;
            aggFuncData[colKey] = column.aggFunc;
          }
        });
        if (hasResizable) {
          storeData.resizableData = resizableData;
        }
        if (hasSort) {
          storeData.sortData = sortData;
        }
        if (hasFixed) {
          storeData.fixedData = fixedData;
        }
        if (hasVisible) {
          storeData.visibleData = visibleData;
        }
        if (isCustomAggGroup && isRowGroupStatus) {
          rowGroupList.forEach((aggConf) => {
            const colRest = fullColumnFieldData[aggConf.field];
            if (colRest) {
              aggGroupData[colRest.column.getKey()] = true;
            }
          });
          storeData.aggGroupData = aggGroupData;
        }
        if (hasAggFunc) {
          storeData.aggFuncData = aggFuncData;
        }
        return storeData;
      },
      focus() {
        internalData.isActivated = true;
        return nextTick();
      },
      blur() {
        internalData.isActivated = false;
        return nextTick();
      },
      /**
       * 已废弃，被 connectToolbar 替换
       * @deprecated
       */
      connect($toolbar) {
        return $xeTable.connectToolbar($toolbar);
      },
      /**
       * 连接工具栏
       * @param $toolbar
       */
      connectToolbar($toolbar) {
        if ($toolbar) {
          $xeToolbar = $toolbar;
          $xeToolbar.syncUpdate({ collectColumn: internalData.collectColumn, $table: $xeTable });
        } else {
          errLog("vxe.error.barUnableLink");
        }
        return nextTick();
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { editStore, ctxMenuStore, customStore } = reactData;
      const { mouseConfig, editRules } = props;
      const el = refElem.value;
      const editOpts = computeEditOpts.value;
      const validOpts = computeValidOpts.value;
      const areaOpts = computeAreaOpts.value;
      const { actived } = editStore;
      const $validTooltip = refValidTooltip.value;
      const tableFilter = refTableFilter.value;
      const tableCustom = refTableCustom.value;
      const tableMenu = refTableMenu.value;
      if (tableFilter) {
        if (getEventTargetNode(evnt, el, "vxe-cell--filter").flag) {
        } else if (getEventTargetNode(evnt, tableFilter.getRefMaps().refElem.value).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearFilter", internalData._currFilterParams, tableMethods.closeFilter);
          }
        }
      }
      if (tableCustom) {
        if (customStore.btnEl === evnt.target || getEventTargetNode(evnt, document.body, "vxe-toolbar-custom-target").flag) {
        } else if (getEventTargetNode(evnt, tableCustom.getRefMaps().refElem.value).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            if (customStore.visible && $xeTable.closeCustom) {
              tablePrivateMethods.preventEvent(evnt, "event.clearCustom", {}, () => {
                $xeTable.closeCustom();
                $xeTable.dispatchEvent("custom", { type: "close" }, evnt);
              });
            }
          }
        }
      }
      if (actived.row) {
        if (!(editOpts.autoClear === false)) {
          const cell = actived.args.cell;
          if (!cell || !getEventTargetNode(evnt, cell).flag) {
            if ($validTooltip && getEventTargetNode(evnt, $validTooltip.$el).flag) {
            } else if (!internalData._lastCallTime || internalData._lastCallTime + 50 < Date.now()) {
              if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearEdit", actived.args, () => {
                  let isClear;
                  if (editOpts.mode === "row") {
                    const rowTargetNode = getEventTargetNode(evnt, el, "vxe-body--row");
                    const rowNodeRest = rowTargetNode.flag ? tableMethods.getRowNode(rowTargetNode.targetElem) : null;
                    isClear = rowNodeRest ? !$xeTable.eqRow(rowNodeRest.item, actived.args.row) : false;
                  } else {
                    isClear = !getEventTargetNode(evnt, el, "col--edit").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el, "vxe-header--row").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el, "vxe-footer--row").flag;
                  }
                  if (!isClear && props.height && !reactData.overflowY) {
                    const bodyWrapperElem = evnt.target;
                    if (hasClass(bodyWrapperElem, "vxe-table--body-wrapper")) {
                      isClear = evnt.offsetY < bodyWrapperElem.clientHeight;
                    }
                  }
                  if (isClear || // 如果点击了当前表格之外
                  !getEventTargetNode(evnt, el).flag) {
                    setTimeout(() => {
                      $xeTable.handleClearEdit(evnt).then(() => {
                        if (!internalData.isActivated && editRules && validOpts.autoClear) {
                          reactData.validErrorMaps = {};
                        }
                      });
                    });
                  }
                });
              }
            }
          }
        }
      } else if (mouseConfig) {
        if (!getEventTargetNode(evnt, el).flag && !($xeGGWrapper && getEventTargetNode(evnt, $xeGGWrapper.getRefMaps().refElem.value).flag) && !(tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) && !($xeToolbar && getEventTargetNode(evnt, $xeToolbar.getRefMaps().refElem.value).flag)) {
          if ($xeTable.clearSelected) {
            $xeTable.clearSelected();
          }
          if (areaOpts.autoClear) {
            if ($xeTable.getCellAreas) {
              const cellAreas = $xeTable.getCellAreas();
              if (cellAreas && cellAreas.length && !getEventTargetNode(evnt, document.body, "vxe-table--ignore-areas-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearAreas", {}, () => {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                  dispatchEvent("clear-cell-area-selection", { cellAreas }, evnt);
                });
              }
            }
          }
        }
      }
      if ($xeTable.closeMenu) {
        if (ctxMenuStore.visible && tableMenu && !getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
          $xeTable.closeMenu();
        }
      }
      const isActivated = getEventTargetNode(evnt, $xeGGWrapper ? $xeGGWrapper.getRefMaps().refElem.value : el).flag;
      if (!isActivated && editRules && validOpts.autoClear) {
        reactData.validErrorMaps = {};
      }
      internalData.isActivated = isActivated;
    };
    const handleGlobalBlurEvent = () => {
      tableMethods.closeFilter();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
    };
    const handleGlobalMousewheelEvent = () => {
      tableMethods.closeTooltip();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
    };
    const keydownEvent = (evnt) => {
      const { mouseConfig, keyboardConfig } = props;
      const { filterStore, ctxMenuStore, editStore } = reactData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      const isEsc = globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.ESCAPE);
      if (isEsc) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, () => {
          dispatchEvent("keydown-start", {}, evnt);
          if (keyboardConfig && mouseConfig && mouseOpts.area && $xeTable.handleKeyboardCellAreaEvent) {
            $xeTable.handleKeyboardCellAreaEvent(evnt);
          } else if (actived.row || filterStore.visible || ctxMenuStore.visible) {
            evnt.stopPropagation();
            if ($xeTable.closeMenu) {
              $xeTable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xeTable.handleSelected(params, evnt));
                }
              }
            }
          }
          dispatchEvent("keydown", {}, evnt);
          dispatchEvent("keydown-end", {}, evnt);
        });
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      if (internalData.isActivated) {
        $xeTable.preventEvent(evnt, "event.keydown", null, () => {
          const { mouseConfig, keyboardConfig, treeConfig, editConfig, highlightCurrentRow, highlightCurrentColumn } = props;
          const { ctxMenuStore, editStore, currentRow } = reactData;
          const { afterFullData } = internalData;
          const isContentMenu = computeIsContentMenu.value;
          const bodyMenu = computeBodyMenu.value;
          const keyboardOpts = computeKeyboardOpts.value;
          const mouseOpts = computeMouseOpts.value;
          const editOpts = computeEditOpts.value;
          const treeOpts = computeTreeOpts.value;
          const menuList = computeMenuList.value;
          const rowOpts = computeRowOpts.value;
          const columnOpts = computeColumnOpts.value;
          const { selected, actived } = editStore;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const keyCode = evnt.keyCode;
          const isEsc = globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.ESCAPE);
          const hasBackspaceKey = globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.BACKSPACE);
          const isTab = globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.TAB);
          const isEnter = globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.ENTER);
          const isSpacebar = globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.SPACEBAR);
          const isLeftArrow = globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_LEFT);
          const isUpArrow = globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_UP);
          const isRightArrow = globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_RIGHT);
          const isDwArrow = globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_DOWN);
          const hasDeleteKey = globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.DELETE);
          const isF2 = globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.F2);
          const isContextMenu = globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.CONTEXT_MENU);
          const isControlKey = hasControlKey(evnt);
          const hasShiftKey = evnt.shiftKey;
          const isAltKey = evnt.altKey;
          const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
          const operCtxMenu = isContentMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);
          const isEditStatus = isEnableConf(editConfig) && actived.column && actived.row;
          const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
          if (operCtxMenu) {
            evnt.preventDefault();
            if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {
              $xeTable.moveCtxMenu(evnt, ctxMenuStore, "selectChild", isLeftArrow, false, ctxMenuStore.selected.children);
            } else {
              $xeTable.moveCtxMenu(evnt, ctxMenuStore, "selected", isRightArrow, true, menuList);
            }
          } else if (keyboardConfig && mouseConfig && mouseOpts.area && $xeTable.handleKeyboardCellAreaEvent) {
            $xeTable.handleKeyboardCellAreaEvent(evnt);
          } else if (isEsc) {
            if ($xeTable.closeMenu) {
              $xeTable.closeMenu();
            }
            $xeTable.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xeTable.handleSelected(params, evnt));
                }
              }
            }
          } else if (isSpacebar && keyboardConfig && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === "checkbox" || selected.column.type === "radio")) {
            evnt.preventDefault();
            if (selected.column.type === "checkbox") {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, selected.args);
            } else {
              tablePrivateMethods.triggerRadioRowEvent(evnt, selected.args);
            }
          } else if (isF2 && isEnableConf(editConfig)) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                evnt.preventDefault();
                $xeTable.handleEdit(selected.args, evnt);
              }
            }
          } else if (isContextMenu) {
            internalData._keyCtx = selected.row && selected.column && bodyMenu.length;
            clearTimeout(internalData.keyCtxTimeout);
            internalData.keyCtxTimeout = setTimeout(() => {
              internalData._keyCtx = false;
            }, 1e3);
          } else if (isEnter && !isAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow)) {
            const { isLastEnterAppendRow, beforeEnterMethod, enterMethod } = keyboardOpts;
            if (isControlKey) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => {
                    $xeTable.handleSelected(params, evnt);
                  });
                }
              }
            } else {
              if (selected.row || actived.row) {
                const activeParams = selected.row ? selected.args : actived.args;
                if (hasShiftKey) {
                  if (keyboardOpts.enterToTab) {
                    $xeTable.moveTabSelected(activeParams, hasShiftKey, evnt);
                  } else {
                    $xeTable.moveEnterSelected(activeParams, isLeftArrow, true, isRightArrow, false, evnt);
                  }
                } else {
                  if (keyboardOpts.enterToTab) {
                    $xeTable.moveTabSelected(activeParams, hasShiftKey, evnt);
                  } else {
                    const activeRow = selected.row || actived.row;
                    const activeColumn = selected.column || actived.column;
                    const _rowIndex = $xeTable.getVTRowIndex(activeRow);
                    const etrParams = {
                      row: activeRow,
                      rowIndex: $xeTable.getRowIndex(activeRow),
                      $rowIndex: $xeTable.getVMRowIndex(activeRow),
                      _rowIndex,
                      column: activeColumn,
                      columnIndex: $xeTable.getColumnIndex(activeColumn),
                      $columnIndex: $xeTable.getVMColumnIndex(activeColumn),
                      _columnIndex: $xeTable.getVTColumnIndex(activeColumn),
                      $table: $xeTable
                    };
                    if (!beforeEnterMethod || beforeEnterMethod(etrParams) !== false) {
                      if (isLastEnterAppendRow) {
                        if (_rowIndex >= afterFullData.length - 1) {
                          $xeTable.insertAt({}, -1).then(({ row: newRow }) => {
                            $xeTable.scrollToRow(newRow, activeColumn);
                            $xeTable.handleSelected(Object.assign(Object.assign({}, activeParams), { row: newRow }), evnt);
                          });
                          $xeTable.dispatchEvent("enter-append-row", etrParams, evnt);
                          return;
                        }
                      }
                      $xeTable.moveEnterSelected(activeParams, isLeftArrow, false, isRightArrow, true, evnt);
                      if (enterMethod) {
                        enterMethod(etrParams);
                      }
                    }
                  }
                }
              } else if (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
                const childrens = currentRow[childrenField];
                if (childrens && childrens.length) {
                  evnt.preventDefault();
                  const targetRow = childrens[0];
                  const params = {
                    $table: $xeTable,
                    row: targetRow,
                    rowIndex: $xeTable.getRowIndex(targetRow),
                    $rowIndex: $xeTable.getVMRowIndex(targetRow)
                  };
                  $xeTable.setTreeExpand(currentRow, true).then(() => $xeTable.scrollToRow(targetRow)).then(() => $xeTable.triggerCurrentRowEvent(evnt, params));
                }
              }
            }
          } else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {
            if (!isEditStatus) {
              if (mouseOpts.selected && selected.row && selected.column) {
                $xeTable.moveArrowSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);
              } else {
                if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
                  $xeTable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
                }
                if ((isLeftArrow || isRightArrow) && (columnOpts.isCurrent || highlightCurrentColumn)) {
                  $xeTable.moveCurrentColumn(isLeftArrow, isRightArrow, evnt);
                }
              }
            }
          } else if (isTab && keyboardConfig && keyboardOpts.isTab) {
            if (selected.row || selected.column) {
              $xeTable.moveTabSelected(selected.args, hasShiftKey, evnt);
            } else if (actived.row || actived.column) {
              $xeTable.moveTabSelected(actived.args, hasShiftKey, evnt);
            }
          } else if (keyboardConfig && keyboardOpts.isDel && hasDeleteKey && isEnableConf(editConfig) && (selected.row || selected.column)) {
            if (!isEditStatus) {
              const { delMethod } = keyboardOpts;
              const params = {
                row: selected.row,
                rowIndex: tableMethods.getRowIndex(selected.row),
                column: selected.column,
                columnIndex: tableMethods.getColumnIndex(selected.column),
                $table: $xeTable,
                $grid: $xeGrid,
                $gantt: $xeGantt
              };
              if (!beforeEditMethod || beforeEditMethod(params)) {
                if (delMethod) {
                  delMethod(params);
                } else {
                  setCellValue(selected.row, selected.column, null);
                }
                tableMethods.updateFooter();
                dispatchEvent("cell-delete-value", params, evnt);
              }
            }
          } else if (hasBackspaceKey && keyboardConfig && keyboardOpts.isBack && isEnableConf(editConfig) && (selected.row || selected.column)) {
            if (!isEditStatus) {
              const { backMethod } = keyboardOpts;
              if (keyboardOpts.isDel && isEnableConf(editConfig) && (selected.row || selected.column)) {
                const params = {
                  row: selected.row,
                  rowIndex: $xeTable.getRowIndex(selected.row),
                  column: selected.column,
                  columnIndex: $xeTable.getColumnIndex(selected.column),
                  $table: $xeTable,
                  $grid: $xeGrid,
                  $gantt: $xeGantt
                };
                if (!beforeEditMethod || beforeEditMethod(params)) {
                  if (backMethod) {
                    backMethod(params);
                  } else {
                    setCellValue(selected.row, selected.column, null);
                    $xeTable.handleEdit(selected.args, evnt);
                  }
                  dispatchEvent("cell-backspace-value", params, evnt);
                }
              }
            }
          } else if (hasBackspaceKey && keyboardConfig && treeConfig && keyboardOpts.isBack && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
            const { parent: parentRow } = import_xe_utils18.default.findTree(internalData.afterTreeFullData, (item) => item === currentRow, { children: childrenField });
            if (parentRow) {
              evnt.preventDefault();
              const params = {
                row: parentRow,
                rowIndex: $xeTable.getRowIndex(parentRow),
                $rowIndex: $xeTable.getVMRowIndex(parentRow),
                $table: $xeTable,
                $grid: $xeGrid,
                $gantt: $xeGantt
              };
              $xeTable.setTreeExpand(parentRow, false).then(() => $xeTable.scrollToRow(parentRow)).then(() => $xeTable.triggerCurrentRowEvent(evnt, params));
            }
          } else if (keyboardConfig && isEnableConf(editConfig) && keyboardOpts.isEdit && !isControlKey && (isSpacebar || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222)) {
            const { editMode, editMethod } = keyboardOpts;
            if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {
              const beforeEditMethod2 = editOpts.beforeEditMethod || editOpts.activeMethod;
              const params = {
                row: selected.row,
                rowIndex: $xeTable.getRowIndex(selected.row),
                column: selected.column,
                columnIndex: $xeTable.getColumnIndex(selected.column),
                $table: $xeTable,
                $grid: $xeGrid,
                $gantt: $xeGantt
              };
              if (!beforeEditMethod2 || beforeEditMethod2(Object.assign(Object.assign({}, selected.args), { $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt }))) {
                if (editMethod) {
                  editMethod(params);
                } else {
                  if (editMode !== "insert") {
                    setCellValue(selected.row, selected.column, null);
                  }
                  $xeTable.handleEdit(selected.args, evnt);
                }
              }
            }
          }
          dispatchEvent("keydown", {}, evnt);
        });
      }
    };
    const handleGlobalPasteEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handlePasteCellAreaEvent) {
            $xeTable.handlePasteCellAreaEvent(evnt);
          }
        }
        dispatchEvent("paste", {}, evnt);
      }
    };
    const handleGlobalCopyEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handleCopyCellAreaEvent) {
            $xeTable.handleCopyCellAreaEvent(evnt);
          }
        }
        dispatchEvent("copy", {}, evnt);
      }
    };
    const handleGlobalCutEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handleCutCellAreaEvent) {
            $xeTable.handleCutCellAreaEvent(evnt);
          }
        }
        dispatchEvent("cut", {}, evnt);
      }
    };
    const handleGlobalResizeEvent = () => {
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
      const el = refElem.value;
      if (!el || !el.clientWidth) {
        return;
      }
      handleResizeEvent();
      $xeTable.updateCellAreas();
    };
    const handleTargetEnterEvent = (isClear) => {
      const $tooltip = refTooltip.value;
      clearTimeout(internalData.tooltipTimeout);
      if (isClear) {
        tableMethods.closeTooltip();
      } else {
        if ($tooltip && $tooltip.setActived) {
          $tooltip.setActived(true);
        }
      }
    };
    const clearCrossTableDragStatus = () => {
      crossTableDragRowObj = null;
      crossTableDragRowInfo2.row = null;
    };
    const clearDragStatus = () => {
      const { dragRow, dragCol } = reactData;
      if (dragRow || dragCol) {
        clearColDropOrigin();
        clearRowDropOrigin();
        hideDropTip();
        clearCrossTableDragStatus();
        reactData.dragRow = null;
        reactData.dragCol = null;
      }
    };
    const clearRowDropOrigin = () => {
      const el = refElem.value;
      if (el) {
        const clss = "row--drag-origin";
        import_xe_utils18.default.arrayEach(el.querySelectorAll(`.${clss}`), (elem) => {
          elem.draggable = false;
          removeClass(elem, clss);
        });
      }
    };
    const updateRowDropOrigin = (row) => {
      const el = refElem.value;
      if (el) {
        const clss = "row--drag-origin";
        const rowid = getRowid($xeTable, row);
        import_xe_utils18.default.arrayEach(el.querySelectorAll(`[rowid="${rowid}"]`), (elem) => {
          addClass(elem, clss);
        });
      }
    };
    const updateRowDropTipContent = (tdEl) => {
      const { dragConfig } = props;
      const { dragRow } = reactData;
      const rowDragOpts = computeRowDragOpts.value;
      const { tooltipMethod } = rowDragOpts;
      const rTooltipMethod = tooltipMethod || (dragConfig ? dragConfig.rowTooltipMethod : null);
      let tipContent = "";
      if (rTooltipMethod) {
        const rtParams = {
          $table: $xeTable,
          row: dragRow
        };
        tipContent = `${rTooltipMethod(rtParams) || ""}`;
      } else {
        tipContent = getI18n10("vxe.table.dragTip", [tdEl.textContent || ""]);
      }
      reactData.dragTipText = tipContent;
    };
    const updateColDropOrigin = (column) => {
      const el = refElem.value;
      if (el) {
        const colQuerys = [];
        import_xe_utils18.default.eachTree([column], (item) => {
          colQuerys.push(`[colid="${item.id}"]`);
        });
        const clss = "col--drag-origin";
        import_xe_utils18.default.arrayEach(el.querySelectorAll(colQuerys.join(",")), (elem) => {
          addClass(elem, clss);
        });
      }
    };
    const clearColDropOrigin = () => {
      const el = refElem.value;
      if (el) {
        const clss = "col--drag-origin";
        import_xe_utils18.default.arrayEach(el.querySelectorAll(`.${clss}`), (elem) => {
          elem.draggable = false;
          removeClass(elem, clss);
        });
      }
    };
    const updateColDropTipContent = (tdEl) => {
      const { dragCol } = reactData;
      const columnDragOpts = computeColumnDragOpts.value;
      const { tooltipMethod } = columnDragOpts;
      let tipContent = "";
      if (tooltipMethod) {
        const dtParams = {
          $table: $xeTable,
          column: dragCol
        };
        tipContent = `${tooltipMethod(dtParams) || ""}`;
      } else {
        tipContent = getI18n10("vxe.table.dragTip", [tdEl.textContent || ""]);
      }
      reactData.dragTipText = tipContent;
    };
    const showDropTip = (evnt, trEl, thEl, showLine, dragPos) => {
      let wrapperEl = refElem.value;
      if ($xeGantt && trEl) {
        const { refGanttContainerElem } = $xeGantt.getRefMaps();
        const ganttContainerElem = refGanttContainerElem.value;
        if (ganttContainerElem) {
          wrapperEl = ganttContainerElem;
        }
      }
      if (!wrapperEl) {
        return;
      }
      const { overflowX, scrollbarWidth, overflowY, scrollbarHeight } = reactData;
      const { prevDragToChild } = internalData;
      const wrapperRect = wrapperEl.getBoundingClientRect();
      const osbWidth = overflowY ? scrollbarWidth : 0;
      const osbHeight = overflowX ? scrollbarHeight : 0;
      const tableWrapperWidth = wrapperEl.clientWidth;
      const tableWrapperHeight = wrapperEl.clientHeight;
      if (trEl) {
        const rdLineEl = refDragRowLineElem.value;
        if (rdLineEl) {
          if (showLine) {
            const scrollbarYToLeft = computeScrollbarYToLeft.value;
            const trRect = trEl.getBoundingClientRect();
            let trHeight = trEl.clientHeight;
            const offsetTop = Math.max(1, trRect.y - wrapperRect.y);
            if (offsetTop + trHeight > tableWrapperHeight - osbHeight) {
              trHeight = tableWrapperHeight - offsetTop - osbHeight;
            }
            rdLineEl.style.display = "block";
            rdLineEl.style.left = `${scrollbarYToLeft ? osbWidth : 0}px`;
            rdLineEl.style.top = `${offsetTop}px`;
            rdLineEl.style.height = `${trHeight}px`;
            rdLineEl.style.width = `${tableWrapperWidth - osbWidth}px`;
            rdLineEl.setAttribute("drag-pos", dragPos);
            rdLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            rdLineEl.style.display = "";
          }
        }
      } else if (thEl) {
        const cdLineEl = refDragColLineElem.value;
        if (cdLineEl) {
          if (showLine) {
            const scrollbarXToTop = computeScrollbarXToTop.value;
            const leftContainerElem = refLeftContainer.value;
            const leftContainerWidth = leftContainerElem ? leftContainerElem.clientWidth : 0;
            const rightContainerElem = refRightContainer.value;
            const rightContainerWidth = rightContainerElem ? rightContainerElem.clientWidth : 0;
            const thRect = thEl.getBoundingClientRect();
            let thWidth = thEl.clientWidth;
            const offsetTop = Math.max(0, thRect.y - wrapperRect.y);
            const startX = leftContainerWidth;
            let offsetLeft = thRect.x - wrapperRect.x;
            if (offsetLeft < startX) {
              thWidth -= startX - offsetLeft;
              offsetLeft = startX;
            }
            const endX = tableWrapperWidth - rightContainerWidth - (rightContainerWidth ? 0 : osbWidth);
            if (offsetLeft + thWidth > endX) {
              thWidth = endX - offsetLeft;
            }
            cdLineEl.style.display = "block";
            cdLineEl.style.top = `${offsetTop}px`;
            cdLineEl.style.left = `${offsetLeft}px`;
            cdLineEl.style.width = `${thWidth}px`;
            if (prevDragToChild) {
              cdLineEl.style.height = `${thRect.height}px`;
            } else {
              cdLineEl.style.height = `${tableWrapperHeight - offsetTop - (scrollbarXToTop ? 0 : osbHeight)}px`;
            }
            cdLineEl.setAttribute("drag-pos", dragPos);
            cdLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            cdLineEl.style.display = "";
          }
        }
      }
      const rdTipEl = refDragTipElem.value;
      if (rdTipEl) {
        rdTipEl.style.display = "block";
        rdTipEl.style.top = `${Math.min(wrapperEl.clientHeight - wrapperEl.scrollTop - rdTipEl.clientHeight, evnt.clientY - wrapperRect.y)}px`;
        rdTipEl.style.left = `${Math.min(wrapperEl.clientWidth - wrapperEl.scrollLeft - rdTipEl.clientWidth - 16, evnt.clientX - wrapperRect.x)}px`;
        rdTipEl.setAttribute("drag-status", showLine ? prevDragToChild ? "sub" : "normal" : "disabled");
      }
    };
    const hideDropTip = () => {
      const rdTipEl = refDragTipElem.value;
      const rdLineEl = refDragRowLineElem.value;
      const cdLineEl = refDragColLineElem.value;
      if (rdTipEl) {
        rdTipEl.style.display = "";
      }
      if (rdLineEl) {
        rdLineEl.style.display = "";
      }
      if (cdLineEl) {
        cdLineEl.style.display = "";
      }
    };
    const clearRowDragData = () => {
      let wrapperEl = refElem.value;
      const dtClss = [".vxe-body--row"];
      if ($xeGantt) {
        const { refGanttContainerElem } = $xeGantt.getRefMaps();
        const ganttContainerElem = refGanttContainerElem.value;
        if (ganttContainerElem) {
          wrapperEl = ganttContainerElem;
        }
        dtClss.push(".vxe-gantt-view--body-row", ".vxe-gantt-view--chart-row");
      }
      hideDropTip();
      clearRowDropOrigin();
      clearRowAnimate(wrapperEl, dtClss);
      internalData.prevDragToChild = false;
      reactData.dragRow = null;
      reactData.dragCol = null;
    };
    const clearColDragData = () => {
      const el = refElem.value;
      hideDropTip();
      clearColDropOrigin();
      clearColAnimate(el, [".vxe-table--column"]);
      internalData.prevDragToChild = false;
      reactData.dragRow = null;
      reactData.dragCol = null;
    };
    const handleTooltip = (evnt, tipOpts, type, tdEl, overflowElem, tipElem, params) => {
      const tipOverEl = overflowElem || tdEl;
      if (!tipOverEl) {
        return nextTick();
      }
      params.cell = tdEl;
      const { tooltipStore } = reactData;
      const { column, row } = params;
      const { showAll, contentMethod } = tipOpts;
      const customContent = contentMethod ? contentMethod(params) : null;
      const useCustom = contentMethod && !import_xe_utils18.default.eqNull(customContent);
      const content = useCustom ? customContent : import_xe_utils18.default.toString(column.type === "html" ? tipOverEl.innerText : tipOverEl.textContent).trim();
      const isOver = tipOverEl.scrollWidth > tipOverEl.clientWidth;
      if (content && (showAll || useCustom || isOver)) {
        const tipContent = formatText(content);
        Object.assign(tooltipStore, {
          row,
          column,
          visible: true,
          content: tipContent,
          type,
          currOpts: tipOpts
        });
        nextTick(() => {
          const $tooltip = refTooltip.value;
          if ($tooltip && $tooltip.open) {
            $tooltip.open(isOver ? tipOverEl : tipElem, tipContent);
          }
        });
      }
      return nextTick();
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if ($xeGGWrapper) {
          return $xeGGWrapper.callSlot(slotFunc, params);
        }
        if (import_xe_utils18.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    tablePrivateMethods = {
      getSetupOptions() {
        return getConfig5();
      },
      updateAfterDataIndex,
      callSlot,
      /**
       * 获取父容器元素
       */
      getParentElem() {
        const el = refElem.value;
        if ($xeGGWrapper) {
          const gridEl = $xeGGWrapper.getRefMaps().refElem.value;
          return gridEl ? gridEl.parentNode : null;
        }
        return el ? el.parentNode : null;
      },
      /**
       * 获取父容器的高度
       */
      getParentHeight() {
        const { height } = props;
        const el = refElem.value;
        if (el) {
          const parentElem = el.parentNode;
          let parentPaddingSize = 0;
          let parentWrapperHeight = 0;
          if (parentElem) {
            if ($xeGantt && hasClass(parentElem, "vxe-gantt--table-wrapper")) {
              parentWrapperHeight = $xeGantt.getParentHeight();
            } else if ($xeGrid && hasClass(parentElem, "vxe-grid--table-wrapper")) {
              parentWrapperHeight = $xeGrid.getParentHeight();
            } else {
              parentWrapperHeight = parentElem.clientHeight;
              parentPaddingSize = height === "100%" || height === "auto" ? getPaddingTopBottomSize(parentElem) : 0;
            }
          }
          return Math.floor(parentWrapperHeight - parentPaddingSize);
        }
        return 0;
      },
      /**
       * 获取需要排除的高度
       * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度
       * 如果存在表尾合计滚动条，则需要排除滚动条高度
       */
      getExcludeHeight() {
        return $xeGGWrapper ? $xeGGWrapper.getExcludeHeight() : 0;
      },
      /**
       * 定义行数据中的列属性，如果不存在则定义
       * @param {Row} records 行数据
       */
      defineField(records) {
        const { treeConfig } = props;
        const expandOpts = computeExpandOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rowkey = getRowkey($xeTable);
        if (!import_xe_utils18.default.isArray(records)) {
          records = [records];
        }
        return records.map((record) => {
          internalData.tableFullColumn.forEach((column) => {
            const { field, editRender } = column;
            if (field && !import_xe_utils18.default.has(record, field) && !record[field]) {
              let cellValue = null;
              if (editRender) {
                const { defaultValue } = editRender;
                if (import_xe_utils18.default.isFunction(defaultValue)) {
                  cellValue = defaultValue({ column });
                } else if (!import_xe_utils18.default.isUndefined(defaultValue)) {
                  cellValue = defaultValue;
                }
              }
              import_xe_utils18.default.set(record, field, cellValue);
            }
          });
          const otherFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];
          otherFields.forEach((key) => {
            if (key && eqEmptyValue(import_xe_utils18.default.get(record, key))) {
              import_xe_utils18.default.set(record, key, null);
            }
          });
          if (treeConfig && treeOpts.lazy && import_xe_utils18.default.isUndefined(record[childrenField])) {
            record[childrenField] = null;
          }
          if (eqEmptyValue(import_xe_utils18.default.get(record, rowkey))) {
            import_xe_utils18.default.set(record, rowkey, getRowUniqueId());
          }
          return record;
        });
      },
      handleTableData(force) {
        const { scrollYLoad } = reactData;
        const { scrollYStore, fullDataRowIdData } = internalData;
        const $xeGanttView = internalData.xeGanttView;
        let fullList = internalData.afterFullData;
        if (force) {
          updateAfterFullData();
          fullList = handleVirtualTreeToList();
        }
        const tableData = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);
        const visibleDataRowIdMaps = {};
        tableData.forEach((row, $index) => {
          const rowid = getRowid($xeTable, row);
          const rest = fullDataRowIdData[rowid];
          if (rest) {
            rest.$index = $index;
          }
          visibleDataRowIdMaps[rowid] = row;
        });
        reactData.tableData = tableData;
        internalData.visibleDataRowIdData = visibleDataRowIdMaps;
        if ($xeGanttView && $xeGanttView.updateViewData) {
          $xeGanttView.updateViewData();
        }
        return nextTick();
      },
      /**
       * 更新数据行的 Map
       */
      cacheRowMap(isReset) {
        const { treeConfig } = props;
        const { isRowGroupStatus } = reactData;
        const { currKeyField, fullAllDataRowIdData, tableFullData, tableFullTreeData, tableFullGroupData, treeExpandedMaps, rowExpandedMaps, selectCheckboxMaps } = internalData;
        const fullAllDataRowIdMaps = isReset ? {} : Object.assign({}, fullAllDataRowIdData);
        const fullDataRowIdMaps = {};
        const idMaps = {};
        const { handleUpdateRowId } = createHandleUpdateRowId($xeTable);
        const handleRowCache = (row, index, items, currIndex, parentRow, rowid, level, seq) => {
          let rowRest = fullAllDataRowIdMaps[rowid];
          if (idMaps[rowid]) {
            errLog("vxe.error.repeatKey", [currKeyField, rowid]);
          }
          if (!rowRest) {
            rowRest = { row, rowid, seq, index: -1, _index: -1, $index: -1, treeIndex: index, _tIndex: -1, items, parent: parentRow, level, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
            fullDataRowIdMaps[rowid] = rowRest;
            fullAllDataRowIdMaps[rowid] = rowRest;
          }
          rowRest.treeLoaded = false;
          rowRest.expandLoaded = false;
          rowRest.row = row;
          rowRest.items = items;
          rowRest.parent = parentRow;
          rowRest.level = level;
          rowRest.index = currIndex;
          rowRest.treeIndex = index;
          if (selectCheckboxMaps[rowid]) {
            selectCheckboxMaps[rowid] = row;
          }
          if (rowExpandedMaps[rowid]) {
            rowExpandedMaps[rowid] = row;
          }
          idMaps[rowid] = true;
          fullDataRowIdMaps[rowid] = rowRest;
          fullAllDataRowIdMaps[rowid] = rowRest;
        };
        if (treeConfig) {
          const treeOpts = computeTreeOpts.value;
          const { lazy } = treeOpts;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
          import_xe_utils18.default.eachTree(tableFullTreeData, (row, index, items, path, parentRow, nodes) => {
            const rowid = handleUpdateRowId(row);
            if (treeConfig && lazy) {
              if (row[hasChildField] && row[childrenField] === void 0) {
                row[childrenField] = null;
              }
              if (treeExpandedMaps[rowid]) {
                if (!row[childrenField] || !row[childrenField].length) {
                  delete treeExpandedMaps[rowid];
                }
              }
            }
            handleRowCache(row, index, items, parentRow ? -1 : index, parentRow, rowid, nodes.length - 1, toTreePathSeq(path));
          }, { children: childrenField });
        } else if (isRowGroupStatus) {
          const aggregateOpts = computeAggregateOpts.value;
          const { mapChildrenField } = aggregateOpts;
          import_xe_utils18.default.eachTree(tableFullGroupData, (row, index, items, path, parentRow, nodes) => {
            const rowid = handleUpdateRowId(row);
            handleRowCache(row, index, items, parentRow ? -1 : index, parentRow, rowid, nodes.length - 1, toTreePathSeq(path));
          }, { children: mapChildrenField });
        } else {
          tableFullData.forEach((row, index, items) => {
            handleRowCache(row, index, items, index, null, handleUpdateRowId(row), 0, index + 1);
          });
        }
        internalData.fullDataRowIdData = fullDataRowIdMaps;
        internalData.fullAllDataRowIdData = fullAllDataRowIdMaps;
        reactData.treeExpandedFlag++;
      },
      cacheSourceMap(fullData) {
        const { treeConfig } = props;
        const treeOpts = computeTreeOpts.value;
        const sourceData = import_xe_utils18.default.clone(fullData, true);
        const { handleUpdateRowId } = createHandleUpdateRowId($xeTable);
        const sourceRowIdData = {};
        const handleSourceRow = (row) => {
          const rowid = handleUpdateRowId(row);
          sourceRowIdData[rowid] = row;
        };
        if (treeConfig) {
          const childrenField = treeOpts.children || treeOpts.childrenField;
          import_xe_utils18.default.eachTree(sourceData, handleSourceRow, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });
        } else {
          sourceData.forEach(handleSourceRow);
        }
        internalData.sourceDataRowIdData = sourceRowIdData;
        internalData.tableSourceData = sourceData;
      },
      /**
       * 指定列宽的列进行拆分
       */
      analyColumnWidth() {
        const { tableFullColumn } = internalData;
        const columnOpts = computeColumnOpts.value;
        const { width: defaultWidth, minWidth: defaultMinWidth } = columnOpts;
        const resizeList = [];
        const pxList = [];
        const pxMinList = [];
        const autoMinList = [];
        const scaleList = [];
        const scaleMinList = [];
        const autoList = [];
        const remainList = [];
        tableFullColumn.forEach((column) => {
          if (defaultWidth && !column.width) {
            column.width = defaultWidth;
          }
          if (defaultMinWidth && !column.minWidth) {
            column.minWidth = defaultMinWidth;
          }
          if (column.visible) {
            if (column.resizeWidth) {
              resizeList.push(column);
            } else if (column.width === "auto") {
              autoList.push(column);
            } else if (isPx(column.width)) {
              pxList.push(column);
            } else if (isScale(column.width)) {
              scaleList.push(column);
            } else if (isPx(column.minWidth)) {
              pxMinList.push(column);
            } else if (column.minWidth === "auto") {
              autoMinList.push(column);
            } else if (isScale(column.minWidth)) {
              scaleMinList.push(column);
            } else {
              remainList.push(column);
            }
          }
        });
        Object.assign(reactData.columnStore, { resizeList, pxList, pxMinList, autoMinList, scaleList, scaleMinList, autoList, remainList });
      },
      handleColResizeMousedownEvent(evnt, fixedType, params) {
        evnt.stopPropagation();
        evnt.preventDefault();
        const { column } = params;
        const { columnStore, overflowX, scrollbarHeight } = reactData;
        const { visibleColumn } = internalData;
        const { leftList, rightList } = columnStore;
        const resizableOpts = computeResizableOpts.value;
        const osbHeight = overflowX ? scrollbarHeight : 0;
        const tableEl = refElem.value;
        const leftContainerElem = refLeftContainer.value;
        const rightContainerElem = refRightContainer.value;
        const resizeBarElem = refColResizeBar.value;
        if (!resizeBarElem) {
          return;
        }
        const isLeftFixed = fixedType === "left";
        const isRightFixed = fixedType === "right";
        const resizeTipElem = resizeBarElem.firstElementChild;
        const scrollbarXToTop = computeScrollbarXToTop.value;
        const { clientX: dragClientX } = evnt;
        const dragBtnElem = evnt.target;
        let cell = dragBtnElem.parentElement;
        let resizeColumn = column;
        const isDragGroupCol = column.children && column.children.length;
        if (isDragGroupCol) {
          resizeColumn = getLastChildColumn(column);
          if (isDragGroupCol) {
            const trEl = cell ? cell.parentElement : null;
            const theadEl = trEl ? trEl.parentElement : null;
            cell = theadEl ? theadEl.querySelector(`.vxe-header--column[colid="${resizeColumn.id}"]`) : null;
          }
        }
        if (!cell) {
          return;
        }
        const cellParams = import_xe_utils18.default.assign(params, { cell, $table: $xeTable });
        let dragLeft = 0;
        const tableRect = tableEl.getBoundingClientRect();
        const rightContainerRect = rightContainerElem ? rightContainerElem.getBoundingClientRect() : null;
        const cellRect = cell.getBoundingClientRect();
        const dragBtnRect = dragBtnElem.getBoundingClientRect();
        const dragBtnWidth = dragBtnElem.clientWidth;
        const dragBtnOffsetWidth = import_xe_utils18.default.floor(dragBtnWidth / 2);
        const dragPosLeft = dragBtnRect.x - tableRect.x + dragBtnOffsetWidth;
        const minInterval = getColReMinWidth(cellParams) - dragBtnOffsetWidth;
        const dragMinLeft = isRightFixed ? 0 : cellRect.x - tableRect.x + dragBtnWidth + minInterval;
        const dragMaxLeft = cellRect.x - tableRect.x + cell.clientWidth - minInterval;
        let fixedLeftRemainWidth = 0;
        let fixedRightRemainWidth = 0;
        if (isLeftFixed || isRightFixed) {
          let isMach = false;
          const fixedColumn = isLeftFixed ? leftList : rightList;
          for (let i = 0; i < fixedColumn.length; i++) {
            const item = fixedColumn[i];
            if (isMach) {
              fixedLeftRemainWidth += item.renderWidth;
            } else {
              isMach = item.id === resizeColumn.id;
              if (!isMach) {
                fixedRightRemainWidth += item.renderWidth;
              }
            }
          }
        }
        const updateEvent = (evnt2) => {
          evnt2.stopPropagation();
          evnt2.preventDefault();
          const tableHeight = tableEl.clientHeight;
          const offsetX = evnt2.clientX - dragClientX;
          let left = dragPosLeft + offsetX;
          if (isLeftFixed) {
            if (rightContainerRect) {
              left = Math.min(left, rightContainerRect.x - tableRect.x - fixedLeftRemainWidth - minInterval);
            }
          } else if (isRightFixed) {
            if (leftContainerElem) {
              left = Math.max(left, leftContainerElem.clientWidth + fixedRightRemainWidth + minInterval);
            }
            left = Math.min(left, dragMaxLeft);
          }
          dragLeft = Math.max(left, dragMinLeft);
          const resizeBarLeft = Math.max(1, dragLeft);
          resizeBarElem.style.left = `${resizeBarLeft}px`;
          resizeBarElem.style.top = `${scrollbarXToTop ? osbHeight : 0}px`;
          resizeBarElem.style.height = `${scrollbarXToTop ? tableHeight - osbHeight : tableHeight}px`;
          if (resizableOpts.showDragTip && resizeTipElem) {
            resizeTipElem.textContent = getI18n10("vxe.table.resizeColTip", [Math.floor(resizeColumn.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft))]);
            const tableWrapperWidth = tableEl.clientWidth;
            const resizeBarWidth = resizeBarElem.clientWidth;
            const resizeTipWidth = resizeTipElem.clientWidth;
            const resizeTipHeight = resizeTipElem.clientHeight;
            let resizeTipLeft = -resizeTipWidth;
            if (resizeBarLeft < resizeTipWidth + resizeBarWidth) {
              resizeTipLeft = 0;
            } else if (resizeBarLeft > tableWrapperWidth) {
              resizeTipLeft += tableWrapperWidth - resizeBarLeft;
            }
            resizeTipElem.style.left = `${resizeTipLeft}px`;
            resizeTipElem.style.top = `${Math.min(tableHeight - resizeTipHeight, Math.max(0, evnt2.clientY - tableRect.y - resizeTipHeight / 2))}px`;
          }
          reactData.isDragResize = true;
        };
        reactData.isDragResize = true;
        addClass(tableEl, "col-drag--resize");
        resizeBarElem.style.display = "block";
        document.onmousemove = updateEvent;
        document.onmouseup = function(evnt2) {
          document.onmousemove = null;
          document.onmouseup = null;
          resizeBarElem.style.display = "none";
          internalData._lastResizeTime = Date.now();
          setTimeout(() => {
            reactData.isDragResize = false;
          }, 50);
          const resizeWidth = resizeColumn.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft);
          const resizeParams = Object.assign(Object.assign({}, params), { resizeWidth, resizeColumn });
          if (resizableOpts.dragMode === "fixed") {
            visibleColumn.forEach((item) => {
              if (item.id !== resizeColumn.id) {
                if (!item.resizeWidth) {
                  item.resizeWidth = item.renderWidth;
                }
              }
            });
          }
          if ($xeTable.handleColResizeCellAreaEvent) {
            $xeTable.handleColResizeCellAreaEvent(evnt2, resizeParams);
          } else {
            resizeColumn.resizeWidth = resizeWidth;
            handleUpdateColResize(evnt2, resizeParams);
          }
          removeClass(tableEl, "col-drag--resize");
        };
        updateEvent(evnt);
        if ($xeTable.closeMenu) {
          $xeTable.closeMenu();
        }
      },
      handleColResizeDblclickEvent(evnt, params) {
        const resizableOpts = computeResizableOpts.value;
        const { isDblclickAutoWidth } = resizableOpts;
        const el = refElem.value;
        if (isDblclickAutoWidth && el) {
          evnt.stopPropagation();
          evnt.preventDefault();
          const { fullColumnIdData } = internalData;
          const { column } = params;
          let resizeColumn = column;
          if (column.children && column.children.length) {
            import_xe_utils18.default.eachTree(column.children, (childColumn) => {
              resizeColumn = childColumn;
            });
          }
          const colid = resizeColumn.id;
          const colRest = fullColumnIdData[colid];
          const dragBtnElem = evnt.target;
          const cell = dragBtnElem.parentNode;
          const cellParams = Object.assign(params, { cell, $table: $xeTable });
          const colMinWidth = getColReMinWidth(cellParams);
          el.setAttribute("data-calc-col", "Y");
          let resizeWidth = calcColumnAutoWidth(resizeColumn, el);
          el.removeAttribute("data-calc-col");
          if (colRest) {
            resizeWidth = Math.max(resizeWidth, colRest.width);
          }
          resizeWidth = Math.max(colMinWidth, resizeWidth);
          const resizeParams = Object.assign(Object.assign({}, params), { resizeWidth, resizeColumn });
          reactData.isDragResize = false;
          internalData._lastResizeTime = Date.now();
          if ($xeTable.handleColResizeDblclickCellAreaEvent) {
            $xeTable.handleColResizeDblclickCellAreaEvent(evnt, resizeParams);
          } else {
            resizeColumn.resizeWidth = resizeWidth;
            handleUpdateColResize(evnt, resizeParams);
          }
        }
      },
      handleRowResizeMousedownEvent(evnt, params) {
        evnt.stopPropagation();
        evnt.preventDefault();
        const { row } = params;
        const { showOverflow } = props;
        const { overflowX, scrollbarWidth, overflowY, scrollbarHeight } = reactData;
        const { elemStore, fullAllDataRowIdData } = internalData;
        const osbWidth = overflowY ? scrollbarWidth : 0;
        const osbHeight = overflowX ? scrollbarHeight : 0;
        const scrollbarYToLeft = computeScrollbarYToLeft.value;
        const resizableOpts = computeResizableOpts.value;
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        let tableEl = refElem.value;
        if ($xeGantt) {
          const { refGanttContainerElem } = $xeGantt.getRefMaps();
          const ganttContainerElem = refGanttContainerElem.value;
          if (ganttContainerElem) {
            tableEl = ganttContainerElem;
          }
        }
        const resizeBarElem = refRowResizeBar.value;
        if (!resizeBarElem) {
          return;
        }
        const { clientY: dragClientY } = evnt;
        const resizeTipElem = resizeBarElem.firstElementChild;
        const dragBtnElem = evnt.currentTarget;
        const tdEl = dragBtnElem.parentNode;
        const trEl = tdEl.parentNode;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        if (!bodyScrollElem) {
          return;
        }
        const rowid = getRowid($xeTable, row);
        const rowRest = fullAllDataRowIdData[rowid];
        if (!rowRest) {
          return;
        }
        const defaultRowHeight = computeDefaultRowHeight.value;
        let currCellHeight = rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
        if (!showOverflow) {
          currCellHeight = tdEl.clientHeight;
        }
        const tableRect = tableEl.getBoundingClientRect();
        const trRect = trEl.getBoundingClientRect();
        const targetOffsetY = dragClientY - trRect.y - trEl.clientHeight;
        let resizeHeight = currCellHeight;
        const cellEl = tdEl.querySelector(".vxe-cell");
        let cellMinHeight = 0;
        if (cellEl) {
          const cellStyle = getComputedStyle(cellEl);
          cellMinHeight = Math.max(1, Math.ceil(import_xe_utils18.default.toNumber(cellStyle.paddingTop) + import_xe_utils18.default.toNumber(cellStyle.paddingBottom)));
        }
        const minTop = trRect.y - tableRect.y + cellMinHeight;
        const updateEvent = (evnt2) => {
          evnt2.stopPropagation();
          evnt2.preventDefault();
          const rtWidth = tableEl.clientWidth - osbWidth;
          const tableHeight = tableEl.clientHeight - osbHeight;
          let dragTop = evnt2.clientY - tableRect.y - targetOffsetY;
          if (dragTop < minTop) {
            dragTop = minTop;
          } else {
            resizeHeight = Math.max(cellMinHeight, currCellHeight + evnt2.clientY - dragClientY);
          }
          resizeBarElem.style.left = `${scrollbarYToLeft ? osbWidth : 0}px`;
          resizeBarElem.style.top = `${dragTop}px`;
          resizeBarElem.style.width = `${rtWidth}px`;
          if (resizableOpts.showDragTip && resizeTipElem) {
            resizeTipElem.textContent = getI18n10("vxe.table.resizeRowTip", [resizeHeight]);
            const resizeTipWidth = resizeTipElem.clientWidth;
            const resizeTipHeight = resizeTipElem.clientHeight;
            let resizeBarLeft = Math.max(2, evnt2.clientX - tableRect.x);
            let resizeBarTop = 0;
            if (resizeBarLeft + resizeTipWidth >= rtWidth - 2) {
              resizeBarLeft = rtWidth - resizeTipWidth - 2;
            }
            if (dragTop + resizeTipHeight >= tableHeight) {
              resizeBarTop = tableHeight - (dragTop + resizeTipHeight);
            }
            resizeTipElem.style.left = `${resizeBarLeft}px`;
            resizeTipElem.style.top = `${resizeBarTop}px`;
          }
          reactData.isDragResize = true;
        };
        reactData.isDragResize = true;
        addClass(tableEl, "row-drag--resize");
        resizeBarElem.style.display = "block";
        document.onmousemove = updateEvent;
        document.onmouseup = function(evnt2) {
          document.onmousemove = null;
          document.onmouseup = null;
          resizeBarElem.style.display = "none";
          internalData._lastResizeTime = Date.now();
          setTimeout(() => {
            reactData.isDragResize = false;
          }, 50);
          if (resizeHeight !== currCellHeight) {
            const resizeParams = Object.assign(Object.assign({}, params), { resizeHeight, resizeRow: row });
            internalData.isResizeCellHeight = true;
            if ($xeTable.handleRowResizeCellAreaEvent) {
              $xeTable.handleRowResizeCellAreaEvent(evnt2, resizeParams);
            } else {
              rowRest.resizeHeight = resizeHeight;
              handleUpdateRowResize(evnt2, resizeParams);
              updateRowOffsetTop();
            }
          }
          removeClass(tableEl, "row-drag--resize");
        };
        updateEvent(evnt);
      },
      handleRowResizeDblclickEvent(evnt, params) {
        const resizableOpts = computeResizableOpts.value;
        const { isDblclickAutoHeight } = resizableOpts;
        const el = refElem.value;
        if (isDblclickAutoHeight && el) {
          evnt.stopPropagation();
          evnt.preventDefault();
          const { editStore } = reactData;
          const { fullAllDataRowIdData } = internalData;
          const { actived } = editStore;
          const { row } = params;
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (!rowRest) {
            return;
          }
          const handleRsHeight = () => {
            el.setAttribute("data-calc-row", "Y");
            const resizeHeight = calcCellAutoHeight(rowRest, el);
            el.removeAttribute("data-calc-row");
            const resizeParams = Object.assign(Object.assign({}, params), { resizeHeight, resizeRow: row });
            reactData.isDragResize = false;
            internalData._lastResizeTime = Date.now();
            if ($xeTable.handleRowResizeDblclickCellAreaEvent) {
              $xeTable.handleRowResizeDblclickCellAreaEvent(evnt, resizeParams);
            } else {
              rowRest.resizeHeight = resizeHeight;
              handleUpdateRowResize(evnt, resizeParams);
            }
          };
          if (actived.row || actived.column) {
            $xeTable.clearEdit().then(handleRsHeight);
          } else {
            handleRsHeight();
          }
        }
      },
      saveCustomStore(type) {
        const { customConfig } = props;
        const tableId = computeTableId.value;
        const customOpts = computeCustomOpts.value;
        const { updateStore, storage, storeOptions } = customOpts;
        const isAllCustom = storage === true;
        const storageOpts = Object.assign({}, isAllCustom ? {} : storage || {}, storeOptions);
        const isCustomResizable = hangleStorageDefaultValue(storageOpts.resizable, isAllCustom);
        const isCustomVisible = hangleStorageDefaultValue(storageOpts.visible, isAllCustom);
        const isCustomFixed = hangleStorageDefaultValue(storageOpts.fixed, isAllCustom);
        const isCustomSort = hangleStorageDefaultValue(storageOpts.sort, isAllCustom);
        const isCustomAggGroup = hangleStorageDefaultValue(storageOpts.aggGroup, isAllCustom);
        const isCustomAggFunc = hangleStorageDefaultValue(storageOpts.aggFunc, isAllCustom);
        if (type !== "reset") {
          reactData.isCustomStatus = true;
        }
        if (storage && (customConfig ? isEnableConf(customOpts) : customOpts.enabled) && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort || isCustomAggGroup || isCustomAggFunc)) {
          if (!tableId) {
            errLog("vxe.error.reqProp", ["id"]);
            return nextTick();
          }
          const storeData = type === "reset" ? {
            resizableData: {},
            sortData: [],
            visibleData: {},
            fixedData: {},
            aggGroupData: {},
            aggFuncData: {}
          } : tableMethods.getCustomStoreData();
          if (updateStore) {
            return updateStore({
              $table: $xeTable,
              id: tableId,
              type,
              storeData
            });
          } else {
            setCustomStorageMap(tableId, type === "reset" ? null : storeData);
          }
        }
        return nextTick();
      },
      handleCustom() {
        const { mouseConfig } = props;
        if (mouseConfig) {
          if ($xeTable.clearSelected) {
            $xeTable.clearSelected();
          }
          if ($xeTable.clearCellAreas) {
            $xeTable.clearCellAreas();
            $xeTable.clearCopyCellArea();
          }
        }
        tablePrivateMethods.analyColumnWidth();
        return tableMethods.refreshColumn(true);
      },
      handleUpdateDataQueue() {
        reactData.upDataFlag++;
      },
      handleRefreshColumnQueue() {
        reactData.reColumnFlag++;
      },
      handleFilterOptions(column) {
        if (column) {
          const { filterStore } = reactData;
          const { filterRender, filters } = column;
          const filterOptions = filters || [];
          const compConf = isEnableConf(filterRender) ? renderer9.get(filterRender.name) : null;
          const frMethod = column.filterRecoverMethod || (compConf ? compConf.tableFilterRecoverMethod || compConf.filterRecoverMethod : null);
          filterStore.column = column;
          filterOptions.forEach((option) => {
            const { _checked, checked } = option;
            option._checked = checked;
            if (!checked && _checked !== checked) {
              if (frMethod) {
                frMethod({ option, column, $table: $xeTable });
              }
            }
          });
          $xeTable.checkFilterOptions();
        }
      },
      preventEvent(evnt, type, args, next, end) {
        let evntList = interceptor.get(type);
        if (!evntList.length && type === "event.clearEdit") {
          evntList = interceptor.get("event.clearActived");
          if (evntList.length) {
            warnLog("vxe.error.delEvent", ["event.clearActived", "event.clearEdit"]);
          }
        }
        let rest = null;
        let isStop = false;
        for (let i = 0; i < evntList.length; i++) {
          const func = evntList[i];
          const fnRest = func(Object.assign({ $table: $xeTable, $grid: $xeGrid, gantt: $xeGantt, $event: evnt }, args));
          if (fnRest === false) {
            isStop = true;
            break;
          } else if (fnRest && fnRest.status === false) {
            rest = fnRest.result;
            isStop = true;
            break;
          }
        }
        if (!isStop) {
          if (next) {
            rest = next();
          }
        }
        if (end) {
          end();
        }
        return rest;
      },
      updateCheckboxStatus() {
        const { treeConfig } = props;
        const { isRowGroupStatus } = reactData;
        const { afterTreeFullData, afterGroupFullData, selectCheckboxMaps, treeIndeterminateRowMaps } = internalData;
        const aggregateOpts = computeAggregateOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, indeterminateField, checkStrictly, checkMethod } = checkboxOpts;
        if (checkStrictly) {
          return;
        }
        if (isRowGroupStatus || treeConfig) {
          const { handleGetRowId } = createHandleGetRowId($xeTable);
          const childRowMaps = {};
          const childRowList = [];
          if (isRowGroupStatus) {
            const mapChildrenField = aggregateOpts.mapChildrenField;
            if (mapChildrenField) {
              import_xe_utils18.default.eachTree(afterGroupFullData, (row) => {
                const rowid = handleGetRowId(row);
                const childList = row[mapChildrenField];
                if (childList && childList.length && !childRowMaps[rowid]) {
                  childRowMaps[rowid] = 1;
                  childRowList.unshift([row, rowid, childList]);
                }
              }, { children: mapChildrenField });
            }
          } else if (treeConfig) {
            const { transform, mapChildrenField } = treeOpts;
            import_xe_utils18.default.eachTree(afterTreeFullData, (row) => {
              const rowid = handleGetRowId(row);
              const childList = row[transform ? mapChildrenField : childrenField];
              if (childList && childList.length && !childRowMaps[rowid]) {
                childRowMaps[rowid] = 1;
                childRowList.unshift([row, rowid, childList]);
              } else {
                if (indeterminateField) {
                  import_xe_utils18.default.set(row, indeterminateField, false);
                }
              }
            }, { children: transform ? mapChildrenField : childrenField });
          }
          childRowList.forEach((vals) => {
            const row = vals[0];
            const rowid = vals[1];
            const childList = vals[2];
            let sLen = 0;
            let hLen = 0;
            let vLen = 0;
            const cLen = childList.length;
            childList.forEach(checkMethod ? (item) => {
              const childRowid = handleGetRowId(item);
              const isSelect = checkField ? import_xe_utils18.default.get(item, checkField) : selectCheckboxMaps[childRowid];
              if (checkMethod({ $table: $xeTable, row: item })) {
                if (isSelect) {
                  sLen++;
                } else if (treeIndeterminateRowMaps[childRowid]) {
                  hLen++;
                }
                vLen++;
              } else {
                if (isSelect) {
                  sLen++;
                } else if (treeIndeterminateRowMaps[childRowid]) {
                  hLen++;
                }
              }
            } : (item) => {
              const childRowid = handleGetRowId(item);
              const isSelect = checkField ? import_xe_utils18.default.get(item, checkField) : selectCheckboxMaps[childRowid];
              if (isSelect) {
                sLen++;
              } else if (treeIndeterminateRowMaps[childRowid]) {
                hLen++;
              }
              vLen++;
            });
            let isSelected = false;
            if (cLen > 0) {
              if (vLen > 0) {
                isSelected = (sLen > 0 || hLen > 0) && sLen >= vLen;
              } else {
                if (sLen > 0 && sLen >= vLen) {
                  isSelected = true;
                } else if (selectCheckboxMaps[rowid]) {
                  isSelected = true;
                } else {
                  isSelected = false;
                }
              }
            } else {
              isSelected = selectCheckboxMaps[rowid];
            }
            const halfSelect = !isSelected && (sLen > 0 || hLen > 0);
            if (checkField) {
              import_xe_utils18.default.set(row, checkField, isSelected);
            }
            if (indeterminateField) {
              import_xe_utils18.default.set(row, indeterminateField, halfSelect);
            }
            if (isSelected) {
              if (!checkField) {
                selectCheckboxMaps[rowid] = row;
              }
              if (treeIndeterminateRowMaps[rowid]) {
                delete treeIndeterminateRowMaps[rowid];
              }
            } else {
              if (!checkField) {
                if (selectCheckboxMaps[rowid]) {
                  delete selectCheckboxMaps[rowid];
                }
              }
              if (halfSelect) {
                treeIndeterminateRowMaps[rowid] = row;
              } else {
                if (treeIndeterminateRowMaps[rowid]) {
                  delete treeIndeterminateRowMaps[rowid];
                }
              }
            }
          });
        }
        reactData.updateCheckboxFlag++;
      },
      updateAllCheckboxStatus() {
        const { treeConfig } = props;
        const { isRowGroupStatus } = reactData;
        const { afterFullData, afterTreeFullData, afterGroupFullData, checkboxReserveRowMap, selectCheckboxMaps, treeIndeterminateRowMaps } = internalData;
        const aggregateOpts = computeAggregateOpts.value;
        const { mapChildrenField } = aggregateOpts;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkMethod, showReserveStatus } = checkboxOpts;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        let sLen = 0;
        let dsLen = 0;
        let hLen = 0;
        let dhLen = 0;
        let vLen = 0;
        const rootList = treeConfig ? afterTreeFullData : isRowGroupStatus ? afterGroupFullData : afterFullData;
        rootList.forEach(checkMethod ? (row) => {
          const childRowid = handleGetRowId(row);
          const selected = checkField ? import_xe_utils18.default.get(row, checkField) : selectCheckboxMaps[childRowid];
          if (isRowGroupStatus && $xeTable.isAggregateRecord(row)) {
            const childList = row[mapChildrenField || ""];
            if (selected) {
              vLen++;
              sLen++;
            } else if (treeIndeterminateRowMaps[childRowid]) {
              vLen++;
              hLen++;
            } else if (childList && childList.length && childList.some((item) => checkMethod({ $table: $xeTable, row: item }))) {
              vLen++;
            }
          } else if (checkMethod({ $table: $xeTable, row })) {
            if (selected) {
              sLen++;
            } else if (treeIndeterminateRowMaps[childRowid]) {
              hLen++;
            }
            vLen++;
          } else {
            if (selected) {
              dsLen++;
            } else if (treeIndeterminateRowMaps[childRowid]) {
              dhLen++;
            }
          }
        } : (row) => {
          const childRowid = handleGetRowId(row);
          const selected = checkField ? import_xe_utils18.default.get(row, checkField) : selectCheckboxMaps[childRowid];
          if (selected) {
            sLen++;
          } else if (treeIndeterminateRowMaps[childRowid]) {
            hLen++;
          }
          vLen++;
        });
        const isSelected = rootList.length > 0 ? vLen > 0 ? sLen >= vLen : sLen >= rootList.length : false;
        let halfSelect = !isSelected && (sLen > 0 || hLen > 0 || dsLen > 0 || dhLen > 0);
        if (!isSelected && !halfSelect && showReserveStatus) {
          halfSelect = !import_xe_utils18.default.isEmpty(checkboxReserveRowMap);
        }
        reactData.isAllSelected = isSelected;
        reactData.isIndeterminate = halfSelect;
      },
      checkSelectionStatus() {
        $xeTable.updateCheckboxStatus();
        $xeTable.updateAllCheckboxStatus();
      },
      /**
       * 切换选中
       * 多选，行选中事件
       */
      handleBatchSelectRows(rows, checked, isForce) {
        const { treeConfig } = props;
        const { isRowGroupStatus } = reactData;
        const { selectCheckboxMaps } = internalData;
        const aggregateOpts = computeAggregateOpts.value;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkStrictly, checkMethod } = checkboxOpts;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (checkField) {
          if ((treeConfig || isRowGroupStatus) && !checkStrictly) {
            import_xe_utils18.default.eachTree(rows, (row) => {
              if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
                import_xe_utils18.default.set(row, checkField, checked);
                if (indeterminateField) {
                  import_xe_utils18.default.set(row, indeterminateField, false);
                }
                handleCheckboxReserveRow(row, checked);
              }
            }, { children: transform ? mapChildrenField : childrenField });
            reactData.updateCheckboxFlag++;
            return;
          }
          rows.forEach((row) => {
            if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
              import_xe_utils18.default.set(row, checkField, checked);
              handleCheckboxReserveRow(row, checked);
            }
          });
          reactData.updateCheckboxFlag++;
          return;
        }
        if (!checkStrictly) {
          if (isRowGroupStatus) {
            import_xe_utils18.default.eachTree(rows, (row) => {
              const rowid = handleGetRowId(row);
              if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
                if (checked) {
                  selectCheckboxMaps[rowid] = row;
                } else {
                  if (selectCheckboxMaps[rowid]) {
                    delete selectCheckboxMaps[rowid];
                  }
                }
                handleCheckboxReserveRow(row, checked);
              }
            }, { children: aggregateOpts.mapChildrenField });
            reactData.updateCheckboxFlag++;
            return;
          } else if (treeConfig) {
            import_xe_utils18.default.eachTree(rows, (row) => {
              const rowid = handleGetRowId(row);
              if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
                if (checked) {
                  selectCheckboxMaps[rowid] = row;
                } else {
                  if (selectCheckboxMaps[rowid]) {
                    delete selectCheckboxMaps[rowid];
                  }
                }
                handleCheckboxReserveRow(row, checked);
              }
            }, { children: transform ? mapChildrenField : childrenField });
            reactData.updateCheckboxFlag++;
            return;
          }
        }
        rows.forEach((row) => {
          const rowid = handleGetRowId(row);
          if (isForce || (!checkMethod || checkMethod({ $table: $xeTable, row }))) {
            if (checked) {
              if (!selectCheckboxMaps[rowid]) {
                selectCheckboxMaps[rowid] = row;
              }
            } else {
              if (selectCheckboxMaps[rowid]) {
                delete selectCheckboxMaps[rowid];
              }
            }
            handleCheckboxReserveRow(row, checked);
            reactData.updateCheckboxFlag++;
          }
        });
      },
      /**
       * 即将移除
       * @deprecated
       */
      handleSelectRow({ row }, checked, isForce) {
        $xeTable.handleBatchSelectRows([row], checked, isForce);
      },
      /**
       * 处理合并
       */
      handleUpdateBodyMerge() {
        const { mergeBodyList } = internalData;
        internalData.mergeBodyCellMaps = buildMergeData(mergeBodyList);
        reactData.mergeBodyFlag++;
      },
      handleUpdateHeaderMerge() {
        const { mergeHeaderList } = internalData;
        internalData.mergeHeaderCellMaps = buildMergeData(mergeHeaderList);
        reactData.mergeHeadFlag++;
      },
      handleUpdateFooterMerge() {
        const { mergeFooterList } = internalData;
        internalData.mergeFooterCellMaps = buildMergeData(mergeFooterList);
        reactData.mergeFootFlag++;
      },
      handleAggregateSummaryData() {
        return updateGroupData();
      },
      triggerHeaderTitleEvent(evnt, iconParams, params) {
        const tipContent = iconParams.content || iconParams.message;
        if (tipContent) {
          const { tooltipStore } = reactData;
          const { column } = params;
          const content = getFuncText(tipContent);
          handleTargetEnterEvent(true);
          tooltipStore.row = null;
          tooltipStore.column = column;
          tooltipStore.visible = true;
          tooltipStore.currOpts = iconParams;
          nextTick(() => {
            const $tooltip = refTooltip.value;
            if ($tooltip && $tooltip.open) {
              $tooltip.open(evnt.currentTarget, content);
            }
          });
        }
      },
      /**
       * 触发表头 tooltip 事件
       */
      triggerHeaderTooltipEvent(evnt, params) {
        const { tooltipStore } = reactData;
        const headerTooltipOpts = computeHeaderTooltipOpts.value;
        const { column } = params;
        handleTargetEnterEvent(true);
        const titleElem = evnt.currentTarget;
        if (!titleElem) {
          return;
        }
        const cWrapperEl = titleElem.parentElement;
        if (!cWrapperEl) {
          return;
        }
        const cellEl = cWrapperEl.parentElement;
        if (!cellEl) {
          return;
        }
        const thEl = cellEl.parentElement;
        if (!thEl) {
          return;
        }
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          const ctEl = thEl.querySelector(".vxe-cell--title");
          handleTooltip(evnt, headerTooltipOpts, "header", thEl, (hasClass(thEl, "col--ellipsis") ? ctEl : cWrapperEl) || cWrapperEl, ctEl || cellEl, params);
        }
      },
      /**
       * 触发单元格 tooltip 事件
       */
      triggerBodyTooltipEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore } = reactData;
        const { tooltipStore } = reactData;
        const tooltipOpts = computeTooltipOpts.value;
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const { row, column } = params;
        const tdEl = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || tooltipStore.row !== row);
        if (column.editRender && isEnableConf(editConfig)) {
          if (editOpts.mode === "row" && actived.row === row) {
            return;
          }
          if (actived.row === row && actived.column === column) {
            return;
          }
        }
        if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {
          const ctEl = tdEl.querySelector(".vxe-cell--wrapper");
          let ovEl = null;
          let tipEl = tdEl.querySelector(column.type === "html" ? ".vxe-cell--html" : ".vxe-cell--label");
          if (column.treeNode) {
            ovEl = tdEl.querySelector(".vxe-tree-cell");
          }
          if (!tipEl) {
            tipEl = ctEl;
          }
          handleTooltip(evnt, tooltipOpts, "body", tdEl, ovEl || ctEl, tipEl, params);
        }
      },
      /**
       * 触发表尾 tooltip 事件
       */
      triggerFooterTooltipEvent(evnt, params) {
        const { column } = params;
        const { tooltipStore } = reactData;
        const footerTooltipOpts = computeFooterTooltipOpts.value;
        const tdEl = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || !!tooltipStore.row);
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          const ctEl = tdEl.querySelector(".vxe-cell--wrapper");
          let ovEl = null;
          let tipEl = tdEl.querySelector(column.type === "html" ? ".vxe-cell--html" : ".vxe-cell--label");
          if (column.type === "html") {
            ovEl = tdEl.querySelector(".vxe-cell--html");
          }
          if (!tipEl) {
            tipEl = ctEl;
          }
          handleTooltip(evnt, footerTooltipOpts, "footer", tdEl, ovEl || ctEl, tipEl, params);
        }
      },
      handleTargetLeaveEvent() {
        const tooltipOpts = computeTooltipOpts.value;
        let $tooltip = refTooltip.value;
        if ($tooltip && $tooltip.setActived) {
          $tooltip.setActived(false);
        }
        if (tooltipOpts.enterable) {
          internalData.tooltipTimeout = setTimeout(() => {
            $tooltip = refTooltip.value;
            if ($tooltip && $tooltip.isActived && !$tooltip.isActived()) {
              $xeTable.closeTooltip();
            }
          }, tooltipOpts.leaveDelay);
        } else {
          $xeTable.closeTooltip();
        }
      },
      triggerHeaderCellClickEvent(evnt, params) {
        const { _lastResizeTime } = internalData;
        const sortOpts = computeSortOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const { column } = params;
        const cell = evnt.currentTarget;
        const triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;
        const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
        const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
        if (sortOpts.trigger === "cell" && !(triggerResizable || triggerSort || triggerFilter)) {
          $xeTable.triggerSortEvent(evnt, column, getNextSortOrder(column));
        }
        dispatchEvent("header-cell-click", Object.assign({ triggerResizable, triggerSort, triggerFilter, cell }, params), evnt);
        if ((columnOpts.isCurrent || props.highlightCurrentColumn) && (!currentColumnOpts.trigger || ["header", "default"].includes(currentColumnOpts.trigger))) {
          $xeTable.triggerCurrentColumnEvent(evnt, params);
        }
      },
      triggerHeaderCellDblclickEvent(evnt, params) {
        dispatchEvent("header-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, params), evnt);
      },
      /**
       * 列点击事件
       * 如果是单击模式，则激活为编辑状态
       * 如果是双击模式，则单击后选中状态
       */
      triggerCellClickEvent(evnt, params) {
        const { treeConfig, highlightCurrentRow, highlightCurrentColumn, editConfig, aggregateConfig, rowGroupConfig } = props;
        const { editStore, isDragResize, expandColumn, checkboxColumn, radioColumn } = reactData;
        if (isDragResize) {
          return;
        }
        const expandOpts = computeExpandOpts.value;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const keyboardOpts = computeKeyboardOpts.value;
        const aggregateOpts = computeAggregateOpts.value;
        const rowOpts = computeRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const { actived, focused } = editStore;
        const { row, column } = params;
        const { type, treeNode, rowGroupNode } = column;
        const isRadioType = type === "radio";
        const isCheckboxType = type === "checkbox";
        const isExpandType = type === "expand";
        const cell = evnt.currentTarget;
        const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, "vxe-cell--radio").flag;
        const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, "vxe-cell--tree-btn").flag;
        const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-table--expanded").flag;
        const triggerRowGroupNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-row-group--node-btn").flag;
        params = Object.assign({ cell, triggerRadio, triggerCheckbox, triggerTreeNode, triggerExpandNode }, params);
        if (!triggerCheckbox && !triggerRadio) {
          if (!triggerExpandNode && (expandColumn && expandOpts.trigger === "row" || isExpandType && expandOpts.trigger === "cell")) {
            $xeTable.triggerRowExpandEvent(evnt, params);
          }
          if (treeConfig && (treeOpts.trigger === "row" || treeNode && treeOpts.trigger === "cell")) {
            $xeTable.triggerTreeExpandEvent(evnt, params);
          }
          if ((aggregateConfig || rowGroupConfig) && (aggregateOpts.trigger === "row" || rowGroupNode && aggregateOpts.trigger === "cell")) {
            $xeTable.triggerRowGroupExpandEvent(evnt, params);
          }
        }
        if (!triggerTreeNode) {
          if (!triggerExpandNode && !triggerRowGroupNode) {
            if (rowOpts.isCurrent || highlightCurrentRow) {
              if (!triggerCheckbox && !triggerRadio) {
                $xeTable.triggerCurrentRowEvent(evnt, params);
              }
            }
            if ((columnOpts.isCurrent || highlightCurrentColumn) && (!currentColumnOpts.trigger || ["cell", "default"].includes(currentColumnOpts.trigger))) {
              if (!triggerCheckbox && !triggerRadio) {
                $xeTable.triggerCurrentColumnEvent(evnt, params);
              }
            }
            if (!triggerRadio && (radioColumn && radioOpts.trigger === "row" || isRadioType && radioOpts.trigger === "cell")) {
              $xeTable.triggerRadioRowEvent(evnt, params);
            }
            if (!triggerCheckbox && (checkboxColumn && checkboxOpts.trigger === "row" || isCheckboxType && checkboxOpts.trigger === "cell")) {
              $xeTable.handleToggleCheckRowEvent(evnt, params);
            }
          }
          if (isEnableConf(editConfig)) {
            if (keyboardOpts.arrowCursorLock && evnt && editOpts.mode === "cell" && evnt.target && /^input|textarea$/i.test(evnt.target.tagName)) {
              focused.column = column;
              focused.row = row;
            }
            if (editOpts.trigger === "manual") {
              if (actived.args && actived.row === row && column !== actived.column) {
                handleChangeCell(evnt, params);
              }
            } else if (!actived.args || row !== actived.row || column !== actived.column) {
              if (editOpts.trigger === "click") {
                handleChangeCell(evnt, params);
              } else if (editOpts.trigger === "dblclick") {
                if (editOpts.mode === "row" && actived.row === row) {
                  handleChangeCell(evnt, params);
                }
              }
            }
          }
        }
        if (isEnableConf(editConfig) && editOpts.trigger === "dblclick") {
          if (actived.row && actived.column) {
            if (editOpts.mode === "row") {
              if (!$xeTable.eqRow(actived.row, row)) {
                $xeTable.handleClearEdit(evnt);
              }
            } else if (editOpts.mode === "cell") {
              if (!$xeTable.eqRow(actived.row, row) || actived.column.id !== column.id) {
                $xeTable.handleClearEdit(evnt);
              }
            }
          }
        }
        dispatchEvent("cell-click", params, evnt);
      },
      /**
       * 列双击点击事件
       * 如果是双击模式，则激活为编辑状态
       */
      triggerCellDblclickEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore, isDragResize } = reactData;
        if (isDragResize) {
          return;
        }
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const cell = evnt.currentTarget;
        params = Object.assign({ cell }, params);
        if (isEnableConf(editConfig) && editOpts.trigger === "dblclick") {
          if (!actived.args || evnt.currentTarget !== actived.args.cell) {
            if (editOpts.mode === "row") {
              checkValidate("blur").catch((e) => e).then(() => {
                $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e) => e);
              });
            } else if (editOpts.mode === "cell") {
              $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e) => e);
            }
          }
        }
        dispatchEvent("cell-dblclick", params, evnt);
      },
      handleToggleCheckRowEvent(evnt, params) {
        const { selectCheckboxMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, trigger } = checkboxOpts;
        const { row } = params;
        if (trigger === "manual") {
          return;
        }
        let checked = false;
        if (checkField) {
          checked = !import_xe_utils18.default.get(row, checkField);
        } else {
          checked = !selectCheckboxMaps[getRowid($xeTable, row)];
        }
        if (evnt) {
          $xeTable.triggerCheckRowEvent(evnt, params, checked);
        } else {
          $xeTable.handleBatchSelectRows([row], checked);
          $xeTable.checkSelectionStatus();
        }
      },
      triggerCheckRowEvent(evnt, params, checked) {
        const { treeConfig } = props;
        const { row } = params;
        const { isRowGroupStatus } = reactData;
        const { afterFullData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkMethod, trigger } = checkboxOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        if (checkboxOpts.isShiftKey && evnt.shiftKey && !(treeConfig || isRowGroupStatus)) {
          const checkboxRecords = $xeTable.getCheckboxRecords();
          if (checkboxRecords.length) {
            const firstRow = checkboxRecords[0];
            const _rowIndex = $xeTable.getVTRowIndex(row);
            const _firstRowIndex = $xeTable.getVTRowIndex(firstRow);
            if (_rowIndex !== _firstRowIndex) {
              $xeTable.setAllCheckboxRow(false);
              const rangeRows = _rowIndex < _firstRowIndex ? afterFullData.slice(_rowIndex, _firstRowIndex + 1) : afterFullData.slice(_firstRowIndex, _rowIndex + 1);
              nextTick(() => {
                handleCheckedCheckboxRow(rangeRows, true, false);
              });
              dispatchEvent("checkbox-range-select", Object.assign({ rangeRecords: rangeRows }, params), evnt);
              return;
            }
          }
        }
        if (isRowGroupStatus || !checkMethod || checkMethod({ $table: $xeTable, row })) {
          $xeTable.handleBatchSelectRows([row], checked);
          $xeTable.checkSelectionStatus();
          dispatchEvent("checkbox-change", Object.assign({
            records: () => $xeTable.getCheckboxRecords(),
            reserves: () => $xeTable.getCheckboxReserveRecords(),
            indeterminates: () => $xeTable.getCheckboxIndeterminateRecords(),
            checked
          }, params), evnt);
        }
      },
      /**
       * 多选，选中所有事件
       */
      triggerCheckAllEvent(evnt, value) {
        const checkboxOpts = computeCheckboxOpts.value;
        const { trigger } = checkboxOpts;
        if (trigger === "manual") {
          return;
        }
        if (evnt) {
          evnt.stopPropagation();
        }
        handleCheckAllEvent(evnt, value);
      },
      /**
       * 单选，行选中事件
       */
      triggerRadioRowEvent(evnt, params) {
        const { selectRadioRow: oldValue } = reactData;
        const { row } = params;
        const radioOpts = computeRadioOpts.value;
        const { trigger, checkMethod } = radioOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        if (!checkMethod || checkMethod({ $table: $xeTable, row })) {
          let newValue = row;
          let isChange = oldValue !== newValue;
          if (isChange) {
            handleCheckedRadioRow(newValue);
          } else if (!radioOpts.strict) {
            isChange = oldValue === newValue;
            if (isChange) {
              newValue = null;
              $xeTable.clearRadioRow();
            }
          }
          if (isChange) {
            dispatchEvent("radio-change", Object.assign({ oldValue, newValue }, params), evnt);
          }
        }
      },
      triggerCurrentColumnEvent(evnt, params) {
        const { currentColumn: oldValue } = reactData;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const beforeRowMethod = currentColumnOpts.beforeSelectMethod || columnOpts.currentMethod;
        const { column: newValue } = params;
        const { trigger } = currentColumnOpts;
        if (trigger === "manual") {
          return;
        }
        const isChange = oldValue !== newValue;
        if (!beforeRowMethod || beforeRowMethod({ column: newValue, $table: $xeTable })) {
          $xeTable.setCurrentColumn(newValue);
          if (isChange) {
            dispatchEvent("current-column-change", Object.assign({ oldValue, newValue }, params), evnt);
          }
        } else {
          dispatchEvent("current-column-disabled", params, evnt);
        }
      },
      triggerCurrentRowEvent(evnt, params) {
        const { currentRow: oldValue } = reactData;
        const rowOpts = computeRowOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const beforeRowMethod = currentRowOpts.beforeSelectMethod || rowOpts.currentMethod;
        const { row: newValue } = params;
        const { trigger } = currentRowOpts;
        if (trigger === "manual") {
          return;
        }
        const isChange = oldValue !== newValue;
        if (!beforeRowMethod || beforeRowMethod({ row: newValue, $table: $xeTable })) {
          $xeTable.setCurrentRow(newValue);
          if (isChange) {
            dispatchEvent("current-row-change", Object.assign({ oldValue, newValue }, params), evnt);
            dispatchEvent("current-change", Object.assign({ oldValue, newValue }, params), evnt);
          }
        } else {
          dispatchEvent("current-row-disabled", params, evnt);
        }
      },
      /**
       * 展开行事件
       */
      triggerRowExpandEvent(evnt, params) {
        const { expandColumn } = reactData;
        const { rowExpandLazyLoadedMaps } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { row } = params;
        const { lazy, trigger } = expandOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        const rowid = getRowid($xeTable, row);
        if (!lazy || !rowExpandLazyLoadedMaps[rowid]) {
          const expanded = !$xeTable.isRowExpandByRow(row);
          const columnIndex = expandColumn ? $xeTable.getColumnIndex(expandColumn) : -1;
          const $columnIndex = expandColumn ? $xeTable.getVMColumnIndex(expandColumn) : -1;
          $xeTable.setRowExpand(row, expanded);
          dispatchEvent("toggle-row-expand", {
            expanded,
            column: expandColumn,
            columnIndex,
            $columnIndex,
            row,
            rowIndex: $xeTable.getRowIndex(row),
            $rowIndex: $xeTable.getVMRowIndex(row)
          }, evnt);
        }
      },
      /**
       * 行分组事件
       */
      triggerRowGroupExpandEvent(evnt, params) {
        const { rowGroupExpandedMaps } = internalData;
        const aggregateOpts = computeAggregateOpts.value;
        const { row, column } = params;
        const { trigger } = aggregateOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        const rowid = getRowid($xeTable, row);
        const expanded = !rowGroupExpandedMaps[rowid];
        const columnIndex = $xeTable.getColumnIndex(column);
        const $columnIndex = $xeTable.getVMColumnIndex(column);
        $xeTable.setRowGroupExpand(row, expanded);
        dispatchEvent("toggle-row-group-expand", { expanded, column, columnIndex, $columnIndex, row }, evnt);
      },
      /**
       * 展开树节点事件
       */
      triggerTreeExpandEvent(evnt, params) {
        const { treeExpandLazyLoadedMaps, treeEATime } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { row, column } = params;
        const { lazy, trigger, accordion } = treeOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        const rowid = getRowid($xeTable, row);
        if (!lazy || !treeExpandLazyLoadedMaps[rowid]) {
          const expanded = !$xeTable.isTreeExpandByRow(row);
          const columnIndex = $xeTable.getColumnIndex(column);
          const $columnIndex = $xeTable.getVMColumnIndex(column);
          if (treeEATime) {
            clearTimeout(treeEATime);
          }
          $xeTable.setTreeExpand(row, expanded).then(() => {
            if (accordion) {
              internalData.treeEATime = setTimeout(() => {
                internalData.treeEATime = void 0;
                $xeTable.scrollToRow(row);
              }, 30);
            }
          });
          dispatchEvent("toggle-tree-expand", { expanded, column, columnIndex, $columnIndex, row }, evnt);
        }
      },
      handleColumnSortEvent(evnt, column) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        const { field, sortable, order } = column;
        if (sortable) {
          const params = { $table: $xeTable, $event: evnt, column, field, property: field, order, sortList: tableMethods.getSortColumns(), sortTime: column.sortTime };
          if (mouseConfig && mouseOpts.area && $xeTable.handleSortEvent) {
            $xeTable.handleSortEvent(evnt, params);
          }
          if (!order) {
            dispatchEvent("clear-sort", params, evnt);
          }
          dispatchEvent("sort-change", params, evnt);
        }
      },
      /**
       * 点击排序事件
       */
      triggerSortEvent(evnt, column, order) {
        const sortOpts = computeSortOpts.value;
        const { multiple, allowClear } = sortOpts;
        const { field, sortable } = column;
        if (sortable) {
          if (!order || column.order === order) {
            if (allowClear) {
              $xeTable.clearSort(multiple ? column : null);
            }
          } else {
            $xeTable.sort({ field, order });
          }
          $xeTable.handleColumnSortEvent(evnt, column);
        }
      },
      handleCellRuleUpdateStatus(type, cellParams, cellValue) {
        const { validStore } = reactData;
        const { row, column } = cellParams;
        if ($xeTable.hasCellRules) {
          if ($xeTable.hasCellRules(type, row, column)) {
            const cell = $xeTable.getCellElement(row, column);
            if (cell) {
              const customVal = !import_xe_utils18.default.isUndefined(cellValue);
              return $xeTable.validCellRules(type, row, column, cellValue).then(() => {
                if (customVal && validStore.visible) {
                  setCellValue(row, column, cellValue);
                }
                $xeTable.clearValidate(row, column);
              }).catch(({ rule }) => {
                if (customVal) {
                  setCellValue(row, column, cellValue);
                }
                $xeTable.showValidTooltip({ rule, row, column, cell });
              });
            }
          }
        }
        return nextTick();
      },
      /**
       * 表头单元格按下事件
       */
      triggerHeaderCellMousedownEvent(evnt, params) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        const columnOpts = computeColumnOpts.value;
        const columnDragOpts = computeColumnDragOpts.value;
        const { trigger, isCrossDrag, isPeerDrag, disabledMethod } = columnDragOpts;
        const cell = evnt.currentTarget;
        const triggerInput = cell && cell.tagName && cell.tagName.toLowerCase() === "input";
        const triggerCheckbox = getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
        const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
        let triggerDrag = false;
        const isColDragCell = columnOpts.drag && trigger === "cell";
        if (!(triggerInput || triggerCheckbox || triggerSort || triggerFilter)) {
          const { column } = params;
          if (isColDragCell && !column.fixed && (isCrossDrag || isPeerDrag || !column.parentId) && !(disabledMethod && disabledMethod(params))) {
            triggerDrag = true;
            $xeTable.handleHeaderCellDragMousedownEvent(evnt, params);
          }
        }
        if (!triggerDrag && mouseConfig && mouseOpts.area && $xeTable.handleHeaderCellAreaMouseDnEvent) {
          $xeTable.handleHeaderCellAreaMouseDnEvent(evnt, Object.assign({ cell, triggerSort, triggerFilter }, params));
        }
        $xeTable.focus();
        if ($xeTable.closeMenu) {
          $xeTable.closeMenu();
        }
      },
      /**
       * 单元格按下事件
       */
      triggerCellMousedownEvent(evnt, params) {
        const { column } = params;
        const { type, treeNode } = column;
        const isRadioType = type === "radio";
        const isCheckboxType = type === "checkbox";
        const isExpandType = type === "expand";
        const rowOpts = computeRowOpts.value;
        const rowDragOpts = computeRowDragOpts.value;
        const { trigger, isCrossDrag, isPeerDrag, disabledMethod } = rowDragOpts;
        const cell = evnt.currentTarget;
        params.cell = cell;
        const triggerInput = cell && cell.tagName && cell.tagName.toLowerCase() === "input";
        const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, "vxe-cell--radio").flag;
        const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, "vxe-cell--tree-btn").flag;
        const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-table--expanded").flag;
        let isColDragCell = false;
        if (rowOpts.drag) {
          isColDragCell = trigger === "row" || column.dragSort && trigger === "cell";
        }
        let triggerDrag = false;
        if (!(triggerInput || triggerRadio || triggerCheckbox || triggerTreeNode || triggerExpandNode)) {
          if (isColDragCell && (isCrossDrag || isPeerDrag || !params.level) && !(disabledMethod && disabledMethod(params))) {
            triggerDrag = true;
            $xeTable.handleCellDragMousedownEvent(evnt, params);
          }
        }
        if (!triggerDrag && $xeTable.handleCellMousedownEvent) {
          $xeTable.handleCellMousedownEvent(evnt, params);
        }
        $xeTable.focus();
        $xeTable.closeFilter();
        if ($xeTable.closeMenu) {
          $xeTable.closeMenu();
        }
      },
      triggerCellMouseupEvent() {
        clearDragStatus();
      },
      /**
       * 行拖拽
       */
      handleRowDragDragstartEvent(evnt) {
        if (evnt.dataTransfer) {
          evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
        }
      },
      handleRowDragSwapEvent(evnt, isSyncRow, dragRow, prevDragRow, prevDragPos, prevDragToChild) {
        const { treeConfig, dragConfig } = props;
        const rowDragOpts = computeRowDragOpts.value;
        const { afterFullData, tableFullData, fullAllDataRowIdData } = internalData;
        const $xeGanttView = internalData.xeGanttView;
        const { animation, isPeerDrag, isCrossDrag, isSelfToChildDrag, dragEndMethod, dragToChildMethod } = rowDragOpts;
        const treeOpts = computeTreeOpts.value;
        const cellOpts = computeCellOpts.value;
        const rowOpts = computeRowOpts.value;
        const defaultRowHeight = computeDefaultRowHeight.value;
        const { transform, rowField, mapChildrenField, parentField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const dEndMethod = dragEndMethod || (dragConfig ? dragConfig.dragEndMethod : null);
        const dragOffsetIndex = prevDragPos === "bottom" ? 1 : 0;
        const el = refElem.value;
        const errRest = {
          status: false
        };
        if (!(el && prevDragRow && dragRow)) {
          return Promise.resolve(errRest);
        }
        if (prevDragRow !== dragRow) {
          const dragParams = {
            oldRow: dragRow,
            newRow: prevDragRow,
            dragRow,
            dragPos: prevDragPos,
            dragToChild: !!prevDragToChild,
            offsetIndex: dragOffsetIndex
          };
          const isDragToChildFlag = isSelfToChildDrag && dragToChildMethod ? dragToChildMethod(dragParams) : prevDragToChild;
          return Promise.resolve(dEndMethod ? dEndMethod(dragParams) : true).then((status) => {
            if (!status) {
              clearRowDragData();
              clearCrossTableDragStatus();
              return errRest;
            }
            const dragRowid = getRowid($xeTable, dragRow);
            const dragRowRest = fullAllDataRowIdData[dragRowid] || {};
            const _dragRowIndex = dragRowRest._index;
            let dragRowHeight = 0;
            let dragOffsetTop = -1;
            if (animation) {
              dragRowHeight = getCellRestHeight(dragRowRest, cellOpts, rowOpts, defaultRowHeight);
              const oldTrEl = el.querySelector(`.vxe-body--row[rowid="${dragRowid}"]`);
              if (oldTrEl) {
                dragOffsetTop = oldTrEl.offsetTop;
              }
            }
            let oafIndex = -1;
            let nafIndex = -1;
            if (treeConfig) {
              if (transform) {
                const oldRest = dragRowRest;
                const newRowid = getRowid($xeTable, prevDragRow);
                const newRest = fullAllDataRowIdData[newRowid];
                if (oldRest && newRest) {
                  const { level: oldLevel } = oldRest;
                  const { level: newLevel } = newRest;
                  const oldAllMaps = {};
                  import_xe_utils18.default.eachTree([dragRow], (item) => {
                    oldAllMaps[getRowid($xeTable, item)] = item;
                  }, { children: mapChildrenField });
                  let isSelfToChildStatus = false;
                  if (oldLevel && newLevel) {
                    if (isPeerDrag && !isCrossDrag) {
                      if (oldRest.row[parentField] !== newRest.row[parentField]) {
                        return errRest;
                      }
                    } else {
                      if (!isCrossDrag) {
                        return errRest;
                      }
                      if (oldAllMaps[newRowid]) {
                        isSelfToChildStatus = true;
                        if (!(isCrossDrag && isSelfToChildDrag)) {
                          if (VxeUI.modal) {
                            VxeUI.modal.message({
                              status: "error",
                              content: getI18n10("vxe.error.treeDragChild")
                            });
                          }
                          return errRest;
                        }
                      }
                    }
                  } else if (oldLevel) {
                    if (!isCrossDrag) {
                      return errRest;
                    }
                  } else if (newLevel) {
                    if (!isCrossDrag) {
                      return errRest;
                    }
                    if (oldAllMaps[newRowid]) {
                      isSelfToChildStatus = true;
                      if (!(isCrossDrag && isSelfToChildDrag)) {
                        if (VxeUI.modal) {
                          VxeUI.modal.message({
                            status: "error",
                            content: getI18n10("vxe.error.treeDragChild")
                          });
                        }
                        return errRest;
                      }
                    }
                  } else {
                  }
                  const fullList = import_xe_utils18.default.toTreeArray(internalData.afterTreeFullData, {
                    key: rowField,
                    parentKey: parentField,
                    children: mapChildrenField
                  });
                  const otfIndex = $xeTable.findRowIndexOf(fullList, dragRow);
                  fullList.splice(otfIndex, 1);
                  const ptfIndex = $xeTable.findRowIndexOf(fullList, prevDragRow);
                  const ntfIndex = ptfIndex + dragOffsetIndex;
                  fullList.splice(ntfIndex, 0, dragRow);
                  if (isSelfToChildStatus && (isCrossDrag && isSelfToChildDrag)) {
                    import_xe_utils18.default.each(dragRow[childrenField], (childRow) => {
                      childRow[parentField] = dragRow[parentField];
                    });
                  }
                  dragRow[parentField] = isDragToChildFlag ? prevDragRow[rowField] : prevDragRow[parentField];
                  internalData.tableFullTreeData = import_xe_utils18.default.toArrayTree(fullList, {
                    key: rowField,
                    parentKey: parentField,
                    children: childrenField,
                    mapChildren: mapChildrenField
                  });
                }
              }
            } else {
              oafIndex = $xeTable.findRowIndexOf(afterFullData, dragRow);
              const otfIndex = $xeTable.findRowIndexOf(tableFullData, dragRow);
              afterFullData.splice(oafIndex, 1);
              tableFullData.splice(otfIndex, 1);
              const pafIndex = $xeTable.findRowIndexOf(afterFullData, prevDragRow);
              const ptfIndex = $xeTable.findRowIndexOf(tableFullData, prevDragRow);
              nafIndex = pafIndex + dragOffsetIndex;
              const ntfIndex = ptfIndex + dragOffsetIndex;
              afterFullData.splice(nafIndex, 0, dragRow);
              tableFullData.splice(ntfIndex, 0, dragRow);
            }
            clearRowDragData();
            clearCrossTableDragStatus();
            $xeTable.handleTableData(treeConfig && transform);
            $xeTable.cacheRowMap(false);
            updateScrollYStatus();
            if (!(treeConfig && transform)) {
              $xeTable.updateAfterDataIndex();
            }
            $xeTable.checkSelectionStatus();
            if (reactData.scrollYLoad) {
              $xeTable.updateScrollYSpace();
            }
            if (evnt) {
              dispatchEvent("row-dragend", {
                oldRow: dragRow,
                newRow: prevDragRow,
                dragRow,
                dragPos: prevDragPos,
                dragToChild: isDragToChildFlag,
                offsetIndex: dragOffsetIndex,
                _index: {
                  newIndex: nafIndex,
                  oldIndex: oafIndex
                }
              }, evnt);
            }
            return nextTick().then(() => {
              if (animation) {
                const { tableData } = reactData;
                const dragRowRest2 = fullAllDataRowIdData[dragRowid];
                const _newRowIndex = dragRowRest2._index;
                const firstRow = tableData[0];
                const firstRowRest = fullAllDataRowIdData[getRowid($xeTable, firstRow)];
                let wrapperEl = el;
                if ($xeGantt && $xeGanttView) {
                  const { refGanttContainerElem } = $xeGantt.getRefMaps();
                  const ganttContainerElem = refGanttContainerElem.value;
                  if (ganttContainerElem) {
                    wrapperEl = ganttContainerElem;
                  }
                }
                if (firstRowRest) {
                  const _firstRowIndex = firstRowRest._index;
                  const _lastRowIndex = _firstRowIndex + tableData.length;
                  let rsIndex = -1;
                  let reIndex = -1;
                  let offsetRate = 1;
                  if (_dragRowIndex < _firstRowIndex) {
                    rsIndex = 0;
                    reIndex = _newRowIndex - _firstRowIndex;
                  } else if (_dragRowIndex > _lastRowIndex) {
                    const $newRowIndex = dragRowRest2.$index;
                    rsIndex = $newRowIndex + 1;
                    reIndex = tableData.length;
                    offsetRate = -1;
                  } else {
                    if (_newRowIndex > _dragRowIndex) {
                      rsIndex = _dragRowIndex - _firstRowIndex;
                      reIndex = rsIndex + _newRowIndex - _dragRowIndex;
                    } else {
                      rsIndex = _newRowIndex - _firstRowIndex;
                      reIndex = rsIndex + _dragRowIndex - _newRowIndex + 1;
                      offsetRate = -1;
                    }
                  }
                  const dragRangeList = tableData.slice(rsIndex, reIndex);
                  if (dragRangeList.length) {
                    const dtClss = [];
                    dragRangeList.forEach((row) => {
                      const rowid = getRowid($xeTable, row);
                      dtClss.push(`.vxe-body--row[rowid="${rowid}"]`);
                      if ($xeGantt) {
                        dtClss.push(`.vxe-gantt-view--body-row[rowid="${rowid}"]`, `.vxe-gantt-view--chart-row[rowid="${rowid}"]`);
                      }
                    });
                    const dtTrList = wrapperEl.querySelectorAll(dtClss.join(","));
                    moveRowAnimateToTb(dtTrList, offsetRate * dragRowHeight);
                  }
                }
                const drClss = [`.vxe-body--row[rowid="${dragRowid}"]`];
                if ($xeGantt) {
                  drClss.push(`.vxe-gantt-view--body-row[rowid="${dragRowid}"]`, `.vxe-gantt-view--chart-row[rowid="${dragRowid}"]`);
                }
                const newDtTrList = wrapperEl.querySelectorAll(drClss.join(","));
                const newTrEl = newDtTrList[0];
                if (dragOffsetTop > -1 && newTrEl) {
                  moveRowAnimateToTb(newDtTrList, dragOffsetTop - newTrEl.offsetTop);
                }
              }
              updateRowOffsetTop();
              updateRowExpandStyle();
              $xeTable.updateCellAreas();
              $xeTable.recalculate();
            }).then(() => {
              return {
                status: true
              };
            });
          }).catch(() => {
            return errRest;
          });
        }
        return Promise.resolve(errRest);
      },
      handleCrossTableRowDragCancelEvent() {
        clearRowDragData();
        clearCrossTableDragStatus();
      },
      /**
       * 处理跨表拖拽完成
       */
      handleCrossTableRowDragFinishEvent(evnt) {
        const { tableData } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        const defaultRowHeight = computeDefaultRowHeight.value;
        const rowDragOpts = computeRowDragOpts.value;
        const { animation, isCrossTableDrag } = rowDragOpts;
        const treeOpts = computeTreeOpts.value;
        const { mapChildrenField } = treeOpts;
        const el = refElem.value;
        if (isCrossTableDrag && crossTableDragRowObj && crossTableDragRowInfo2) {
          const { row: dragRow } = crossTableDragRowInfo2;
          if (dragRow) {
            const dragRowid = getRowid($xeTable, dragRow);
            const dragRowRest = fullAllDataRowIdData[dragRowid];
            let dragRowHeight = 0;
            let rsIndex = -1;
            if (dragRowRest) {
              if (animation) {
                dragRowHeight = getCellRestHeight(dragRowRest, cellOpts, rowOpts, defaultRowHeight);
              }
              rsIndex = dragRowRest.$index;
            }
            const dragRangeList = rsIndex > -1 && rsIndex < tableData.length - 1 ? tableData.slice(rsIndex + 1) : [];
            const dragList = import_xe_utils18.default.toTreeArray([dragRow], {
              updated: true,
              children: mapChildrenField
            });
            $xeTable.remove(dragList).then(() => {
              if (animation && dragRowHeight && dragRangeList.length) {
                const $xeGanttView = internalData.xeGanttView;
                let wrapperEl = el;
                if ($xeGantt && $xeGanttView) {
                  const { refGanttContainerElem } = $xeGantt.getRefMaps();
                  const ganttContainerElem = refGanttContainerElem.value;
                  if (ganttContainerElem) {
                    wrapperEl = ganttContainerElem;
                  }
                }
                const dtClss = [];
                dragRangeList.forEach((row) => {
                  const rowid = getRowid($xeTable, row);
                  dtClss.push(`.vxe-body--row[rowid="${rowid}"]`);
                  if ($xeGantt) {
                    dtClss.push(`.vxe-gantt-view--body-row[rowid="${rowid}"]`, `.vxe-gantt-view--chart-row[rowid="${rowid}"]`);
                  }
                });
                const dtTrList = wrapperEl.querySelectorAll(dtClss.join(","));
                moveRowAnimateToTb(dtTrList, dragRowHeight);
              }
            });
            dispatchEvent("row-remove-dragend", {
              row: dragRow
            }, evnt);
            clearRowDragData();
            clearCrossTableDragStatus();
          }
        }
      },
      /**
       * 处理跨表拖至新的空表
       */
      handleCrossTableRowDragoverEmptyEvent(evnt) {
        const { tableData } = reactData;
        const rowDragOpts = computeRowDragOpts.value;
        const { isCrossTableDrag } = rowDragOpts;
        if (isCrossTableDrag && crossTableDragRowObj && !tableData.length) {
          const { $oldTable, $newTable } = crossTableDragRowObj;
          if ($oldTable) {
            const oldTableReactData = $oldTable.reactData;
            if ($oldTable.xID !== $xeTable.xID) {
              if ($newTable && $newTable.xID !== $xeTable.xID) {
                $newTable.hideCrossTableRowDropClearStatus();
              }
              evnt.preventDefault();
              $oldTable.hideCrossTableRowDropClearStatus();
              crossTableDragRowObj.$newTable = $xeTable;
              internalData.prevDragRow = null;
              reactData.dragTipText = oldTableReactData.dragTipText;
              showDropTip(evnt, evnt.currentTarget, null, true, "");
            }
          }
        }
      },
      /**
       * 处理跨表拖插入
       */
      handleCrossTableRowDragInsertEvent(evnt) {
        const { treeConfig } = props;
        const { prevDragRow, prevDragPos, prevDragToChild } = internalData;
        const rowDragOpts = computeRowDragOpts.value;
        const { animation, isSelfToChildDrag, isCrossTableDrag, dragEndMethod, dragToChildMethod } = rowDragOpts;
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        const defaultRowHeight = computeDefaultRowHeight.value;
        const treeOpts = computeTreeOpts.value;
        const { parentField, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (isCrossTableDrag && crossTableDragRowObj && crossTableDragRowInfo2) {
          const { row: oldRow } = crossTableDragRowInfo2;
          const { $oldTable } = crossTableDragRowObj;
          const el = refElem.value;
          if ($oldTable && oldRow) {
            const dragRow = oldRow;
            let dragOffsetIndex = -1;
            if (prevDragRow) {
              dragOffsetIndex = prevDragPos === "bottom" ? 1 : 0;
            }
            const dragParams = {
              oldRow: dragRow,
              newRow: prevDragRow,
              dragRow,
              dragPos: prevDragPos,
              dragToChild: !!prevDragToChild,
              offsetIndex: dragOffsetIndex
            };
            const isDragToChildFlag = isSelfToChildDrag && dragToChildMethod ? dragToChildMethod(dragParams) : prevDragToChild;
            const errRest = {
              status: false
            };
            Promise.resolve(dragEndMethod ? dragEndMethod(dragParams) : true).then((status) => {
              if (!status) {
                if ($oldTable) {
                  if ($oldTable.xID !== $xeTable.xID) {
                    $oldTable.handleCrossTableRowDragCancelEvent(evnt);
                  }
                }
                clearRowDragData();
                clearCrossTableDragStatus();
                return errRest;
              }
              let insertRest = Promise.resolve();
              if (treeConfig) {
                const dragList = import_xe_utils18.default.toTreeArray([dragRow], {
                  updated: true,
                  children: mapChildrenField
                });
                $oldTable.handleCrossTableRowDragFinishEvent(evnt);
                if (prevDragRow) {
                  dragRow[parentField] = prevDragRow[parentField];
                } else {
                  dragRow[parentField] = null;
                }
                dragList.forEach((row) => {
                  row[childrenField] = void 0;
                  row[mapChildrenField] = void 0;
                });
                if (prevDragRow) {
                  if (prevDragPos === "bottom") {
                    insertRest = $xeTable.insertNextAt(dragList, prevDragRow);
                  } else {
                    insertRest = $xeTable.insertAt(dragList, prevDragRow);
                  }
                } else {
                  insertRest = $xeTable.insert(dragList);
                }
              } else {
                $oldTable.handleCrossTableRowDragFinishEvent(evnt);
                if (prevDragRow) {
                  if (prevDragPos === "bottom") {
                    insertRest = $xeTable.insertNextAt(dragRow, prevDragRow);
                  } else {
                    insertRest = $xeTable.insertAt(dragRow, prevDragRow);
                  }
                } else {
                  insertRest = $xeTable.insert(dragRow);
                }
              }
              dispatchEvent("row-insert-dragend", {
                oldRow,
                newRow: prevDragRow,
                dragRow,
                dragPos: prevDragPos,
                dragToChild: isDragToChildFlag,
                offsetIndex: dragOffsetIndex
              }, evnt);
              clearRowDragData();
              insertRest.then(() => {
                const { tableData } = reactData;
                const { fullAllDataRowIdData } = internalData;
                const oldRowid = getRowid($xeTable, dragRow);
                const oldRowRest = fullAllDataRowIdData[oldRowid];
                let dragRowHeight = 0;
                let rsIndex = -1;
                if (oldRowRest) {
                  if (animation) {
                    dragRowHeight = getCellRestHeight(oldRowRest, cellOpts, rowOpts, defaultRowHeight);
                  }
                  rsIndex = oldRowRest.$index;
                }
                const dragRangeList = rsIndex > -1 ? tableData.slice(rsIndex) : [];
                if (animation && dragRowHeight && dragRangeList.length) {
                  const $xeGanttView = internalData.xeGanttView;
                  let wrapperEl = el;
                  if ($xeGantt && $xeGanttView) {
                    const { refGanttContainerElem } = $xeGantt.getRefMaps();
                    const ganttContainerElem = refGanttContainerElem.value;
                    if (ganttContainerElem) {
                      wrapperEl = ganttContainerElem;
                    }
                  }
                  const dtClss = [];
                  dragRangeList.forEach((row) => {
                    const rowid = getRowid($xeTable, row);
                    dtClss.push(`.vxe-body--row[rowid="${rowid}"]`);
                    if ($xeGantt) {
                      dtClss.push(`.vxe-gantt-view--body-row[rowid="${rowid}"]`, `.vxe-gantt-view--chart-row[rowid="${rowid}"]`);
                    }
                  });
                  const dtTrList = wrapperEl.querySelectorAll(dtClss.join(","));
                  moveRowAnimateToTb(dtTrList, -dragRowHeight);
                }
              });
            });
          }
        }
      },
      hideCrossTableRowDropClearStatus() {
        hideDropTip();
      },
      handleRowDragDragendEvent(evnt) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData, prevDragToChild } = internalData;
        const { dragRow } = reactData;
        const treeOpts = computeTreeOpts.value;
        const { lazy } = treeOpts;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const { prevDragRow, prevDragPos } = internalData;
        const rowDragOpts = computeRowDragOpts.value;
        const { isCrossTableDrag } = rowDragOpts;
        if (isCrossTableDrag && crossTableDragRowObj) {
          const { $newTable } = crossTableDragRowObj;
          if ($newTable && $newTable.xID !== $xeTable.xID) {
            $newTable.handleCrossTableRowDragInsertEvent(evnt);
            return;
          }
        }
        if (treeConfig && lazy && prevDragToChild) {
          const newRowid = getRowid($xeTable, prevDragRow);
          const rowRest = fullAllDataRowIdData[newRowid];
          if (prevDragRow[hasChildField]) {
            if (rowRest && rowRest.treeLoaded) {
              $xeTable.handleRowDragSwapEvent(evnt, true, dragRow, prevDragRow, prevDragPos, prevDragToChild);
            }
          } else {
            $xeTable.handleRowDragSwapEvent(evnt, true, dragRow, prevDragRow, prevDragPos, prevDragToChild);
          }
        } else {
          $xeTable.handleRowDragSwapEvent(evnt, true, dragRow, prevDragRow, prevDragPos, prevDragToChild);
        }
      },
      handleRowDragDragoverEvent(evnt) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData } = internalData;
        const { dragRow } = reactData;
        const treeOpts = computeTreeOpts.value;
        const { lazy, transform, parentField } = treeOpts;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const rowDragOpts = computeRowDragOpts.value;
        const { isPeerDrag, isCrossDrag, isToChildDrag, isCrossTableDrag } = rowDragOpts;
        if (!dragRow && !(isCrossTableDrag && (!treeConfig || isCrossDrag) && crossTableDragRowObj)) {
          evnt.preventDefault();
          return;
        }
        const isControlKey = hasControlKey(evnt);
        const trEl = evnt.currentTarget;
        const rowid = trEl.getAttribute("rowid") || "";
        const rest = fullAllDataRowIdData[rowid];
        if (rest) {
          evnt.preventDefault();
          const row = rest.row;
          const rowid2 = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid2];
          const offsetY = evnt.clientY - trEl.getBoundingClientRect().y;
          const dragPos = offsetY < trEl.clientHeight / 2 ? "top" : "bottom";
          internalData.prevDragToChild = !!(treeConfig && transform && (isCrossDrag && isToChildDrag) && isControlKey);
          internalData.prevDragRow = row;
          internalData.prevDragPos = dragPos;
          if (isCrossTableDrag && (!treeConfig || isCrossDrag) && crossTableDragRowObj) {
            const { $oldTable, $newTable } = crossTableDragRowObj;
            if ($oldTable) {
              const oldTableReactData = $oldTable.reactData;
              if ($oldTable.xID === $xeTable.xID) {
                if ($newTable) {
                  $newTable.hideCrossTableRowDropClearStatus();
                }
                reactData.isCrossDragRow = false;
                oldTableReactData.isCrossDragRow = false;
                crossTableDragRowObj.$newTable = null;
              } else {
                if ($newTable && $newTable.xID !== $xeTable.xID) {
                  $newTable.hideCrossTableRowDropClearStatus();
                }
                $oldTable.hideCrossTableRowDropClearStatus();
                oldTableReactData.isCrossDragRow = true;
                reactData.dragTipText = oldTableReactData.dragTipText;
                crossTableDragRowObj.$newTable = $xeTable;
                showDropTip(evnt, trEl, null, true, dragPos);
                return;
              }
            }
          }
          if ($xeTable.eqRow(dragRow, row) || isControlKey && treeConfig && lazy && row[hasChildField] && rowRest && !rowRest.treeLoaded || !isCrossDrag && treeConfig && transform && (isPeerDrag ? dragRow[parentField] !== row[parentField] : rest.level)) {
            showDropTip(evnt, trEl, null, false, dragPos);
            return;
          }
          showDropTip(evnt, trEl, null, true, dragPos);
          dispatchEvent("row-dragover", {
            oldRow: dragRow,
            targetRow: row,
            dragPos
          }, evnt);
        }
      },
      handleCellDragMousedownEvent(evnt, params) {
        var _a;
        evnt.stopPropagation();
        const { dragConfig } = props;
        const rowDragOpts = computeRowDragOpts.value;
        const { isCrossTableDrag, trigger, dragStartMethod } = rowDragOpts;
        const { row } = params;
        const dragEl = evnt.currentTarget;
        const tdEl = trigger === "cell" || trigger === "row" ? dragEl : (_a = dragEl.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement;
        const trEl = tdEl.parentElement;
        const dStartMethod = dragStartMethod || (dragConfig ? dragConfig.dragStartMethod : null);
        clearRowDropOrigin();
        if (dStartMethod && !dStartMethod(params)) {
          trEl.draggable = false;
          reactData.dragRow = null;
          reactData.dragCol = null;
          clearCrossTableDragStatus();
          hideDropTip();
          return;
        }
        if (isCrossTableDrag) {
          crossTableDragRowInfo2.row = row;
          crossTableDragRowObj = { $oldTable: $xeTable, $newTable: null };
        }
        reactData.dragRow = row;
        reactData.isCrossDragRow = false;
        reactData.dragCol = null;
        trEl.draggable = true;
        updateRowDropOrigin(row);
        updateRowDropTipContent(tdEl);
        dispatchEvent("row-dragstart", params, evnt);
      },
      handleCellDragMouseupEvent() {
        clearDragStatus();
      },
      /**
       * 列拖拽
       */
      handleHeaderCellDragDragstartEvent(evnt) {
        if (evnt.dataTransfer) {
          evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
        }
      },
      handleColDragSwapColumn() {
        handleUpdateColumn();
        return parseColumns(false).then(() => {
          $xeTable.updateCellAreas();
          $xeTable.saveCustomStore("update:sort");
        });
      },
      handleColDragSwapEvent(evnt, isSyncColumn, dragCol, prevDragCol, prevDragPos, prevDragToChild) {
        const { mouseConfig } = props;
        const columnDragOpts = computeColumnDragOpts.value;
        const { animation, isPeerDrag, isCrossDrag, isSelfToChildDrag, isToChildDrag, dragEndMethod, dragToChildMethod } = columnDragOpts;
        const { collectColumn, fullColumnIdData } = internalData;
        const el = refElem.value;
        const dragOffsetIndex = prevDragPos === "right" ? 1 : 0;
        const errRest = {
          status: false
        };
        if (!(el && prevDragCol && dragCol)) {
          return Promise.resolve(errRest);
        }
        if (prevDragCol !== dragCol) {
          const dragColumn = dragCol;
          const newColumn = prevDragCol;
          const dragParams = {
            oldColumn: dragColumn,
            newColumn,
            dragColumn,
            dragPos: prevDragPos,
            dragToChild: !!prevDragToChild,
            offsetIndex: dragOffsetIndex
          };
          const isDragToChildFlag = isSelfToChildDrag && dragToChildMethod ? dragToChildMethod(dragParams) : prevDragToChild;
          return Promise.resolve(dragEndMethod ? dragEndMethod(dragParams) : true).then((status) => {
            if (!status) {
              clearColDragData();
              clearCrossTableDragStatus();
              return errRest;
            }
            let dragTargetColumn = null;
            const dragAllTargetCols = [];
            let dragColWidth = 0;
            if (animation) {
              import_xe_utils18.default.eachTree([dragColumn], (column) => {
                if (!dragTargetColumn && (!column.children || !column.children.length)) {
                  dragTargetColumn = column;
                  dragColWidth += column.renderWidth;
                }
                dragAllTargetCols.push(column);
              });
            }
            if (!dragTargetColumn) {
              dragTargetColumn = dragColumn;
            }
            const dragColRest = fullColumnIdData[dragTargetColumn.id] || {};
            const _dragColIndex = dragColRest._index;
            let dragOffsetLeft = -1;
            if (animation) {
              const oldTrEl = el.querySelector(`.vxe-table--column[colid="${dragTargetColumn.id}"]`);
              if (oldTrEl) {
                dragOffsetLeft = oldTrEl.offsetLeft;
              }
            }
            let oafIndex = -1;
            let nafIndex = -1;
            const oldAllMaps = {};
            import_xe_utils18.default.eachTree([dragColumn], (column) => {
              oldAllMaps[column.id] = column;
            });
            let isSelfToChildStatus = false;
            if (dragColumn.parentId && newColumn.parentId) {
              if (isPeerDrag && !isCrossDrag) {
                if (dragColumn.parentId !== newColumn.parentId) {
                  return errRest;
                }
              } else {
                if (!isCrossDrag) {
                  return errRest;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n10("vxe.error.treeDragChild")
                      });
                    }
                    return errRest;
                  }
                }
              }
            } else if (dragColumn.parentId) {
              if (!isCrossDrag) {
                return errRest;
              }
            } else if (newColumn.parentId) {
              if (!isCrossDrag) {
                return errRest;
              }
              if (oldAllMaps[newColumn.id]) {
                isSelfToChildStatus = true;
                if (!(isCrossDrag && isSelfToChildDrag)) {
                  if (VxeUI.modal) {
                    VxeUI.modal.message({
                      status: "error",
                      content: getI18n10("vxe.error.treeDragChild")
                    });
                  }
                  return errRest;
                }
              }
            } else {
            }
            const oldewMatchRest = import_xe_utils18.default.findTree(collectColumn, (item) => item.id === dragColumn.id);
            if (isSelfToChildStatus && (isCrossDrag && isSelfToChildDrag)) {
              if (oldewMatchRest) {
                const { items: oCols, index: oIndex } = oldewMatchRest;
                const childList = dragColumn.children || [];
                childList.forEach((column) => {
                  column.parentId = dragColumn.parentId;
                });
                oCols.splice(oIndex, 1, ...childList);
                dragColumn.children = [];
              }
            } else {
              if (oldewMatchRest) {
                const { items: oCols, index: oIndex, parent: oParent } = oldewMatchRest;
                oCols.splice(oIndex, 1);
                if (!oParent) {
                  oafIndex = oIndex;
                }
              }
            }
            const newMatchRest = import_xe_utils18.default.findTree(collectColumn, (item) => item.id === newColumn.id);
            if (newMatchRest) {
              const { items: nCols, index: nIndex, parent: nParent } = newMatchRest;
              if (isCrossDrag && isToChildDrag && isDragToChildFlag) {
                dragColumn.parentId = newColumn.id;
                newColumn.children = (newColumn.children || []).concat([dragColumn]);
              } else {
                dragColumn.parentId = newColumn.parentId;
                nCols.splice(nIndex + dragOffsetIndex, 0, dragColumn);
              }
              if (!nParent) {
                nafIndex = nIndex;
              }
            }
            import_xe_utils18.default.eachTree(collectColumn, (column, index, items, path, parentColumn) => {
              if (!parentColumn) {
                const sortIndex = index + 1;
                column.renderSortNumber = sortIndex;
              }
            });
            if (mouseConfig) {
              if ($xeTable.clearSelected) {
                $xeTable.clearSelected();
              }
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
            }
            clearColDragData();
            clearCrossTableDragStatus();
            if (evnt) {
              dispatchEvent("column-dragend", {
                oldColumn: dragColumn,
                newColumn,
                dragColumn,
                dragPos: prevDragPos,
                dragToChild: isDragToChildFlag,
                offsetIndex: dragOffsetIndex,
                _index: {
                  newIndex: nafIndex,
                  oldIndex: oafIndex
                }
              }, evnt);
            }
            return nextTick().then(() => {
              if (isSyncColumn) {
                return $xeTable.handleColDragSwapColumn();
              }
            }).then(() => {
              if (animation) {
                const { tableColumn } = reactData;
                const { visibleColumn, fullColumnIdData: fullColumnIdData2 } = internalData;
                let dragNewColumn = null;
                const dragNewColMaps = {};
                import_xe_utils18.default.eachTree([dragColumn], (column) => {
                  if (!dragNewColumn && (!column.children || !column.children.length)) {
                    dragNewColumn = column;
                  }
                  dragNewColMaps[column.id] = column;
                });
                if (!dragNewColumn) {
                  dragNewColumn = dragColumn;
                }
                if (dragColWidth && dragAllTargetCols.length) {
                  const _newColIndex = import_xe_utils18.default.findIndexOf(visibleColumn, (column) => !!dragNewColumn && column.id === dragNewColumn.id);
                  const firstCol = tableColumn[0];
                  const firstColRest = fullColumnIdData2[firstCol.id];
                  if (firstColRest) {
                    const _firstColIndex = firstColRest._index;
                    const _lastColIndex = _firstColIndex + tableColumn.length;
                    let csIndex = -1;
                    let ceIndex = -1;
                    let offsetRate = 1;
                    if (_dragColIndex < _firstColIndex) {
                      csIndex = 0;
                      ceIndex = _newColIndex - _firstColIndex;
                    } else if (_dragColIndex > _lastColIndex) {
                      const $newRowIndex = dragColRest.$index;
                      csIndex = $newRowIndex + 1;
                      ceIndex = tableColumn.length;
                      offsetRate = -1;
                    } else {
                      if (_newColIndex > _dragColIndex) {
                        csIndex = _dragColIndex - _firstColIndex;
                        ceIndex = csIndex + _newColIndex - _dragColIndex;
                      } else {
                        csIndex = _newColIndex - _firstColIndex + 1;
                        ceIndex = csIndex + _dragColIndex - _newColIndex;
                        offsetRate = -1;
                      }
                    }
                    const dragRangeList = [];
                    const dragRangeMaps = {};
                    for (let i = csIndex; i < ceIndex; i++) {
                      const column = tableColumn[i];
                      if (!dragRangeMaps[column.id] && !dragNewColMaps[column.id]) {
                        dragRangeMaps[column.id] = column;
                        dragRangeList.push(column);
                      }
                    }
                    import_xe_utils18.default.eachTree([newColumn], (column) => {
                      if (!dragRangeMaps[column.id]) {
                        dragRangeMaps[column.id] = column;
                        dragRangeList.push(column);
                      }
                    });
                    if (dragRangeList.length) {
                      const dtTrList = el.querySelectorAll(dragRangeList.map((column) => `.vxe-table--column[colid="${column.id}"]`).join(","));
                      moveColAnimateToLr(dtTrList, offsetRate * dragColWidth);
                    }
                  }
                  const newTrList = el.querySelectorAll(dragAllTargetCols.map((column) => `.vxe-table--column[colid="${column.id}"]`).join(","));
                  const newTdEl = newTrList[0];
                  if (dragOffsetLeft > -1 && newTdEl) {
                    moveColAnimateToLr(newTrList, dragOffsetLeft - newTdEl.offsetLeft);
                  }
                }
              }
              updateColumnOffsetLeft();
              loadScrollXData();
              $xeTable.updateCellAreas();
              return {
                status: true
              };
            });
          }).catch(() => {
            return errRest;
          });
        }
        return Promise.resolve(errRest);
      },
      handleHeaderCellDragDragendEvent(evnt) {
        const { dragCol } = reactData;
        const { prevDragCol, prevDragPos, prevDragToChild } = internalData;
        $xeTable.handleColDragSwapEvent(evnt, true, dragCol, prevDragCol, prevDragPos, prevDragToChild);
      },
      handleHeaderCellDragDragoverEvent(evnt) {
        const { dragCol } = reactData;
        const columnDragOpts = computeColumnDragOpts.value;
        const { isToChildDrag, isPeerDrag, isCrossDrag } = columnDragOpts;
        if (!dragCol) {
          evnt.preventDefault();
          return;
        }
        const isControlKey = hasControlKey(evnt);
        const thEl = evnt.currentTarget;
        const colid = thEl.getAttribute("colid");
        const column = $xeTable.getColumnById(colid);
        if (column) {
          evnt.preventDefault();
          const { clientX } = evnt;
          const offsetX = clientX - thEl.getBoundingClientRect().x;
          const dragPos = offsetX < thEl.clientWidth / 2 ? "left" : "right";
          internalData.prevDragToChild = !!(isCrossDrag && isToChildDrag && isControlKey);
          internalData.prevDragCol = column;
          internalData.prevDragPos = dragPos;
          if (column.fixed || dragCol && dragCol.id === column.id || !isCrossDrag && (isPeerDrag ? dragCol.parentId !== column.parentId : column.parentId)) {
            showDropTip(evnt, null, thEl, false, dragPos);
            return;
          }
          showDropTip(evnt, null, thEl, true, dragPos);
          dispatchEvent("column-dragover", {
            oldColumn: dragCol,
            targetColumn: column,
            dragPos
          }, evnt);
          const el = refElem.value;
          if (!el) {
            return;
          }
          const xHandleEl = refScrollXHandleElem.value;
          const tableBody = refTableBody.value;
          const tableBodyElem = tableBody ? tableBody.$el : null;
          const scrollTargetEl = xHandleEl || tableBodyElem;
          if (scrollTargetEl) {
            const wrapperRect = el.getBoundingClientRect();
            const tableWrapperWidth = el.clientWidth;
            const leftContainerElem = refLeftContainer.value;
            const leftContainerWidth = leftContainerElem ? leftContainerElem.clientWidth : 0;
            const rightContainerElem = refRightContainer.value;
            const rightContainerWidth = rightContainerElem ? rightContainerElem.clientWidth : 0;
            const srartX = wrapperRect.x + leftContainerWidth;
            const endX = wrapperRect.x + tableWrapperWidth - rightContainerWidth;
            const distSize = 28;
            const startDistSize = clientX - srartX;
            const endDistSize = endX - clientX;
            if (startDistSize > 0 && startDistSize <= distSize) {
              const scrollRatio = Math.floor(tableWrapperWidth / (startDistSize > distSize / 2 ? 240 : 120));
              scrollTargetEl.scrollLeft -= scrollRatio * (distSize - startDistSize);
            } else if (endDistSize > 0 && endDistSize <= distSize) {
              const scrollRatio = Math.floor(tableWrapperWidth / (endDistSize > distSize / 2 ? 240 : 120));
              scrollTargetEl.scrollLeft += scrollRatio * (distSize - endDistSize);
            }
          }
        }
      },
      handleHeaderCellDragMousedownEvent(evnt, params) {
        var _a;
        evnt.stopPropagation();
        const columnDragOpts = computeColumnDragOpts.value;
        const { trigger, dragStartMethod } = columnDragOpts;
        const { column } = params;
        const dragEl = evnt.currentTarget;
        const thEl = trigger === "cell" ? dragEl : (_a = dragEl.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement;
        clearColDropOrigin();
        if (dragStartMethod && !dragStartMethod(params)) {
          thEl.draggable = false;
          reactData.dragRow = null;
          reactData.dragCol = null;
          clearCrossTableDragStatus();
          hideDropTip();
          return;
        }
        reactData.dragCol = column;
        reactData.dragRow = null;
        thEl.draggable = true;
        clearCrossTableDragStatus();
        updateColDropOrigin(column);
        updateColDropTipContent(thEl);
        dispatchEvent("column-dragstart", params, evnt);
      },
      handleHeaderCellDragMouseupEvent() {
        clearColDropOrigin();
        hideDropTip();
        clearCrossTableDragStatus();
        reactData.dragRow = null;
        reactData.dragCol = null;
      },
      handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, params) {
        const { highlightHoverRow } = props;
        const { lastScrollLeft, lastScrollTop } = internalData;
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        if (!xHandleEl || !yHandleEl) {
          return;
        }
        const rowOpts = computeRowOpts.value;
        const validTip = refValidTooltip.value;
        const tooltip = refTooltip.value;
        const bodyHeight = yHandleEl.clientHeight;
        const bodyWidth = xHandleEl.clientWidth;
        const scrollHeight = yHandleEl.scrollHeight;
        const scrollWidth = xHandleEl.scrollWidth;
        let isTop = false;
        let isBottom = false;
        let isLeft = false;
        let isRight = false;
        let direction = "";
        let isTopBoundary = false;
        let isBottomBoundary = false;
        let isLeftBoundary = false;
        let isRightBoundary = false;
        if (isRollX) {
          const xThreshold = computeScrollXThreshold.value;
          isLeft = scrollLeft <= 0;
          if (!isLeft) {
            isRight = scrollLeft + bodyWidth >= scrollWidth;
          }
          if (scrollLeft > lastScrollLeft) {
            direction = "right";
            if (scrollLeft + bodyWidth >= scrollWidth - xThreshold) {
              isRightBoundary = true;
            }
          } else {
            direction = "left";
            if (scrollLeft <= xThreshold) {
              isLeftBoundary = true;
            }
          }
          $xeTable.checkScrolling();
          internalData.lastScrollLeft = scrollLeft;
        }
        if (isRollY) {
          const yThreshold = computeScrollYThreshold.value;
          isTop = scrollTop <= 1;
          if (!isTop) {
            isBottom = scrollTop + bodyHeight >= scrollHeight - 1;
          }
          if (scrollTop > lastScrollTop) {
            direction = "bottom";
            if (scrollTop + bodyHeight >= scrollHeight - yThreshold) {
              isBottomBoundary = true;
            }
          } else {
            direction = "top";
            if (scrollTop <= yThreshold) {
              isTopBoundary = true;
            }
          }
          internalData.lastScrollTop = scrollTop;
        }
        reactData.lastScrollTime = Date.now();
        const evntParams = Object.assign({
          scrollTop,
          scrollLeft,
          bodyHeight,
          bodyWidth,
          scrollHeight,
          scrollWidth,
          isX: isRollX,
          isY: isRollY,
          isTop,
          isBottom,
          isLeft,
          isRight,
          direction
        }, params);
        updateRowExpandStyle();
        checkLastSyncScroll(isRollX, isRollY);
        if (isRollX) {
          $xeTable.closeFilter();
        }
        if (rowOpts.isHover || highlightHoverRow) {
          $xeTable.clearHoverRow();
        }
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        if (tooltip && tooltip.reactData.visible) {
          tooltip.close();
        }
        if (isBottomBoundary || isTopBoundary || isRightBoundary || isLeftBoundary) {
          dispatchEvent("scroll-boundary", evntParams, evnt);
        }
        dispatchEvent("scroll", evntParams, evnt);
      },
      /**
       * 横向 X 可视渲染事件处理
       */
      triggerScrollXEvent() {
        const virtualXOpts = computeVirtualXOpts.value;
        if (virtualXOpts.immediate) {
          loadScrollXData();
        } else {
          lazyScrollXData();
        }
      },
      /**
       * 纵向 Y 可视渲染事件处理
       */
      triggerScrollYEvent() {
        const virtualYOpts = computeVirtualYOpts.value;
        if (virtualYOpts.immediate) {
          loadScrollYData();
        } else {
          lazyScrollYData();
        }
      },
      triggerBodyScrollEvent(evnt, fixedType) {
        const { scrollYLoad, scrollXLoad } = reactData;
        const { elemStore, intoRunScroll, lastScrollTop, lastScrollLeft, inWheelScroll, inVirtualScroll, inHeaderScroll, inBodyScroll, scrollRenderType, inFooterScroll } = internalData;
        if (inWheelScroll || inVirtualScroll || inHeaderScroll || inFooterScroll) {
          return;
        }
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const rowExpandEl = refRowExpandElem.value;
        if (intoRunScroll) {
          return;
        }
        if (!bodyScrollElem) {
          return;
        }
        if (!xHandleEl) {
          return;
        }
        if (!yHandleEl) {
          return;
        }
        if (inBodyScroll) {
          if (scrollRenderType !== fixedType) {
            return;
          }
        }
        let scrollTop = yHandleEl.scrollTop;
        let scrollLeft = xHandleEl.scrollLeft;
        if (leftScrollElem && fixedType === "left") {
          scrollTop = leftScrollElem.scrollTop;
        } else if (rightScrollElem && fixedType === "right") {
          scrollTop = rightScrollElem.scrollTop;
        } else {
          scrollTop = bodyScrollElem.scrollTop;
          scrollLeft = bodyScrollElem.scrollLeft;
        }
        const isRollX = scrollLeft !== lastScrollLeft;
        const isRollY = scrollTop !== lastScrollTop;
        internalData.inBodyScroll = true;
        internalData.scrollRenderType = fixedType;
        if (isRollY) {
          if (fixedType === "left") {
            setScrollTop(bodyScrollElem, scrollTop);
            setScrollTop(rightScrollElem, scrollTop);
          } else if (fixedType === "right") {
            setScrollTop(bodyScrollElem, scrollTop);
            setScrollTop(leftScrollElem, scrollTop);
          } else {
            setScrollTop(leftScrollElem, scrollTop);
            setScrollTop(rightScrollElem, scrollTop);
          }
          setScrollTop(yHandleEl, scrollTop);
          setScrollTop(rowExpandEl, scrollTop);
          syncGanttScrollTop(scrollTop);
          if (scrollYLoad) {
            $xeTable.triggerScrollYEvent(evnt);
          }
        }
        if (isRollX) {
          setScrollLeft(xHandleEl, scrollLeft);
          setScrollLeft(headerScrollElem, scrollLeft);
          setScrollLeft(footerScrollElem, scrollLeft);
          if (scrollXLoad) {
            $xeTable.triggerScrollXEvent(evnt);
          }
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "body",
          fixed: fixedType
        });
      },
      triggerHeaderScrollEvent(evnt, fixedType) {
        const { scrollXLoad } = reactData;
        const { elemStore, intoRunScroll, inWheelScroll, inVirtualScroll, inBodyScroll, inFooterScroll } = internalData;
        if (inWheelScroll || inVirtualScroll || inBodyScroll || inFooterScroll) {
          return;
        }
        const yHandleEl = refScrollYHandleElem.value;
        const xHandleEl = refScrollXHandleElem.value;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        if (intoRunScroll) {
          return;
        }
        if (!headerScrollElem) {
          return;
        }
        if (!xHandleEl) {
          return;
        }
        if (!yHandleEl) {
          return;
        }
        const scrollTop = yHandleEl.scrollTop;
        const scrollLeft = headerScrollElem.scrollLeft;
        const isRollX = true;
        const isRollY = false;
        internalData.inHeaderScroll = true;
        setScrollLeft(xHandleEl, scrollLeft);
        setScrollLeft(footerScrollElem, scrollLeft);
        setScrollLeft(bodyScrollElem, scrollLeft);
        if (scrollXLoad) {
          $xeTable.triggerScrollXEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "header",
          fixed: fixedType
        });
      },
      triggerFooterScrollEvent(evnt, fixedType) {
        const { scrollXLoad } = reactData;
        const { elemStore, intoRunScroll, inWheelScroll, inVirtualScroll, inHeaderScroll, inBodyScroll } = internalData;
        if (inWheelScroll || inVirtualScroll || inHeaderScroll || inBodyScroll) {
          return;
        }
        const yHandleEl = refScrollYHandleElem.value;
        const xHandleEl = refScrollXHandleElem.value;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        if (intoRunScroll) {
          return;
        }
        if (!footerScrollElem) {
          return;
        }
        if (!xHandleEl) {
          return;
        }
        if (!yHandleEl) {
          return;
        }
        const scrollTop = yHandleEl.scrollTop;
        const scrollLeft = footerScrollElem.scrollLeft;
        const isRollX = true;
        const isRollY = false;
        internalData.inFooterScroll = true;
        setScrollLeft(xHandleEl, scrollLeft);
        setScrollLeft(headerScrollElem, scrollLeft);
        setScrollLeft(bodyScrollElem, scrollLeft);
        if (scrollXLoad) {
          $xeTable.triggerScrollXEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "footer",
          fixed: fixedType
        });
      },
      triggerBodyWheelEvent(evnt) {
        const { target, deltaY, deltaX, shiftKey } = evnt;
        if (target && /^textarea$/i.test(target.tagName)) {
          return;
        }
        if (!deltaY && !deltaX) {
          return;
        }
        const { highlightHoverRow } = tableProps;
        const { scrollXLoad, scrollYLoad, expandColumn } = reactData;
        const leftFixedWidth = computeLeftFixedWidth.value;
        const rightFixedWidth = computeRightFixedWidth.value;
        const { elemStore, lastScrollTop, lastScrollLeft } = internalData;
        const rowOpts = computeRowOpts.value;
        const scrollbarXOpts = computeScrollbarXOpts.value;
        const scrollbarYOpts = computeScrollbarYOpts.value;
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const rowExpandEl = refRowExpandElem.value;
        if (!bodyScrollElem) {
          return;
        }
        const wheelSpeed = getWheelSpeed(reactData.lastScrollTime);
        const deltaTop = shiftKey ? 0 : deltaY * wheelSpeed;
        const deltaLeft = (shiftKey ? deltaX || deltaY : deltaX) * wheelSpeed;
        const currScrollTop = bodyScrollElem.scrollTop;
        const currScrollLeft = bodyScrollElem.scrollLeft;
        const scrollTop = currScrollTop + deltaTop;
        const scrollLeft = currScrollLeft + deltaLeft;
        const isRollX = scrollLeft !== lastScrollLeft;
        const isRollY = scrollTop !== lastScrollTop;
        if (isRollX) {
          if (scrollbarXOpts.visible === "hidden") {
            evnt.preventDefault();
            return;
          }
        }
        if (isRollY) {
          if (scrollbarYOpts.visible === "hidden") {
            evnt.preventDefault();
            return;
          }
          const isTopWheel = deltaTop < 0;
          if (isTopWheel ? currScrollTop <= 0 : currScrollTop >= bodyScrollElem.scrollHeight - bodyScrollElem.clientHeight) {
            return;
          }
        }
        if ($xeParentTable) {
          if (isRollY) {
            if (checkTargetElement(evnt.target, [leftScrollElem, bodyScrollElem, rightScrollElem], evnt.currentTarget)) {
              evnt.stopPropagation();
              return;
            }
          }
          if (isRollX) {
            if (checkTargetElement(evnt.target, [headerScrollElem, bodyScrollElem, footerScrollElem], evnt.currentTarget)) {
              evnt.stopPropagation();
              return;
            }
          }
        }
        if (!(leftFixedWidth || rightFixedWidth || expandColumn)) {
          return;
        }
        if (rowOpts.isHover || highlightHoverRow) {
          $xeTable.clearHoverRow();
        }
        if (isRollX) {
          evnt.preventDefault();
          internalData.inWheelScroll = true;
          if (browseObj.firefox || browseObj.safari) {
            const currLeftNum = scrollLeft;
            setScrollLeft(xHandleEl, currLeftNum);
            setScrollLeft(bodyScrollElem, currLeftNum);
            setScrollLeft(headerScrollElem, currLeftNum);
            setScrollLeft(footerScrollElem, currLeftNum);
            if (scrollXLoad) {
              $xeTable.triggerScrollXEvent(evnt);
            }
            $xeTable.handleScrollEvent(evnt, isRollY, isRollX, bodyScrollElem.scrollTop, currLeftNum, {
              type: "table",
              fixed: ""
            });
          } else {
            wheelScrollLeftTo(scrollLeft, (offsetLeft) => {
              internalData.inWheelScroll = true;
              const currLeftNum = offsetLeft;
              setScrollLeft(xHandleEl, currLeftNum);
              setScrollLeft(bodyScrollElem, currLeftNum);
              setScrollLeft(headerScrollElem, currLeftNum);
              setScrollLeft(footerScrollElem, currLeftNum);
              if (scrollXLoad) {
                $xeTable.triggerScrollXEvent(evnt);
              }
              $xeTable.handleScrollEvent(evnt, isRollY, isRollX, bodyScrollElem.scrollTop, currLeftNum, {
                type: "table",
                fixed: ""
              });
            });
          }
        }
        if (isRollY) {
          evnt.preventDefault();
          internalData.inWheelScroll = true;
          if (browseObj.firefox || browseObj.safari) {
            const currTopNum = scrollTop;
            setScrollTop(yHandleEl, currTopNum);
            setScrollTop(bodyScrollElem, currTopNum);
            setScrollTop(leftScrollElem, currTopNum);
            setScrollTop(rightScrollElem, currTopNum);
            setScrollTop(rowExpandEl, currTopNum);
            syncGanttScrollTop(currTopNum);
            if (scrollYLoad) {
              $xeTable.triggerScrollYEvent(evnt);
            }
            $xeTable.handleScrollEvent(evnt, isRollY, isRollX, currTopNum, bodyScrollElem.scrollLeft, {
              type: "table",
              fixed: ""
            });
          } else {
            wheelScrollTopTo(scrollTop - currScrollTop, (offsetTop) => {
              internalData.inWheelScroll = true;
              const currTopNum = bodyScrollElem.scrollTop + offsetTop;
              setScrollTop(yHandleEl, currTopNum);
              setScrollTop(bodyScrollElem, currTopNum);
              setScrollTop(leftScrollElem, currTopNum);
              setScrollTop(rightScrollElem, currTopNum);
              setScrollTop(rowExpandEl, currTopNum);
              syncGanttScrollTop(currTopNum);
              if (scrollYLoad) {
                $xeTable.triggerScrollYEvent(evnt);
              }
              $xeTable.handleScrollEvent(evnt, isRollY, isRollX, currTopNum, bodyScrollElem.scrollLeft, {
                type: "table",
                fixed: ""
              });
            });
          }
        }
      },
      triggerVirtualScrollXEvent(evnt) {
        const { scrollXLoad } = reactData;
        const { elemStore, inWheelScroll, lastScrollTop, inHeaderScroll, inBodyScroll, inFooterScroll } = internalData;
        if (inHeaderScroll || inBodyScroll || inFooterScroll) {
          return;
        }
        if (inWheelScroll) {
          return;
        }
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const yHandleEl = refScrollYHandleElem.value;
        const wrapperEl = evnt.currentTarget;
        const { scrollLeft } = wrapperEl;
        const yBodyEl = yHandleEl || bodyScrollElem;
        let scrollTop = 0;
        if (yBodyEl) {
          scrollTop = yBodyEl.scrollTop;
        }
        const isRollX = true;
        const isRollY = scrollTop !== lastScrollTop;
        internalData.inVirtualScroll = true;
        setScrollLeft(bodyScrollElem, scrollLeft);
        setScrollLeft(headerScrollElem, scrollLeft);
        setScrollLeft(footerScrollElem, scrollLeft);
        if (scrollXLoad) {
          $xeTable.triggerScrollXEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "table",
          fixed: ""
        });
      },
      triggerVirtualScrollYEvent(evnt) {
        const { scrollYLoad } = reactData;
        const { elemStore, inWheelScroll, lastScrollLeft, inHeaderScroll, inBodyScroll, inFooterScroll } = internalData;
        if (inHeaderScroll || inBodyScroll || inFooterScroll) {
          return;
        }
        if (inWheelScroll) {
          return;
        }
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const rowExpandEl = refRowExpandElem.value;
        const xHandleEl = refScrollXHandleElem.value;
        const wrapperEl = evnt.currentTarget;
        const { scrollTop } = wrapperEl;
        const xBodyEl = xHandleEl || bodyScrollElem;
        let scrollLeft = 0;
        if (xBodyEl) {
          scrollLeft = xBodyEl.scrollLeft;
        }
        const isRollX = scrollLeft !== lastScrollLeft;
        const isRollY = true;
        internalData.inVirtualScroll = true;
        setScrollTop(bodyScrollElem, scrollTop);
        setScrollTop(leftScrollElem, scrollTop);
        setScrollTop(rightScrollElem, scrollTop);
        setScrollTop(rowExpandEl, scrollTop);
        syncGanttScrollTop(scrollTop);
        if (scrollYLoad) {
          $xeTable.triggerScrollYEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "table",
          fixed: ""
        });
      },
      /**
       * 对于树形结构中，可以直接滚动到指定深层节点中
       * 对于某些特定的场景可能会用到，比如定位到某一节点
       * @param {Row} row 行对象
       */
      scrollToTreeRow(row) {
        const { treeConfig } = props;
        const { isRowGroupStatus } = reactData;
        const { tableFullData } = internalData;
        const rests = [];
        if (treeConfig || isRowGroupStatus) {
          const aggregateOpts = computeAggregateOpts.value;
          const treeOpts = computeTreeOpts.value;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const matchObj = import_xe_utils18.default.findTree(tableFullData, (item) => $xeTable.eqRow(item, row), { children: isRowGroupStatus ? aggregateOpts.mapChildrenField : childrenField });
          if (matchObj) {
            const nodes = matchObj.nodes;
            nodes.forEach((row2, index) => {
              if (index < nodes.length - 1 && !$xeTable.isTreeExpandByRow(row2)) {
                rests.push($xeTable.setTreeExpand(row2, true));
              }
            });
          }
        }
        return Promise.all(rests).then(() => rowToVisible($xeTable, row));
      },
      updateScrollYStatus,
      // 更新横向 X 可视渲染上下剩余空间大小
      updateScrollXSpace() {
        const { scrollXLoad, overflowX, scrollXWidth } = reactData;
        const { visibleColumn, scrollXStore, elemStore, fullColumnIdData } = internalData;
        const $xeGanttView = internalData.xeGanttView;
        const mouseOpts = computeMouseOpts.value;
        const tableBody = refTableBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        if (tableBodyElem) {
          const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
          const bodyTableElem = getRefElem(elemStore["main-body-table"]);
          const headerTableElem = getRefElem(elemStore["main-header-table"]);
          const footerTableElem = getRefElem(elemStore["main-footer-table"]);
          let xSpaceLeft = 0;
          const firstColumn = visibleColumn[scrollXStore.startIndex];
          if (firstColumn) {
            const colRest = fullColumnIdData[firstColumn.id] || {};
            xSpaceLeft = colRest.oLeft;
          }
          let clientWidth = 0;
          if (bodyScrollElem) {
            clientWidth = bodyScrollElem.clientWidth;
          }
          let isScrollXBig = false;
          let ySpaceWidth = scrollXWidth;
          if (scrollXWidth > maxXWidth) {
            if (bodyScrollElem && bodyTableElem && bodyScrollElem.scrollLeft + clientWidth >= maxXWidth) {
              xSpaceLeft = maxXWidth - bodyTableElem.clientWidth;
            } else {
              xSpaceLeft = (maxXWidth - clientWidth) * (xSpaceLeft / (scrollXWidth - clientWidth));
            }
            ySpaceWidth = maxXWidth;
            isScrollXBig = true;
          }
          if (!(scrollXLoad && overflowX)) {
            xSpaceLeft = 0;
          }
          if (getConfig5().scrollMarginStyle) {
            if (headerTableElem) {
              headerTableElem.style.marginLeft = headerTableElem.getAttribute("xvm") ? `${xSpaceLeft}px` : "";
            }
            if (bodyTableElem) {
              bodyTableElem.style.marginLeft = `${xSpaceLeft}px`;
            }
            if (footerTableElem) {
              footerTableElem.style.marginLeft = footerTableElem.getAttribute("xvm") ? `${xSpaceLeft}px` : "";
            }
          } else {
            if (headerTableElem) {
              headerTableElem.style.transform = headerTableElem.getAttribute("xvm") ? `translate(${xSpaceLeft}px, 0px)` : "";
            }
            if (bodyTableElem) {
              bodyTableElem.style.transform = `translate(${xSpaceLeft}px, ${reactData.scrollYTop || 0}px)`;
            }
            if (footerTableElem) {
              footerTableElem.style.transform = footerTableElem.getAttribute("xvm") ? `translate(${xSpaceLeft}px, 0px)` : "";
            }
          }
          const containerList = ["main"];
          containerList.forEach((name) => {
            const layoutList = ["header", "body", "footer"];
            layoutList.forEach((layout) => {
              const xSpaceElem = getRefElem(elemStore[`${name}-${layout}-xSpace`]);
              if (xSpaceElem) {
                xSpaceElem.style.width = scrollXLoad ? `${ySpaceWidth}px` : "";
              }
            });
          });
          reactData.scrollXLeft = xSpaceLeft;
          reactData.scrollXWidth = ySpaceWidth;
          reactData.isScrollXBig = isScrollXBig;
          const scrollXSpaceEl = refScrollXSpaceElem.value;
          if (scrollXSpaceEl) {
            scrollXSpaceEl.style.width = `${ySpaceWidth}px`;
          }
          calcScrollbar();
          if (isScrollXBig && mouseOpts.area) {
            errLog("vxe.error.notProp", ["mouse-config.area"]);
          }
          if ($xeGanttView && $xeGanttView.handleUpdateSXSpace) {
            $xeGanttView.handleUpdateSXSpace();
          }
          return nextTick().then(() => {
            updateStyle();
          });
        }
      },
      // 更新纵向 Y 可视渲染上下剩余空间大小
      updateScrollYSpace() {
        const { isAllOverflow, overflowY, scrollYLoad, scrollYHeight, expandColumn } = reactData;
        const { scrollYStore, elemStore, isResizeCellHeight, afterFullData, fullAllDataRowIdData, rowExpandedMaps } = internalData;
        const $xeGanttView = internalData.xeGanttView;
        const { startIndex } = scrollYStore;
        const mouseOpts = computeMouseOpts.value;
        const expandOpts = computeExpandOpts.value;
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        const defaultRowHeight = computeDefaultRowHeight.value;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const bodyTableElem = getRefElem(elemStore["main-body-table"]);
        const leftBodyTableElem = getRefElem(elemStore["left-body-table"]);
        const rightbodyTableElem = getRefElem(elemStore["right-body-table"]);
        const containerList = ["main", "left", "right"];
        let ySpaceTop = 0;
        let sYHeight = scrollYHeight;
        let isScrollYBig = false;
        if (scrollYLoad) {
          const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
          if (!isCustomCellHeight && !expandColumn && isAllOverflow) {
            sYHeight = afterFullData.length * defaultRowHeight;
            if (sYHeight > maxYHeight) {
              isScrollYBig = true;
            }
            ySpaceTop = Math.max(0, startIndex * defaultRowHeight);
          } else {
            const firstRow = afterFullData[startIndex];
            if (firstRow) {
              let rowid = getRowid($xeTable, firstRow);
              let rowRest = fullAllDataRowIdData[rowid] || {};
              ySpaceTop = rowRest.oTop || 0;
              const lastRow = afterFullData[afterFullData.length - 1];
              rowid = getRowid($xeTable, lastRow);
              rowRest = fullAllDataRowIdData[rowid] || {};
              if (rowRest.oTop) {
                sYHeight = (rowRest.oTop || 0) + (rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight);
                if (expandColumn && rowExpandedMaps[rowid]) {
                  sYHeight += rowRest.expandHeight || expandOpts.height || 0;
                }
              }
              if (sYHeight > maxYHeight) {
                isScrollYBig = true;
              }
            } else {
              sYHeight = bodyTableElem ? bodyTableElem.clientHeight : 0;
            }
          }
        } else {
          if (bodyTableElem) {
            sYHeight = bodyTableElem.clientHeight;
          }
        }
        let clientHeight = 0;
        if (bodyScrollElem) {
          clientHeight = bodyScrollElem.clientHeight;
        }
        let ySpaceHeight = sYHeight;
        let scrollYTop = ySpaceTop;
        if (isScrollYBig) {
          if (bodyScrollElem && bodyTableElem && bodyScrollElem.scrollTop + clientHeight >= maxYHeight) {
            scrollYTop = maxYHeight - bodyTableElem.clientHeight;
          } else {
            scrollYTop = (maxYHeight - clientHeight) * (ySpaceTop / (scrollYHeight - clientHeight));
          }
          ySpaceHeight = maxYHeight;
        }
        if (!(scrollYLoad && overflowY)) {
          scrollYTop = 0;
        }
        if (getConfig5().scrollMarginStyle) {
          if (leftBodyTableElem) {
            leftBodyTableElem.style.marginTop = `${scrollYTop}px`;
          }
          if (bodyTableElem) {
            bodyTableElem.style.marginTop = `${scrollYTop}px`;
          }
          if (rightbodyTableElem) {
            rightbodyTableElem.style.marginTop = `${scrollYTop}px`;
          }
        } else {
          if (leftBodyTableElem) {
            leftBodyTableElem.style.transform = `translate(0px, ${scrollYTop}px)`;
          }
          if (bodyTableElem) {
            bodyTableElem.style.transform = `translate(${reactData.scrollXLeft || 0}px, ${scrollYTop}px)`;
          }
          if (rightbodyTableElem) {
            rightbodyTableElem.style.transform = `translate(0px, ${scrollYTop}px)`;
          }
        }
        containerList.forEach((name) => {
          const layoutList = ["header", "body", "footer"];
          layoutList.forEach((layout) => {
            const ySpaceElem = getRefElem(elemStore[`${name}-${layout}-ySpace`]);
            if (ySpaceElem) {
              ySpaceElem.style.height = ySpaceHeight ? `${ySpaceHeight}px` : "";
            }
          });
        });
        const scrollYSpaceEl = refScrollYSpaceElem.value;
        if (scrollYSpaceEl) {
          scrollYSpaceEl.style.height = ySpaceHeight ? `${ySpaceHeight}px` : "";
        }
        const rowExpandYSpaceEl = refRowExpandYSpaceElem.value;
        if (rowExpandYSpaceEl) {
          rowExpandYSpaceEl.style.height = ySpaceHeight ? `${ySpaceHeight}px` : "";
        }
        reactData.scrollYTop = scrollYTop;
        reactData.scrollYHeight = ySpaceHeight;
        reactData.isScrollYBig = isScrollYBig;
        calcScrollbar();
        if (isScrollYBig && mouseOpts.area) {
          errLog("vxe.error.notProp", ["mouse-config.area"]);
        }
        if ($xeGanttView && $xeGanttView.handleUpdateSYSpace) {
          $xeGanttView.handleUpdateSYSpace();
        }
        return nextTick().then(() => {
          updateStyle();
        });
      },
      updateScrollXData() {
        const { isAllOverflow } = reactData;
        handleTableColumn();
        $xeTable.updateScrollXSpace();
        return nextTick().then(() => {
          handleTableColumn();
          $xeTable.updateScrollXSpace();
          if (!isAllOverflow) {
            $xeTable.updateScrollYSpace();
          }
        });
      },
      updateScrollYData() {
        $xeTable.handleTableData();
        $xeTable.updateScrollYSpace();
        return nextTick().then(() => {
          $xeTable.handleTableData();
          $xeTable.updateScrollYSpace();
        });
      },
      /**
       * 处理固定列的显示状态
       */
      checkScrolling() {
        const { elemStore } = internalData;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const leftContainerElem = refLeftContainer.value;
        const rightContainerElem = refRightContainer.value;
        const xHandleEl = refScrollXHandleElem.value;
        const bodtTargetEl = xHandleEl || bodyScrollElem;
        if (bodtTargetEl) {
          if (leftContainerElem) {
            if (bodtTargetEl.scrollLeft > 0) {
              addClass(leftContainerElem, "scrolling--middle");
            } else {
              removeClass(leftContainerElem, "scrolling--middle");
            }
          }
          if (rightContainerElem) {
            if (bodtTargetEl.clientWidth < bodtTargetEl.scrollWidth - Math.ceil(bodtTargetEl.scrollLeft)) {
              addClass(rightContainerElem, "scrolling--middle");
            } else {
              removeClass(rightContainerElem, "scrolling--middle");
            }
          }
        }
      },
      handleUpdateAggData() {
        return loadTableData(internalData.tableSynchData, true);
      },
      updateZindex() {
        if (props.zIndex) {
          internalData.tZindex = props.zIndex;
        } else if (internalData.tZindex < getLastZIndex()) {
          internalData.tZindex = nextZIndex();
        }
      },
      handleCheckedCheckboxRow,
      /**
       * 行 hover 事件
       */
      triggerHoverEvent(evnt, { row }) {
        tablePrivateMethods.setHoverRow(row);
      },
      setHoverRow(row) {
        const $xeGanttView = internalData.xeGanttView;
        const rowid = getRowid($xeTable, row);
        const el = refElem.value;
        tablePrivateMethods.clearHoverRow();
        if (el) {
          import_xe_utils18.default.arrayEach(el.querySelectorAll(`.vxe-body--row[rowid="${rowid}"]`), (elem) => addClass(elem, "row--hover"));
        }
        internalData.hoverRow = row;
        if ($xeGanttView && $xeGanttView.handleUpdateHoverRow) {
          $xeGanttView.handleUpdateHoverRow(row);
        }
      },
      clearHoverRow() {
        const $xeGanttView = internalData.xeGanttView;
        const el = refElem.value;
        if (el) {
          import_xe_utils18.default.arrayEach(el.querySelectorAll(".vxe-body--row.row--hover"), (elem) => removeClass(elem, "row--hover"));
        }
        internalData.hoverRow = null;
        if ($xeGanttView && $xeGanttView.handleUpdateHoverRow) {
          $xeGanttView.handleUpdateHoverRow();
        }
      },
      /**
       * 已废弃，被 getCellElement 替换
       * @deprecated
       */
      getCell(row, column) {
        return tableMethods.getCellElement(row, column);
      },
      findRowIndexOf(list, row) {
        return row ? import_xe_utils18.default.findIndexOf(list, (item) => $xeTable.eqRow(item, row)) : -1;
      },
      eqRow(row1, row2) {
        if (row1 && row2) {
          if (row1 === row2) {
            return true;
          }
          return getRowid($xeTable, row1) === getRowid($xeTable, row2);
        }
        return false;
      },
      handleConnectGanttView($ganttView) {
        if ($ganttView && $ganttView.connectUpdate) {
          $ganttView.connectUpdate({ $table: $xeTable });
          internalData.xeGanttView = $ganttView;
        }
        return nextTick();
      }
    };
    Object.assign($xeTable, tableMethods, tablePrivateMethods);
    const renderViewFixed = (fixedType) => {
      const { showHeader, showFooter } = props;
      const { tableData, tableColumn, tableGroupColumn, columnStore, footerTableData } = reactData;
      const scrollbarOpts = computeScrollbarOpts.value;
      const scrollbarXOpts = computeScrollbarXOpts.value;
      const scrollbarYOpts = computeScrollbarYOpts.value;
      const { overscrollBehavior: overscrollXBehavior } = scrollbarXOpts;
      const { overscrollBehavior: overscrollYBehavior } = scrollbarYOpts;
      const isFixedLeft = fixedType === "left";
      const fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
      const osXBehavior = import_xe_utils18.default.eqNull(overscrollXBehavior) ? scrollbarOpts.overscrollBehavior : overscrollXBehavior;
      const osYBehavior = import_xe_utils18.default.eqNull(overscrollYBehavior) ? scrollbarOpts.overscrollBehavior : overscrollYBehavior;
      return h("div", {
        ref: isFixedLeft ? refLeftContainer : refRightContainer,
        class: [`vxe-table--fixed-${fixedType}-wrapper`, `sx--${scrollbarXOpts.visible}`, `sy--${scrollbarYOpts.visible}`, {
          [`x-ob--${osXBehavior}`]: osXBehavior,
          [`y-ob--${osYBehavior}`]: osYBehavior
        }]
      }, [
        showHeader ? h(header_default, {
          ref: isFixedLeft ? refTableLeftHeader : refTableRightHeader,
          fixedType,
          tableData,
          tableColumn,
          tableGroupColumn,
          fixedColumn
        }) : renderEmptyElement9($xeTable),
        h(body_default, {
          ref: isFixedLeft ? refTableLeftBody : refTableRightBody,
          fixedType,
          tableData,
          tableColumn,
          fixedColumn
        }),
        showFooter ? h(footer_default, {
          ref: isFixedLeft ? refTableLeftFooter : refTableRightFooter,
          footerTableData,
          tableColumn,
          fixedColumn,
          fixedType
        }) : renderEmptyElement9($xeTable)
      ]);
    };
    const renderEmptyBody = () => {
      const emptyOpts = computeEmptyOpts.value;
      const emptySlot = slots.empty;
      const emptyParams = { $table: $xeTable, $grid: $xeGrid, gantt: $xeGantt };
      if (emptySlot) {
        return emptySlot(emptyParams);
      } else {
        const compConf = emptyOpts.name ? renderer9.get(emptyOpts.name) : null;
        const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (rtEmptyView) {
          return getSlotVNs(rtEmptyView(emptyOpts, emptyParams));
        }
      }
      return getFuncText(props.emptyText) || getI18n10("vxe.table.emptyText");
    };
    const renderDragTipContents = () => {
      const { dragConfig } = props;
      const { dragRow, dragCol, dragTipText } = reactData;
      const columnDragOpts = computeColumnDragOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const rowDragSlots = rowDragOpts.slots || {};
      const rTipSlot = rowDragSlots.tip || (dragConfig && dragConfig.slots ? dragConfig.slots.rowTip : null);
      const columnDragSlots = columnDragOpts.slots || {};
      const cTipSlot = columnDragSlots.tip;
      const dRow = dragRow || (rowDragOpts.isCrossTableDrag ? crossTableDragRowInfo2.row : null);
      if (dRow && rTipSlot) {
        return callSlot(rTipSlot, { row: dRow });
      }
      if (dragCol && cTipSlot) {
        return callSlot(cTipSlot, { column: dragCol });
      }
      return [h("span", dragTipText)];
    };
    const renderDragTip = () => {
      const { dragRow, dragCol } = reactData;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const dRow = dragRow || (rowDragOpts.isCrossTableDrag ? crossTableDragRowInfo2.row : null);
      if (rowOpts.drag || columnOpts.drag) {
        return h("div", {
          class: "vxe-table--drag-wrapper"
        }, [
          h("div", {
            ref: refDragRowLineElem,
            class: ["vxe-table--drag-row-line", {
              "is--guides": rowDragOpts.showGuidesStatus
            }]
          }),
          h("div", {
            ref: refDragColLineElem,
            class: ["vxe-table--drag-col-line", {
              "is--guides": columnDragOpts.showGuidesStatus
            }]
          }),
          dRow && rowDragOpts.showDragTip || dragCol && columnDragOpts.showDragTip ? h("div", {
            ref: refDragTipElem,
            class: "vxe-table--drag-sort-tip"
          }, [
            h("div", {
              class: "vxe-table--drag-sort-tip-wrapper"
            }, [
              h("div", {
                class: "vxe-table--drag-sort-tip-status"
              }, [
                h("span", {
                  class: ["vxe-table--drag-sort-tip-normal-status", dRow ? getIcon6().TABLE_DRAG_STATUS_ROW : getIcon6().TABLE_DRAG_STATUS_COLUMN]
                }),
                h("span", {
                  class: ["vxe-table--drag-sort-tip-sub-status", getIcon6().TABLE_DRAG_STATUS_SUB_ROW]
                }),
                h("span", {
                  class: ["vxe-table--drag-sort-tip-disabled-status", getIcon6().TABLE_DRAG_DISABLED]
                })
              ]),
              h("div", {
                class: "vxe-table--drag-sort-tip-content"
              }, renderDragTipContents())
            ])
          ]) : renderEmptyElement9($xeTable)
        ]);
      }
      return renderEmptyElement9($xeTable);
    };
    const renderRowExpandedVNs = () => {
      const { treeConfig } = props;
      const { expandColumn, isRowGroupStatus } = reactData;
      const tableRowExpandedList = computeTableRowExpandedList.value;
      const expandOpts = computeExpandOpts.value;
      const { mode } = expandOpts;
      if (mode !== "fixed") {
        return renderEmptyElement9($xeTable);
      }
      const expandVNs = [
        h("div", {
          key: "repY",
          ref: refRowExpandYSpaceElem
        })
      ];
      if (expandColumn) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        tableRowExpandedList.forEach((row) => {
          const expandOpts2 = computeExpandOpts.value;
          const { height: expandHeight, padding, indent } = expandOpts2;
          const { fullAllDataRowIdData, fullColumnIdData } = internalData;
          const treeOpts = computeTreeOpts.value;
          const { transform, seqMode } = treeOpts;
          const cellStyle = {};
          const rowid = handleGetRowId(row);
          const rowRest = fullAllDataRowIdData[rowid];
          const colid = expandColumn.id;
          const colRest = fullColumnIdData[colid] || {};
          let rowLevel = 0;
          let seq = -1;
          let _rowIndex = -1;
          let rowIndex = -1;
          let $rowIndex = -1;
          if (rowRest) {
            rowIndex = rowRest.index;
            $rowIndex = rowRest.$index;
            _rowIndex = rowRest._index;
            rowLevel = rowRest.level;
            seq = rowRest.seq;
            if (isRowGroupStatus || treeConfig && transform && seqMode === "increasing") {
              seq = rowRest._index + 1;
            } else if (treeConfig && seqMode === "fixed") {
              seq = rowRest._tIndex + 1;
            }
          }
          if (expandHeight) {
            cellStyle.height = `${expandHeight}px`;
          }
          if (isRowGroupStatus || treeConfig) {
            cellStyle.paddingLeft = `${rowLevel * (import_xe_utils18.default.isNumber(indent) ? indent : treeOpts.indent) + 30}px`;
          }
          let columnIndex = -1;
          let $columnIndex = -1;
          let _columnIndex = -1;
          if (colRest) {
            columnIndex = colRest.index;
            $columnIndex = colRest.$index;
            _columnIndex = colRest._index;
          }
          const expandParams = {
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt,
            seq,
            column: expandColumn,
            columnIndex,
            $columnIndex,
            _columnIndex,
            fixed: "",
            source: "table",
            type: "body",
            level: rowLevel,
            rowid,
            row,
            rowIndex,
            $rowIndex,
            _rowIndex,
            isHidden: false,
            isEdit: false,
            visibleData: [],
            data: [],
            items: []
          };
          expandVNs.push(h("div", {
            key: rowid,
            class: ["vxe-body--row-expanded-cell", {
              "is--padding": padding,
              "is--ellipsis": expandHeight
            }],
            rowid,
            style: cellStyle
          }, expandColumn.renderData(expandParams)));
        });
      }
      return h("div", {
        ref: refRowExpandElem,
        class: "vxe-table--row-expanded-wrapper"
      }, expandVNs);
    };
    const renderScrollX = () => {
      return h("div", {
        key: "vsx",
        ref: refScrollXVirtualElem,
        class: "vxe-table--scroll-x-virtual"
      }, [
        h("div", {
          ref: refScrollXLeftCornerElem,
          class: "vxe-table--scroll-x-left-corner"
        }),
        h("div", {
          ref: refScrollXWrapperElem,
          class: "vxe-table--scroll-x-wrapper"
        }, [
          h("div", {
            ref: refScrollXHandleElem,
            class: "vxe-table--scroll-x-handle",
            onScroll: $xeTable.triggerVirtualScrollXEvent
          }, [
            h("div", {
              ref: refScrollXSpaceElem,
              class: "vxe-table--scroll-x-space"
            })
          ]),
          h("div", {
            class: "vxe-table--scroll-x-handle-appearance"
          })
        ]),
        h("div", {
          ref: refScrollXRightCornerElem,
          class: "vxe-table--scroll-x-right-corner"
        })
      ]);
    };
    const renderScrollY = () => {
      return h("div", {
        ref: refScrollYVirtualElem,
        class: "vxe-table--scroll-y-virtual"
      }, [
        h("div", {
          ref: refScrollYTopCornerElem,
          class: "vxe-table--scroll-y-top-corner"
        }),
        h("div", {
          ref: refScrollYWrapperElem,
          class: "vxe-table--scroll-y-wrapper"
        }, [
          h("div", {
            ref: refScrollYHandleElem,
            class: "vxe-table--scroll-y-handle",
            onScroll: $xeTable.triggerVirtualScrollYEvent
          }, [
            h("div", {
              ref: refScrollYSpaceElem,
              class: "vxe-table--scroll-y-space"
            })
          ]),
          h("div", {
            class: "vxe-table--scroll-y-handle-appearance"
          })
        ]),
        h("div", {
          ref: refScrollYBottomCornerElem,
          class: "vxe-table--scroll-y-bottom-corner"
        })
      ]);
    };
    const renderViewport = () => {
      const { showHeader, showFooter } = props;
      const { overflowX, tableData, tableColumn, tableGroupColumn, footerTableData, columnStore } = reactData;
      const scrollbarOpts = computeScrollbarOpts.value;
      const scrollbarXOpts = computeScrollbarXOpts.value;
      const scrollbarYOpts = computeScrollbarYOpts.value;
      const { overscrollBehavior: overscrollXBehavior } = scrollbarXOpts;
      const { overscrollBehavior: overscrollYBehavior } = scrollbarYOpts;
      const { leftList, rightList } = columnStore;
      const osXBehavior = import_xe_utils18.default.eqNull(overscrollXBehavior) ? scrollbarOpts.overscrollBehavior : overscrollXBehavior;
      const osYBehavior = import_xe_utils18.default.eqNull(overscrollYBehavior) ? scrollbarOpts.overscrollBehavior : overscrollYBehavior;
      return h("div", {
        ref: refTableViewportElem,
        class: ["vxe-table--viewport-wrapper", {
          [`x-ob--${osXBehavior}`]: osXBehavior,
          [`y-ob--${osYBehavior}`]: osYBehavior
        }]
      }, [
        h("div", {
          class: ["vxe-table--main-wrapper", `sx--${scrollbarXOpts.visible}`, `sy--${scrollbarYOpts.visible}`]
        }, [
          /**
           * 表头
           */
          showHeader ? h(header_default, {
            ref: refTableHeader,
            tableData,
            tableColumn,
            tableGroupColumn
          }) : renderEmptyElement9($xeTable),
          /**
           * 表体
           */
          h(body_default, {
            ref: refTableBody,
            tableData,
            tableColumn
          }),
          /**
           * 表尾
           */
          showFooter ? h(footer_default, {
            ref: refTableFooter,
            footerTableData,
            tableColumn
          }) : renderEmptyElement9($xeTable)
        ]),
        h("div", {
          class: "vxe-table--fixed-wrapper"
        }, [
          leftList && leftList.length && overflowX ? renderViewFixed("left") : renderEmptyElement9($xeTable),
          rightList && rightList.length && overflowX ? renderViewFixed("right") : renderEmptyElement9($xeTable)
        ]),
        renderRowExpandedVNs()
      ]);
    };
    const renderBody = () => {
      const scrollbarYToLeft = computeScrollbarYToLeft.value;
      return h("div", {
        class: "vxe-table--layout-wrapper"
      }, scrollbarYToLeft ? [
        renderScrollY(),
        renderViewport()
      ] : [
        renderViewport(),
        renderScrollY()
      ]);
    };
    const renderVN = () => {
      const { loading, stripe, showHeader, height, treeConfig, mouseConfig, showFooter, highlightCell, highlightHoverRow, highlightHoverColumn, editConfig, editRules } = props;
      const { isGroup, overflowX, overflowY, scrollXLoad, scrollYLoad, tableData, initStore, isRowGroupStatus, columnStore, filterStore, customStore, tooltipStore } = reactData;
      const { teleportToWrapperElem, popupToWrapperElem } = internalData;
      const { leftList, rightList } = columnStore;
      const loadingSlot = slots.loading;
      const tipSlots = {
        header: slots.headerTooltip || slots["header-tooltip"],
        body: slots.tooltip,
        footer: slots.footerTooltip || slots["footer-tooltip"]
      };
      const currTooltipSlot = tooltipStore.visible && tooltipStore.type ? tipSlots[tooltipStore.type] : null;
      const rowDragOpts = computeRowDragOpts.value;
      const tableTipConfig = computeTableTipConfig.value;
      const validTipConfig = computeValidTipConfig.value;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const vSize = computeSize.value;
      const tableBorder = computeTableBorder.value;
      const mouseOpts = computeMouseOpts.value;
      const areaOpts = computeAreaOpts.value;
      const loadingOpts = computeLoadingOpts.value;
      const isContentMenu = computeIsContentMenu.value;
      const currLoading = reactData.isColLoading || reactData.isRowLoading || loading;
      const resizableOpts = computeResizableOpts.value;
      const isArea = mouseConfig && mouseOpts.area;
      const columnDragOpts = computeColumnDragOpts.value;
      const scrollbarXToTop = computeScrollbarXToTop.value;
      const scrollbarYToLeft = computeScrollbarYToLeft.value;
      const { isCrossTableDrag } = rowDragOpts;
      const tbOns = {
        onKeydown: keydownEvent
      };
      if (isCrossTableDrag && !tableData.length) {
        tbOns.onDragover = $xeTable.handleCrossTableRowDragoverEmptyEvent;
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-table", "vxe-table--render-default", `tid_${xID}`, `border--${tableBorder}`, `sx-pos--${scrollbarXToTop ? "top" : "bottom"}`, `sy-pos--${scrollbarYToLeft ? "left" : "right"}`, {
        [`size--${vSize}`]: vSize,
        [`valid-msg--${validOpts.msgMode}`]: !!editRules,
        "vxe-editable": !!editConfig,
        "old-cell-valid": editRules && getConfig5().cellVaildMode === "obsolete",
        "cell--highlight": highlightCell,
        "cell--selected": mouseConfig && mouseOpts.selected,
        "cell--area": isArea,
        "header-cell--area": isArea && areaOpts.selectCellByHeader,
        "body-cell--area": isArea && areaOpts.selectCellByBody,
        "row--highlight": rowOpts.isHover || highlightHoverRow,
        "column--highlight": columnOpts.isHover || highlightHoverColumn,
        "checkbox--range": checkboxOpts.range,
        "col--drag-cell": columnOpts.drag && columnDragOpts.trigger === "cell",
        "is--header": showHeader,
        "is--footer": showFooter,
        "is--group": isGroup,
        "is-row-group": isRowGroupStatus,
        "is--tree-line": treeConfig && (treeOpts.showLine || treeOpts.line),
        "is--fixed-left": leftList.length,
        "is--fixed-right": rightList.length,
        "is--animat": !!props.animat,
        "is--round": props.round,
        "is--stripe": !treeConfig && stripe,
        "is--loading": currLoading,
        "is--empty": !currLoading && !tableData.length,
        "is--scroll-y": overflowY,
        "is--scroll-x": overflowX,
        "is--virtual-x": scrollXLoad,
        "is--virtual-y": scrollYLoad
      }], spellcheck: false }, tbOns), [
        /**
         * 隐藏列
         */
        h("div", {
          class: "vxe-table-slots"
        }, slots.default ? slots.default({}) : []),
        h("div", {
          ref: refVarElem,
          class: "vxe-table-vars"
        }, [
          h("div", {
            class: "vxe-table-var-default"
          }),
          h("div", {
            class: "vxe-table-var-medium"
          }),
          h("div", {
            class: "vxe-table-var-small"
          }),
          h("div", {
            class: "vxe-table-var-mini"
          })
        ]),
        h("div", {
          key: "tw",
          class: "vxe-table--render-wrapper"
        }, scrollbarXToTop ? [
          renderScrollX(),
          renderBody()
        ] : [
          renderBody(),
          renderScrollX()
        ]),
        /**
         * 空数据
         */
        h("div", {
          key: "tn",
          ref: refEmptyPlaceholder,
          class: "vxe-table--empty-place-wrapper"
        }, [
          h("div", {
            class: "vxe-table--empty-placeholder"
          }, [
            h("div", {
              class: "vxe-table--empty-content"
            }, renderEmptyBody())
          ])
        ]),
        /**
         * 边框线
         */
        h("div", {
          key: "tl",
          class: "vxe-table--border-line"
        }),
        /**
         * 列宽线
         */
        h("div", {
          key: "tcl",
          ref: refColResizeBar,
          class: "vxe-table--resizable-col-bar"
        }, resizableOpts.showDragTip ? [
          h("div", {
            class: "vxe-table--resizable-number-tip"
          })
        ] : []),
        h("div", {
          key: "ttw"
        }, [
          h(Teleport, {
            to: teleportToWrapperElem,
            disabled: !($xeGantt && teleportToWrapperElem)
          }, [
            h("div", {
              ref: refTeleportWrapper
            }, [
              /**
               * 行高线
               */
              h("div", {
                key: "trl",
                ref: refRowResizeBar,
                class: "vxe-table--resizable-row-bar"
              }, resizableOpts.showDragTip ? [
                h("div", {
                  class: "vxe-table--resizable-number-tip"
                })
              ] : []),
              /**
               * 自定义列
               */
              initStore.custom ? h(panel_default, {
                key: "cs",
                ref: refTableCustom,
                customStore
              }) : renderEmptyElement9($xeTable),
              /**
               * 加载中
               */
              VxeUILoadingComponent ? h(VxeUILoadingComponent, {
                key: "lg",
                class: "vxe-table--loading",
                modelValue: currLoading,
                icon: loadingOpts.icon,
                text: loadingOpts.text
              }, loadingSlot ? {
                default: () => callSlot(loadingSlot, { $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt, loading: currLoading })
              } : {}) : loadingSlot ? h("div", {
                class: ["vxe-loading--custom-wrapper", {
                  "is--visible": currLoading
                }]
              }, callSlot(loadingSlot, { $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt, loading: currLoading })) : renderEmptyElement9($xeTable),
              /**
               * 拖拽排序提示
               */
              renderDragTip()
            ])
          ])
        ]),
        h("div", {
          key: "tpw"
        }, [
          h(Teleport, {
            to: popupToWrapperElem,
            disabled: !($xeGGWrapper && popupToWrapperElem)
          }, [
            h("div", {
              ref: refPopupWrapperElem
            }, [
              /**
               * 筛选
               */
              initStore.filter ? h(panel_default2, {
                key: "tf",
                ref: refTableFilter,
                filterStore
              }) : renderEmptyElement9($xeTable),
              /**
               * 快捷菜单
               */
              isContentMenu ? h(panel_default3, {
                key: "tm",
                ref: refTableMenu
              }) : renderEmptyElement9($xeTable)
            ])
          ])
        ]),
        /**
         * 导入
         */
        initStore.import && props.importConfig ? h(import_panel_default, {
          key: "it",
          defaultOptions: reactData.importParams,
          storeData: reactData.importStore
        }) : renderEmptyElement9($xeTable),
        /**
         * 导出
         */
        initStore.export && (props.exportConfig || props.printConfig) ? h(export_panel_default, {
          key: "et",
          defaultOptions: reactData.exportParams,
          storeData: reactData.exportStore
        }) : renderEmptyElement9($xeTable),
        /**
         * 提示相关
         */
        VxeUITooltipComponent ? h("div", {}, [
          /**
           * 通用提示
           */
          h(VxeUITooltipComponent, {
            key: "ctp",
            ref: refCommTooltip,
            isArrow: false,
            enterable: false
          }),
          /**
            * 工具提示
            */
          h(VxeUITooltipComponent, {
            key: "btp",
            ref: refTooltip,
            theme: tableTipConfig.theme,
            enterable: tableTipConfig.enterable,
            enterDelay: tableTipConfig.enterDelay,
            leaveDelay: tableTipConfig.leaveDelay,
            useHTML: tableTipConfig.useHTML,
            width: tableTipConfig.width,
            height: tableTipConfig.height,
            minWidth: tableTipConfig.minWidth,
            minHeight: tableTipConfig.minHeight,
            maxWidth: tableTipConfig.maxWidth,
            maxHeight: tableTipConfig.maxHeight
          }, currTooltipSlot ? {
            content: () => {
              const { type, row, column, content: tooltipContent } = tooltipStore;
              if (currTooltipSlot) {
                if (column && type === "header") {
                  return h("div", {
                    key: type
                  }, currTooltipSlot({ column, tooltipContent, $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt }));
                }
                if (row && column && type === "body") {
                  return h("div", {
                    key: type
                  }, currTooltipSlot({ row, column, tooltipContent, $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt }));
                }
                if (row && column && type === "footer") {
                  return h("div", {
                    key: type
                  }, currTooltipSlot({ row, column, tooltipContent, $table: $xeTable, $grid: $xeGrid, $gantt: $xeGantt }));
                }
              }
              return renderEmptyElement9($xeTable);
            }
          } : {}),
          /**
            * 校验提示
            */
          props.editRules && validOpts.showMessage && (validOpts.message === "default" ? !height : validOpts.message === "tooltip") ? h(VxeUITooltipComponent, {
            key: "vtp",
            ref: refValidTooltip,
            class: [{
              "old-cell-valid": editRules && getConfig5().cellVaildMode === "obsolete"
            }, "vxe-table--valid-error"],
            theme: validTipConfig.theme,
            enterable: validTipConfig.enterable,
            enterDelay: validTipConfig.enterDelay,
            leaveDelay: validTipConfig.leaveDelay
          }) : renderEmptyElement9($xeTable)
        ]) : renderEmptyElement9($xeTable)
      ]);
    };
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      const { initStatus } = internalData;
      const value = props.data || [];
      if (value && value.length >= 2e4) {
        warnLog("vxe.error.errLargeData", ["loadData(data), reloadData(data)"]);
      }
      loadTableData(value, true).then(() => {
        const { scrollXLoad, scrollYLoad, expandColumn } = reactData;
        const expandOpts = computeExpandOpts.value;
        internalData.inited = true;
        internalData.initStatus = true;
        if (!initStatus) {
          handleLoadDefaults();
        }
        if ((scrollXLoad || scrollYLoad) && (expandColumn && expandOpts.mode !== "fixed")) {
          warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
        }
        return tableMethods.recalculate();
      });
    });
    const staticColumnFlag = ref(0);
    watch(() => reactData.staticColumns.length, () => {
      staticColumnFlag.value++;
    });
    watch(() => reactData.staticColumns, () => {
      staticColumnFlag.value++;
    });
    watch(staticColumnFlag, () => {
      nextTick(() => handleInitColumn(import_xe_utils18.default.clone(reactData.staticColumns)));
    });
    const tableColumnFlag = ref(0);
    watch(() => reactData.tableColumn.length, () => {
      tableColumnFlag.value++;
    });
    watch(() => reactData.tableColumn, () => {
      tableColumnFlag.value++;
    });
    watch(tableColumnFlag, () => {
      tablePrivateMethods.analyColumnWidth();
    });
    watch(() => reactData.upDataFlag, () => {
      nextTick(() => {
        tableMethods.updateData();
      });
    });
    watch(() => reactData.reColumnFlag, () => {
      nextTick(() => {
        tableMethods.refreshColumn();
      });
    });
    const reLayoutFlag = ref(0);
    watch(computeSize, () => {
      reLayoutFlag.value++;
    });
    watch(() => props.showHeader, () => {
      reLayoutFlag.value++;
    });
    watch(() => props.showFooter, () => {
      reLayoutFlag.value++;
    });
    watch(() => reactData.overflowX, () => {
      reLayoutFlag.value++;
    });
    watch(() => reactData.overflowY, () => {
      reLayoutFlag.value++;
    });
    watch(() => props.height, () => {
      reLayoutFlag.value++;
    });
    watch(() => props.maxHeight, () => {
      reLayoutFlag.value++;
    });
    watch(computeScrollbarXToTop, () => {
      reLayoutFlag.value++;
    });
    watch(computeScrollbarYToLeft, () => {
      reLayoutFlag.value++;
    });
    watch(() => VxeUI.getLanguage(), () => {
      reLayoutFlag.value++;
    });
    watch(() => {
      const scrollbarXOpts = computeScrollbarXOpts.value;
      return scrollbarXOpts.visible;
    }, () => {
      reLayoutFlag.value++;
    });
    watch(() => {
      const scrollbarYOpts = computeScrollbarYOpts.value;
      return scrollbarYOpts.visible;
    }, () => {
      reLayoutFlag.value++;
    });
    watch(reLayoutFlag, () => {
      $xeTable.recalculate(true);
    });
    const footFlag = ref(0);
    watch(() => props.footerData ? props.footerData.length : -1, () => {
      footFlag.value++;
    });
    watch(() => props.footerData, () => {
      footFlag.value++;
    });
    watch(footFlag, () => {
      internalData.footerFullDataRowData = {};
      $xeTable.updateFooter();
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        handleUpdateResize();
        nextTick(() => {
          handleUpdateResize();
          setTimeout(() => handleUpdateResize());
        });
      }
    });
    const mergeCellFlag = ref(0);
    watch(() => props.mergeCells ? props.mergeCells.length : -1, () => {
      mergeCellFlag.value++;
    });
    watch(() => props.mergeCells, () => {
      mergeCellFlag.value++;
    });
    watch(mergeCellFlag, () => {
      handleUpdateMergeBodyCells(props.mergeCells || []);
    });
    const mergeHeaderItemFlag = ref(0);
    watch(() => props.mergeHeaderCells ? props.mergeHeaderCells.length : -1, () => {
      mergeHeaderItemFlag.value++;
    });
    watch(() => props.mergeHeaderCells, () => {
      mergeHeaderItemFlag.value++;
    });
    watch(mergeHeaderItemFlag, () => {
      handleUpdateMergeHeaderCells(props.mergeHeaderCells || []);
    });
    const mergeFooteCellFlag = ref(0);
    watch(() => props.mergeFooterCells ? props.mergeFooterCells.length : -1, () => {
      mergeFooteCellFlag.value++;
    });
    watch(() => props.mergeFooterCells, () => {
      mergeFooteCellFlag.value++;
    });
    watch(() => props.mergeFooterItems ? props.mergeFooterItems.length : -1, () => {
      mergeFooteCellFlag.value++;
    });
    watch(() => props.mergeFooterItems, () => {
      mergeFooteCellFlag.value++;
    });
    watch(mergeFooteCellFlag, () => {
      const mFooterCells = props.mergeFooterCells || props.mergeFooterItems;
      handleUpdateMergeFooterCells(mFooterCells || []);
    });
    watch(computeRowGroupFields, (val) => {
      handleUpdateRowGroup(val);
    });
    watch(computeRowField, () => {
      const { inited, tableFullData } = internalData;
      if (inited) {
        handleKeyField();
        reactData.tableData = [];
        nextTick(() => {
          $xeTable.reloadData(tableFullData);
        });
      }
    });
    if ($xeTabs) {
      watch(() => $xeTabs ? $xeTabs.reactData.resizeFlag : null, () => {
        handleGlobalResizeEvent();
      });
    }
    handleKeyField();
    hooks7.forEach((options) => {
      const { setupTable } = options;
      if (setupTable) {
        const hookRest = setupTable($xeTable);
        if (hookRest && import_xe_utils18.default.isObject(hookRest)) {
          Object.assign($xeTable, hookRest);
        }
      }
    });
    tablePrivateMethods.preventEvent(null, "created", { $table: $xeTable });
    let resizeObserver;
    onActivated(() => {
      tableMethods.recalculate().then(() => tableMethods.refreshScroll());
      tablePrivateMethods.preventEvent(null, "activated", { $table: $xeTable });
    });
    onDeactivated(() => {
      const { filterStore } = reactData;
      if (filterStore.visible) {
        $xeTable.clearFilter();
      }
      $xeTable.closeTooltip();
      internalData.isActivated = false;
      tablePrivateMethods.preventEvent(null, "deactivated", { $table: $xeTable });
    });
    onMounted(() => {
      const columnOpts = computeColumnOpts.value;
      const rowOpts = computeRowOpts.value;
      const customOpts = computeCustomOpts.value;
      const aggregateOpts = computeAggregateOpts.value;
      const virtualYOpts = computeVirtualYOpts.value;
      const { groupFields } = aggregateOpts;
      if ($xeGantt) {
        const { refClassifyWrapperElem } = $xeGantt.getRefMaps();
        const classifyWrapperEl = refClassifyWrapperElem.value;
        if (classifyWrapperEl) {
          internalData.teleportToWrapperElem = classifyWrapperEl;
        }
      }
      if ($xeGGWrapper) {
        const { refPopupContainerElem } = $xeGGWrapper.getRefMaps();
        const popupContainerEl = refPopupContainerElem.value;
        if (popupContainerEl) {
          internalData.popupToWrapperElem = popupContainerEl;
        }
      }
      if (columnOpts.drag || rowOpts.drag || customOpts.allowSort) {
        initTpImg();
      }
      handleUpdateRowGroup(groupFields);
      nextTick(() => {
        const { exportConfig, importConfig, treeConfig, highlightCurrentRow, highlightCurrentColumn } = props;
        const { scrollXStore, scrollYStore } = internalData;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const expandOpts = computeExpandOpts.value;
        const rowOpts2 = computeRowOpts.value;
        const customOpts2 = computeCustomOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const exportOpts = computeExportOpts.value;
        const importOpts = computeImportOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const keyboardOpts = computeKeyboardOpts.value;
        const aggregateOpts2 = computeAggregateOpts.value;
        const rowDragOpts = computeRowDragOpts.value;
        if (props.rowId) {
          warnLog("vxe.error.delProp", ["row-id", "row-config.keyField"]);
        }
        if (props.rowKey) {
          warnLog("vxe.error.delProp", ["row-key", "row-config.useKey"]);
        }
        if (props.columnKey) {
          warnLog("vxe.error.delProp", ["column-id", "column-config.useKey"]);
        }
        if (!(props.rowId || rowOpts2.keyField) && (checkboxOpts.reserve || checkboxOpts.checkRowKeys || radioOpts.reserve || radioOpts.checkRowKey || expandOpts.expandRowKeys || treeOpts.expandRowKeys)) {
          warnLog("vxe.error.reqProp", ["row-config.keyField"]);
        }
        if (props.editConfig && (editOpts.showStatus || editOpts.showUpdateStatus || editOpts.showInsertStatus) && !props.keepSource) {
          warnLog("vxe.error.reqProp", ["keep-source"]);
        }
        if (treeConfig && !treeOpts.transform && props.stripe) {
          warnLog("vxe.error.noTree", ["stripe"]);
        }
        if (props.showFooter && !(props.footerMethod || props.footerData)) {
          warnLog("vxe.error.reqProp", ["footer-data | footer-method"]);
        }
        if (rowOpts2.height) {
          warnLog("vxe.error.delProp", ["row-config.height", "cell-config.height"]);
        }
        if (props.highlightCurrentRow) {
          warnLog("vxe.error.delProp", ["highlight-current-row", "row-config.isCurrent"]);
        }
        if (props.highlightHoverRow) {
          warnLog("vxe.error.delProp", ["highlight-hover-row", "row-config.isHover"]);
        }
        if (props.highlightCurrentColumn) {
          warnLog("vxe.error.delProp", ["highlight-current-column", "column-config.isCurrent"]);
        }
        if (props.highlightHoverColumn) {
          warnLog("vxe.error.delProp", ["highlight-hover-column", "column-config.isHover"]);
        }
        if (props.resizable) {
          warnLog("vxe.error.delProp", ["resizable", "column-config.resizable"]);
        }
        if (props.aggregateConfig && props.rowGroupConfig) {
          warnLog("vxe.error.notSupportProp", ["aggregate-config", "row-group-config", "row-group-config=null"]);
        }
        if (importConfig && importOpts.types && !importOpts.importMethod && !import_xe_utils18.default.includeArrays(import_xe_utils18.default.keys(importOpts._typeMaps), importOpts.types)) {
          warnLog("vxe.error.errProp", [`export-config.types=${importOpts.types.join(",")}`, importOpts.types.filter((type) => import_xe_utils18.default.includes(import_xe_utils18.default.keys(importOpts._typeMaps), type)).join(",") || import_xe_utils18.default.keys(importOpts._typeMaps).join(",")]);
        }
        if (exportConfig && exportOpts.types && !exportOpts.exportMethod && !import_xe_utils18.default.includeArrays(import_xe_utils18.default.keys(exportOpts._typeMaps), exportOpts.types)) {
          warnLog("vxe.error.errProp", [`export-config.types=${exportOpts.types.join(",")}`, exportOpts.types.filter((type) => import_xe_utils18.default.includes(import_xe_utils18.default.keys(exportOpts._typeMaps), type)).join(",") || import_xe_utils18.default.keys(exportOpts._typeMaps).join(",")]);
        }
        if (!props.id) {
          if ((props.customConfig ? isEnableConf(customOpts2) : customOpts2.enabled) && customOpts2.storage) {
            errLog("vxe.error.reqProp", ["id"]);
          }
        }
        if (props.treeConfig && checkboxOpts.range) {
          errLog("vxe.error.noTree", ["checkbox-config.range"]);
        }
        if (rowOpts2.height && !props.showOverflow) {
          warnLog("vxe.error.notProp", ["table.show-overflow"]);
        }
        if (!$xeTable.triggerCellAreaModnEvent) {
          if (props.areaConfig) {
            warnLog("vxe.error.notProp", ["area-config"]);
          }
          if (props.clipConfig) {
            warnLog("vxe.error.notProp", ["clip-config"]);
          }
          if (props.fnrConfig) {
            warnLog("vxe.error.notProp", ["fnr-config"]);
          }
          if (mouseOpts.area) {
            errLog("vxe.error.notProp", ["mouse-config.area"]);
            return;
          }
        }
        if (!$xeTable.handlePivotTableAggregateData) {
          if (customOpts2.allowGroup) {
            errLog("vxe.error.notProp", ["custom-config.allowGroup"]);
            return;
          }
          if (customOpts2.allowValues) {
            errLog("vxe.error.notProp", ["custom-config.allowValues"]);
            return;
          }
        }
        if (treeConfig && rowOpts2.drag && !treeOpts.transform) {
          errLog("vxe.error.notSupportProp", ["row-config.drag", "tree-config.transform=false", "tree-config.transform=true"]);
        }
        if (treeConfig && rowDragOpts.isCrossTableDrag && !rowDragOpts.isCrossDrag) {
          errLog("vxe.error.reqSupportProp", ["tree-config & row-drag-config.isCrossTableDrag", "row-drag-config.isCrossDrag"]);
        }
        if (props.dragConfig) {
          warnLog("vxe.error.delProp", ["drag-config", "row-drag-config"]);
        }
        if (props.rowGroupConfig) {
          warnLog("vxe.error.delProp", ["row-group-config", "aggregate-config"]);
        }
        if (aggregateOpts2.countFields) {
          warnLog("vxe.error.delProp", ["row-group-config.countFields", "column.agg-func"]);
        }
        if (aggregateOpts2.aggregateMethod) {
          warnLog("vxe.error.delProp", ["row-group-config.aggregateMethod", "aggregate-config.calcValuesMethod"]);
        }
        if (aggregateOpts2.countMethod) {
          warnLog("vxe.error.delProp", ["aggregate-config.countMethod", "aggregate-config.calcValuesMethod"]);
        }
        if (props.treeConfig && treeOpts.children) {
          warnLog("vxe.error.delProp", ["tree-config.children", "tree-config.childrenField"]);
        }
        if (props.treeConfig && treeOpts.line) {
          warnLog("vxe.error.delProp", ["tree-config.line", "tree-config.showLine"]);
        }
        if (mouseOpts.area && mouseOpts.selected) {
          warnLog("vxe.error.errConflicts", ["mouse-config.area", "mouse-config.selected"]);
        }
        if (mouseOpts.area && (props.treeConfig && !treeOpts.transform)) {
          errLog("vxe.error.noTree", ["mouse-config.area"]);
        }
        if (props.editConfig && editOpts.activeMethod) {
          warnLog("vxe.error.delProp", ["edit-config.activeMethod", "edit-config.beforeEditMethod"]);
        }
        if (props.treeConfig && checkboxOpts.isShiftKey) {
          errLog("vxe.error.errConflicts", ["tree-config", "checkbox-config.isShiftKey"]);
        }
        if (checkboxOpts.halfField) {
          warnLog("vxe.error.delProp", ["checkbox-config.halfField", "checkbox-config.indeterminateField"]);
        }
        if (treeConfig) {
          import_xe_utils18.default.arrayEach(["rowField", "parentField", "childrenField", "hasChildField", "mapChildrenField"], (key) => {
            const val = treeOpts[key];
            if (val && val.indexOf(".") > -1) {
              errLog("vxe.error.errProp", [`${key}=${val}`, `${key}=${val.split(".")[0]}`]);
            }
          });
        }
        if (rowOpts2.currentMethod) {
          warnLog("vxe.error.delProp", ["row-config.currentMethod", "current-row-config.beforeSelectMethod"]);
        }
        if (columnOpts.currentMethod) {
          warnLog("vxe.error.delProp", ["row-config.currentMethod", "current-column-config.beforeSelectMethod"]);
        }
        if ((rowOpts2.isCurrent || highlightCurrentRow) && props.keyboardConfig && keyboardOpts.isArrow && !import_xe_utils18.default.isBoolean(currentRowOpts.isFollowSelected)) {
          warnLog("vxe.error.notConflictProp", ["row-config.isCurrent", "current-row-config.isFollowSelected"]);
        }
        if ((columnOpts.isCurrent || highlightCurrentColumn) && props.keyboardConfig && keyboardOpts.isArrow && !import_xe_utils18.default.isBoolean(currentColumnOpts.isFollowSelected)) {
          warnLog("vxe.error.notConflictProp", ["column-config.isCurrent", "current-column-config.isFollowSelected"]);
        }
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        });
        Object.assign(scrollXStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        });
        initData();
        if (props.autoResize) {
          const el = refElem.value;
          const parentEl = tablePrivateMethods.getParentElem();
          resizeObserver = globalResize.create(() => {
            if (props.autoResize) {
              handleResizeEvent();
            }
          });
          if (el) {
            resizeObserver.observe(el);
          }
          if (parentEl) {
            resizeObserver.observe(parentEl);
          }
        }
      });
      if (virtualYOpts.mode !== "scroll") {
        const tableViewportEl = refTableViewportElem.value;
        if (tableViewportEl) {
          tableViewportEl.addEventListener("wheel", $xeTable.triggerBodyWheelEvent, { passive: false });
        }
      }
      globalEvents2.on($xeTable, "paste", handleGlobalPasteEvent);
      globalEvents2.on($xeTable, "copy", handleGlobalCopyEvent);
      globalEvents2.on($xeTable, "cut", handleGlobalCutEvent);
      globalEvents2.on($xeTable, "mousedown", handleGlobalMousedownEvent);
      globalEvents2.on($xeTable, "blur", handleGlobalBlurEvent);
      globalEvents2.on($xeTable, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents2.on($xeTable, "keydown", handleGlobalKeydownEvent);
      globalEvents2.on($xeTable, "resize", handleGlobalResizeEvent);
      globalEvents2.on($xeTable, "contextmenu", $xeTable.handleGlobalContextmenuEvent);
      $xeTable.preventEvent(null, "mounted", { $table: $xeTable });
    });
    onBeforeUnmount(() => {
      const tableViewportEl = refTableViewportElem.value;
      if (tableViewportEl) {
        tableViewportEl.removeEventListener("wheel", $xeTable.triggerBodyWheelEvent);
      }
      internalData.cvCacheMaps = {};
      internalData.prevDragRow = null;
      internalData.prevDragCol = null;
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      tableMethods.closeFilter();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
      globalEvents2.off($xeTable, "paste");
      globalEvents2.off($xeTable, "copy");
      globalEvents2.off($xeTable, "cut");
      globalEvents2.off($xeTable, "mousedown");
      globalEvents2.off($xeTable, "blur");
      globalEvents2.off($xeTable, "mousewheel");
      globalEvents2.off($xeTable, "keydown");
      globalEvents2.off($xeTable, "resize");
      globalEvents2.off($xeTable, "contextmenu");
      tablePrivateMethods.preventEvent(null, "beforeUnmount", { $table: $xeTable });
    });
    onUnmounted(() => {
      tablePrivateMethods.preventEvent(null, "unmounted", { $table: $xeTable });
      import_xe_utils18.default.assign(internalData, createInternalData());
    });
    nextTick(() => {
      if (props.loading) {
        if (!VxeUILoadingComponent && !slots.loading) {
          errLog("vxe.error.errProp", ["loading=true", "loading=false | <template #loading>...</template>"]);
          errLog("vxe.error.reqComp", ["vxe-loading"]);
        }
      }
      if (props.showOverflow === true || props.showOverflow === "tooltip" || (props.showHeaderOverflow === true || props.showHeaderOverflow === "tooltip") || (props.showFooterOverflow === true || props.showFooterOverflow === "tooltip") || props.tooltipConfig || props.editRules) {
        if (!VxeUITooltipComponent) {
          if (props.showOverflow === true) {
            errLog("vxe.error.errProp", ["show-overflow=true", "show-overflow=title"]);
          }
          if (props.showOverflow === "tooltip") {
            errLog("vxe.error.errProp", ["show-overflow=tooltip", "show-overflow=title"]);
          }
          if (props.showHeaderOverflow === true) {
            errLog("vxe.error.errProp", ["show-header-overflow=true", "show-header-overflow=title"]);
          }
          if (props.showHeaderOverflow === "tooltip") {
            errLog("vxe.error.errProp", ["show-header-overflow=tooltip", "show-header-overflow=title"]);
          }
          if (props.showFooterOverflow === true) {
            errLog("vxe.error.errProp", ["show-footer-overflow=true", "show-footer-overflow=title"]);
          }
          if (props.showFooterOverflow === "tooltip") {
            errLog("vxe.error.errProp", ["show-footer-overflow=tooltip", "show-footer-overflow=title"]);
          }
          errLog("vxe.error.reqComp", ["vxe-tooltip"]);
        }
      }
    });
    provide("$xeColgroup", null);
    provide("$xeTable", $xeTable);
    $xeTable.renderVN = renderVN;
    return $xeTable;
  },
  render() {
    return this.renderVN();
  }
});

export {
  tableProps,
  tableEmits,
  table_default
};
//# sourceMappingURL=chunk-V6QTR4IG.js.map
