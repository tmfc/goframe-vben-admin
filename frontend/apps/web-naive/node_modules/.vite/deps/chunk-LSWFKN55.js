import {
  Axis2D_default,
  SymbolDraw_default,
  install
} from "./chunk-EXZFT6FE.js";
import {
  createSeriesData_default
} from "./chunk-2GV52CN5.js";
import {
  Chart_default,
  Series_default,
  createFloat32Array,
  createRenderPlanner,
  createSymbol,
  getECData,
  isDimensionStacked,
  makeInner,
  tokens_default,
  use
} from "./chunk-BBIN2DI5.js";
import {
  BoundingRect_default,
  Group_default,
  Path_default,
  __extends,
  map
} from "./chunk-FHOMOJ23.js";

// ../../node_modules/.pnpm/echarts@6.0.0/node_modules/echarts/lib/chart/scatter/ScatterSeries.js
var ScatterSeriesModel = (
  /** @class */
  function(_super) {
    __extends(ScatterSeriesModel2, _super);
    function ScatterSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ScatterSeriesModel2.type;
      _this.hasSymbolVisual = true;
      return _this;
    }
    ScatterSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      return createSeriesData_default(null, this, {
        useEncodeDefaulter: true
      });
    };
    ScatterSeriesModel2.prototype.getProgressive = function() {
      var progressive = this.option.progressive;
      if (progressive == null) {
        return this.option.large ? 5e3 : this.get("progressive");
      }
      return progressive;
    };
    ScatterSeriesModel2.prototype.getProgressiveThreshold = function() {
      var progressiveThreshold = this.option.progressiveThreshold;
      if (progressiveThreshold == null) {
        return this.option.large ? 1e4 : this.get("progressiveThreshold");
      }
      return progressiveThreshold;
    };
    ScatterSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
      return selectors.point(data.getItemLayout(dataIndex));
    };
    ScatterSeriesModel2.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    };
    ScatterSeriesModel2.type = "series.scatter";
    ScatterSeriesModel2.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar", "matrix"];
    ScatterSeriesModel2.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: true,
      symbolSize: 10,
      // symbolRotate: null,  // 图形旋转控制
      large: false,
      // Available when large is true
      largeThreshold: 2e3,
      // cursor: null,
      itemStyle: {
        opacity: 0.8
        // color: 各异
      },
      emphasis: {
        scale: true
      },
      // If clip the overflow graphics
      // Works on cartesian / polar series
      clip: true,
      select: {
        itemStyle: {
          borderColor: tokens_default.color.primary
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
      // progressive: null
    };
    return ScatterSeriesModel2;
  }(Series_default)
);
var ScatterSeries_default = ScatterSeriesModel;

// ../../node_modules/.pnpm/echarts@6.0.0/node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js
var BOOST_SIZE_THRESHOLD = 4;
var LargeSymbolPathShape = (
  /** @class */
  /* @__PURE__ */ function() {
    function LargeSymbolPathShape2() {
    }
    return LargeSymbolPathShape2;
  }()
);
var LargeSymbolPath = (
  /** @class */
  function(_super) {
    __extends(LargeSymbolPath2, _super);
    function LargeSymbolPath2(opts) {
      var _this = _super.call(this, opts) || this;
      _this._off = 0;
      _this.hoverDataIdx = -1;
      return _this;
    }
    LargeSymbolPath2.prototype.getDefaultShape = function() {
      return new LargeSymbolPathShape();
    };
    LargeSymbolPath2.prototype.reset = function() {
      this.notClear = false;
      this._off = 0;
    };
    LargeSymbolPath2.prototype.buildPath = function(path, shape) {
      var points = shape.points;
      var size = shape.size;
      var symbolProxy = this.symbolProxy;
      var symbolProxyShape = symbolProxy.shape;
      var ctx = path.getContext ? path.getContext() : path;
      var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD;
      var softClipShape = this.softClipShape;
      var i;
      if (canBoost) {
        this._ctx = ctx;
        return;
      }
      this._ctx = null;
      for (i = this._off; i < points.length; ) {
        var x = points[i++];
        var y = points[i++];
        if (isNaN(x) || isNaN(y)) {
          continue;
        }
        if (softClipShape && !softClipShape.contain(x, y)) {
          continue;
        }
        symbolProxyShape.x = x - size[0] / 2;
        symbolProxyShape.y = y - size[1] / 2;
        symbolProxyShape.width = size[0];
        symbolProxyShape.height = size[1];
        symbolProxy.buildPath(path, symbolProxyShape, true);
      }
      if (this.incremental) {
        this._off = i;
        this.notClear = true;
      }
    };
    LargeSymbolPath2.prototype.afterBrush = function() {
      var shape = this.shape;
      var points = shape.points;
      var size = shape.size;
      var ctx = this._ctx;
      var softClipShape = this.softClipShape;
      var i;
      if (!ctx) {
        return;
      }
      for (i = this._off; i < points.length; ) {
        var x = points[i++];
        var y = points[i++];
        if (isNaN(x) || isNaN(y)) {
          continue;
        }
        if (softClipShape && !softClipShape.contain(x, y)) {
          continue;
        }
        ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
      }
      if (this.incremental) {
        this._off = i;
        this.notClear = true;
      }
    };
    LargeSymbolPath2.prototype.findDataIndex = function(x, y) {
      var shape = this.shape;
      var points = shape.points;
      var size = shape.size;
      var w = Math.max(size[0], 4);
      var h = Math.max(size[1], 4);
      for (var idx = points.length / 2 - 1; idx >= 0; idx--) {
        var i = idx * 2;
        var x0 = points[i] - w / 2;
        var y0 = points[i + 1] - h / 2;
        if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {
          return idx;
        }
      }
      return -1;
    };
    LargeSymbolPath2.prototype.contain = function(x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      x = localPos[0];
      y = localPos[1];
      if (rect.contain(x, y)) {
        var dataIdx = this.hoverDataIdx = this.findDataIndex(x, y);
        return dataIdx >= 0;
      }
      this.hoverDataIdx = -1;
      return false;
    };
    LargeSymbolPath2.prototype.getBoundingRect = function() {
      var rect = this._rect;
      if (!rect) {
        var shape = this.shape;
        var points = shape.points;
        var size = shape.size;
        var w = size[0];
        var h = size[1];
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        for (var i = 0; i < points.length; ) {
          var x = points[i++];
          var y = points[i++];
          minX = Math.min(x, minX);
          maxX = Math.max(x, maxX);
          minY = Math.min(y, minY);
          maxY = Math.max(y, maxY);
        }
        rect = this._rect = new BoundingRect_default(minX - w / 2, minY - h / 2, maxX - minX + w, maxY - minY + h);
      }
      return rect;
    };
    return LargeSymbolPath2;
  }(Path_default)
);
var LargeSymbolDraw = (
  /** @class */
  function() {
    function LargeSymbolDraw2() {
      this.group = new Group_default();
    }
    LargeSymbolDraw2.prototype.updateData = function(data, opt) {
      this._clear();
      var symbolEl = this._create();
      symbolEl.setShape({
        points: data.getLayout("points")
      });
      this._setCommon(symbolEl, data, opt);
    };
    LargeSymbolDraw2.prototype.updateLayout = function(data) {
      var points = data.getLayout("points");
      this.group.eachChild(function(child) {
        if (child.startIndex != null) {
          var len = (child.endIndex - child.startIndex) * 2;
          var byteOffset = child.startIndex * 4 * 2;
          points = new Float32Array(points.buffer, byteOffset, len);
        }
        child.setShape("points", points);
        child.reset();
      });
    };
    LargeSymbolDraw2.prototype.incrementalPrepareUpdate = function(data) {
      this._clear();
    };
    LargeSymbolDraw2.prototype.incrementalUpdate = function(taskParams, data, opt) {
      var lastAdded = this._newAdded[0];
      var points = data.getLayout("points");
      var oldPoints = lastAdded && lastAdded.shape.points;
      if (oldPoints && oldPoints.length < 2e4) {
        var oldLen = oldPoints.length;
        var newPoints = new Float32Array(oldLen + points.length);
        newPoints.set(oldPoints);
        newPoints.set(points, oldLen);
        lastAdded.endIndex = taskParams.end;
        lastAdded.setShape({
          points: newPoints
        });
      } else {
        this._newAdded = [];
        var symbolEl = this._create();
        symbolEl.startIndex = taskParams.start;
        symbolEl.endIndex = taskParams.end;
        symbolEl.incremental = true;
        symbolEl.setShape({
          points
        });
        this._setCommon(symbolEl, data, opt);
      }
    };
    LargeSymbolDraw2.prototype.eachRendered = function(cb) {
      this._newAdded[0] && cb(this._newAdded[0]);
    };
    LargeSymbolDraw2.prototype._create = function() {
      var symbolEl = new LargeSymbolPath({
        cursor: "default"
      });
      symbolEl.ignoreCoarsePointer = true;
      this.group.add(symbolEl);
      this._newAdded.push(symbolEl);
      return symbolEl;
    };
    LargeSymbolDraw2.prototype._setCommon = function(symbolEl, data, opt) {
      var hostModel = data.hostModel;
      opt = opt || {};
      var size = data.getVisual("symbolSize");
      symbolEl.setShape("size", size instanceof Array ? size : [size, size]);
      symbolEl.softClipShape = opt.clipShape || null;
      symbolEl.symbolProxy = createSymbol(data.getVisual("symbol"), 0, 0, 0, 0);
      symbolEl.setColor = symbolEl.symbolProxy.setColor;
      var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;
      symbolEl.useStyle(
        // Draw shadow when doing fillRect is extremely slow.
        hostModel.getModel("itemStyle").getItemStyle(extrudeShadow ? ["color", "shadowBlur", "shadowColor"] : ["color"])
      );
      var globalStyle = data.getVisual("style");
      var visualColor = globalStyle && globalStyle.fill;
      if (visualColor) {
        symbolEl.setColor(visualColor);
      }
      var ecData = getECData(symbolEl);
      ecData.seriesIndex = hostModel.seriesIndex;
      symbolEl.on("mousemove", function(e) {
        ecData.dataIndex = null;
        var dataIndex = symbolEl.hoverDataIdx;
        if (dataIndex >= 0) {
          ecData.dataIndex = dataIndex + (symbolEl.startIndex || 0);
        }
      });
    };
    LargeSymbolDraw2.prototype.remove = function() {
      this._clear();
    };
    LargeSymbolDraw2.prototype._clear = function() {
      this._newAdded = [];
      this.group.removeAll();
    };
    return LargeSymbolDraw2;
  }()
);
var LargeSymbolDraw_default = LargeSymbolDraw;

// ../../node_modules/.pnpm/echarts@6.0.0/node_modules/echarts/lib/layout/points.js
function pointsLayout(seriesType, forceStoreInTypedArray) {
  return {
    seriesType,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      var pipelineContext = seriesModel.pipelineContext;
      var useTypedArray = forceStoreInTypedArray || pipelineContext.large;
      if (!coordSys) {
        return;
      }
      var dims = map(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }).slice(0, 2);
      var dimLen = dims.length;
      var stackResultDim = data.getCalculationInfo("stackResultDimension");
      if (isDimensionStacked(data, dims[0])) {
        dims[0] = stackResultDim;
      }
      if (isDimensionStacked(data, dims[1])) {
        dims[1] = stackResultDim;
      }
      var store = data.getStore();
      var dimIdx0 = data.getDimensionIndex(dims[0]);
      var dimIdx1 = data.getDimensionIndex(dims[1]);
      return dimLen && {
        progress: function(params, data2) {
          var segCount = params.end - params.start;
          var points = useTypedArray && createFloat32Array(segCount * dimLen);
          var tmpIn = [];
          var tmpOut = [];
          for (var i = params.start, offset = 0; i < params.end; i++) {
            var point = void 0;
            if (dimLen === 1) {
              var x = store.get(dimIdx0, i);
              point = coordSys.dataToPoint(x, null, tmpOut);
            } else {
              tmpIn[0] = store.get(dimIdx0, i);
              tmpIn[1] = store.get(dimIdx1, i);
              point = coordSys.dataToPoint(tmpIn, null, tmpOut);
            }
            if (useTypedArray) {
              points[offset++] = point[0];
              points[offset++] = point[1];
            } else {
              data2.setItemLayout(i, point.slice());
            }
          }
          useTypedArray && data2.setLayout("points", points);
        }
      };
    }
  };
}

// ../../node_modules/.pnpm/echarts@6.0.0/node_modules/echarts/lib/chart/scatter/ScatterView.js
var ScatterView = (
  /** @class */
  function(_super) {
    __extends(ScatterView2, _super);
    function ScatterView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ScatterView2.type;
      return _this;
    }
    ScatterView2.prototype.render = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var symbolDraw = this._updateSymbolDraw(data, seriesModel);
      symbolDraw.updateData(data, {
        // TODO
        // If this parameter should be a shape or a bounding volume
        // shape will be more general.
        // But bounding volume like bounding rect will be much faster in the contain calculation
        clipShape: this._getClipShape(seriesModel)
      });
      this._finished = true;
    };
    ScatterView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var symbolDraw = this._updateSymbolDraw(data, seriesModel);
      symbolDraw.incrementalPrepareUpdate(data);
      this._finished = false;
    };
    ScatterView2.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
      this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {
        clipShape: this._getClipShape(seriesModel)
      });
      this._finished = taskParams.end === seriesModel.getData().count();
    };
    ScatterView2.prototype.updateTransform = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      this.group.dirty();
      if (!this._finished || data.count() > 1e4) {
        return {
          update: true
        };
      } else {
        var res = pointsLayout("").reset(seriesModel, ecModel, api);
        if (res.progress) {
          res.progress({
            start: 0,
            end: data.count(),
            count: data.count()
          }, data);
        }
        this._symbolDraw.updateLayout(data);
      }
    };
    ScatterView2.prototype.eachRendered = function(cb) {
      this._symbolDraw && this._symbolDraw.eachRendered(cb);
    };
    ScatterView2.prototype._getClipShape = function(seriesModel) {
      if (!seriesModel.get("clip", true)) {
        return;
      }
      var coordSys = seriesModel.coordinateSystem;
      return coordSys && coordSys.getArea && coordSys.getArea(0.1);
    };
    ScatterView2.prototype._updateSymbolDraw = function(data, seriesModel) {
      var symbolDraw = this._symbolDraw;
      var pipelineContext = seriesModel.pipelineContext;
      var isLargeDraw = pipelineContext.large;
      if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
        symbolDraw && symbolDraw.remove();
        symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw_default() : new SymbolDraw_default();
        this._isLargeDraw = isLargeDraw;
        this.group.removeAll();
      }
      this.group.add(symbolDraw.group);
      return symbolDraw;
    };
    ScatterView2.prototype.remove = function(ecModel, api) {
      this._symbolDraw && this._symbolDraw.remove(true);
      this._symbolDraw = null;
    };
    ScatterView2.prototype.dispose = function() {
    };
    ScatterView2.type = "scatter";
    return ScatterView2;
  }(Chart_default)
);
var ScatterView_default = ScatterView;

// ../../node_modules/.pnpm/echarts@6.0.0/node_modules/echarts/lib/util/jitter.js
function needFixJitter(seriesModel, axis) {
  var coordinateSystem = seriesModel.coordinateSystem;
  var coordType = coordinateSystem && coordinateSystem.type;
  var baseAxis = coordinateSystem && coordinateSystem.getBaseAxis && coordinateSystem.getBaseAxis();
  var scaleType = baseAxis && baseAxis.scale && baseAxis.scale.type;
  var seriesValid = coordType === "cartesian2d" && scaleType === "ordinal" || coordType === "single";
  var axisValid = axis.model.get("jitter") > 0;
  return seriesValid && axisValid;
}
var inner = makeInner();
function fixJitter(fixedAxis, fixedCoord, floatCoord, radius) {
  if (fixedAxis instanceof Axis2D_default) {
    var scaleType = fixedAxis.scale.type;
    if (scaleType !== "category" && scaleType !== "ordinal") {
      return floatCoord;
    }
  }
  var axisModel = fixedAxis.model;
  var jitter = axisModel.get("jitter");
  var jitterOverlap = axisModel.get("jitterOverlap");
  var jitterMargin = axisModel.get("jitterMargin") || 0;
  var bandWidth = fixedAxis.scale.type === "ordinal" ? fixedAxis.getBandWidth() : null;
  if (jitter > 0) {
    if (jitterOverlap) {
      return fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius);
    } else {
      return fixJitterAvoidOverlaps(fixedAxis, fixedCoord, floatCoord, radius, jitter, jitterMargin);
    }
  }
  return floatCoord;
}
function fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius) {
  if (bandWidth === null) {
    return floatCoord + (Math.random() - 0.5) * jitter;
  }
  var maxJitter = bandWidth - radius * 2;
  var actualJitter = Math.min(Math.max(0, jitter), maxJitter);
  return floatCoord + (Math.random() - 0.5) * actualJitter;
}
function fixJitterAvoidOverlaps(fixedAxis, fixedCoord, floatCoord, radius, jitter, margin) {
  var store = inner(fixedAxis);
  if (!store.items) {
    store.items = [];
  }
  var items = store.items;
  var overlapA = placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, 1);
  var overlapB = placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, -1);
  var minFloat = Math.abs(overlapA - floatCoord) < Math.abs(overlapB - floatCoord) ? overlapA : overlapB;
  var bandWidth = fixedAxis.scale.type === "ordinal" ? fixedAxis.getBandWidth() : null;
  var distance = Math.abs(minFloat - floatCoord);
  if (distance > jitter / 2 || bandWidth && distance > bandWidth / 2 - radius) {
    return fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius);
  }
  items.push({
    fixedCoord,
    floatCoord: minFloat,
    r: radius
  });
  return minFloat;
}
function placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, direction) {
  var y = floatCoord;
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var dx = fixedCoord - item.fixedCoord;
    var dy = y - item.floatCoord;
    var d2 = dx * dx + dy * dy;
    var r = radius + item.r + margin;
    if (d2 < r * r) {
      var requiredY = item.floatCoord + Math.sqrt(r * r - dx * dx) * direction;
      if (Math.abs(requiredY - floatCoord) > jitter / 2) {
        return Number.MAX_VALUE;
      }
      if (direction === 1 && requiredY > y || direction === -1 && requiredY < y) {
        y = requiredY;
        i = -1;
        continue;
      }
    }
  }
  return y;
}

// ../../node_modules/.pnpm/echarts@6.0.0/node_modules/echarts/lib/chart/scatter/jitterLayout.js
function jitterLayout(ecModel) {
  ecModel.eachSeriesByType("scatter", function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && (coordSys.type === "cartesian2d" || coordSys.type === "single")) {
      var baseAxis_1 = coordSys.getBaseAxis ? coordSys.getBaseAxis() : null;
      var hasJitter = baseAxis_1 && needFixJitter(seriesModel, baseAxis_1);
      if (hasJitter) {
        var data_1 = seriesModel.getData();
        data_1.each(function(idx) {
          var dim = baseAxis_1.dim;
          var orient = baseAxis_1.orient;
          var isSingleY = orient === "horizontal" && baseAxis_1.type !== "category" || orient === "vertical" && baseAxis_1.type === "category";
          var layout = data_1.getItemLayout(idx);
          var rawSize = data_1.getItemVisual(idx, "symbolSize");
          var size = rawSize instanceof Array ? (rawSize[1] + rawSize[0]) / 2 : rawSize;
          if (dim === "y" || dim === "single" && isSingleY) {
            var jittered = fixJitter(baseAxis_1, layout[0], layout[1], size / 2);
            data_1.setItemLayout(idx, [layout[0], jittered]);
          } else if (dim === "x" || dim === "single" && !isSingleY) {
            var jittered = fixJitter(baseAxis_1, layout[1], layout[0], size / 2);
            data_1.setItemLayout(idx, [jittered, layout[1]]);
          }
        });
      }
    }
  });
}

// ../../node_modules/.pnpm/echarts@6.0.0/node_modules/echarts/lib/chart/scatter/install.js
function install2(registers) {
  use(install);
  registers.registerSeriesModel(ScatterSeries_default);
  registers.registerChartView(ScatterView_default);
  registers.registerLayout(pointsLayout("scatter"));
}
function installScatterJitter(registers) {
  registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, jitterLayout);
}

export {
  pointsLayout,
  install2 as install,
  installScatterJitter
};
//# sourceMappingURL=chunk-LSWFKN55.js.map
