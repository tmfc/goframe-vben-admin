{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/@tanstack+store@0.8.0/node_modules/@tanstack/store/src/scheduler.ts", "../../../../../node_modules/.pnpm/@tanstack+store@0.8.0/node_modules/@tanstack/store/src/types.ts", "../../../../../node_modules/.pnpm/@tanstack+store@0.8.0/node_modules/@tanstack/store/src/store.ts", "../../../../../node_modules/.pnpm/@tanstack+store@0.8.0/node_modules/@tanstack/store/src/derived.ts", "../../../../../node_modules/.pnpm/@tanstack+store@0.8.0/node_modules/@tanstack/store/src/effect.ts", "../../../../../node_modules/.pnpm/@tanstack+vue-store@0.8.0_vue@3.5.24_typescript@5.9.3_/node_modules/@tanstack/vue-store/src/index.ts"],
  "sourcesContent": ["import type { Derived } from './derived'\nimport type { Store } from './store'\n\n/**\n * This is here to solve the pyramid dependency problem where:\n *       A\n *      / \\\n *     B   C\n *      \\ /\n *       D\n *\n * Where we deeply traverse this tree, how do we avoid D being recomputed twice; once when B is updated, once when C is.\n *\n * To solve this, we create linkedDeps that allows us to sync avoid writes to the state until all of the deps have been\n * resolved.\n *\n * This is a record of stores, because derived stores are not able to write values to, but stores are\n */\nexport const __storeToDerived = new WeakMap<\n  Store<unknown>,\n  Array<Derived<unknown>>\n>()\nexport const __derivedToStore = new WeakMap<\n  Derived<unknown>,\n  Set<Store<unknown>>\n>()\n\nexport const __depsThatHaveWrittenThisTick = {\n  current: [] as Array<Derived<unknown> | Store<unknown>>,\n}\n\nlet __isFlushing = false\nlet __batchDepth = 0\nconst __pendingUpdates = new Set<Store<unknown>>()\n// Add a map to store initial values before batch\nconst __initialBatchValues = new Map<Store<unknown>, unknown>()\n\nfunction __flush_internals(relatedVals: ReadonlyArray<Derived<unknown>>) {\n  for (const derived of relatedVals) {\n    if (__depsThatHaveWrittenThisTick.current.includes(derived)) {\n      continue\n    }\n\n    __depsThatHaveWrittenThisTick.current.push(derived)\n    derived.recompute()\n\n    const stores = __derivedToStore.get(derived)\n    if (stores) {\n      for (const store of stores) {\n        const relatedLinkedDerivedVals = __storeToDerived.get(store)\n        if (!relatedLinkedDerivedVals?.length) continue\n        __flush_internals(relatedLinkedDerivedVals)\n      }\n    }\n  }\n}\n\nfunction __notifyListeners(store: Store<unknown>) {\n  const value = {\n    prevVal: store.prevState as never,\n    currentVal: store.state as never,\n  }\n  for (const listener of store.listeners) {\n    listener(value)\n  }\n}\n\nfunction __notifyDerivedListeners(derived: Derived<unknown>) {\n  const value = {\n    prevVal: derived.prevState as never,\n    currentVal: derived.state as never,\n  }\n  for (const listener of derived.listeners) {\n    listener(value)\n  }\n}\n\n/**\n * @private only to be called from `Store` on write\n */\nexport function __flush(store: Store<unknown>) {\n  // If we're starting a batch, store the initial values\n  if (__batchDepth > 0 && !__initialBatchValues.has(store)) {\n    __initialBatchValues.set(store, store.prevState)\n  }\n\n  __pendingUpdates.add(store)\n\n  if (__batchDepth > 0) return\n  if (__isFlushing) return\n\n  try {\n    __isFlushing = true\n\n    while (__pendingUpdates.size > 0) {\n      const stores = Array.from(__pendingUpdates)\n      __pendingUpdates.clear()\n\n      // First notify listeners with updated values\n      for (const store of stores) {\n        // Use initial batch values for prevState if we have them\n        const prevState = __initialBatchValues.get(store) ?? store.prevState\n        store.prevState = prevState\n        __notifyListeners(store)\n      }\n\n      // Then update all derived values\n      for (const store of stores) {\n        const derivedVals = __storeToDerived.get(store)\n        if (!derivedVals) continue\n\n        __depsThatHaveWrittenThisTick.current.push(store)\n        __flush_internals(derivedVals)\n      }\n\n      // Notify derived listeners after recomputing\n      for (const store of stores) {\n        const derivedVals = __storeToDerived.get(store)\n        if (!derivedVals) continue\n\n        for (const derived of derivedVals) {\n          __notifyDerivedListeners(derived)\n        }\n      }\n    }\n  } finally {\n    __isFlushing = false\n    __depsThatHaveWrittenThisTick.current = []\n    __initialBatchValues.clear()\n  }\n}\n\nexport function batch(fn: () => void) {\n  __batchDepth++\n  try {\n    fn()\n  } finally {\n    __batchDepth--\n    if (__batchDepth === 0) {\n      const pendingUpdateToFlush = __pendingUpdates.values().next().value\n      if (pendingUpdateToFlush) {\n        __flush(pendingUpdateToFlush) // Trigger flush of all pending updates\n      }\n    }\n  }\n}\n", "/**\n * @private\n */\nexport type AnyUpdater = (prev: any) => any\n\n/**\n * Type-safe updater that can be either a function or direct value\n */\nexport type Updater<T> = ((prev: T) => T) | T\n\n/**\n * @private\n */\nexport interface ListenerValue<T> {\n  readonly prevVal: T\n  readonly currentVal: T\n}\n\n/**\n * @private\n */\nexport type Listener<T> = (value: ListenerValue<T>) => void\n\n/**\n * Type guard to check if updater is a function\n */\nexport function isUpdaterFunction<T>(\n  updater: Updater<T>,\n): updater is (prev: T) => T {\n  return typeof updater === 'function'\n}\n", "import { __flush } from './scheduler'\nimport { isUpdaterFunction } from './types'\nimport type { AnyUpdater, Listener, Updater } from './types'\n\nexport interface StoreOptions<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  /**\n   * Replace the default update function with a custom one.\n   */\n  updateFn?: (previous: TState) => (updater: TUpdater) => TState\n  /**\n   * Called when a listener subscribes to the store.\n   *\n   * @return a function to unsubscribe the listener\n   */\n  onSubscribe?: (\n    listener: Listener<TState>,\n    store: Store<TState, TUpdater>,\n  ) => () => void\n  /**\n   * Called after the state has been updated, used to derive other state.\n   */\n  onUpdate?: () => void\n}\n\nexport class Store<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  listeners = new Set<Listener<TState>>()\n  state: TState\n  prevState: TState\n  options?: StoreOptions<TState, TUpdater>\n\n  constructor(initialState: TState, options?: StoreOptions<TState, TUpdater>) {\n    this.prevState = initialState\n    this.state = initialState\n    this.options = options\n  }\n\n  subscribe = (listener: Listener<TState>) => {\n    this.listeners.add(listener)\n    const unsub = this.options?.onSubscribe?.(listener, this)\n    return () => {\n      this.listeners.delete(listener)\n      unsub?.()\n    }\n  }\n\n  /**\n   * Update the store state safely with improved type checking\n   */\n  setState(updater: (prevState: TState) => TState): void\n  setState(updater: TState): void\n  setState(updater: TUpdater): void\n  setState(updater: Updater<TState> | TUpdater): void {\n    this.prevState = this.state\n\n    if (this.options?.updateFn) {\n      this.state = this.options.updateFn(this.prevState)(updater as TUpdater)\n    } else {\n      if (isUpdaterFunction(updater)) {\n        this.state = updater(this.prevState)\n      } else {\n        this.state = updater as TState\n      }\n    }\n\n    // Always run onUpdate, regardless of batching\n    this.options?.onUpdate?.()\n\n    // Attempt to flush\n    __flush(this as never)\n  }\n}\n", "import { Store } from './store'\nimport { __derivedToStore, __storeToDerived } from './scheduler'\nimport type { Listener } from './types'\n\nexport type UnwrapDerivedOrStore<T> =\n  T extends Derived<infer InnerD>\n    ? InnerD\n    : T extends Store<infer InnerS>\n      ? InnerS\n      : never\n\ntype UnwrapReadonlyDerivedOrStoreArray<\n  TArr extends ReadonlyArray<Derived<any> | Store<any>>,\n> = TArr extends readonly []\n  ? []\n  : TArr extends readonly [infer Head, ...infer Tail]\n    ? Head extends Derived<any> | Store<any>\n      ? Tail extends ReadonlyArray<Derived<any> | Store<any>>\n        ? [\n            UnwrapDerivedOrStore<Head>,\n            ...UnwrapReadonlyDerivedOrStoreArray<Tail>,\n          ]\n        : [UnwrapDerivedOrStore<Head>]\n      : []\n    : TArr extends ReadonlyArray<Derived<any> | Store<any>>\n      ? Array<UnwrapDerivedOrStore<TArr[number]>>\n      : []\n\n// Can't have currVal, as it's being evaluated from the current derived fn\nexport interface DerivedFnProps<\n  TArr extends ReadonlyArray<Derived<any> | Store<any>> = ReadonlyArray<any>,\n  TUnwrappedArr extends\n    UnwrapReadonlyDerivedOrStoreArray<TArr> = UnwrapReadonlyDerivedOrStoreArray<TArr>,\n> {\n  // `undefined` if it's the first run\n  /**\n   * `undefined` if it's the first run\n   * @privateRemarks this also cannot be typed as TState, as it breaks the inferencing of the function's return type when an argument is used - even with `NoInfer` usage\n   */\n  prevVal: unknown | undefined\n  prevDepVals: TUnwrappedArr | undefined\n  currDepVals: TUnwrappedArr\n}\n\nexport interface DerivedOptions<\n  TState,\n  TArr extends ReadonlyArray<Derived<any> | Store<any>> = ReadonlyArray<any>,\n> {\n  onSubscribe?: (\n    listener: Listener<TState>,\n    derived: Derived<TState>,\n  ) => () => void\n  onUpdate?: () => void\n  deps: TArr\n  /**\n   * Values of the `deps` from before and after the current invocation of `fn`\n   */\n  fn: (props: DerivedFnProps<TArr>) => TState\n}\n\nexport class Derived<\n  TState,\n  const TArr extends ReadonlyArray<\n    Derived<any> | Store<any>\n  > = ReadonlyArray<any>,\n> {\n  listeners = new Set<Listener<TState>>()\n  state: TState\n  prevState: TState | undefined\n  options: DerivedOptions<TState, TArr>\n\n  /**\n   * Functions representing the subscriptions. Call a function to cleanup\n   * @private\n   */\n  _subscriptions: Array<() => void> = []\n\n  lastSeenDepValues: Array<unknown> = []\n  getDepVals = () => {\n    const l = this.options.deps.length\n    const prevDepVals = new Array<unknown>(l)\n    const currDepVals = new Array<unknown>(l)\n    for (let i = 0; i < l; i++) {\n      const dep = this.options.deps[i]!\n      prevDepVals[i] = dep.prevState\n      currDepVals[i] = dep.state\n    }\n    this.lastSeenDepValues = currDepVals\n    return {\n      prevDepVals,\n      currDepVals,\n      prevVal: this.prevState ?? undefined,\n    }\n  }\n\n  constructor(options: DerivedOptions<TState, TArr>) {\n    this.options = options\n    this.state = options.fn({\n      prevDepVals: undefined,\n      prevVal: undefined,\n      currDepVals: this.getDepVals().currDepVals as never,\n    })\n  }\n\n  registerOnGraph(\n    deps: ReadonlyArray<Derived<any> | Store<any>> = this.options.deps,\n  ) {\n    const toSort = new Set<Array<Derived<unknown>>>()\n    for (const dep of deps) {\n      if (dep instanceof Derived) {\n        // First register the intermediate derived value if it's not already registered\n        dep.registerOnGraph()\n        // Then register this derived with the dep's underlying stores\n        this.registerOnGraph(dep.options.deps)\n      } else if (dep instanceof Store) {\n        // Register the derived as related derived to the store\n        let relatedLinkedDerivedVals = __storeToDerived.get(dep)\n        if (!relatedLinkedDerivedVals) {\n          relatedLinkedDerivedVals = [this as never]\n          __storeToDerived.set(dep, relatedLinkedDerivedVals)\n        } else if (!relatedLinkedDerivedVals.includes(this as never)) {\n          relatedLinkedDerivedVals.push(this as never)\n          toSort.add(relatedLinkedDerivedVals)\n        }\n\n        // Register the store as a related store to this derived\n        let relatedStores = __derivedToStore.get(this as never)\n        if (!relatedStores) {\n          relatedStores = new Set()\n          __derivedToStore.set(this as never, relatedStores)\n        }\n        relatedStores.add(dep)\n      }\n    }\n    for (const arr of toSort) {\n      // First sort deriveds by dependency order\n      arr.sort((a, b) => {\n        // If a depends on b, b should go first\n        if (a instanceof Derived && a.options.deps.includes(b)) return 1\n        // If b depends on a, a should go first\n        if (b instanceof Derived && b.options.deps.includes(a)) return -1\n        return 0\n      })\n    }\n  }\n\n  unregisterFromGraph(\n    deps: ReadonlyArray<Derived<any> | Store<any>> = this.options.deps,\n  ) {\n    for (const dep of deps) {\n      if (dep instanceof Derived) {\n        this.unregisterFromGraph(dep.options.deps)\n      } else if (dep instanceof Store) {\n        const relatedLinkedDerivedVals = __storeToDerived.get(dep)\n        if (relatedLinkedDerivedVals) {\n          relatedLinkedDerivedVals.splice(\n            relatedLinkedDerivedVals.indexOf(this as never),\n            1,\n          )\n        }\n\n        const relatedStores = __derivedToStore.get(this as never)\n        if (relatedStores) {\n          relatedStores.delete(dep)\n        }\n      }\n    }\n  }\n\n  recompute = () => {\n    this.prevState = this.state\n    const depVals = this.getDepVals()\n    this.state = this.options.fn(depVals as never)\n\n    this.options.onUpdate?.()\n  }\n\n  checkIfRecalculationNeededDeeply = () => {\n    for (const dep of this.options.deps) {\n      if (dep instanceof Derived) {\n        dep.checkIfRecalculationNeededDeeply()\n      }\n    }\n    let shouldRecompute = false\n    const lastSeenDepValues = this.lastSeenDepValues\n    const { currDepVals } = this.getDepVals()\n    for (let i = 0; i < currDepVals.length; i++) {\n      if (currDepVals[i] !== lastSeenDepValues[i]) {\n        shouldRecompute = true\n        break\n      }\n    }\n\n    if (shouldRecompute) {\n      this.recompute()\n    }\n  }\n\n  mount = () => {\n    this.registerOnGraph()\n    this.checkIfRecalculationNeededDeeply()\n\n    return () => {\n      this.unregisterFromGraph()\n      for (const cleanup of this._subscriptions) {\n        cleanup()\n      }\n    }\n  }\n\n  subscribe = (listener: Listener<TState>) => {\n    this.listeners.add(listener)\n    const unsub = this.options.onSubscribe?.(listener, this)\n    return () => {\n      this.listeners.delete(listener)\n      unsub?.()\n    }\n  }\n}\n", "import { Derived } from './derived'\nimport type { DerivedOptions } from './derived'\n\ninterface EffectOptions\n  extends Omit<\n    DerivedOptions<unknown>,\n    'onUpdate' | 'onSubscribe' | 'lazy' | 'fn'\n  > {\n  /**\n   * Should the effect trigger immediately?\n   * @default false\n   */\n  eager?: boolean\n  fn: () => void\n}\n\nexport class Effect {\n  /**\n   * @private\n   */\n  _derived: Derived<void>\n\n  constructor(opts: EffectOptions) {\n    const { eager, fn, ...derivedProps } = opts\n\n    this._derived = new Derived({\n      ...derivedProps,\n      fn: () => {},\n      onUpdate() {\n        fn()\n      },\n    })\n\n    if (eager) {\n      fn()\n    }\n  }\n\n  mount() {\n    return this._derived.mount()\n  }\n}\n", "import { readonly, ref, toRaw, watch } from 'vue-demi'\nimport type { Derived, Store } from '@tanstack/store'\nimport type { Ref } from 'vue-demi'\n\nexport * from '@tanstack/store'\n\n/**\n * @private\n */\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\ntype EqualityFn<T> = (objA: T, objB: T) => boolean\ninterface UseStoreOptions<T> {\n  equal?: EqualityFn<T>\n}\n\nexport function useStore<TState, TSelected = NoInfer<TState>>(\n  store: Store<TState, any>,\n  selector?: (state: NoInfer<TState>) => TSelected,\n  options?: UseStoreOptions<TSelected>,\n): Readonly<Ref<TSelected>>\nexport function useStore<TState, TSelected = NoInfer<TState>>(\n  store: Derived<TState, any>,\n  selector?: (state: NoInfer<TState>) => TSelected,\n  options?: UseStoreOptions<TSelected>,\n): Readonly<Ref<TSelected>>\nexport function useStore<TState, TSelected = NoInfer<TState>>(\n  store: Store<TState, any> | Derived<TState, any>,\n  selector: (state: NoInfer<TState>) => TSelected = (d) => d as any,\n  options: UseStoreOptions<TSelected> = {},\n): Readonly<Ref<TSelected>> {\n  const slice = ref(selector(store.state)) as Ref<TSelected>\n  const equal = options.equal ?? shallow\n\n  watch(\n    () => store,\n    (value, _oldValue, onCleanup) => {\n      const unsub = value.subscribe(() => {\n        const data = selector(value.state)\n        if (equal(toRaw(slice.value), data)) {\n          return\n        }\n        slice.value = data\n      })\n\n      onCleanup(() => {\n        unsub()\n      })\n    },\n    { immediate: true },\n  )\n\n  return readonly(slice) as never\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false\n    for (const [k, v] of objA) {\n      if (!objB.has(k) || !Object.is(v, objB.get(k))) return false\n    }\n    return true\n  }\n\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false\n    for (const v of objA) {\n      if (!objB.has(v)) return false\n    }\n    return true\n  }\n\n  if (objA instanceof Date && objB instanceof Date) {\n    if (objA.getTime() !== objB.getTime()) return false\n    return true\n  }\n\n  const keysA = Object.keys(objA)\n  if (keysA.length !== Object.keys(objB).length) {\n    return false\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||\n      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n"],
  "mappings": ";;;;;;;;;;;;AAkBO,IAAM,mBAAA,oBAAuB,QAAA;AAI7B,IAAM,mBAAA,oBAAuB,QAAA;AAK7B,IAAM,gCAAgC;EAC3C,SAAS,CAAA;AACX;AAEA,IAAI,eAAe;AACnB,IAAI,eAAe;AACnB,IAAM,mBAAA,oBAAuB,IAAA;AAE7B,IAAM,uBAAA,oBAA2B,IAAA;AAEjC,SAAS,kBAAkB,aAA8C;AACvE,aAAW,WAAW,aAAa;AACjC,QAAI,8BAA8B,QAAQ,SAAS,OAAO,GAAG;AAC3D;IACF;AAEA,kCAA8B,QAAQ,KAAK,OAAO;AAClD,YAAQ,UAAA;AAER,UAAM,SAAS,iBAAiB,IAAI,OAAO;AAC3C,QAAI,QAAQ;AACV,iBAAW,SAAS,QAAQ;AAC1B,cAAM,2BAA2B,iBAAiB,IAAI,KAAK;AAC3D,YAAI,EAAC,4BAAA,OAAA,SAAA,yBAA0B,QAAQ;AACvC,0BAAkB,wBAAwB;MAC5C;IACF;EACF;AACF;AAEA,SAAS,kBAAkB,OAAuB;AAChD,QAAM,QAAQ;IACZ,SAAS,MAAM;IACf,YAAY,MAAM;EAAA;AAEpB,aAAW,YAAY,MAAM,WAAW;AACtC,aAAS,KAAK;EAChB;AACF;AAEA,SAAS,yBAAyB,SAA2B;AAC3D,QAAM,QAAQ;IACZ,SAAS,QAAQ;IACjB,YAAY,QAAQ;EAAA;AAEtB,aAAW,YAAY,QAAQ,WAAW;AACxC,aAAS,KAAK;EAChB;AACF;AAKO,SAAS,QAAQ,OAAuB;AAE7C,MAAI,eAAe,KAAK,CAAC,qBAAqB,IAAI,KAAK,GAAG;AACxD,yBAAqB,IAAI,OAAO,MAAM,SAAS;EACjD;AAEA,mBAAiB,IAAI,KAAK;AAE1B,MAAI,eAAe,EAAG;AACtB,MAAI,aAAc;AAElB,MAAI;AACF,mBAAe;AAEf,WAAO,iBAAiB,OAAO,GAAG;AAChC,YAAM,SAAS,MAAM,KAAK,gBAAgB;AAC1C,uBAAiB,MAAA;AAGjB,iBAAWA,UAAS,QAAQ;AAE1B,cAAM,YAAY,qBAAqB,IAAIA,MAAK,KAAKA,OAAM;AAC3DA,eAAM,YAAY;AAClB,0BAAkBA,MAAK;MACzB;AAGA,iBAAWA,UAAS,QAAQ;AAC1B,cAAM,cAAc,iBAAiB,IAAIA,MAAK;AAC9C,YAAI,CAAC,YAAa;AAElB,sCAA8B,QAAQ,KAAKA,MAAK;AAChD,0BAAkB,WAAW;MAC/B;AAGA,iBAAWA,UAAS,QAAQ;AAC1B,cAAM,cAAc,iBAAiB,IAAIA,MAAK;AAC9C,YAAI,CAAC,YAAa;AAElB,mBAAW,WAAW,aAAa;AACjC,mCAAyB,OAAO;QAClC;MACF;IACF;EACF,UAAA;AACE,mBAAe;AACf,kCAA8B,UAAU,CAAA;AACxC,yBAAqB,MAAA;EACvB;AACF;AAEO,SAAS,MAAM,IAAgB;AACpC;AACA,MAAI;AACF,OAAA;EACF,UAAA;AACE;AACA,QAAI,iBAAiB,GAAG;AACtB,YAAM,uBAAuB,iBAAiB,OAAA,EAAS,KAAA,EAAO;AAC9D,UAAI,sBAAsB;AACxB,gBAAQ,oBAAoB;MAC9B;IACF;EACF;AACF;;;ACvHO,SAAS,kBACd,SAC2B;AAC3B,SAAO,OAAO,YAAY;AAC5B;;;ACHO,IAAM,QAAN,MAGL;EAMA,YAAY,cAAsB,SAA0C;AAL5E,SAAA,YAAA,oBAAgB,IAAA;AAWhB,SAAA,YAAY,CAAC,aAA+B;;AAC1C,WAAK,UAAU,IAAI,QAAQ;AAC3B,YAAM,SAAQ,MAAA,KAAA,KAAK,YAAL,OAAA,SAAA,GAAc,gBAAd,OAAA,SAAA,GAAA,KAAA,IAA4B,UAAU,IAAA;AACpD,aAAO,MAAM;AACX,aAAK,UAAU,OAAO,QAAQ;AAC9B,iBAAA,OAAA,SAAA,MAAA;MACF;IACF;AAZE,SAAK,YAAY;AACjB,SAAK,QAAQ;AACb,SAAK,UAAU;EACjB;EAiBA,SAAS,SAA2C;;AAClD,SAAK,YAAY,KAAK;AAEtB,SAAI,KAAA,KAAK,YAAL,OAAA,SAAA,GAAc,UAAU;AAC1B,WAAK,QAAQ,KAAK,QAAQ,SAAS,KAAK,SAAS,EAAE,OAAmB;IACxE,OAAO;AACL,UAAI,kBAAkB,OAAO,GAAG;AAC9B,aAAK,QAAQ,QAAQ,KAAK,SAAS;MACrC,OAAO;AACL,aAAK,QAAQ;MACf;IACF;AAGA,KAAA,MAAA,KAAA,KAAK,YAAL,OAAA,SAAA,GAAc,aAAd,OAAA,SAAA,GAAA,KAAA,EAAA;AAGA,YAAQ,IAAa;EACvB;AACF;;;AChBO,IAAM,UAAN,MAAM,SAKX;EA8BA,YAAY,SAAuC;AA7BnD,SAAA,YAAA,oBAAgB,IAAA;AAShB,SAAA,iBAAoC,CAAA;AAEpC,SAAA,oBAAoC,CAAA;AACpC,SAAA,aAAa,MAAM;AACjB,YAAM,IAAI,KAAK,QAAQ,KAAK;AAC5B,YAAM,cAAc,IAAI,MAAe,CAAC;AACxC,YAAM,cAAc,IAAI,MAAe,CAAC;AACxC,eAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,cAAM,MAAM,KAAK,QAAQ,KAAK,CAAC;AAC/B,oBAAY,CAAC,IAAI,IAAI;AACrB,oBAAY,CAAC,IAAI,IAAI;MACvB;AACA,WAAK,oBAAoB;AACzB,aAAO;QACL;QACA;QACA,SAAS,KAAK,aAAa;MAAA;IAE/B;AA4EA,SAAA,YAAY,MAAM;;AAChB,WAAK,YAAY,KAAK;AACtB,YAAM,UAAU,KAAK,WAAA;AACrB,WAAK,QAAQ,KAAK,QAAQ,GAAG,OAAgB;AAE7C,OAAA,MAAA,KAAA,KAAK,SAAQ,aAAb,OAAA,SAAA,GAAA,KAAA,EAAA;IACF;AAEA,SAAA,mCAAmC,MAAM;AACvC,iBAAW,OAAO,KAAK,QAAQ,MAAM;AACnC,YAAI,eAAe,UAAS;AAC1B,cAAI,iCAAA;QACN;MACF;AACA,UAAI,kBAAkB;AACtB,YAAM,oBAAoB,KAAK;AAC/B,YAAM,EAAE,YAAA,IAAgB,KAAK,WAAA;AAC7B,eAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,YAAI,YAAY,CAAC,MAAM,kBAAkB,CAAC,GAAG;AAC3C,4BAAkB;AAClB;QACF;MACF;AAEA,UAAI,iBAAiB;AACnB,aAAK,UAAA;MACP;IACF;AAEA,SAAA,QAAQ,MAAM;AACZ,WAAK,gBAAA;AACL,WAAK,iCAAA;AAEL,aAAO,MAAM;AACX,aAAK,oBAAA;AACL,mBAAW,WAAW,KAAK,gBAAgB;AACzC,kBAAA;QACF;MACF;IACF;AAEA,SAAA,YAAY,CAAC,aAA+B;;AAC1C,WAAK,UAAU,IAAI,QAAQ;AAC3B,YAAM,SAAQ,MAAA,KAAA,KAAK,SAAQ,gBAAb,OAAA,SAAA,GAAA,KAAA,IAA2B,UAAU,IAAA;AACnD,aAAO,MAAM;AACX,aAAK,UAAU,OAAO,QAAQ;AAC9B,iBAAA,OAAA,SAAA,MAAA;MACF;IACF;AAzHE,SAAK,UAAU;AACf,SAAK,QAAQ,QAAQ,GAAG;MACtB,aAAa;MACb,SAAS;MACT,aAAa,KAAK,WAAA,EAAa;IAAA,CAChC;EACH;EAEA,gBACE,OAAiD,KAAK,QAAQ,MAC9D;AACA,UAAM,SAAA,oBAAa,IAAA;AACnB,eAAW,OAAO,MAAM;AACtB,UAAI,eAAe,UAAS;AAE1B,YAAI,gBAAA;AAEJ,aAAK,gBAAgB,IAAI,QAAQ,IAAI;MACvC,WAAW,eAAe,OAAO;AAE/B,YAAI,2BAA2B,iBAAiB,IAAI,GAAG;AACvD,YAAI,CAAC,0BAA0B;AAC7B,qCAA2B,CAAC,IAAa;AACzC,2BAAiB,IAAI,KAAK,wBAAwB;QACpD,WAAW,CAAC,yBAAyB,SAAS,IAAa,GAAG;AAC5D,mCAAyB,KAAK,IAAa;AAC3C,iBAAO,IAAI,wBAAwB;QACrC;AAGA,YAAI,gBAAgB,iBAAiB,IAAI,IAAa;AACtD,YAAI,CAAC,eAAe;AAClB,0BAAA,oBAAoB,IAAA;AACpB,2BAAiB,IAAI,MAAe,aAAa;QACnD;AACA,sBAAc,IAAI,GAAG;MACvB;IACF;AACA,eAAW,OAAO,QAAQ;AAExB,UAAI,KAAK,CAAC,GAAG,MAAM;AAEjB,YAAI,aAAa,YAAW,EAAE,QAAQ,KAAK,SAAS,CAAC,EAAG,QAAO;AAE/D,YAAI,aAAa,YAAW,EAAE,QAAQ,KAAK,SAAS,CAAC,EAAG,QAAO;AAC/D,eAAO;MACT,CAAC;IACH;EACF;EAEA,oBACE,OAAiD,KAAK,QAAQ,MAC9D;AACA,eAAW,OAAO,MAAM;AACtB,UAAI,eAAe,UAAS;AAC1B,aAAK,oBAAoB,IAAI,QAAQ,IAAI;MAC3C,WAAW,eAAe,OAAO;AAC/B,cAAM,2BAA2B,iBAAiB,IAAI,GAAG;AACzD,YAAI,0BAA0B;AAC5B,mCAAyB;YACvB,yBAAyB,QAAQ,IAAa;YAC9C;UAAA;QAEJ;AAEA,cAAM,gBAAgB,iBAAiB,IAAI,IAAa;AACxD,YAAI,eAAe;AACjB,wBAAc,OAAO,GAAG;QAC1B;MACF;IACF;EACF;AAmDF;;;AC1MO,IAAM,SAAN,MAAa;EAMlB,YAAY,MAAqB;AAC/B,UAAM,EAAE,OAAO,IAAI,GAAG,aAAA,IAAiB;AAEvC,SAAK,WAAW,IAAI,QAAQ;MAC1B,GAAG;MACH,IAAI,MAAM;MAAC;MACX,WAAW;AACT,WAAA;MACF;IAAA,CACD;AAED,QAAI,OAAO;AACT,SAAA;IACF;EACF;EAEA,QAAQ;AACN,WAAO,KAAK,SAAS,MAAA;EACvB;AACF;;;AChBO,SAAS,SACd,OACA,WAAkD,CAAC,MAAM,GACzD,UAAsC,CAAA,GACZ;AAC1B,QAAM,QAAQ,IAAI,SAAS,MAAM,KAAK,CAAC;AACvC,QAAM,QAAQ,QAAQ,SAAS;AAE/B;IACE,MAAM;IACN,CAAC,OAAO,WAAW,cAAc;AAC/B,YAAM,QAAQ,MAAM,UAAU,MAAM;AAClC,cAAM,OAAO,SAAS,MAAM,KAAK;AACjC,YAAI,MAAM,MAAM,MAAM,KAAK,GAAG,IAAI,GAAG;AACnC;QACF;AACA,cAAM,QAAQ;MAChB,CAAC;AAED,gBAAU,MAAM;AACd,cAAA;MACF,CAAC;IACH;IACA,EAAE,WAAW,KAAA;EAAK;AAGpB,SAAO,SAAS,KAAK;AACvB;AAEO,SAAS,QAAW,MAAS,MAAS;AAC3C,MAAI,OAAO,GAAG,MAAM,IAAI,GAAG;AACzB,WAAO;EACT;AAEA,MACE,OAAO,SAAS,YAChB,SAAS,QACT,OAAO,SAAS,YAChB,SAAS,MACT;AACA,WAAO;EACT;AAEA,MAAI,gBAAgB,OAAO,gBAAgB,KAAK;AAC9C,QAAI,KAAK,SAAS,KAAK,KAAM,QAAO;AACpC,eAAW,CAAC,GAAG,CAAC,KAAK,MAAM;AACzB,UAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,GAAG,KAAK,IAAI,CAAC,CAAC,EAAG,QAAO;IACzD;AACA,WAAO;EACT;AAEA,MAAI,gBAAgB,OAAO,gBAAgB,KAAK;AAC9C,QAAI,KAAK,SAAS,KAAK,KAAM,QAAO;AACpC,eAAW,KAAK,MAAM;AACpB,UAAI,CAAC,KAAK,IAAI,CAAC,EAAG,QAAO;IAC3B;AACA,WAAO;EACT;AAEA,MAAI,gBAAgB,QAAQ,gBAAgB,MAAM;AAChD,QAAI,KAAK,QAAA,MAAc,KAAK,QAAA,EAAW,QAAO;AAC9C,WAAO;EACT;AAEA,QAAM,QAAQ,OAAO,KAAK,IAAI;AAC9B,MAAI,MAAM,WAAW,OAAO,KAAK,IAAI,EAAE,QAAQ;AAC7C,WAAO;EACT;AAEA,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,QACE,CAAC,OAAO,UAAU,eAAe,KAAK,MAAM,MAAM,CAAC,CAAW,KAC9D,CAAC,OAAO,GAAG,KAAK,MAAM,CAAC,CAAY,GAAG,KAAK,MAAM,CAAC,CAAY,CAAC,GAC/D;AACA,aAAO;IACT;EACF;AACA,SAAO;AACT;",
  "names": ["store"]
}
