import {
  conductCheck,
  convertDataToEntities,
  useMaxLevel
} from "./chunk-NHZHZ6XE.js";
import {
  BaseSelect_default,
  baseSelectPropsWithoutPrivate,
  getIcons,
  style_default,
  useBaseProps,
  useId
} from "./chunk-GOWALUB4.js";
import {
  getStyle
} from "./chunk-JAVOCOCU.js";
import {
  getMergedStatus,
  getStatusClassNames
} from "./chunk-YLGUWWS4.js";
import {
  cloneElement
} from "./chunk-IKAOF4U6.js";
import {
  LoadingOutlined_default,
  useState
} from "./chunk-NXVP7DNM.js";
import {
  useCompactItemContext
} from "./chunk-RYPRWOE4.js";
import {
  genCompactItemStyle
} from "./chunk-YA73NSEU.js";
import {
  FormItemInputContext,
  useInjectFormItemContext
} from "./chunk-NDS5F2LZ.js";
import {
  devWarning_default
} from "./chunk-L6TGBB7Z.js";
import {
  LeftOutlined_default,
  RightOutlined_default
} from "./chunk-GFLU7AL6.js";
import {
  useMergedState
} from "./chunk-ZGKJV6XL.js";
import {
  omit_default
} from "./chunk-YRHJQYD4.js";
import {
  getTransitionDirection,
  getTransitionName
} from "./chunk-DE5RXXBR.js";
import {
  KeyCode_default
} from "./chunk-NETYDMDQ.js";
import {
  vue_types_default
} from "./chunk-CYXPT36C.js";
import {
  _objectSpread2,
  classNames_default,
  genComponentStyleHook,
  initDefaultProps_default,
  isValidElement,
  objectType,
  textEllipsis,
  useConfigInject_default,
  useInjectDisabled,
  warning,
  withInstall
} from "./chunk-JXH4FBKL.js";
import {
  _extends
} from "./chunk-4JQJ24TQ.js";
import {
  computed,
  createVNode,
  defineComponent,
  inject,
  onMounted,
  provide,
  ref,
  shallowRef,
  toRef,
  toRefs,
  watch,
  watchEffect
} from "./chunk-W3DDEFPZ.js";

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/utils/commonUtil.js
var VALUE_SPLIT = "__RC_CASCADER_SPLIT__";
var SHOW_PARENT = "SHOW_PARENT";
var SHOW_CHILD = "SHOW_CHILD";
function toPathKey(value) {
  return value.join(VALUE_SPLIT);
}
function toPathKeys(value) {
  return value.map(toPathKey);
}
function toPathValueStr(pathKey) {
  return pathKey.split(VALUE_SPLIT);
}
function fillFieldNames(fieldNames) {
  const {
    label,
    value,
    children
  } = fieldNames || {};
  const val = value || "value";
  return {
    label: label || "label",
    value: val,
    key: val,
    children: children || "children"
  };
}
function isLeaf(option, fieldNames) {
  var _a, _b;
  return (_a = option.isLeaf) !== null && _a !== void 0 ? _a : !((_b = option[fieldNames.children]) === null || _b === void 0 ? void 0 : _b.length);
}
function scrollIntoParentView(element) {
  const parent = element.parentElement;
  if (!parent) {
    return;
  }
  const elementToParent = element.offsetTop - parent.offsetTop;
  if (elementToParent - parent.scrollTop < 0) {
    parent.scrollTo({
      top: elementToParent
    });
  } else if (elementToParent + element.offsetHeight - parent.scrollTop > parent.offsetHeight) {
    parent.scrollTo({
      top: elementToParent + element.offsetHeight - parent.offsetHeight
    });
  }
}

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/hooks/useEntities.js
var useEntities_default = (options, fieldNames) => {
  const entities = computed(() => {
    return convertDataToEntities(options.value, {
      fieldNames: fieldNames.value,
      initWrapper: (wrapper) => _extends(_extends({}, wrapper), {
        pathKeyEntities: {}
      }),
      processEntity: (entity, wrapper) => {
        const pathKey = entity.nodes.map((node) => node[fieldNames.value.value]).join(VALUE_SPLIT);
        wrapper.pathKeyEntities[pathKey] = entity;
        entity.key = pathKey;
      }
    }).pathKeyEntities;
  });
  return entities;
};

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/hooks/useSearchConfig.js
function useSearchConfig(showSearch) {
  const mergedShowSearch = shallowRef(false);
  const mergedSearchConfig = ref({});
  watchEffect(() => {
    if (!showSearch.value) {
      mergedShowSearch.value = false;
      mergedSearchConfig.value = {};
      return;
    }
    let searchConfig = {
      matchInputWidth: true,
      limit: 50
    };
    if (showSearch.value && typeof showSearch.value === "object") {
      searchConfig = _extends(_extends({}, searchConfig), showSearch.value);
    }
    if (searchConfig.limit <= 0) {
      delete searchConfig.limit;
      if (true) {
        warning(false, "'limit' of showSearch should be positive number or false.");
      }
    }
    mergedShowSearch.value = true;
    mergedSearchConfig.value = searchConfig;
    return;
  });
  return {
    showSearch: mergedShowSearch,
    searchConfig: mergedSearchConfig
  };
}

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/hooks/useSearchOptions.js
var SEARCH_MARK = "__rc_cascader_search_mark__";
var defaultFilter = (search, options, _ref) => {
  let {
    label
  } = _ref;
  return options.some((opt) => String(opt[label]).toLowerCase().includes(search.toLowerCase()));
};
var defaultRender = (_ref2) => {
  let {
    path,
    fieldNames
  } = _ref2;
  return path.map((opt) => opt[fieldNames.label]).join(" / ");
};
var useSearchOptions_default = (search, options, fieldNames, prefixCls, config, changeOnSelect) => {
  return computed(() => {
    const {
      filter = defaultFilter,
      render = defaultRender,
      limit = 50,
      sort
    } = config.value;
    const filteredOptions = [];
    if (!search.value) {
      return [];
    }
    function dig(list, pathOptions) {
      list.forEach((option) => {
        if (!sort && limit > 0 && filteredOptions.length >= limit) {
          return;
        }
        const connectedPathOptions = [...pathOptions, option];
        const children = option[fieldNames.value.children];
        if (
          // If is leaf option
          !children || children.length === 0 || // If is changeOnSelect
          changeOnSelect.value
        ) {
          if (filter(search.value, connectedPathOptions, {
            label: fieldNames.value.label
          })) {
            filteredOptions.push(_extends(_extends({}, option), {
              [fieldNames.value.label]: render({
                inputValue: search.value,
                path: connectedPathOptions,
                prefixCls: prefixCls.value,
                fieldNames: fieldNames.value
              }),
              [SEARCH_MARK]: connectedPathOptions
            }));
          }
        }
        if (children) {
          dig(option[fieldNames.value.children], connectedPathOptions);
        }
      });
    }
    dig(options.value, []);
    if (sort) {
      filteredOptions.sort((a, b) => {
        return sort(a[SEARCH_MARK], b[SEARCH_MARK], search.value, fieldNames.value);
      });
    }
    return limit > 0 ? filteredOptions.slice(0, limit) : filteredOptions;
  });
};

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/utils/treeUtil.js
function formatStrategyValues(pathKeys, keyPathEntities, showCheckedStrategy) {
  const valueSet = new Set(pathKeys);
  return pathKeys.filter((key) => {
    const entity = keyPathEntities[key];
    const parent = entity ? entity.parent : null;
    const children = entity ? entity.children : null;
    return showCheckedStrategy === SHOW_CHILD ? !(children && children.some((child) => child.key && valueSet.has(child.key))) : !(parent && !parent.node.disabled && valueSet.has(parent.key));
  });
}
function toPathOptions(valueCells, options, fieldNames) {
  let stringMode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var _a;
  let currentList = options;
  const valueOptions = [];
  for (let i = 0; i < valueCells.length; i += 1) {
    const valueCell = valueCells[i];
    const foundIndex = currentList === null || currentList === void 0 ? void 0 : currentList.findIndex((option) => {
      const val = option[fieldNames.value];
      return stringMode ? String(val) === String(valueCell) : val === valueCell;
    });
    const foundOption = foundIndex !== -1 ? currentList === null || currentList === void 0 ? void 0 : currentList[foundIndex] : null;
    valueOptions.push({
      value: (_a = foundOption === null || foundOption === void 0 ? void 0 : foundOption[fieldNames.value]) !== null && _a !== void 0 ? _a : valueCell,
      index: foundIndex,
      option: foundOption
    });
    currentList = foundOption === null || foundOption === void 0 ? void 0 : foundOption[fieldNames.children];
  }
  return valueOptions;
}

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/hooks/useMissingValues.js
var useMissingValues_default = (options, fieldNames, rawValues) => {
  return computed(() => {
    const missingValues = [];
    const existsValues = [];
    rawValues.value.forEach((valueCell) => {
      const pathOptions = toPathOptions(valueCell, options.value, fieldNames.value);
      if (pathOptions.every((opt) => opt.option)) {
        existsValues.push(valueCell);
      } else {
        missingValues.push(valueCell);
      }
    });
    return [existsValues, missingValues];
  });
};

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/hooks/useDisplayValues.js
var useDisplayValues_default = (rawValues, options, fieldNames, multiple, displayRender) => {
  return computed(() => {
    const mergedDisplayRender = displayRender.value || // Default displayRender
    ((_ref) => {
      let {
        labels
      } = _ref;
      const mergedLabels = multiple.value ? labels.slice(-1) : labels;
      const SPLIT = " / ";
      if (mergedLabels.every((label) => ["string", "number"].includes(typeof label))) {
        return mergedLabels.join(SPLIT);
      }
      return mergedLabels.reduce((list, label, index) => {
        const keyedLabel = isValidElement(label) ? cloneElement(label, {
          key: index
        }) : label;
        if (index === 0) {
          return [keyedLabel];
        }
        return [...list, SPLIT, keyedLabel];
      }, []);
    });
    return rawValues.value.map((valueCells) => {
      const valueOptions = toPathOptions(valueCells, options.value, fieldNames.value);
      const label = mergedDisplayRender({
        labels: valueOptions.map((_ref2) => {
          let {
            option,
            value: value2
          } = _ref2;
          var _a;
          return (_a = option === null || option === void 0 ? void 0 : option[fieldNames.value.label]) !== null && _a !== void 0 ? _a : value2;
        }),
        selectedOptions: valueOptions.map((_ref3) => {
          let {
            option
          } = _ref3;
          return option;
        })
      });
      const value = toPathKey(valueCells);
      return {
        label,
        value,
        key: value,
        valueCells
      };
    });
  });
};

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/context.js
var CascaderContextKey = Symbol("CascaderContextKey");
var useProvideCascader = (props) => {
  provide(CascaderContextKey, props);
};
var useInjectCascader = () => {
  return inject(CascaderContextKey);
};

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/OptionList/useActive.js
var useActive_default = () => {
  const baseProps = useBaseProps();
  const {
    values
  } = useInjectCascader();
  const [activeValueCells, setActiveValueCells] = useState([]);
  watch(() => baseProps.open, () => {
    if (baseProps.open && !baseProps.multiple) {
      const firstValueCells = values.value[0];
      setActiveValueCells(firstValueCells || []);
    }
  }, {
    immediate: true
  });
  return [activeValueCells, setActiveValueCells];
};

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/OptionList/useKeyboard.js
var useKeyboard_default = (context, options, fieldNames, activeValueCells, setActiveValueCells, onKeyBoardSelect) => {
  const baseProps = useBaseProps();
  const rtl = computed(() => baseProps.direction === "rtl");
  const [validActiveValueCells, lastActiveIndex, lastActiveOptions] = [ref([]), ref(), ref([])];
  watchEffect(() => {
    let activeIndex = -1;
    let currentOptions = options.value;
    const mergedActiveIndexes = [];
    const mergedActiveValueCells = [];
    const len = activeValueCells.value.length;
    for (let i = 0; i < len && currentOptions; i += 1) {
      const nextActiveIndex = currentOptions.findIndex((option) => option[fieldNames.value.value] === activeValueCells.value[i]);
      if (nextActiveIndex === -1) {
        break;
      }
      activeIndex = nextActiveIndex;
      mergedActiveIndexes.push(activeIndex);
      mergedActiveValueCells.push(activeValueCells.value[i]);
      currentOptions = currentOptions[activeIndex][fieldNames.value.children];
    }
    let activeOptions = options.value;
    for (let i = 0; i < mergedActiveIndexes.length - 1; i += 1) {
      activeOptions = activeOptions[mergedActiveIndexes[i]][fieldNames.value.children];
    }
    [validActiveValueCells.value, lastActiveIndex.value, lastActiveOptions.value] = [mergedActiveValueCells, activeIndex, activeOptions];
  });
  const internalSetActiveValueCells = (next) => {
    setActiveValueCells(next);
  };
  const offsetActiveOption = (offset) => {
    const len = lastActiveOptions.value.length;
    let currentIndex = lastActiveIndex.value;
    if (currentIndex === -1 && offset < 0) {
      currentIndex = len;
    }
    for (let i = 0; i < len; i += 1) {
      currentIndex = (currentIndex + offset + len) % len;
      const option = lastActiveOptions.value[currentIndex];
      if (option && !option.disabled) {
        const value = option[fieldNames.value.value];
        const nextActiveCells = validActiveValueCells.value.slice(0, -1).concat(value);
        internalSetActiveValueCells(nextActiveCells);
        return;
      }
    }
  };
  const prevColumn = () => {
    if (validActiveValueCells.value.length > 1) {
      const nextActiveCells = validActiveValueCells.value.slice(0, -1);
      internalSetActiveValueCells(nextActiveCells);
    } else {
      baseProps.toggleOpen(false);
    }
  };
  const nextColumn = () => {
    var _a;
    const nextOptions = ((_a = lastActiveOptions.value[lastActiveIndex.value]) === null || _a === void 0 ? void 0 : _a[fieldNames.value.children]) || [];
    const nextOption = nextOptions.find((option) => !option.disabled);
    if (nextOption) {
      const nextActiveCells = [...validActiveValueCells.value, nextOption[fieldNames.value.value]];
      internalSetActiveValueCells(nextActiveCells);
    }
  };
  context.expose({
    // scrollTo: treeRef.current?.scrollTo,
    onKeydown: (event) => {
      const {
        which
      } = event;
      switch (which) {
        // >>> Arrow keys
        case KeyCode_default.UP:
        case KeyCode_default.DOWN: {
          let offset = 0;
          if (which === KeyCode_default.UP) {
            offset = -1;
          } else if (which === KeyCode_default.DOWN) {
            offset = 1;
          }
          if (offset !== 0) {
            offsetActiveOption(offset);
          }
          break;
        }
        case KeyCode_default.LEFT: {
          if (rtl.value) {
            nextColumn();
          } else {
            prevColumn();
          }
          break;
        }
        case KeyCode_default.RIGHT: {
          if (rtl.value) {
            prevColumn();
          } else {
            nextColumn();
          }
          break;
        }
        case KeyCode_default.BACKSPACE: {
          if (!baseProps.searchValue) {
            prevColumn();
          }
          break;
        }
        // >>> Select
        case KeyCode_default.ENTER: {
          if (validActiveValueCells.value.length) {
            const option = lastActiveOptions.value[lastActiveIndex.value];
            const originOptions = (option === null || option === void 0 ? void 0 : option[SEARCH_MARK]) || [];
            if (originOptions.length) {
              onKeyBoardSelect(originOptions.map((opt) => opt[fieldNames.value.value]), originOptions[originOptions.length - 1]);
            } else {
              onKeyBoardSelect(validActiveValueCells.value, option);
            }
          }
          break;
        }
        // >>> Close
        case KeyCode_default.ESC: {
          baseProps.toggleOpen(false);
          if (open) {
            event.stopPropagation();
          }
        }
      }
    },
    onKeyup: () => {
    }
  });
};

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/OptionList/Checkbox.js
function Checkbox(_ref) {
  let {
    prefixCls,
    checked,
    halfChecked,
    disabled,
    onClick
  } = _ref;
  const {
    customSlots,
    checkable
  } = useInjectCascader();
  const mergedCheckable = checkable.value !== false ? customSlots.value.checkable : checkable.value;
  const customCheckbox = typeof mergedCheckable === "function" ? mergedCheckable() : typeof mergedCheckable === "boolean" ? null : mergedCheckable;
  return createVNode("span", {
    "class": {
      [prefixCls]: true,
      [`${prefixCls}-checked`]: checked,
      [`${prefixCls}-indeterminate`]: !checked && halfChecked,
      [`${prefixCls}-disabled`]: disabled
    },
    "onClick": onClick
  }, [customCheckbox]);
}
Checkbox.props = ["prefixCls", "checked", "halfChecked", "disabled", "onClick"];
Checkbox.displayName = "Checkbox";
Checkbox.inheritAttrs = false;

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/OptionList/Column.js
var FIX_LABEL = "__cascader_fix_label__";
function Column(_ref) {
  let {
    prefixCls,
    multiple,
    options,
    activeValue,
    prevValuePath,
    onToggleOpen,
    onSelect,
    onActive,
    checkedSet,
    halfCheckedSet,
    loadingKeys,
    isSelectable
  } = _ref;
  var _a, _b, _c, _d, _e, _f;
  const menuPrefixCls = `${prefixCls}-menu`;
  const menuItemPrefixCls = `${prefixCls}-menu-item`;
  const {
    fieldNames,
    changeOnSelect,
    expandTrigger,
    expandIcon: expandIconRef,
    loadingIcon: loadingIconRef,
    dropdownMenuColumnStyle,
    customSlots
  } = useInjectCascader();
  const expandIcon = (_a = expandIconRef.value) !== null && _a !== void 0 ? _a : (_c = (_b = customSlots.value).expandIcon) === null || _c === void 0 ? void 0 : _c.call(_b);
  const loadingIcon = (_d = loadingIconRef.value) !== null && _d !== void 0 ? _d : (_f = (_e = customSlots.value).loadingIcon) === null || _f === void 0 ? void 0 : _f.call(_e);
  const hoverOpen = expandTrigger.value === "hover";
  return createVNode("ul", {
    "class": menuPrefixCls,
    "role": "menu"
  }, [options.map((option) => {
    var _a2;
    const {
      disabled
    } = option;
    const searchOptions = option[SEARCH_MARK];
    const label = (_a2 = option[FIX_LABEL]) !== null && _a2 !== void 0 ? _a2 : option[fieldNames.value.label];
    const value = option[fieldNames.value.value];
    const isMergedLeaf = isLeaf(option, fieldNames.value);
    const fullPath = searchOptions ? searchOptions.map((opt) => opt[fieldNames.value.value]) : [...prevValuePath, value];
    const fullPathKey = toPathKey(fullPath);
    const isLoading = loadingKeys.includes(fullPathKey);
    const checked = checkedSet.has(fullPathKey);
    const halfChecked = halfCheckedSet.has(fullPathKey);
    const triggerOpenPath = () => {
      if (!disabled && (!hoverOpen || !isMergedLeaf)) {
        onActive(fullPath);
      }
    };
    const triggerSelect = () => {
      if (isSelectable(option)) {
        onSelect(fullPath, isMergedLeaf);
      }
    };
    let title;
    if (typeof option.title === "string") {
      title = option.title;
    } else if (typeof label === "string") {
      title = label;
    }
    return createVNode("li", {
      "key": fullPathKey,
      "class": [menuItemPrefixCls, {
        [`${menuItemPrefixCls}-expand`]: !isMergedLeaf,
        [`${menuItemPrefixCls}-active`]: activeValue === value,
        [`${menuItemPrefixCls}-disabled`]: disabled,
        [`${menuItemPrefixCls}-loading`]: isLoading
      }],
      "style": dropdownMenuColumnStyle.value,
      "role": "menuitemcheckbox",
      "title": title,
      "aria-checked": checked,
      "data-path-key": fullPathKey,
      "onClick": () => {
        triggerOpenPath();
        if (!multiple || isMergedLeaf) {
          triggerSelect();
        }
      },
      "onDblclick": () => {
        if (changeOnSelect.value) {
          onToggleOpen(false);
        }
      },
      "onMouseenter": () => {
        if (hoverOpen) {
          triggerOpenPath();
        }
      },
      "onMousedown": (e) => {
        e.preventDefault();
      }
    }, [multiple && createVNode(Checkbox, {
      "prefixCls": `${prefixCls}-checkbox`,
      "checked": checked,
      "halfChecked": halfChecked,
      "disabled": disabled,
      "onClick": (e) => {
        e.stopPropagation();
        triggerSelect();
      }
    }, null), createVNode("div", {
      "class": `${menuItemPrefixCls}-content`
    }, [label]), !isLoading && expandIcon && !isMergedLeaf && createVNode("div", {
      "class": `${menuItemPrefixCls}-expand-icon`
    }, [cloneElement(expandIcon)]), isLoading && loadingIcon && createVNode("div", {
      "class": `${menuItemPrefixCls}-loading-icon`
    }, [cloneElement(loadingIcon)])]);
  })]);
}
Column.props = ["prefixCls", "multiple", "options", "activeValue", "prevValuePath", "onToggleOpen", "onSelect", "onActive", "checkedSet", "halfCheckedSet", "loadingKeys", "isSelectable"];
Column.displayName = "Column";
Column.inheritAttrs = false;

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/OptionList/index.js
var OptionList_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: false,
  setup(_props, context) {
    const {
      attrs,
      slots
    } = context;
    const baseProps = useBaseProps();
    const containerRef = ref();
    const rtl = computed(() => baseProps.direction === "rtl");
    const {
      options,
      values,
      halfValues,
      fieldNames,
      changeOnSelect,
      onSelect,
      searchOptions,
      dropdownPrefixCls,
      loadData,
      expandTrigger,
      customSlots
    } = useInjectCascader();
    const mergedPrefixCls = computed(() => dropdownPrefixCls.value || baseProps.prefixCls);
    const loadingKeys = shallowRef([]);
    const internalLoadData = (valueCells) => {
      if (!loadData.value || baseProps.searchValue) {
        return;
      }
      const optionList = toPathOptions(valueCells, options.value, fieldNames.value);
      const rawOptions = optionList.map((_ref) => {
        let {
          option
        } = _ref;
        return option;
      });
      const lastOption = rawOptions[rawOptions.length - 1];
      if (lastOption && !isLeaf(lastOption, fieldNames.value)) {
        const pathKey = toPathKey(valueCells);
        loadingKeys.value = [...loadingKeys.value, pathKey];
        loadData.value(rawOptions);
      }
    };
    watchEffect(() => {
      if (loadingKeys.value.length) {
        loadingKeys.value.forEach((loadingKey) => {
          const valueStrCells = toPathValueStr(loadingKey);
          const optionList = toPathOptions(valueStrCells, options.value, fieldNames.value, true).map((_ref2) => {
            let {
              option
            } = _ref2;
            return option;
          });
          const lastOption = optionList[optionList.length - 1];
          if (!lastOption || lastOption[fieldNames.value.children] || isLeaf(lastOption, fieldNames.value)) {
            loadingKeys.value = loadingKeys.value.filter((key) => key !== loadingKey);
          }
        });
      }
    });
    const checkedSet = computed(() => new Set(toPathKeys(values.value)));
    const halfCheckedSet = computed(() => new Set(toPathKeys(halfValues.value)));
    const [activeValueCells, setActiveValueCells] = useActive_default();
    const onPathOpen = (nextValueCells) => {
      setActiveValueCells(nextValueCells);
      internalLoadData(nextValueCells);
    };
    const isSelectable = (option) => {
      const {
        disabled
      } = option;
      const isMergedLeaf = isLeaf(option, fieldNames.value);
      return !disabled && (isMergedLeaf || changeOnSelect.value || baseProps.multiple);
    };
    const onPathSelect = function(valuePath, leaf) {
      let fromKeyboard = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      onSelect(valuePath);
      if (!baseProps.multiple && (leaf || changeOnSelect.value && (expandTrigger.value === "hover" || fromKeyboard))) {
        baseProps.toggleOpen(false);
      }
    };
    const mergedOptions = computed(() => {
      if (baseProps.searchValue) {
        return searchOptions.value;
      }
      return options.value;
    });
    const optionColumns = computed(() => {
      const optionList = [{
        options: mergedOptions.value
      }];
      let currentList = mergedOptions.value;
      for (let i = 0; i < activeValueCells.value.length; i += 1) {
        const activeValueCell = activeValueCells.value[i];
        const currentOption = currentList.find((option) => option[fieldNames.value.value] === activeValueCell);
        const subOptions = currentOption === null || currentOption === void 0 ? void 0 : currentOption[fieldNames.value.children];
        if (!(subOptions === null || subOptions === void 0 ? void 0 : subOptions.length)) {
          break;
        }
        currentList = subOptions;
        optionList.push({
          options: subOptions
        });
      }
      return optionList;
    });
    const onKeyboardSelect = (selectValueCells, option) => {
      if (isSelectable(option)) {
        onPathSelect(selectValueCells, isLeaf(option, fieldNames.value), true);
      }
    };
    useKeyboard_default(context, mergedOptions, fieldNames, activeValueCells, onPathOpen, onKeyboardSelect);
    const onListMouseDown = (event) => {
      event.preventDefault();
    };
    onMounted(() => {
      watch(activeValueCells, (cells) => {
        var _a;
        for (let i = 0; i < cells.length; i += 1) {
          const cellPath = cells.slice(0, i + 1);
          const cellKeyPath = toPathKey(cellPath);
          const ele = (_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.querySelector(`li[data-path-key="${cellKeyPath.replace(/\\{0,2}"/g, '\\"')}"]`);
          if (ele) {
            scrollIntoParentView(ele);
          }
        }
      }, {
        flush: "post",
        immediate: true
      });
    });
    return () => {
      var _a, _b, _c, _d, _e;
      const {
        notFoundContent = ((_a = slots.notFoundContent) === null || _a === void 0 ? void 0 : _a.call(slots)) || ((_c = (_b = customSlots.value).notFoundContent) === null || _c === void 0 ? void 0 : _c.call(_b)),
        multiple,
        toggleOpen
      } = baseProps;
      const isEmpty = !((_e = (_d = optionColumns.value[0]) === null || _d === void 0 ? void 0 : _d.options) === null || _e === void 0 ? void 0 : _e.length);
      const emptyList = [{
        [fieldNames.value.value]: "__EMPTY__",
        [FIX_LABEL]: notFoundContent,
        disabled: true
      }];
      const columnProps = _extends(_extends({}, attrs), {
        multiple: !isEmpty && multiple,
        onSelect: onPathSelect,
        onActive: onPathOpen,
        onToggleOpen: toggleOpen,
        checkedSet: checkedSet.value,
        halfCheckedSet: halfCheckedSet.value,
        loadingKeys: loadingKeys.value,
        isSelectable
      });
      const mergedOptionColumns = isEmpty ? [{
        options: emptyList
      }] : optionColumns.value;
      const columnNodes = mergedOptionColumns.map((col, index) => {
        const prevValuePath = activeValueCells.value.slice(0, index);
        const activeValue = activeValueCells.value[index];
        return createVNode(Column, _objectSpread2(_objectSpread2({
          "key": index
        }, columnProps), {}, {
          "prefixCls": mergedPrefixCls.value,
          "options": col.options,
          "prevValuePath": prevValuePath,
          "activeValue": activeValue
        }), null);
      });
      return createVNode("div", {
        "class": [`${mergedPrefixCls.value}-menus`, {
          [`${mergedPrefixCls.value}-menu-empty`]: isEmpty,
          [`${mergedPrefixCls.value}-rtl`]: rtl.value
        }],
        "onMousedown": onListMouseDown,
        "ref": containerRef
      }, [columnNodes]);
    };
  }
});

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/Cascader.js
function baseCascaderProps() {
  return _extends(_extends({}, omit_default(baseSelectPropsWithoutPrivate(), ["tokenSeparators", "mode", "showSearch"])), {
    // MISC
    id: String,
    prefixCls: String,
    fieldNames: objectType(),
    children: Array,
    // Value
    value: {
      type: [String, Number, Array]
    },
    defaultValue: {
      type: [String, Number, Array]
    },
    changeOnSelect: {
      type: Boolean,
      default: void 0
    },
    displayRender: Function,
    checkable: {
      type: Boolean,
      default: void 0
    },
    showCheckedStrategy: {
      type: String,
      default: SHOW_PARENT
    },
    // Search
    showSearch: {
      type: [Boolean, Object],
      default: void 0
    },
    searchValue: String,
    onSearch: Function,
    // Trigger
    expandTrigger: String,
    // Options
    options: Array,
    /** @private Internal usage. Do not use in your production. */
    dropdownPrefixCls: String,
    loadData: Function,
    // Open
    /** @deprecated Use `open` instead */
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    dropdownClassName: String,
    dropdownMenuColumnStyle: {
      type: Object,
      default: void 0
    },
    /** @deprecated Use `dropdownStyle` instead */
    popupStyle: {
      type: Object,
      default: void 0
    },
    dropdownStyle: {
      type: Object,
      default: void 0
    },
    /** @deprecated Use `placement` instead */
    popupPlacement: String,
    placement: String,
    /** @deprecated Use `onDropdownVisibleChange` instead */
    onPopupVisibleChange: Function,
    onDropdownVisibleChange: Function,
    // Icon
    expandIcon: vue_types_default.any,
    loadingIcon: vue_types_default.any
  });
}
function internalCascaderProps() {
  return _extends(_extends({}, baseCascaderProps()), {
    onChange: Function,
    customSlots: Object
  });
}
function isMultipleValue(value) {
  return Array.isArray(value) && Array.isArray(value[0]);
}
function toRawValues(value) {
  if (!value) {
    return [];
  }
  if (isMultipleValue(value)) {
    return value;
  }
  return (value.length === 0 ? [] : [value]).map((val) => Array.isArray(val) ? val : [val]);
}
var Cascader_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Cascader",
  inheritAttrs: false,
  props: initDefaultProps_default(internalCascaderProps(), {}),
  setup(props, _ref) {
    let {
      attrs,
      expose,
      slots
    } = _ref;
    const mergedId = useId(toRef(props, "id"));
    const multiple = computed(() => !!props.checkable);
    const [rawValues, setRawValues] = useMergedState(props.defaultValue, {
      value: computed(() => props.value),
      postState: toRawValues
    });
    const mergedFieldNames = computed(() => fillFieldNames(props.fieldNames));
    const mergedOptions = computed(() => props.options || []);
    const pathKeyEntities = useEntities_default(mergedOptions, mergedFieldNames);
    const getValueByKeyPath = (pathKeys) => {
      const keyPathEntities = pathKeyEntities.value;
      return pathKeys.map((pathKey) => {
        const {
          nodes
        } = keyPathEntities[pathKey];
        return nodes.map((node) => node[mergedFieldNames.value.value]);
      });
    };
    const [mergedSearchValue, setSearchValue] = useMergedState("", {
      value: computed(() => props.searchValue),
      postState: (search) => search || ""
    });
    const onInternalSearch = (searchText, info) => {
      setSearchValue(searchText);
      if (info.source !== "blur" && props.onSearch) {
        props.onSearch(searchText);
      }
    };
    const {
      showSearch: mergedShowSearch,
      searchConfig: mergedSearchConfig
    } = useSearchConfig(toRef(props, "showSearch"));
    const searchOptions = useSearchOptions_default(mergedSearchValue, mergedOptions, mergedFieldNames, computed(() => props.dropdownPrefixCls || props.prefixCls), mergedSearchConfig, toRef(props, "changeOnSelect"));
    const missingValuesInfo = useMissingValues_default(mergedOptions, mergedFieldNames, rawValues);
    const [checkedValues, halfCheckedValues, missingCheckedValues] = [ref([]), ref([]), ref([])];
    const {
      maxLevel,
      levelEntities
    } = useMaxLevel(pathKeyEntities);
    watchEffect(() => {
      const [existValues, missingValues] = missingValuesInfo.value;
      if (!multiple.value || !rawValues.value.length) {
        [checkedValues.value, halfCheckedValues.value, missingCheckedValues.value] = [existValues, [], missingValues];
        return;
      }
      const keyPathValues = toPathKeys(existValues);
      const keyPathEntities = pathKeyEntities.value;
      const {
        checkedKeys,
        halfCheckedKeys
      } = conductCheck(keyPathValues, true, keyPathEntities, maxLevel.value, levelEntities.value);
      [checkedValues.value, halfCheckedValues.value, missingCheckedValues.value] = [getValueByKeyPath(checkedKeys), getValueByKeyPath(halfCheckedKeys), missingValues];
    });
    const deDuplicatedValues = computed(() => {
      const checkedKeys = toPathKeys(checkedValues.value);
      const deduplicateKeys = formatStrategyValues(checkedKeys, pathKeyEntities.value, props.showCheckedStrategy);
      return [...missingCheckedValues.value, ...getValueByKeyPath(deduplicateKeys)];
    });
    const displayValues = useDisplayValues_default(deDuplicatedValues, mergedOptions, mergedFieldNames, multiple, toRef(props, "displayRender"));
    const triggerChange = (nextValues) => {
      setRawValues(nextValues);
      if (props.onChange) {
        const nextRawValues = toRawValues(nextValues);
        const valueOptions = nextRawValues.map((valueCells) => toPathOptions(valueCells, mergedOptions.value, mergedFieldNames.value).map((valueOpt) => valueOpt.option));
        const triggerValues = multiple.value ? nextRawValues : nextRawValues[0];
        const triggerOptions = multiple.value ? valueOptions : valueOptions[0];
        props.onChange(triggerValues, triggerOptions);
      }
    };
    const onInternalSelect = (valuePath) => {
      setSearchValue("");
      if (!multiple.value) {
        triggerChange(valuePath);
      } else {
        const pathKey = toPathKey(valuePath);
        const checkedPathKeys = toPathKeys(checkedValues.value);
        const halfCheckedPathKeys = toPathKeys(halfCheckedValues.value);
        const existInChecked = checkedPathKeys.includes(pathKey);
        const existInMissing = missingCheckedValues.value.some((valueCells) => toPathKey(valueCells) === pathKey);
        let nextCheckedValues = checkedValues.value;
        let nextMissingValues = missingCheckedValues.value;
        if (existInMissing && !existInChecked) {
          nextMissingValues = missingCheckedValues.value.filter((valueCells) => toPathKey(valueCells) !== pathKey);
        } else {
          const nextRawCheckedKeys = existInChecked ? checkedPathKeys.filter((key) => key !== pathKey) : [...checkedPathKeys, pathKey];
          let checkedKeys;
          if (existInChecked) {
            ({
              checkedKeys
            } = conductCheck(nextRawCheckedKeys, {
              checked: false,
              halfCheckedKeys: halfCheckedPathKeys
            }, pathKeyEntities.value, maxLevel.value, levelEntities.value));
          } else {
            ({
              checkedKeys
            } = conductCheck(nextRawCheckedKeys, true, pathKeyEntities.value, maxLevel.value, levelEntities.value));
          }
          const deDuplicatedKeys = formatStrategyValues(checkedKeys, pathKeyEntities.value, props.showCheckedStrategy);
          nextCheckedValues = getValueByKeyPath(deDuplicatedKeys);
        }
        triggerChange([...nextMissingValues, ...nextCheckedValues]);
      }
    };
    const onDisplayValuesChange = (_, info) => {
      if (info.type === "clear") {
        triggerChange([]);
        return;
      }
      const {
        valueCells
      } = info.values[0];
      onInternalSelect(valueCells);
    };
    if (true) {
      watchEffect(() => {
        devWarning_default(!props.onPopupVisibleChange, "Cascader", "`popupVisibleChange` is deprecated. Please use `dropdownVisibleChange` instead.");
        devWarning_default(props.popupVisible === void 0, "Cascader", "`popupVisible` is deprecated. Please use `open` instead.");
        devWarning_default(props.popupPlacement === void 0, "Cascader", "`popupPlacement` is deprecated. Please use `placement` instead.");
        devWarning_default(props.popupStyle === void 0, "Cascader", "`popupStyle` is deprecated. Please use `dropdownStyle` instead.");
      });
    }
    const mergedOpen = computed(() => props.open !== void 0 ? props.open : props.popupVisible);
    const mergedDropdownStyle = computed(() => props.dropdownStyle || props.popupStyle || {});
    const mergedPlacement = computed(() => props.placement || props.popupPlacement);
    const onInternalDropdownVisibleChange = (nextVisible) => {
      var _a, _b;
      (_a = props.onDropdownVisibleChange) === null || _a === void 0 ? void 0 : _a.call(props, nextVisible);
      (_b = props.onPopupVisibleChange) === null || _b === void 0 ? void 0 : _b.call(props, nextVisible);
    };
    const {
      changeOnSelect,
      checkable,
      dropdownPrefixCls,
      loadData,
      expandTrigger,
      expandIcon,
      loadingIcon,
      dropdownMenuColumnStyle,
      customSlots,
      dropdownClassName
    } = toRefs(props);
    useProvideCascader({
      options: mergedOptions,
      fieldNames: mergedFieldNames,
      values: checkedValues,
      halfValues: halfCheckedValues,
      changeOnSelect,
      onSelect: onInternalSelect,
      checkable,
      searchOptions,
      dropdownPrefixCls,
      loadData,
      expandTrigger,
      expandIcon,
      loadingIcon,
      dropdownMenuColumnStyle,
      customSlots
    });
    const selectRef = ref();
    expose({
      focus() {
        var _a;
        (_a = selectRef.value) === null || _a === void 0 ? void 0 : _a.focus();
      },
      blur() {
        var _a;
        (_a = selectRef.value) === null || _a === void 0 ? void 0 : _a.blur();
      },
      scrollTo(arg) {
        var _a;
        (_a = selectRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg);
      }
    });
    const pickProps = computed(() => {
      return omit_default(props, [
        "id",
        "prefixCls",
        "fieldNames",
        // Value
        "defaultValue",
        "value",
        "changeOnSelect",
        "onChange",
        "displayRender",
        "checkable",
        // Search
        "searchValue",
        "onSearch",
        "showSearch",
        // Trigger
        "expandTrigger",
        // Options
        "options",
        "dropdownPrefixCls",
        "loadData",
        // Open
        "popupVisible",
        "open",
        "dropdownClassName",
        "dropdownMenuColumnStyle",
        "popupPlacement",
        "placement",
        "onDropdownVisibleChange",
        "onPopupVisibleChange",
        // Icon
        "expandIcon",
        "loadingIcon",
        "customSlots",
        "showCheckedStrategy",
        // Children
        "children"
      ]);
    });
    return () => {
      const emptyOptions = !(mergedSearchValue.value ? searchOptions.value : mergedOptions.value).length;
      const {
        dropdownMatchSelectWidth = false
      } = props;
      const dropdownStyle = (
        // Search to match width
        mergedSearchValue.value && mergedSearchConfig.value.matchInputWidth || // Empty keep the width
        emptyOptions ? {} : {
          minWidth: "auto"
        }
      );
      return createVNode(BaseSelect_default, _objectSpread2(_objectSpread2(_objectSpread2({}, pickProps.value), attrs), {}, {
        "ref": selectRef,
        "id": mergedId,
        "prefixCls": props.prefixCls,
        "dropdownMatchSelectWidth": dropdownMatchSelectWidth,
        "dropdownStyle": _extends(_extends({}, mergedDropdownStyle.value), dropdownStyle),
        "displayValues": displayValues.value,
        "onDisplayValuesChange": onDisplayValuesChange,
        "mode": multiple.value ? "multiple" : void 0,
        "searchValue": mergedSearchValue.value,
        "onSearch": onInternalSearch,
        "showSearch": mergedShowSearch.value,
        "OptionList": OptionList_default,
        "emptyOptions": emptyOptions,
        "open": mergedOpen.value,
        "dropdownClassName": dropdownClassName.value,
        "placement": mergedPlacement.value,
        "onDropdownVisibleChange": onInternalDropdownVisibleChange,
        "getRawInputElement": () => {
          var _a;
          return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
        }
      }), slots);
    };
  }
});

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/vc-cascader/index.js
var vc_cascader_default = Cascader_default;

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/cascader/style/index.js
var genBaseStyle = (token) => {
  const {
    prefixCls,
    componentCls,
    antCls
  } = token;
  const cascaderMenuItemCls = `${componentCls}-menu-item`;
  const iconCls = `
    &${cascaderMenuItemCls}-expand ${cascaderMenuItemCls}-expand-icon,
    ${cascaderMenuItemCls}-loading-icon
  `;
  const itemPaddingVertical = Math.round((token.controlHeight - token.fontSize * token.lineHeight) / 2);
  return [
    // =====================================================
    // ==                     Control                     ==
    // =====================================================
    {
      [componentCls]: {
        width: token.controlWidth
      }
    },
    // =====================================================
    // ==                      Popup                      ==
    // =====================================================
    {
      [`${componentCls}-dropdown`]: [
        // ==================== Checkbox ====================
        getStyle(`${prefixCls}-checkbox`, token),
        {
          [`&${antCls}-select-dropdown`]: {
            padding: 0
          }
        },
        {
          [componentCls]: {
            // ================== Checkbox ==================
            "&-checkbox": {
              top: 0,
              marginInlineEnd: token.paddingXS
            },
            // ==================== Menu ====================
            // >>> Menus
            "&-menus": {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "flex-start",
              [`&${componentCls}-menu-empty`]: {
                [`${componentCls}-menu`]: {
                  width: "100%",
                  height: "auto",
                  [cascaderMenuItemCls]: {
                    color: token.colorTextDisabled
                  }
                }
              }
            },
            // >>> Menu
            "&-menu": {
              flexGrow: 1,
              minWidth: token.controlItemWidth,
              height: token.dropdownHeight,
              margin: 0,
              padding: token.paddingXXS,
              overflow: "auto",
              verticalAlign: "top",
              listStyle: "none",
              "-ms-overflow-style": "-ms-autohiding-scrollbar",
              "&:not(:last-child)": {
                borderInlineEnd: `${token.lineWidth}px ${token.lineType} ${token.colorSplit}`
              },
              "&-item": _extends(_extends({}, textEllipsis), {
                display: "flex",
                flexWrap: "nowrap",
                alignItems: "center",
                padding: `${itemPaddingVertical}px ${token.paddingSM}px`,
                lineHeight: token.lineHeight,
                cursor: "pointer",
                transition: `all ${token.motionDurationMid}`,
                borderRadius: token.borderRadiusSM,
                "&:hover": {
                  background: token.controlItemBgHover
                },
                "&-disabled": {
                  color: token.colorTextDisabled,
                  cursor: "not-allowed",
                  "&:hover": {
                    background: "transparent"
                  },
                  [iconCls]: {
                    color: token.colorTextDisabled
                  }
                },
                [`&-active:not(${cascaderMenuItemCls}-disabled)`]: {
                  [`&, &:hover`]: {
                    fontWeight: token.fontWeightStrong,
                    backgroundColor: token.controlItemBgActive
                  }
                },
                "&-content": {
                  flex: "auto"
                },
                [iconCls]: {
                  marginInlineStart: token.paddingXXS,
                  color: token.colorTextDescription,
                  fontSize: token.fontSizeIcon
                },
                "&-keyword": {
                  color: token.colorHighlight
                }
              })
            }
          }
        }
      ]
    },
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${componentCls}-dropdown-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token)
  ];
};
var style_default2 = genComponentStyleHook("Cascader", (token) => [genBaseStyle(token)], {
  controlWidth: 184,
  controlItemWidth: 111,
  dropdownHeight: 180
});

// ../../node_modules/.pnpm/ant-design-vue@4.2.6_vue@3.5.24_typescript@5.9.3_/node_modules/ant-design-vue/es/cascader/index.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function highlightKeyword(str, lowerKeyword, prefixCls) {
  const cells = str.toLowerCase().split(lowerKeyword).reduce((list, cur, index) => index === 0 ? [cur] : [...list, lowerKeyword, cur], []);
  const fillCells = [];
  let start = 0;
  cells.forEach((cell, index) => {
    const end = start + cell.length;
    let originWorld = str.slice(start, end);
    start = end;
    if (index % 2 === 1) {
      const _originWorld = /* @__PURE__ */ function() {
        return originWorld;
      }();
      originWorld = createVNode("span", {
        "class": `${prefixCls}-menu-item-keyword`,
        "key": "seperator"
      }, [originWorld]);
    }
    fillCells.push(originWorld);
  });
  return fillCells;
}
var defaultSearchRender = (_ref) => {
  let {
    inputValue,
    path,
    prefixCls,
    fieldNames
  } = _ref;
  const optionList = [];
  const lower = inputValue.toLowerCase();
  path.forEach((node, index) => {
    if (index !== 0) {
      optionList.push(" / ");
    }
    let label = node[fieldNames.label];
    const type = typeof label;
    if (type === "string" || type === "number") {
      label = highlightKeyword(String(label), lower, prefixCls);
    }
    optionList.push(label);
  });
  return optionList;
};
function cascaderProps() {
  return _extends(_extends({}, omit_default(internalCascaderProps(), ["customSlots", "checkable", "options"])), {
    multiple: {
      type: Boolean,
      default: void 0
    },
    size: String,
    bordered: {
      type: Boolean,
      default: void 0
    },
    placement: {
      type: String
    },
    suffixIcon: vue_types_default.any,
    status: String,
    options: Array,
    popupClassName: String,
    /** @deprecated Please use `popupClassName` instead */
    dropdownClassName: String,
    "onUpdate:value": Function
  });
}
var Cascader = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACascader",
  inheritAttrs: false,
  props: initDefaultProps_default(cascaderProps(), {
    bordered: true,
    choiceTransitionName: "",
    allowClear: true
  }),
  setup(props, _ref2) {
    let {
      attrs,
      expose,
      slots,
      emit
    } = _ref2;
    if (true) {
      devWarning_default(!props.dropdownClassName, "Cascader", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
    }
    const formItemContext = useInjectFormItemContext();
    const formItemInputContext = FormItemInputContext.useInject();
    const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props.status));
    const {
      prefixCls: cascaderPrefixCls,
      rootPrefixCls,
      getPrefixCls,
      direction,
      getPopupContainer,
      renderEmpty,
      size: contextSize,
      disabled
    } = useConfigInject_default("cascader", props);
    const prefixCls = computed(() => getPrefixCls("select", props.prefixCls));
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const mergedSize = computed(() => compactSize.value || contextSize.value);
    const contextDisabled = useInjectDisabled();
    const mergedDisabled = computed(() => {
      var _a;
      return (_a = disabled.value) !== null && _a !== void 0 ? _a : contextDisabled.value;
    });
    const [wrapSelectSSR, hashId] = style_default(prefixCls);
    const [wrapCascaderSSR] = style_default2(cascaderPrefixCls);
    const isRtl = computed(() => direction.value === "rtl");
    if (true) {
      watchEffect(() => {
        devWarning_default(!props.multiple || !props.displayRender || !slots.displayRender, "Cascader", "`displayRender` not work on `multiple`. Please use `tagRender` instead.");
      });
    }
    const mergedShowSearch = computed(() => {
      if (!props.showSearch) {
        return props.showSearch;
      }
      let searchConfig = {
        render: defaultSearchRender
      };
      if (typeof props.showSearch === "object") {
        searchConfig = _extends(_extends({}, searchConfig), props.showSearch);
      }
      return searchConfig;
    });
    const mergedDropdownClassName = computed(() => classNames_default(props.popupClassName || props.dropdownClassName, `${cascaderPrefixCls.value}-dropdown`, {
      [`${cascaderPrefixCls.value}-dropdown-rtl`]: isRtl.value
    }, hashId.value));
    const selectRef = ref();
    expose({
      focus() {
        var _a;
        (_a = selectRef.value) === null || _a === void 0 ? void 0 : _a.focus();
      },
      blur() {
        var _a;
        (_a = selectRef.value) === null || _a === void 0 ? void 0 : _a.blur();
      }
    });
    const handleChange = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      emit("update:value", args[0]);
      emit("change", ...args);
      formItemContext.onFieldChange();
    };
    const handleBlur = function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      emit("blur", ...args);
      formItemContext.onFieldBlur();
    };
    const mergedShowArrow = computed(() => props.showArrow !== void 0 ? props.showArrow : props.loading || !props.multiple);
    const placement = computed(() => {
      if (props.placement !== void 0) {
        return props.placement;
      }
      return direction.value === "rtl" ? "bottomRight" : "bottomLeft";
    });
    return () => {
      var _a, _b;
      const {
        notFoundContent = (_a = slots.notFoundContent) === null || _a === void 0 ? void 0 : _a.call(slots),
        expandIcon = (_b = slots.expandIcon) === null || _b === void 0 ? void 0 : _b.call(slots),
        multiple,
        bordered,
        allowClear,
        choiceTransitionName,
        transitionName,
        id = formItemContext.id.value
      } = props, restProps = __rest(props, ["notFoundContent", "expandIcon", "multiple", "bordered", "allowClear", "choiceTransitionName", "transitionName", "id"]);
      const mergedNotFoundContent = notFoundContent || renderEmpty("Cascader");
      let mergedExpandIcon = expandIcon;
      if (!expandIcon) {
        mergedExpandIcon = isRtl.value ? createVNode(LeftOutlined_default, null, null) : createVNode(RightOutlined_default, null, null);
      }
      const loadingIcon = createVNode("span", {
        "class": `${prefixCls.value}-menu-item-loading-icon`
      }, [createVNode(LoadingOutlined_default, {
        "spin": true
      }, null)]);
      const {
        suffixIcon,
        removeIcon,
        clearIcon
      } = getIcons(_extends(_extends({}, props), {
        hasFeedback: formItemInputContext.hasFeedback,
        feedbackIcon: formItemInputContext.feedbackIcon,
        multiple,
        prefixCls: prefixCls.value,
        showArrow: mergedShowArrow.value
      }), slots);
      return wrapCascaderSSR(wrapSelectSSR(createVNode(vc_cascader_default, _objectSpread2(_objectSpread2(_objectSpread2({}, restProps), attrs), {}, {
        "id": id,
        "prefixCls": prefixCls.value,
        "class": [cascaderPrefixCls.value, {
          [`${prefixCls.value}-lg`]: mergedSize.value === "large",
          [`${prefixCls.value}-sm`]: mergedSize.value === "small",
          [`${prefixCls.value}-rtl`]: isRtl.value,
          [`${prefixCls.value}-borderless`]: !bordered,
          [`${prefixCls.value}-in-form-item`]: formItemInputContext.isFormItemInput
        }, getStatusClassNames(prefixCls.value, mergedStatus.value, formItemInputContext.hasFeedback), compactItemClassnames.value, attrs.class, hashId.value],
        "disabled": mergedDisabled.value,
        "direction": direction.value,
        "placement": placement.value,
        "notFoundContent": mergedNotFoundContent,
        "allowClear": allowClear,
        "showSearch": mergedShowSearch.value,
        "expandIcon": mergedExpandIcon,
        "inputIcon": suffixIcon,
        "removeIcon": removeIcon,
        "clearIcon": clearIcon,
        "loadingIcon": loadingIcon,
        "checkable": !!multiple,
        "dropdownClassName": mergedDropdownClassName.value,
        "dropdownPrefixCls": cascaderPrefixCls.value,
        "choiceTransitionName": getTransitionName(rootPrefixCls.value, "", choiceTransitionName),
        "transitionName": getTransitionName(rootPrefixCls.value, getTransitionDirection(placement.value), transitionName),
        "getPopupContainer": getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
        "customSlots": _extends(_extends({}, slots), {
          checkable: () => createVNode("span", {
            "class": `${cascaderPrefixCls.value}-checkbox-inner`
          }, null)
        }),
        "tagRender": props.tagRender || slots.tagRender,
        "displayRender": props.displayRender || slots.displayRender,
        "maxTagPlaceholder": props.maxTagPlaceholder || slots.maxTagPlaceholder,
        "showArrow": formItemInputContext.hasFeedback || props.showArrow,
        "onChange": handleChange,
        "onBlur": handleBlur,
        "ref": selectRef
      }), slots)));
    };
  }
});
var cascader_default = withInstall(_extends(Cascader, {
  SHOW_CHILD,
  SHOW_PARENT
}));

export {
  cascaderProps,
  cascader_default
};
//# sourceMappingURL=chunk-7TWUJF7X.js.map
