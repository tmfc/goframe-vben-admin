(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"), require("@vxe-ui/core"), require("xe-utils"));
	else if(typeof define === 'function' && define.amd)
		define([, "@vxe-ui/core", "xe-utils"], factory);
	else if(typeof exports === 'object')
		exports["VxeUITable"] = factory(require("vue"), require("@vxe-ui/core"), require("xe-utils"));
	else
		root["VxeUITable"] = factory(root["Vue"], root["VxeUI"], root["XEUtils"]);
})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__9274__, __WEBPACK_EXTERNAL_MODULE__4345__, __WEBPACK_EXTERNAL_MODULE__8871__) {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 9274:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__9274__;

/***/ }),

/***/ 4345:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__4345__;

/***/ }),

/***/ 8871:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__8871__;

/***/ }),

/***/ 9306:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var tryToString = __webpack_require__(6823);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 679:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isPrototypeOf = __webpack_require__(1625);

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw new $TypeError('Incorrect invocation');
};


/***/ }),

/***/ 8551:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isObject = __webpack_require__(34);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 9617:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIndexedObject = __webpack_require__(5397);
var toAbsoluteIndex = __webpack_require__(5610);
var lengthOfArrayLike = __webpack_require__(6198);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 4527:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var isArray = __webpack_require__(4376);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw new $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};


/***/ }),

/***/ 6319:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var anObject = __webpack_require__(8551);
var iteratorClose = __webpack_require__(9539);

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator, 'throw', error);
  }
};


/***/ }),

/***/ 2195:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 6955:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var TO_STRING_TAG_SUPPORT = __webpack_require__(2140);
var isCallable = __webpack_require__(4901);
var classofRaw = __webpack_require__(2195);
var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7740:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var hasOwn = __webpack_require__(9297);
var ownKeys = __webpack_require__(5031);
var getOwnPropertyDescriptorModule = __webpack_require__(7347);
var definePropertyModule = __webpack_require__(4913);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 2211:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 2529:
/***/ (function(module) {


// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),

/***/ 6699:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var definePropertyModule = __webpack_require__(4913);
var createPropertyDescriptor = __webpack_require__(6980);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 6980:
/***/ (function(module) {


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 4659:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var definePropertyModule = __webpack_require__(4913);
var createPropertyDescriptor = __webpack_require__(6980);

module.exports = function (object, key, value) {
  if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
  else object[key] = value;
};


/***/ }),

/***/ 2106:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var makeBuiltIn = __webpack_require__(283);
var defineProperty = __webpack_require__(4913);

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ 6840:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var definePropertyModule = __webpack_require__(4913);
var makeBuiltIn = __webpack_require__(283);
var defineGlobalProperty = __webpack_require__(9433);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 6279:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var defineBuiltIn = __webpack_require__(6840);

module.exports = function (target, src, options) {
  for (var key in src) defineBuiltIn(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ 9433:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    globalThis[key] = value;
  } return value;
};


/***/ }),

/***/ 3724:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ 4055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var isObject = __webpack_require__(34);

var document = globalThis.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 6837:
/***/ (function(module) {


var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ 8727:
/***/ (function(module) {


// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 2839:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);

var navigator = globalThis.navigator;
var userAgent = navigator && navigator.userAgent;

module.exports = userAgent ? String(userAgent) : '';


/***/ }),

/***/ 9519:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var userAgent = __webpack_require__(2839);

var process = globalThis.process;
var Deno = globalThis.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 6518:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var getOwnPropertyDescriptor = (__webpack_require__(7347).f);
var createNonEnumerableProperty = __webpack_require__(6699);
var defineBuiltIn = __webpack_require__(6840);
var defineGlobalProperty = __webpack_require__(9433);
var copyConstructorProperties = __webpack_require__(7740);
var isForced = __webpack_require__(2796);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = globalThis;
  } else if (STATIC) {
    target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = globalThis[TARGET] && globalThis[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 9039:
/***/ (function(module) {


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 6080:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(7476);
var aCallable = __webpack_require__(9306);
var NATIVE_BIND = __webpack_require__(616);

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 616:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 9565:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 350:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var hasOwn = __webpack_require__(9297);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 7476:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classofRaw = __webpack_require__(2195);
var uncurryThis = __webpack_require__(9504);

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ 9504:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 7751:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var isCallable = __webpack_require__(4901);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(globalThis[namespace]) : globalThis[namespace] && globalThis[namespace][method];
};


/***/ }),

/***/ 1767:
/***/ (function(module) {


// `GetIteratorDirect(obj)` abstract operation
// https://tc39.es/proposal-iterator-helpers/#sec-getiteratordirect
module.exports = function (obj) {
  return {
    iterator: obj,
    next: obj.next,
    done: false
  };
};


/***/ }),

/***/ 851:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(6955);
var getMethod = __webpack_require__(5966);
var isNullOrUndefined = __webpack_require__(4117);
var Iterators = __webpack_require__(6269);
var wellKnownSymbol = __webpack_require__(8227);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ 81:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var tryToString = __webpack_require__(6823);
var getIteratorMethod = __webpack_require__(851);

var $TypeError = TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw new $TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ 5966:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var aCallable = __webpack_require__(9306);
var isNullOrUndefined = __webpack_require__(4117);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 4576:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 9297:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var toObject = __webpack_require__(8981);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 421:
/***/ (function(module) {


module.exports = {};


/***/ }),

/***/ 397:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 5917:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);
var createElement = __webpack_require__(4055);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ 7055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var classof = __webpack_require__(2195);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 3706:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var isCallable = __webpack_require__(4901);
var store = __webpack_require__(7629);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 1181:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_WEAK_MAP = __webpack_require__(8622);
var globalThis = __webpack_require__(4576);
var isObject = __webpack_require__(34);
var createNonEnumerableProperty = __webpack_require__(6699);
var hasOwn = __webpack_require__(9297);
var shared = __webpack_require__(7629);
var sharedKey = __webpack_require__(6119);
var hiddenKeys = __webpack_require__(421);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = globalThis.TypeError;
var WeakMap = globalThis.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 4209:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var wellKnownSymbol = __webpack_require__(8227);
var Iterators = __webpack_require__(6269);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ 4376:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(2195);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ 4901:
/***/ (function(module) {


// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 2796:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 4117:
/***/ (function(module) {


// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 34:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 6395:
/***/ (function(module) {


module.exports = false;


/***/ }),

/***/ 757:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var isCallable = __webpack_require__(4901);
var isPrototypeOf = __webpack_require__(1625);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 2652:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var bind = __webpack_require__(6080);
var call = __webpack_require__(9565);
var anObject = __webpack_require__(8551);
var tryToString = __webpack_require__(6823);
var isArrayIteratorMethod = __webpack_require__(4209);
var lengthOfArrayLike = __webpack_require__(6198);
var isPrototypeOf = __webpack_require__(1625);
var getIterator = __webpack_require__(81);
var getIteratorMethod = __webpack_require__(851);
var iteratorClose = __webpack_require__(9539);

var $TypeError = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw new $TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),

/***/ 9539:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var anObject = __webpack_require__(8551);
var getMethod = __webpack_require__(5966);

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ 9462:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var create = __webpack_require__(2360);
var createNonEnumerableProperty = __webpack_require__(6699);
var defineBuiltIns = __webpack_require__(6279);
var wellKnownSymbol = __webpack_require__(8227);
var InternalStateModule = __webpack_require__(1181);
var getMethod = __webpack_require__(5966);
var IteratorPrototype = (__webpack_require__(7657).IteratorPrototype);
var createIterResultObject = __webpack_require__(2529);
var iteratorClose = __webpack_require__(9539);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ITERATOR_HELPER = 'IteratorHelper';
var WRAP_FOR_VALID_ITERATOR = 'WrapForValidIterator';
var setInternalState = InternalStateModule.set;

var createIteratorProxyPrototype = function (IS_ITERATOR) {
  var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);

  return defineBuiltIns(create(IteratorPrototype), {
    next: function next() {
      var state = getInternalState(this);
      // for simplification:
      //   for `%WrapForValidIteratorPrototype%.next` our `nextHandler` returns `IterResultObject`
      //   for `%IteratorHelperPrototype%.next` - just a value
      if (IS_ITERATOR) return state.nextHandler();
      try {
        var result = state.done ? undefined : state.nextHandler();
        return createIterResultObject(result, state.done);
      } catch (error) {
        state.done = true;
        throw error;
      }
    },
    'return': function () {
      var state = getInternalState(this);
      var iterator = state.iterator;
      state.done = true;
      if (IS_ITERATOR) {
        var returnMethod = getMethod(iterator, 'return');
        return returnMethod ? call(returnMethod, iterator) : createIterResultObject(undefined, true);
      }
      if (state.inner) try {
        iteratorClose(state.inner.iterator, 'normal');
      } catch (error) {
        return iteratorClose(iterator, 'throw', error);
      }
      if (iterator) iteratorClose(iterator, 'normal');
      return createIterResultObject(undefined, true);
    }
  });
};

var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);
var IteratorHelperPrototype = createIteratorProxyPrototype(false);

createNonEnumerableProperty(IteratorHelperPrototype, TO_STRING_TAG, 'Iterator Helper');

module.exports = function (nextHandler, IS_ITERATOR) {
  var IteratorProxy = function Iterator(record, state) {
    if (state) {
      state.iterator = record.iterator;
      state.next = record.next;
    } else state = record;
    state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;
    state.nextHandler = nextHandler;
    state.counter = 0;
    state.done = false;
    setInternalState(this, state);
  };

  IteratorProxy.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;

  return IteratorProxy;
};


/***/ }),

/***/ 713:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);
var createIteratorProxy = __webpack_require__(9462);
var callWithSafeIterationClosing = __webpack_require__(6319);

var IteratorProxy = createIteratorProxy(function () {
  var iterator = this.iterator;
  var result = anObject(call(this.next, iterator));
  var done = this.done = !!result.done;
  if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [result.value, this.counter++], true);
});

// `Iterator.prototype.map` method
// https://github.com/tc39/proposal-iterator-helpers
module.exports = function map(mapper) {
  anObject(this);
  aCallable(mapper);
  return new IteratorProxy(getIteratorDirect(this), {
    mapper: mapper
  });
};


/***/ }),

/***/ 7657:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);
var isObject = __webpack_require__(34);
var create = __webpack_require__(2360);
var getPrototypeOf = __webpack_require__(2787);
var defineBuiltIn = __webpack_require__(6840);
var wellKnownSymbol = __webpack_require__(8227);
var IS_PURE = __webpack_require__(6395);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ 6269:
/***/ (function(module) {


module.exports = {};


/***/ }),

/***/ 6198:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toLength = __webpack_require__(8014);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 283:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);
var hasOwn = __webpack_require__(9297);
var DESCRIPTORS = __webpack_require__(3724);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(350).CONFIGURABLE);
var inspectSource = __webpack_require__(3706);
var InternalStateModule = __webpack_require__(1181);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 741:
/***/ (function(module) {


var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 2360:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(8551);
var definePropertiesModule = __webpack_require__(6801);
var enumBugKeys = __webpack_require__(8727);
var hiddenKeys = __webpack_require__(421);
var html = __webpack_require__(397);
var documentCreateElement = __webpack_require__(4055);
var sharedKey = __webpack_require__(6119);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  // eslint-disable-next-line no-useless-assignment -- avoid memory leak
  activeXDocument = null;
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ 6801:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(8686);
var definePropertyModule = __webpack_require__(4913);
var anObject = __webpack_require__(8551);
var toIndexedObject = __webpack_require__(5397);
var objectKeys = __webpack_require__(1072);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ 4913:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var IE8_DOM_DEFINE = __webpack_require__(5917);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(8686);
var anObject = __webpack_require__(8551);
var toPropertyKey = __webpack_require__(6969);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7347:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var call = __webpack_require__(9565);
var propertyIsEnumerableModule = __webpack_require__(8773);
var createPropertyDescriptor = __webpack_require__(6980);
var toIndexedObject = __webpack_require__(5397);
var toPropertyKey = __webpack_require__(6969);
var hasOwn = __webpack_require__(9297);
var IE8_DOM_DEFINE = __webpack_require__(5917);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 8480:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var internalObjectKeys = __webpack_require__(1828);
var enumBugKeys = __webpack_require__(8727);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 3717:
/***/ (function(__unused_webpack_module, exports) {


// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 2787:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var hasOwn = __webpack_require__(9297);
var isCallable = __webpack_require__(4901);
var toObject = __webpack_require__(8981);
var sharedKey = __webpack_require__(6119);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(2211);

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 1625:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 1828:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var hasOwn = __webpack_require__(9297);
var toIndexedObject = __webpack_require__(5397);
var indexOf = (__webpack_require__(9617).indexOf);
var hiddenKeys = __webpack_require__(421);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 1072:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var internalObjectKeys = __webpack_require__(1828);
var enumBugKeys = __webpack_require__(8727);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 8773:
/***/ (function(__unused_webpack_module, exports) {


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 4270:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isCallable = __webpack_require__(4901);
var isObject = __webpack_require__(34);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 5031:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var uncurryThis = __webpack_require__(9504);
var getOwnPropertyNamesModule = __webpack_require__(8480);
var getOwnPropertySymbolsModule = __webpack_require__(3717);
var anObject = __webpack_require__(8551);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 7750:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isNullOrUndefined = __webpack_require__(4117);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 6119:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var shared = __webpack_require__(5745);
var uid = __webpack_require__(3392);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 7629:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var IS_PURE = __webpack_require__(6395);
var globalThis = __webpack_require__(4576);
var defineGlobalProperty = __webpack_require__(9433);

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.39.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2014-2024 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.39.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 5745:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var store = __webpack_require__(7629);

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ }),

/***/ 4495:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(9519);
var fails = __webpack_require__(9039);
var globalThis = __webpack_require__(4576);

var $String = globalThis.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 5610:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 5397:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(7055);
var requireObjectCoercible = __webpack_require__(7750);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 1291:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var trunc = __webpack_require__(741);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 8014:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 8981:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var requireObjectCoercible = __webpack_require__(7750);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2777:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isObject = __webpack_require__(34);
var isSymbol = __webpack_require__(757);
var getMethod = __webpack_require__(5966);
var ordinaryToPrimitive = __webpack_require__(4270);
var wellKnownSymbol = __webpack_require__(8227);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 6969:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toPrimitive = __webpack_require__(2777);
var isSymbol = __webpack_require__(757);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 2140:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 6823:
/***/ (function(module) {


var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 3392:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 7040:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(4495);

module.exports = NATIVE_SYMBOL &&
  !Symbol.sham &&
  typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 8686:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ 8622:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var isCallable = __webpack_require__(4901);

var WeakMap = globalThis.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 8227:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(4576);
var shared = __webpack_require__(5745);
var hasOwn = __webpack_require__(9297);
var uid = __webpack_require__(3392);
var NATIVE_SYMBOL = __webpack_require__(4495);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var Symbol = globalThis.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 4114:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var toObject = __webpack_require__(8981);
var lengthOfArrayLike = __webpack_require__(6198);
var setArrayLength = __webpack_require__(4527);
var doesNotExceedSafeInteger = __webpack_require__(6837);
var fails = __webpack_require__(9039);

var INCORRECT_TO_LENGTH = fails(function () {
  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;
});

// V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError
// https://bugs.chromium.org/p/v8/issues/detail?id=12681
var properErrorOnNonWritableLength = function () {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).push();
  } catch (error) {
    return error instanceof TypeError;
  }
};

var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();

// `Array.prototype.push` method
// https://tc39.es/ecma262/#sec-array.prototype.push
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength(O, len);
    return len;
  }
});


/***/ }),

/***/ 8111:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var globalThis = __webpack_require__(4576);
var anInstance = __webpack_require__(679);
var anObject = __webpack_require__(8551);
var isCallable = __webpack_require__(4901);
var getPrototypeOf = __webpack_require__(2787);
var defineBuiltInAccessor = __webpack_require__(2106);
var createProperty = __webpack_require__(4659);
var fails = __webpack_require__(9039);
var hasOwn = __webpack_require__(9297);
var wellKnownSymbol = __webpack_require__(8227);
var IteratorPrototype = (__webpack_require__(7657).IteratorPrototype);
var DESCRIPTORS = __webpack_require__(3724);
var IS_PURE = __webpack_require__(6395);

var CONSTRUCTOR = 'constructor';
var ITERATOR = 'Iterator';
var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var $TypeError = TypeError;
var NativeIterator = globalThis[ITERATOR];

// FF56- have non-standard global helper `Iterator`
var FORCED = IS_PURE
  || !isCallable(NativeIterator)
  || NativeIterator.prototype !== IteratorPrototype
  // FF44- non-standard `Iterator` passes previous tests
  || !fails(function () { NativeIterator({}); });

var IteratorConstructor = function Iterator() {
  anInstance(this, IteratorPrototype);
  if (getPrototypeOf(this) === IteratorPrototype) throw new $TypeError('Abstract class Iterator not directly constructable');
};

var defineIteratorPrototypeAccessor = function (key, value) {
  if (DESCRIPTORS) {
    defineBuiltInAccessor(IteratorPrototype, key, {
      configurable: true,
      get: function () {
        return value;
      },
      set: function (replacement) {
        anObject(this);
        if (this === IteratorPrototype) throw new $TypeError("You can't redefine this property");
        if (hasOwn(this, key)) this[key] = replacement;
        else createProperty(this, key, replacement);
      }
    });
  } else IteratorPrototype[key] = value;
};

if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);

if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {
  defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);
}

IteratorConstructor.prototype = IteratorPrototype;

// `Iterator` constructor
// https://tc39.es/ecma262/#sec-iterator
$({ global: true, constructor: true, forced: FORCED }, {
  Iterator: IteratorConstructor
});


/***/ }),

/***/ 1148:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var iterate = __webpack_require__(2652);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);

// `Iterator.prototype.every` method
// https://tc39.es/ecma262/#sec-iterator.prototype.every
$({ target: 'Iterator', proto: true, real: true }, {
  every: function every(predicate) {
    anObject(this);
    aCallable(predicate);
    var record = getIteratorDirect(this);
    var counter = 0;
    return !iterate(record, function (value, stop) {
      if (!predicate(value, counter++)) return stop();
    }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
  }
});


/***/ }),

/***/ 2489:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var call = __webpack_require__(9565);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);
var createIteratorProxy = __webpack_require__(9462);
var callWithSafeIterationClosing = __webpack_require__(6319);
var IS_PURE = __webpack_require__(6395);

var IteratorProxy = createIteratorProxy(function () {
  var iterator = this.iterator;
  var predicate = this.predicate;
  var next = this.next;
  var result, done, value;
  while (true) {
    result = anObject(call(next, iterator));
    done = this.done = !!result.done;
    if (done) return;
    value = result.value;
    if (callWithSafeIterationClosing(iterator, predicate, [value, this.counter++], true)) return value;
  }
});

// `Iterator.prototype.filter` method
// https://tc39.es/ecma262/#sec-iterator.prototype.filter
$({ target: 'Iterator', proto: true, real: true, forced: IS_PURE }, {
  filter: function filter(predicate) {
    anObject(this);
    aCallable(predicate);
    return new IteratorProxy(getIteratorDirect(this), {
      predicate: predicate
    });
  }
});


/***/ }),

/***/ 116:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var iterate = __webpack_require__(2652);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);

// `Iterator.prototype.find` method
// https://tc39.es/ecma262/#sec-iterator.prototype.find
$({ target: 'Iterator', proto: true, real: true }, {
  find: function find(predicate) {
    anObject(this);
    aCallable(predicate);
    var record = getIteratorDirect(this);
    var counter = 0;
    return iterate(record, function (value, stop) {
      if (predicate(value, counter++)) return stop(value);
    }, { IS_RECORD: true, INTERRUPTED: true }).result;
  }
});


/***/ }),

/***/ 7588:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var iterate = __webpack_require__(2652);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);

// `Iterator.prototype.forEach` method
// https://tc39.es/ecma262/#sec-iterator.prototype.foreach
$({ target: 'Iterator', proto: true, real: true }, {
  forEach: function forEach(fn) {
    anObject(this);
    aCallable(fn);
    var record = getIteratorDirect(this);
    var counter = 0;
    iterate(record, function (value) {
      fn(value, counter++);
    }, { IS_RECORD: true });
  }
});


/***/ }),

/***/ 1701:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var map = __webpack_require__(713);
var IS_PURE = __webpack_require__(6395);

// `Iterator.prototype.map` method
// https://tc39.es/ecma262/#sec-iterator.prototype.map
$({ target: 'Iterator', proto: true, real: true, forced: IS_PURE }, {
  map: map
});


/***/ }),

/***/ 8237:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var iterate = __webpack_require__(2652);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);

var $TypeError = TypeError;

// `Iterator.prototype.reduce` method
// https://tc39.es/ecma262/#sec-iterator.prototype.reduce
$({ target: 'Iterator', proto: true, real: true }, {
  reduce: function reduce(reducer /* , initialValue */) {
    anObject(this);
    aCallable(reducer);
    var record = getIteratorDirect(this);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? undefined : arguments[1];
    var counter = 0;
    iterate(record, function (value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = reducer(accumulator, value, counter);
      }
      counter++;
    }, { IS_RECORD: true });
    if (noInitial) throw new $TypeError('Reduce of empty iterator with no initial value');
    return accumulator;
  }
});


/***/ }),

/***/ 3579:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var iterate = __webpack_require__(2652);
var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var getIteratorDirect = __webpack_require__(1767);

// `Iterator.prototype.some` method
// https://tc39.es/ecma262/#sec-iterator.prototype.some
$({ target: 'Iterator', proto: true, real: true }, {
  some: function some(predicate) {
    anObject(this);
    aCallable(predicate);
    var record = getIteratorDirect(this);
    var counter = 0;
    return iterate(record, function (value, stop) {
      if (predicate(value, counter++)) return stop();
    }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
  }
});


/***/ }),

/***/ 1806:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var anObject = __webpack_require__(8551);
var iterate = __webpack_require__(2652);
var getIteratorDirect = __webpack_require__(1767);

var push = [].push;

// `Iterator.prototype.toArray` method
// https://tc39.es/ecma262/#sec-iterator.prototype.toarray
$({ target: 'Iterator', proto: true, real: true }, {
  toArray: function toArray() {
    var result = [];
    iterate(getIteratorDirect(anObject(this)), push, { that: result, IS_RECORD: true });
    return result;
  }
});


/***/ }),

/***/ 8992:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(8111);


/***/ }),

/***/ 3215:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(1148);


/***/ }),

/***/ 4520:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(2489);


/***/ }),

/***/ 2577:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(116);


/***/ }),

/***/ 3949:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(7588);


/***/ }),

/***/ 1454:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(1701);


/***/ }),

/***/ 8872:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(8237);


/***/ }),

/***/ 7550:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(3579);


/***/ }),

/***/ 1795:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(1806);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Colgroup: function() { return /* reexport */ Colgroup; },
  Column: function() { return /* reexport */ Column; },
  Grid: function() { return /* reexport */ Grid; },
  Table: function() { return /* reexport */ Table; },
  Toolbar: function() { return /* reexport */ Toolbar; },
  VXETable: function() { return /* reexport */ VXETable; },
  VxeColgroup: function() { return /* reexport */ VxeColgroup; },
  VxeColumn: function() { return /* reexport */ VxeColumn; },
  VxeGrid: function() { return /* reexport */ VxeGrid; },
  VxeTable: function() { return /* reexport */ VxeTable; },
  VxeToolbar: function() { return /* reexport */ VxeToolbar; },
  VxeUI: function() { return /* reexport */ core_.VxeUI; },
  _t: function() { return /* reexport */ _t; },
  clipboard: function() { return /* reexport */ clipboard; },
  commands: function() { return /* reexport */ commands; },
  config: function() { return /* reexport */ config; },
  "default": function() { return /* binding */ entry_lib; },
  formats: function() { return /* reexport */ formats; },
  getConfig: function() { return /* reexport */ ui_getConfig; },
  getI18n: function() { return /* reexport */ getI18n; },
  getIcon: function() { return /* reexport */ getIcon; },
  getTheme: function() { return /* reexport */ getTheme; },
  globalEvents: function() { return /* reexport */ globalEvents; },
  globalResize: function() { return /* reexport */ globalResize; },
  hooks: function() { return /* reexport */ hooks; },
  install: function() { return /* reexport */ install; },
  interceptor: function() { return /* reexport */ interceptor; },
  log: function() { return /* reexport */ log; },
  menus: function() { return /* reexport */ menus; },
  modal: function() { return /* reexport */ modal; },
  print: function() { return /* reexport */ print; },
  readFile: function() { return /* reexport */ readFile; },
  renderer: function() { return /* reexport */ renderer; },
  saveFile: function() { return /* reexport */ saveFile; },
  setConfig: function() { return /* reexport */ setConfig; },
  setI18n: function() { return /* reexport */ setI18n; },
  setIcon: function() { return /* reexport */ setIcon; },
  setLanguage: function() { return /* reexport */ setLanguage; },
  setTheme: function() { return /* reexport */ setTheme; },
  setup: function() { return /* reexport */ setup; },
  t: function() { return /* reexport */ t; },
  use: function() { return /* reexport */ use; },
  validators: function() { return /* reexport */ validators; },
  version: function() { return /* reexport */ version; }
});

// NAMESPACE OBJECT: ./packages/components.ts
var components_namespaceObject = {};
__webpack_require__.r(components_namespaceObject);
__webpack_require__.d(components_namespaceObject, {
  Colgroup: function() { return Colgroup; },
  Column: function() { return Column; },
  Grid: function() { return Grid; },
  Table: function() { return Table; },
  Toolbar: function() { return Toolbar; },
  VXETable: function() { return VXETable; },
  VxeColgroup: function() { return VxeColgroup; },
  VxeColumn: function() { return VxeColumn; },
  VxeGrid: function() { return VxeGrid; },
  VxeTable: function() { return VxeTable; },
  VxeToolbar: function() { return VxeToolbar; },
  VxeUI: function() { return core_.VxeUI; },
  _t: function() { return _t; },
  clipboard: function() { return clipboard; },
  commands: function() { return commands; },
  config: function() { return config; },
  formats: function() { return formats; },
  getConfig: function() { return ui_getConfig; },
  getI18n: function() { return getI18n; },
  getIcon: function() { return getIcon; },
  getTheme: function() { return getTheme; },
  globalEvents: function() { return globalEvents; },
  globalResize: function() { return globalResize; },
  hooks: function() { return hooks; },
  install: function() { return install; },
  interceptor: function() { return interceptor; },
  log: function() { return log; },
  menus: function() { return menus; },
  modal: function() { return modal; },
  print: function() { return print; },
  readFile: function() { return readFile; },
  renderer: function() { return renderer; },
  saveFile: function() { return saveFile; },
  setConfig: function() { return setConfig; },
  setI18n: function() { return setI18n; },
  setIcon: function() { return setIcon; },
  setLanguage: function() { return setLanguage; },
  setTheme: function() { return setTheme; },
  setup: function() { return setup; },
  t: function() { return t; },
  use: function() { return use; },
  validators: function() { return validators; },
  version: function() { return version; }
});

;// ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
/* eslint-disable no-var */
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (false) { var getCurrentScript; }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.constructor.js
var esnext_iterator_constructor = __webpack_require__(8992);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.for-each.js
var esnext_iterator_for_each = __webpack_require__(3949);
// EXTERNAL MODULE: external {"root":"VxeUI","commonjs":"@vxe-ui/core","commonjs2":"@vxe-ui/core","amd":"@vxe-ui/core"}
var core_ = __webpack_require__(4345);
// EXTERNAL MODULE: external {"root":"XEUtils","commonjs":"xe-utils","commonjs2":"xe-utils","amd":"xe-utils"}
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_ = __webpack_require__(8871);
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default = /*#__PURE__*/__webpack_require__.n(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_);
;// ./node_modules/dom-zindex/es/index.esm.js
var winDom = null;
var bodyEl = null;
var storeEl = null;
var storeId = 'z-index-manage';
var styleEl = null;
var styleId = 'z-index-style';
var storeMainKey = 'm';
var storeSubKey = 's';
var storeData = {
  m: 1000,
  s: 1000
};
function getDocument() {
  if (!winDom) {
    if (typeof document !== 'undefined') {
      winDom = document;
    }
  }
  return winDom;
}
function getBody() {
  if (winDom && !bodyEl) {
    bodyEl = winDom.body || winDom.getElementsByTagName('body')[0];
  }
  return bodyEl;
}
function getDomMaxZIndex() {
  var max = 0;
  var dom = getDocument();
  if (dom) {
    var body = getBody();
    if (body) {
      var allElem = body.getElementsByTagName('*');
      for (var i = 0; i < allElem.length; i++) {
        var elem = allElem[i];
        if (elem && elem.style && elem.nodeType === 1) {
          var zIndex = elem.style.zIndex;
          if (zIndex && /^\d+$/.test(zIndex)) {
            max = Math.max(max, Number(zIndex));
          }
        }
      }
    }
  }
  return max;
}
function getStyle() {
  if (!styleEl) {
    var dom = getDocument();
    if (dom) {
      styleEl = dom.getElementById(styleId);
      if (!styleEl) {
        styleEl = dom.createElement('style');
        styleEl.id = styleId;
        dom.getElementsByTagName('head')[0].appendChild(styleEl);
      }
    }
  }
  return styleEl;
}
function updateVar() {
  var styEl = getStyle();
  if (styEl) {
    var prefixes = '--dom-';
    var propKey = '-z-index';
    styEl.innerHTML = ':root{' + prefixes + 'main' + propKey + ':' + getCurrent() + ';' + prefixes + 'sub' + propKey + ':' + getSubCurrent() + '}';
  }
}
function getStoreDom() {
  if (!storeEl) {
    var dom = getDocument();
    if (dom) {
      storeEl = dom.getElementById(storeId);
      if (!storeEl) {
        var body = getBody();
        if (body) {
          storeEl = dom.createElement('div');
          storeEl.id = storeId;
          storeEl.style.display = 'none';
          body.appendChild(storeEl);
          setCurrent(storeData.m);
          setSubCurrent(storeData.s);
        }
      }
    }
  }
  return storeEl;
}
function createSetHandle(key) {
  return function (value) {
    if (value) {
      value = Number(value);
      storeData[key] = value;
      var el = getStoreDom();
      if (el) {
        if (el.dataset) {
          el.dataset[key] = value + '';
        } else {
          el.setAttribute('data-' + key, value + '');
        }
      }
    }
    updateVar();
    return storeData[key];
  };
}
var setCurrent = createSetHandle(storeMainKey);
function createGetHandle(key, nextMethod) {
  return function getCurrent(currZindex) {
    var zIndex;
    var el = getStoreDom();
    if (el) {
      var domVal = el.dataset ? el.dataset[key] : el.getAttribute('data-' + key);
      if (domVal) {
        zIndex = Number(domVal);
      }
    }
    if (!zIndex) {
      zIndex = storeData[key];
    }
    if (currZindex) {
      if (Number(currZindex) < zIndex) {
        return nextMethod();
      }
      return currZindex;
    }
    return zIndex;
  };
}
var getCurrent = createGetHandle(storeMainKey, getNext);
function getNext() {
  return setCurrent(getCurrent() + 1);
}
var setSubCurrent = createSetHandle(storeSubKey);
var _getSubCurrent = createGetHandle(storeSubKey, getSubNext);
function getSubCurrent() {
  return getCurrent() + _getSubCurrent();
}
function getSubNext() {
  setSubCurrent(_getSubCurrent() + 1);
  return getSubCurrent();
}
/**
 * Web common z-index style management
 */
var DomZIndex = {
  setCurrent: setCurrent,
  getCurrent: getCurrent,
  getNext: getNext,
  setSubCurrent: setSubCurrent,
  getSubCurrent: getSubCurrent,
  getSubNext: getSubNext,
  getMax: getDomMaxZIndex
};
updateVar();
/* harmony default export */ var index_esm = (DomZIndex);
;// ./packages/ui/src/utils.ts



const {
  getConfig
} = core_.VxeUI;
function isEnableConf(conf) {
  return conf && conf.enabled !== false;
}
function isEmptyValue(cellValue) {
  return cellValue === null || cellValue === undefined || cellValue === '';
}
function parseFile(file) {
  const name = file.name;
  const tIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().lastIndexOf(name, '.');
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return {
    filename,
    type
  };
}
function nextZIndex() {
  return index_esm.getNext();
}
function getLastZIndex() {
  return index_esm.getCurrent();
}
function hasChildrenList(item) {
  return item && item.children && item.children.length > 0;
}
function getFuncText(content, args) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(content)) {
    return '';
  }
  const translate = getConfig().translate;
  return `${translate ? translate('' + content, args) : content}`;
}
function formatText(value, placeholder) {
  return '' + (isEmptyValue(value) ? placeholder ? getConfig().emptyCell : '' : value);
}
/**
 * '' | null | undefined 
 */
function eqEmptyValue(cellValue) {
  return cellValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cellValue);
}
;// ./packages/ui/index.ts


const version = "4.17.15";
core_.VxeUI.version = version;
core_.VxeUI.tableVersion = version;
core_.VxeUI.setConfig({
  emptyCell: '',
  table: {
    fit: true,
    showHeader: true,
    animat: true,
    delayHover: 250,
    autoResize: true,
    // minHeight: null,
    // keepSource: false,
    // showOverflow: null,
    // showHeaderOverflow: null,
    // showFooterOverflow: null,
    // resizeInterval: 500,
    // size: null,
    // zIndex: null,
    // stripe: false,
    // border: false,
    // round: false,
    // emptyText: '',
    // emptyRender: {
    //   name: ''
    // },
    // rowConfig: {
    //   keyField: '_X_ROW_KEY' // 
    // },
    resizeConfig: {
      // refreshDelay: 20
    },
    resizableConfig: {
      dragMode: 'auto',
      showDragTip: true,
      isSyncAutoHeight: true,
      isSyncAutoWidth: true,
      minHeight: 18
    },
    radioConfig: {
      // trigger: 'default'
      strict: true
    },
    rowDragConfig: {
      showIcon: true,
      animation: true,
      showGuidesStatus: true,
      showDragTip: true
    },
    columnDragConfig: {
      showIcon: true,
      animation: true,
      showGuidesStatus: true,
      showDragTip: true
    },
    checkboxConfig: {
      // trigger: 'default',
      strict: true
    },
    tooltipConfig: {
      enterable: true
    },
    headerTooltipConfig: {
      enterable: true
    },
    footerTooltipConfig: {
      enterable: true
    },
    validConfig: {
      showMessage: true,
      autoClear: true,
      autoPos: true,
      message: 'inline',
      msgMode: 'single',
      theme: 'beautify'
    },
    columnConfig: {
      autoOptions: {
        isCalcHeader: true,
        isCalcBody: true,
        isCalcFooter: true
      },
      maxFixedSize: 4
    },
    cellConfig: {
      padding: true
    },
    headerCellConfig: {
      height: 'unset'
    },
    footerCellConfig: {
      height: 'unset'
    },
    menuConfig: {
      // visibleMethod () {},
      // transfer: false,
      destroyOnClose: true
    },
    customConfig: {
      // enabled: false,
      allowVisible: true,
      allowResizable: true,
      allowFixed: true,
      allowSort: true,
      showFooter: true,
      placement: 'top-right',
      //  storage: false,
      storeOptions: {
        visible: true,
        resizable: true,
        sort: true,
        fixed: true
        // rowGroup: false,
        // aggFunc: false
      },
      // autoAggGroupValues: false,
      //  checkMethod () {},
      modalOptions: {
        showMaximize: true,
        mask: true,
        lockView: true,
        resize: true,
        escClosable: true
      },
      drawerOptions: {
        mask: true,
        lockView: true,
        escClosable: true,
        resize: true
      }
    },
    sortConfig: {
      // remote: false,
      // trigger: 'default',
      // orders: ['asc', 'desc', null],
      // sortMethod: null,
      showIcon: true,
      allowClear: true,
      allowBtn: true,
      iconLayout: 'vertical'
    },
    filterConfig: {
      // remote: false,
      // filterMethod: null,
      // isEvery: false,
      // transfer: false,
      destroyOnClose: true,
      multiple: true,
      showIcon: true
    },
    floatingFilterConfig: {
      // enabled: false
    },
    aggregateConfig: {
      padding: true,
      rowField: 'id',
      parentField: '_X_ROW_PARENT_KEY',
      childrenField: '_X_ROW_CHILDREN',
      mapChildrenField: '_X_ROW_CHILD_LIST',
      indent: 20,
      showIcon: true,
      maxGroupSize: 4,
      showAggFuncTitle: true
    },
    treeConfig: {
      padding: true,
      rowField: 'id',
      parentField: 'parentId',
      childrenField: 'children',
      hasChildField: 'hasChild',
      mapChildrenField: '_X_ROW_CHILD',
      indent: 20,
      showIcon: true,
      showRootLine: true
    },
    expandConfig: {
      // trigger: 'default',
      showIcon: true,
      mode: 'fixed'
    },
    editConfig: {
      // mode: 'cell',
      showIcon: true,
      showAsterisk: true,
      autoFocus: true
    },
    importConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      }
    },
    exportConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      }
    },
    printConfig: {},
    mouseConfig: {
      extension: true
    },
    keyboardConfig: {
      isAll: true,
      isEsc: true
    },
    areaConfig: {
      autoClear: true,
      selectCellByHeader: true,
      selectCellByBody: true,
      extendDirection: {
        top: true,
        left: true,
        bottom: true,
        right: true
      }
    },
    clipConfig: {
      isCopy: true,
      isCut: true,
      isPaste: true
    },
    fnrConfig: {
      isFind: true,
      isReplace: true
    },
    virtualXConfig: {
      // enabled: false,
      gt: 24,
      preSize: 1,
      oSize: 0
    },
    virtualYConfig: {
      // enabled: false,
      // mode: 'wheel',
      gt: 100,
      preSize: 1,
      oSize: 0
    },
    scrollbarConfig: {
      // width: 14,
      // height: 14,
      x: {
        // position: 'bottom',
        visible: true
      },
      y: {
        // position: 'right',
        visible: true
      }
    }
  },
  grid: {
    // size: null,
    // zoomConfig: {
    //   escRestore: true
    // },
    formConfig: {
      enabled: true
    },
    pagerConfig: {
      enabled: true
      // perfect: false
    },
    toolbarConfig: {
      enabled: true
      // perfect: false
    },
    proxyConfig: {
      enabled: true,
      autoLoad: true,
      showLoading: true,
      showResponseMsg: true,
      showActionMsg: true,
      response: {
        list: null,
        result: 'result',
        total: 'page.total',
        message: 'message'
      }
      // beforeItem: null,
      // beforeColumn: null,
      // beforeQuery: null,
      // afterQuery: null,
      // beforeDelete: null,
      // afterDelete: null,
      // beforeSave: null,
      // afterSave: null
    }
  },
  toolbar: {
    // size: null,
    // import: {
    //   mode: 'covering'
    // },
    // export: {
    //   types: ['csv', 'html', 'xml', 'txt']
    // },
    // buttons: []
  },
  gantt: {}
});
const iconPrefix = 'vxe-table-icon-';
core_.VxeUI.setIcon({
  // table
  TABLE_SORT_ASC: iconPrefix + 'caret-up',
  TABLE_SORT_DESC: iconPrefix + 'caret-down',
  TABLE_FILTER_NONE: iconPrefix + 'funnel',
  TABLE_FILTER_MATCH: iconPrefix + 'funnel',
  TABLE_EDIT: iconPrefix + 'edit',
  TABLE_TITLE_PREFIX: iconPrefix + 'question-circle-fill',
  TABLE_TITLE_SUFFIX: iconPrefix + 'question-circle-fill',
  TABLE_TREE_LOADED: iconPrefix + 'spinner roll',
  TABLE_TREE_OPEN: iconPrefix + 'caret-right rotate90',
  TABLE_TREE_CLOSE: iconPrefix + 'caret-right',
  TABLE_EXPAND_LOADED: iconPrefix + 'spinner roll',
  TABLE_EXPAND_OPEN: iconPrefix + 'arrow-right rotate90',
  TABLE_EXPAND_CLOSE: iconPrefix + 'arrow-right',
  TABLE_CHECKBOX_CHECKED: iconPrefix + 'checkbox-checked-fill',
  TABLE_CHECKBOX_UNCHECKED: iconPrefix + 'checkbox-unchecked',
  TABLE_CHECKBOX_INDETERMINATE: iconPrefix + 'checkbox-indeterminate-fill',
  TABLE_CHECKBOX_DISABLED_UNCHECKED: iconPrefix + 'checkbox-unchecked-fill',
  TABLE_RADIO_CHECKED: iconPrefix + 'radio-checked-fill',
  TABLE_RADIO_UNCHECKED: iconPrefix + 'radio-unchecked',
  TABLE_RADIO_DISABLED_UNCHECKED: iconPrefix + 'radio-unchecked-fill',
  TABLE_CUSTOM_SORT: iconPrefix + 'drag-handle',
  TABLE_MENU_OPTIONS: iconPrefix + 'arrow-right',
  TABLE_MENU_OPTION_LOADING: iconPrefix + 'repeat roll',
  TABLE_DRAG_ROW: iconPrefix + 'drag-handle',
  TABLE_DRAG_COLUMN: iconPrefix + 'drag-handle',
  TABLE_DRAG_STATUS_ROW: iconPrefix + 'sort',
  TABLE_DRAG_STATUS_SUB_ROW: iconPrefix + 'add-sub',
  TABLE_DRAG_STATUS_AGG_GROUP: iconPrefix + 'grouping',
  TABLE_DRAG_STATUS_AGG_VALUES: iconPrefix + 'values',
  TABLE_DRAG_STATUS_COLUMN: iconPrefix + 'swap',
  TABLE_DRAG_DISABLED: iconPrefix + 'no-drop',
  TABLE_ROW_GROUP_OPEN: iconPrefix + 'arrow-right rotate90',
  TABLE_ROW_GROUP_CLOSE: iconPrefix + 'arrow-right',
  TABLE_AGGREGATE_GROUPING: iconPrefix + 'grouping',
  TABLE_AGGREGATE_VALUES: iconPrefix + 'values',
  TABLE_AGGREGATE_SORT: iconPrefix + 'drag-handle',
  TABLE_AGGREGATE_DELETE: iconPrefix + 'close',
  // toolbar
  TOOLBAR_TOOLS_REFRESH: iconPrefix + 'repeat',
  TOOLBAR_TOOLS_REFRESH_LOADING: iconPrefix + 'repeat roll',
  TOOLBAR_TOOLS_IMPORT: iconPrefix + 'upload',
  TOOLBAR_TOOLS_EXPORT: iconPrefix + 'download',
  TOOLBAR_TOOLS_PRINT: iconPrefix + 'print',
  TOOLBAR_TOOLS_FULLSCREEN: iconPrefix + 'fullscreen',
  TOOLBAR_TOOLS_MINIMIZE: iconPrefix + 'minimize',
  TOOLBAR_TOOLS_CUSTOM: iconPrefix + 'custom-column',
  TOOLBAR_TOOLS_FIXED_LEFT: iconPrefix + 'fixed-left',
  TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE: iconPrefix + 'fixed-left-fill',
  TOOLBAR_TOOLS_FIXED_RIGHT: iconPrefix + 'fixed-right',
  TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE: iconPrefix + 'fixed-right-fill'
});
const setTheme = core_.VxeUI.setTheme;
const getTheme = core_.VxeUI.getTheme;
const setConfig = core_.VxeUI.setConfig;
const ui_getConfig = core_.VxeUI.getConfig;
const setIcon = core_.VxeUI.setIcon;
const getIcon = core_.VxeUI.getIcon;
const setLanguage = core_.VxeUI.setLanguage;
const setI18n = core_.VxeUI.setI18n;
const getI18n = core_.VxeUI.getI18n;
const globalEvents = core_.VxeUI.globalEvents;
const globalResize = core_.VxeUI.globalResize;
const renderer = core_.VxeUI.renderer;
const validators = core_.VxeUI.validators;
const menus = core_.VxeUI.menus;
const formats = core_.VxeUI.formats;
const commands = core_.VxeUI.commands;
const interceptor = core_.VxeUI.interceptor;
const clipboard = core_.VxeUI.clipboard;
const log = core_.VxeUI.log;
const hooks = core_.VxeUI.hooks;
const use = core_.VxeUI.use;
/**
 * 
 * @deprecated
 */
const setup = options => {
  return core_.VxeUI.setConfig(options);
};
core_.VxeUI.setup = setup;
/**
 * 
 * @deprecated
 */
const config = options => {
  return core_.VxeUI.setConfig(options);
};
core_.VxeUI.config = config;
/**
 * 
 * @deprecated
 */
const t = (key, args) => {
  return core_.VxeUI.getI18n(key, args);
};
core_.VxeUI.t = t;
/**
 * 
 * @deprecated
 */
const _t = (content, args) => {
  return getFuncText(content, args);
};
core_.VxeUI._t = _t;
/**
 * 
 * @deprecated
 */
const VXETable = core_.VxeUI;
/**
 * 
 * @deprecated
 */
const saveFile = options => {
  return core_.VxeUI.saveFile(options);
};
/**
 * 
 * @deprecated
 */
const readFile = options => {
  return core_.VxeUI.readFile(options);
};
/**
 * 
 * @deprecated
 */
const print = options => {
  return core_.VxeUI.print(options);
};
/**
 * 
 * @deprecated
 */
const modal = {
  /**
   * 
   * @deprecated
   */
  get(id) {
    return core_.VxeUI.modal.get(id);
  },
  /**
   * 
   * @deprecated
   */
  close(id) {
    return core_.VxeUI.modal.close(id);
  },
  /**
   * 
   * @deprecated
   */
  open(options) {
    return core_.VxeUI.modal.open(options);
  },
  /**
   * 
   * @deprecated
   */
  alert(content, title, options) {
    return core_.VxeUI.modal.alert(content, title, options);
  },
  /**
   * 
   * @deprecated
   */
  confirm(content, title, options) {
    return core_.VxeUI.modal.confirm(content, title, options);
  },
  /**
   * 
   * @deprecated
   */
  message(content, options) {
    return core_.VxeUI.modal.message(content, options);
  },
  /**
   * 
   * @deprecated
   */
  notification(content, title, options) {
    return core_.VxeUI.modal.notification(content, title, options);
  }
};

/* harmony default export */ var ui = ((/* unused pure expression or super */ null && (VxeUI)));
// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__(9274);
;// ./packages/ui/src/comp.ts

const defineVxeComponent = external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent;
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__(4114);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.map.js
var esnext_iterator_map = __webpack_require__(1454);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.reduce.js
var esnext_iterator_reduce = __webpack_require__(8872);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.some.js
var esnext_iterator_some = __webpack_require__(7550);
;// ./packages/ui/src/log.ts

const {
  log: log_log
} = core_.VxeUI;
const log_version = `table v${"4.17.15"}`;
const warnLog = log_log.create('warn', log_version);
const errLog = log_log.create('error', log_version);
;// ./packages/table/src/columnInfo.ts





const {
  getI18n: columnInfo_getI18n,
  formats: columnInfo_formats,
  renderer: columnInfo_renderer
} = core_.VxeUI;
class ColumnInfo {
  /* eslint-disable @typescript-eslint/no-use-before-define */
  constructor($xeTable, _vm, {
    renderHeader,
    renderCell,
    renderFooter,
    renderData
  } = {}) {
    const tableProps = $xeTable.props;
    const $xeGrid = $xeTable.xeGrid;
    const $xeGantt = $xeTable.xeGantt;
    const $xeGGWrapper = $xeGrid || $xeGantt;
    const {
      field,
      editRender,
      filterRender,
      headerFormatter
    } = _vm;
    const colId = _vm.colId || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('col_');
    const formatter = _vm.formatter;
    const visible = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.visible) ? _vm.visible : true;
    const flCompConf = isEnableConf(filterRender) ? columnInfo_renderer.get(filterRender.name) : null;
    const ctFilterOptions = flCompConf ? flCompConf.createTableFilterOptions : null;
    const filters = toFilters(_vm.filters, colId);
    if (headerFormatter) {
      errLog('vxe.error.notProp', ['header-formatter']);
    }
    const types = ['seq', 'checkbox', 'radio', 'expand', 'html'];
    if (_vm.type && types.indexOf(_vm.type) === -1) {
      warnLog('vxe.error.errProp', [`type=${_vm.type}`, types.join(', ')]);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.cellRender) || _vm.cellRender && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(_vm.cellRender)) {
      warnLog('vxe.error.errProp', [`column.cell-render=${_vm.cellRender}`, 'column.cell-render={}']);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.editRender) || _vm.editRender && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(_vm.editRender)) {
      warnLog('vxe.error.errProp', [`column.edit-render=${_vm.editRender}`, 'column.edit-render={}']);
    }
    if (_vm.type === 'expand') {
      const {
        treeConfig
      } = tableProps;
      const {
        computeTreeOpts
      } = $xeTable.getComputeMaps();
      const treeOpts = computeTreeOpts.value;
      if (treeConfig && (treeOpts.showLine || treeOpts.line)) {
        errLog('vxe.error.errConflicts', ['tree-config.showLine', 'column.type=expand']);
      }
    }
    if (formatter) {
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(formatter)) {
        const gFormatOpts = columnInfo_formats.get(formatter) || (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default())[formatter];
        if (!gFormatOpts || !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
          errLog('vxe.error.notFormats', [formatter]);
        }
      } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(formatter)) {
        const gFormatOpts = columnInfo_formats.get(formatter[0]) || (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default())[formatter[0]];
        if (!gFormatOpts || !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
          errLog('vxe.error.notFormats', [formatter[0]]);
        }
      }
    }
    if (_vm.aggFunc) {
      if (!$xeTable.handlePivotTableAggregateData && _vm.aggFunc !== true) {
        errLog('vxe.error.errProp', [`column.agg-func=${_vm.aggFunc}`, 'column.agg-func=true']);
      }
    }
    if (field && editRender) {
      if (editRender.startField && `${editRender.startField}`.indexOf(field) >= 0) {
        errLog('vxe.error.modelConflicts', [`field=${field}`, `edit-render.startField=${editRender.startField}`]);
      }
      if (editRender.endField && `${editRender.endField}`.indexOf(field) >= 0) {
        errLog('vxe.error.modelConflicts', [`field=${field}`, `edit-render.endField=${editRender.endField}`]);
      }
    }
    Object.assign(this, {
      // 
      type: _vm.type,
      property: _vm.field,
      field: field,
      title: _vm.title,
      width: _vm.width,
      minWidth: _vm.minWidth,
      maxWidth: _vm.maxWidth,
      resizable: _vm.resizable,
      fixed: _vm.fixed,
      align: _vm.align,
      headerAlign: _vm.headerAlign,
      footerAlign: _vm.footerAlign,
      showOverflow: _vm.showOverflow,
      showHeaderOverflow: _vm.showHeaderOverflow,
      showFooterOverflow: _vm.showFooterOverflow,
      className: _vm.className,
      headerClassName: _vm.headerClassName,
      footerClassName: _vm.footerClassName,
      formatter: formatter,
      headerFormatter: _vm.headerFormatter,
      footerFormatter: _vm.footerFormatter,
      padding: _vm.padding,
      verticalAlign: _vm.verticalAlign,
      sortable: _vm.sortable,
      sortBy: _vm.sortBy,
      sortType: _vm.sortType,
      filters: filters,
      filterMultiple: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.filterMultiple) ? _vm.filterMultiple : true,
      filterMethod: _vm.filterMethod,
      filterResetMethod: _vm.filterResetMethod,
      filterRecoverMethod: _vm.filterRecoverMethod,
      filterRender: filterRender,
      floatingFilters: _vm.floatingFilters,
      rowGroupNode: _vm.rowGroupNode,
      treeNode: _vm.treeNode,
      dragSort: _vm.dragSort,
      rowResize: _vm.rowResize,
      cellType: _vm.cellType,
      cellRender: _vm.cellRender,
      editRender: editRender,
      contentRender: _vm.contentRender,
      headerExportMethod: _vm.headerExportMethod,
      exportMethod: _vm.exportMethod,
      footerExportMethod: _vm.footerExportMethod,
      titleHelp: _vm.titleHelp,
      titlePrefix: _vm.titlePrefix,
      titleSuffix: _vm.titleSuffix,
      aggFunc: _vm.aggFunc,
      copyMethod: _vm.copyMethod,
      cutMethod: _vm.cutMethod,
      pasteMethod: _vm.pasteMethod,
      // 
      params: _vm.params,
      // 
      id: colId,
      parentId: null,
      visible,
      // 
      defaultParentId: null,
      halfVisible: false,
      defaultVisible: visible,
      defaultFixed: _vm.fixed,
      defaultAggGroup: _vm.aggGroup,
      defaultAggFunc: _vm.aggFunc,
      checked: false,
      halfChecked: false,
      disabled: false,
      // 
      level: 1,
      // 
      rowSpan: 1,
      // 
      colSpan: 1,
      // 
      order: null,
      sortTime: 0,
      // 
      sortNumber: 0,
      renderSortNumber: 0,
      renderAggFn: '',
      renderFixed: '',
      renderVisible: false,
      renderWidth: 0,
      renderHeight: 0,
      renderResizeWidth: 0,
      renderAutoWidth: 0,
      resizeWidth: 0,
      renderLeft: 0,
      renderArgs: [],
      model: {},
      renderHeader: renderHeader || _vm.renderHeader,
      renderCell: renderCell || _vm.renderCell,
      renderFooter: renderFooter || _vm.renderFooter,
      renderData: renderData,
      //  grid 
      slots: _vm.slots
    });
    if (ctFilterOptions && (!filters || !filters.length)) {
      this.filters = toFilters(ctFilterOptions({
        $table: $xeTable,
        column: this
      }), colId);
    }
    if ($xeGGWrapper) {
      const {
        computeProxyOpts
      } = $xeGGWrapper.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      if (proxyOpts.beforeColumn) {
        proxyOpts.beforeColumn({
          $table: $xeTable,
          $grid: $xeGrid,
          $gantt: $xeGantt,
          column: this
        });
      }
    }
  }
  getTitle() {
    return getFuncText(this.title || (this.type === 'seq' ? columnInfo_getI18n('vxe.table.seqTitle') : ''));
  }
  getKey() {
    const {
      type
    } = this;
    return this.field || (type ? `type=${type}` : null);
  }
  update(name, value) {
    // 
    if (name !== 'filters') {
      if (name === 'field') {
        // 
        this.property = value;
      }
      this[name] = value;
    }
  }
}
;// ./packages/ui/src/dom.ts

const reClsMap = {};
let tpImgEl;
function initTpImg() {
  if (!tpImgEl) {
    tpImgEl = new Image();
    tpImgEl.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
  }
  return tpImgEl;
}
function getTpImg() {
  if (!tpImgEl) {
    return initTpImg();
  }
  return tpImgEl;
}
function getPropClass(property, params) {
  return property ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(property) ? property(params) : property : '';
}
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, 'g');
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function isPx(val) {
  return val && /^\d+(px)?$/.test(val);
}
function isScale(val) {
  return val && /^\d+%$/.test(val);
}
function hasClass(elem, cls) {
  return !!(elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls)));
}
function removeClass(elem, cls) {
  if (elem && hasClass(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), '');
  }
}
function addClass(elem, cls) {
  if (elem && !hasClass(elem, cls)) {
    removeClass(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function hasControlKey(evnt) {
  return evnt.ctrlKey || evnt.metaKey;
}
function toCssUnit(val, unit = 'px') {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(val) || /^\d+$/.test(`${val}`)) {
    return `${val}${unit}`;
  }
  return `${val || ''}`;
}
function queryElement(elem, selector) {
  if (elem) {
    return elem.querySelector(selector);
  }
  return null;
}
function getDomNode() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
function getOffsetHeight(elem) {
  return elem ? elem.offsetHeight : 0;
}
function getPaddingTopBottomSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingTop);
    const paddingBottom = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingBottom);
    return paddingTop + paddingBottom;
  }
  return 0;
}
function setScrollTop(elem, scrollTop) {
  if (elem) {
    elem.scrollTop = scrollTop;
  }
}
function setScrollLeft(elem, scrollLeft) {
  if (elem) {
    elem.scrollLeft = scrollLeft;
  }
}
// export function setScrollLeftAndTop (elem: HTMLElement | null, scrollLeft: number, scrollTop: number) {
//   if (elem) {
//     elem.scrollLeft = scrollLeft
//     elem.scrollTop = scrollTop
//   }
// }
function updateCellTitle(overflowElem, column) {
  const content = column.type === 'html' ? overflowElem.innerText : overflowElem.textContent;
  if (overflowElem.getAttribute('title') !== content) {
    overflowElem.setAttribute('title', content);
  }
}
function checkTargetElement(target, exEls, endEl) {
  let targetEl = target;
  if (!exEls || !exEls.length) {
    return false;
  }
  const [exEl1, exEl2, exEl3] = exEls;
  while (targetEl) {
    if (exEl1 === targetEl || exEl2 && targetEl === exEl2 || exEl3 && targetEl === exEl3) {
      return true;
    }
    if (endEl && targetEl === endEl) {
      return false;
    }
    targetEl = targetEl.parentElement;
  }
  return false;
}
/**
 * 
 */
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return {
        flag: queryCls ? !!targetElem : true,
        container,
        targetElem: targetElem
      };
    }
    target = target.parentNode;
  }
  return {
    flag: false
  };
}
/**
 *  document 
 */
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, {
    left: 0,
    top: 0
  });
}
function getAbsolutePos(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const {
    scrollTop,
    scrollLeft,
    visibleHeight,
    visibleWidth
  } = getDomNode();
  return {
    boundingTop,
    top: scrollTop + boundingTop,
    boundingLeft,
    left: scrollLeft + boundingLeft,
    visibleHeight,
    visibleWidth
  };
}
const scrollIntoViewIfNeeded = 'scrollIntoViewIfNeeded';
const scrollIntoView = 'scrollIntoView';
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}
function triggerEvent(targetElem, type) {
  if (targetElem) {
    targetElem.dispatchEvent(new Event(type));
  }
}
function isNodeElement(elem) {
  return elem && elem.nodeType === 1;
}
;// ./packages/table/src/util.ts











function createInternalData() {
  return {
    tZindex: 0,
    currKeyField: '',
    isCurrDeepKey: false,
    elemStore: {},
    //  X 
    scrollXStore: {
      preloadSize: 0,
      offsetSize: 0,
      visibleSize: 0,
      visibleStartIndex: 0,
      visibleEndIndex: 0,
      startIndex: 0,
      endIndex: 0
    },
    //  Y 
    scrollYStore: {
      preloadSize: 0,
      offsetSize: 0,
      visibleSize: 0,
      visibleStartIndex: 0,
      visibleEndIndex: 0,
      startIndex: 0,
      endIndex: 0
    },
    // 
    tableWidth: 0,
    // 
    tableHeight: 0,
    customHeight: 0,
    customMinHeight: 0,
    customMaxHeight: 0,
    //  hover 
    hoverRow: null,
    // 
    lastScrollLeft: 0,
    lastScrollTop: 0,
    // 
    radioReserveRow: null,
    // 
    checkboxReserveRowMap: {},
    // 
    rowExpandedReserveRowMap: {},
    // 
    treeExpandedReserveRowMap: {},
    // 
    treeIndeterminateRowMaps: {},
    // 
    tableFullData: [],
    afterFullData: [],
    afterTreeFullData: [],
    afterGroupFullData: [],
    // 
    afterFullRowMaps: {},
    // 
    tableFullTreeData: [],
    // 
    tableFullGroupData: [],
    tableSynchData: [],
    tableSourceData: [],
    // 
    collectColumn: [],
    // 
    tableFullColumn: [],
    // 
    visibleColumn: [],
    // 
    fullAllDataRowIdData: {},
    // 
    fullDataRowIdData: {},
    // 
    visibleDataRowIdData: {},
    footerFullDataRowData: {},
    // 
    sourceDataRowIdData: {},
    fullColumnIdData: {},
    fullColumnFieldData: {},
    // 
    mergeHeaderList: [],
    mergeHeaderMaps: {},
    // 
    mergeHeaderCellMaps: {},
    // 
    mergeBodyList: [],
    mergeBodyMaps: {},
    // 
    mergeBodyCellMaps: {},
    // 
    mergeFooterList: [],
    mergeFooterMaps: {},
    // 
    mergeFooterCellMaps: {},
    // 
    rowExpandedMaps: {},
    // 
    rowExpandLazyLoadedMaps: {},
    // 
    rowGroupExpandedMaps: {},
    // 
    treeExpandedMaps: {},
    // 
    treeExpandLazyLoadedMaps: {},
    // 
    selectCheckboxMaps: {},
    // 
    pendingRowMaps: {},
    // 
    insertRowMaps: {},
    // 
    removeRowMaps: {},
    cvCacheMaps: {},
    // 
    tHeaderHeight: 0,
    // 
    tBodyHeight: 0,
    // 
    tFooterHeight: 0,
    teleportToWrapperElem: null,
    popupToWrapperElem: null,
    inited: false,
    tooltipTimeout: null,
    initStatus: false,
    isActivated: false
  };
}
const getAllConvertColumns = (columns, parentColumn) => {
  const result = [];
  columns.forEach(column => {
    column.parentId = parentColumn ? parentColumn.id : null;
    if (column.visible) {
      if (column.children && column.children.length && column.children.some(column => column.visible)) {
        result.push(column);
        result.push(...getAllConvertColumns(column.children, column));
      } else {
        result.push(column);
      }
    }
  });
  return result;
};
const convertHeaderColumnToRows = originColumns => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column.level = parent.level + 1;
      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }
    if (column.children && column.children.length && column.children.some(column => column.visible)) {
      let colSpan = 0;
      column.children.forEach(subColumn => {
        if (subColumn.visible) {
          traverse(subColumn, column);
          colSpan += subColumn.colSpan;
        }
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };
  originColumns.forEach(column => {
    column.level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getAllConvertColumns(originColumns);
  allColumns.forEach(column => {
    if (column.children && column.children.length && column.children.some(column => column.visible)) {
      column.rowSpan = 1;
    } else {
      column.rowSpan = maxLevel - column.level + 1;
    }
    rows[column.level - 1].push(column);
  });
  return rows;
};
function convertHeaderToGridRows(spanColumns) {
  const rSize = spanColumns.length;
  const cSize = spanColumns[0].reduce((sum, cell) => sum + cell.colSpan, 0);
  const occupiedRows = [];
  const fullRows = [];
  for (let rIndex = 0; rIndex < rSize; rIndex++) {
    const oCols = [];
    const dCols = [];
    for (let cIndex = 0; cIndex < cSize; cIndex++) {
      oCols.push(false);
      dCols.push('');
    }
    occupiedRows.push(oCols);
    fullRows.push(dCols);
  }
  for (let rIndex = 0; rIndex < rSize; rIndex++) {
    let currColIndex = 0;
    for (const column of spanColumns[rIndex]) {
      const {
        colSpan,
        rowSpan
      } = column;
      let startColIndex = -1;
      for (let ccIndex = currColIndex; ccIndex <= cSize - colSpan; ccIndex++) {
        let oFlag = true;
        for (let csIndex = 0; csIndex < colSpan; csIndex++) {
          if (occupiedRows[rIndex][ccIndex + csIndex]) {
            oFlag = false;
            break;
          }
        }
        if (oFlag) {
          startColIndex = ccIndex;
          break;
        }
      }
      if (startColIndex === -1) {
        for (let j = 0; j <= cSize - colSpan; j++) {
          let oFlag = true;
          for (let k = 0; k < colSpan; k++) {
            if (occupiedRows[rIndex][j + k]) {
              oFlag = false;
              break;
            }
          }
          if (oFlag) {
            startColIndex = j;
            break;
          }
        }
        if (startColIndex === -1) {
          // error
          break;
        }
      }
      for (let srIndex = rIndex; srIndex < rIndex + rowSpan; srIndex++) {
        for (let scIndex = startColIndex; scIndex < startColIndex + colSpan; scIndex++) {
          occupiedRows[srIndex][scIndex] = true;
          fullRows[srIndex][scIndex] = column;
        }
      }
      currColIndex = startColIndex + colSpan;
    }
  }
  return fullRows;
}
function restoreScrollLocation($xeTable, scrollLeft, scrollTop) {
  const internalData = $xeTable.internalData;
  if (scrollLeft || scrollTop) {
    internalData.intoRunScroll = false;
    internalData.inVirtualScroll = false;
    internalData.inWheelScroll = false;
    internalData.inHeaderScroll = false;
    internalData.inBodyScroll = false;
    internalData.inFooterScroll = false;
    internalData.scrollRenderType = '';
    // 
    return $xeTable.scrollTo(scrollLeft, scrollTop);
  }
  return $xeTable.clearScroll();
}
/**
 * 
 */
function getRowUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('row_');
}
function hasDeepKey(rowKey) {
  return rowKey.indexOf('.') > -1;
}
//  key
function getRowkey($xeTable) {
  const {
    currKeyField
  } = $xeTable.internalData;
  return currKeyField;
}
//  value
function getRowid($xeTable, row) {
  const internalData = $xeTable.internalData;
  const {
    isCurrDeepKey,
    currKeyField
  } = internalData;
  return row ? encodeRowid((isCurrDeepKey ? getDeepRowIdByKey : getFastRowIdByKey)(row, currKeyField)) : '';
}
function createHandleUpdateRowId($xeTable) {
  const internalData = $xeTable.internalData;
  const {
    isCurrDeepKey,
    currKeyField
  } = internalData;
  const updateRId = isCurrDeepKey ? updateDeepRowKey : updateFastRowKey;
  return {
    rowKey: currKeyField,
    handleUpdateRowId(row) {
      return row ? updateRId(row, currKeyField) : '';
    }
  };
}
function createHandleGetRowId($xeTable) {
  const internalData = $xeTable.internalData;
  const {
    isCurrDeepKey,
    currKeyField
  } = internalData;
  const getRId = isCurrDeepKey ? getDeepRowIdByKey : getFastRowIdByKey;
  return {
    rowKey: currKeyField,
    handleGetRowId(row) {
      return row ? encodeRowid(getRId(row, currKeyField)) : '';
    }
  };
}
// 
function encodeRowid(rowVal) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(rowVal) ? '' : encodeURIComponent(rowVal);
}
function getDeepRowIdByKey(row, rowKey) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, rowKey);
}
function updateDeepRowKey(row, rowKey) {
  let rowid = encodeRowid(getDeepRowIdByKey(row, rowKey));
  if (eqEmptyValue(rowid)) {
    rowid = getRowUniqueId();
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, rowKey, rowid);
  }
  return rowid;
}
function getFastRowIdByKey(row, rowKey) {
  return row[rowKey];
}
function updateFastRowKey(row, rowKey) {
  let rowid = encodeRowid(getFastRowIdByKey(row, rowKey));
  if (eqEmptyValue(rowid)) {
    rowid = getRowUniqueId();
    row[rowKey] = rowid;
  }
  return rowid;
}
function handleFieldOrColumn($xeTable, fieldOrColumn) {
  if (fieldOrColumn) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(fieldOrColumn) ? $xeTable.getColumnByField(`${fieldOrColumn}`) : fieldOrColumn;
  }
  return null;
}
function handleRowidOrRow($xeTable, rowidOrRow) {
  if (rowidOrRow) {
    const rowid = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowidOrRow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(rowidOrRow) ? rowidOrRow : getRowid($xeTable, rowidOrRow);
    return $xeTable.getRowById(rowid);
  }
  return null;
}
function getCellRestHeight(rowRest, cellOpts, rowOpts, defaultRowHeight) {
  return rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
}
function getPaddingLeftRightSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingLeft);
    const paddingRight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingRight);
    return paddingLeft + paddingRight;
  }
  return 0;
}
function getElementMarginAndWidth(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const marginLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.marginLeft);
    const marginRight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.marginRight);
    return elem.offsetWidth + marginLeft + marginRight;
  }
  return 0;
}
function toFilters(filters, colid) {
  if (filters) {
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(filters)) {
      return filters.map(({
        label,
        value,
        data,
        resetValue,
        checked
      }) => {
        return {
          label,
          value,
          data,
          resetValue,
          checked: !!checked,
          _checked: !!checked,
          _colId: colid
        };
      });
    }
    return [];
  }
  return filters;
}
function toTreePathSeq(path) {
  return path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : '.').join('');
}
function getCellValue(row, column) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
}
function setCellValue(row, column, value) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, column.field, value);
}
function getRefElem(refEl) {
  if (refEl) {
    const rest = refEl.value;
    if (rest) {
      return rest.$el || rest;
    }
  }
  return null;
}
function getCalcHeight(height) {
  if (height === 'unset') {
    return 0;
  }
  return height || 0;
}
/**
 * 
 * @param params
 * @returns
 */
function getColReMaxWidth(params) {
  const {
    $table
  } = params;
  const {
    computeResizableOpts
  } = $table.getComputeMaps();
  const resizableOpts = computeResizableOpts.value;
  const {
    maxWidth: reMaxWidth
  } = resizableOpts;
  // 
  if (reMaxWidth) {
    const customMaxWidth = XEUtils.isFunction(reMaxWidth) ? reMaxWidth(params) : reMaxWidth;
    if (customMaxWidth !== 'auto') {
      return Math.max(1, XEUtils.toNumber(customMaxWidth));
    }
  }
  return -1;
}
/**
 * 
 * @param params
 * @returns
 */
function getColReMinWidth(params) {
  const {
    $table,
    column,
    cell
  } = params;
  const tableProps = $table.props;
  const internalData = $table.internalData;
  const {
    computeResizableOpts
  } = $table.getComputeMaps();
  const resizableOpts = computeResizableOpts.value;
  const {
    minWidth: reMinWidth
  } = resizableOpts;
  // 
  if (reMinWidth) {
    const customMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(reMinWidth) ? reMinWidth(params) : reMinWidth;
    if (customMinWidth !== 'auto') {
      return Math.max(1, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(customMinWidth));
    }
  }
  const {
    elemStore
  } = internalData;
  const {
    showHeaderOverflow: allColumnHeaderOverflow
  } = tableProps;
  const {
    showHeaderOverflow,
    minWidth: colMinWidth
  } = column;
  const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showHeaderOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showEllipsis = headOverflow === 'ellipsis';
  const showTitle = headOverflow === 'title';
  const showTooltip = headOverflow === true || headOverflow === 'tooltip';
  const hasEllipsis = showTitle || showTooltip || showEllipsis;
  const minTitleWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getComputedStyle(cell).fontSize) || 14) * 1.8);
  const paddingLeftRight = getPaddingLeftRightSize(cell) + getPaddingLeftRightSize(queryElement(cell, '.vxe-cell'));
  let mWidth = minTitleWidth + paddingLeftRight;
  // 
  if (hasEllipsis) {
    const dragIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell--drag-handle'));
    const checkboxIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell--checkbox'));
    const requiredIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell--required-icon'));
    const editIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell--edit-icon'));
    const prefixIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell-title-prefix-icon'));
    const suffixIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell-title-suffix-icon'));
    const sortIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell--sort'));
    const filterIconWidth = getElementMarginAndWidth(queryElement(cell, '.vxe-cell--filter'));
    mWidth += dragIconWidth + checkboxIconWidth + requiredIconWidth + editIconWidth + prefixIconWidth + suffixIconWidth + filterIconWidth + sortIconWidth;
  }
  // 
  if (colMinWidth) {
    const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
    if (bodyScrollElem) {
      if (isScale(colMinWidth)) {
        const bodyWidth = bodyScrollElem.clientWidth - 1;
        const meanWidth = bodyWidth / 100;
        return Math.max(mWidth, Math.floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(colMinWidth) * meanWidth));
      } else if (isPx(colMinWidth)) {
        return Math.max(mWidth, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(colMinWidth));
      }
    }
  }
  return mWidth;
}
function isColumnInfo(column) {
  return column && (column.constructor === ColumnInfo || column instanceof ColumnInfo);
}
// 
function getColumnList(columns) {
  const result = [];
  columns.forEach(column => {
    result.push(...(column.children && column.children.length ? getColumnList(column.children) : [column]));
  });
  return result;
}
function createColumn($xeTable, options, renderOptions) {
  return isColumnInfo(options) ? options : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(new ColumnInfo($xeTable, options, renderOptions));
}
function watchColumn($xeTable, props, column) {
  Object.keys(props).forEach(name => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props[name], value => {
      column.update(name, value);
      if ($xeTable) {
        if (name === 'filters') {
          $xeTable.setFilter(column, value);
          $xeTable.handleUpdateDataQueue();
        } else if (['visible', 'fixed', 'width', 'minWidth', 'maxWidth'].includes(name)) {
          $xeTable.handleRefreshColumnQueue();
        }
      }
    });
  });
}
function assembleColumn($xeTable, elem, column, colgroup) {
  const {
    reactData
  } = $xeTable;
  const {
    staticColumns
  } = reactData;
  const parentElem = elem.parentNode;
  const parentColumn = colgroup ? colgroup.columnConfig : null;
  const parentCols = parentColumn ? parentColumn.children : staticColumns;
  if (parentElem && parentCols) {
    column.defaultParentId = parentColumn ? parentColumn.id : null;
    parentCols.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, column);
    reactData.staticColumns = staticColumns.slice(0);
  }
}
function destroyColumn($xeTable, column) {
  const {
    reactData
  } = $xeTable;
  const {
    staticColumns
  } = reactData;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticColumns, item => item.id === column.id, {
    children: 'children'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticColumns = staticColumns.slice(0);
}
function getRootColumn($xeTable, column) {
  const {
    internalData
  } = $xeTable;
  const {
    fullColumnIdData
  } = internalData;
  if (!column) {
    return null;
  }
  let parentColId = column.parentId;
  while (fullColumnIdData[parentColId]) {
    const column = fullColumnIdData[parentColId].column;
    parentColId = column.parentId;
    if (!parentColId) {
      return column;
    }
  }
  return column;
}
function getFirstChildColumn(column) {
  const {
    children
  } = column;
  if (children && children.length) {
    return getFirstChildColumn(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().first(children));
  }
  return column;
}
function getLastChildColumn(column) {
  const {
    children
  } = column;
  if (children && children.length) {
    return getFirstChildColumn(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().last(children));
  }
  return column;
}
function clearTableDefaultStatus($xeTable) {
  const {
    props,
    internalData
  } = $xeTable;
  internalData.initStatus = false;
  const actionList = [$xeTable.clearSort(), $xeTable.clearCurrentRow(), $xeTable.clearCurrentColumn(), $xeTable.clearRadioRow(), $xeTable.clearRadioReserve(), $xeTable.clearCheckboxRow(), $xeTable.clearCheckboxReserve(), $xeTable.clearRowExpand(), $xeTable.clearTreeExpand(), $xeTable.clearTreeExpandReserve(), $xeTable.clearPendingRow()];
  if ($xeTable.clearFilter) {
    actionList.push($xeTable.clearFilter());
  }
  if ($xeTable.clearSelected && (props.keyboardConfig || props.mouseConfig)) {
    actionList.push($xeTable.clearSelected());
  }
  if ($xeTable.clearCellAreas && props.mouseConfig) {
    actionList.push($xeTable.clearCellAreas(), $xeTable.clearCopyCellArea());
  }
  return Promise.all(actionList).then(() => {
    return $xeTable.clearScroll();
  });
}
function clearTableAllStatus($xeTable) {
  if ($xeTable.clearFilter) {
    $xeTable.clearFilter();
  }
  return clearTableDefaultStatus($xeTable);
}
function rowToVisible($xeTable, row) {
  const tableProps = $xeTable.props;
  const reactData = $xeTable.reactData;
  const internalData = $xeTable.internalData;
  const {
    computeLeftFixedWidth,
    computeRightFixedWidth,
    computeRowOpts,
    computeCellOpts,
    computeDefaultRowHeight
  } = $xeTable.getComputeMaps();
  const {
    showOverflow
  } = tableProps;
  const {
    scrollYLoad,
    scrollYTop
  } = reactData;
  const {
    elemStore,
    afterFullData,
    fullAllDataRowIdData,
    isResizeCellHeight
  } = internalData;
  const rowOpts = computeRowOpts.value;
  const cellOpts = computeCellOpts.value;
  const defaultRowHeight = computeDefaultRowHeight.value;
  const leftFixedWidth = computeLeftFixedWidth.value;
  const rightFixedWidth = computeRightFixedWidth.value;
  const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
  const rowid = getRowid($xeTable, row);
  if (bodyScrollElem) {
    const bodyHeight = bodyScrollElem.clientHeight;
    const bodyScrollTop = bodyScrollElem.scrollTop;
    const trElem = bodyScrollElem.querySelector(`[rowid="${rowid}"]`);
    if (trElem) {
      const trOffsetTop = trElem.offsetTop + (scrollYLoad ? scrollYTop : 0);
      const trHeight = trElem.clientHeight;
      // 
      if (trOffsetTop < bodyScrollTop || trOffsetTop > bodyScrollTop + bodyHeight) {
        return $xeTable.scrollTo(null, trOffsetTop);
      } else if (trOffsetTop + trHeight >= bodyHeight + bodyScrollTop) {
        return $xeTable.scrollTo(null, bodyScrollTop + trHeight);
      }
    } else {
      // 
      if (scrollYLoad) {
        const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
        if (!isCustomCellHeight && showOverflow) {
          return $xeTable.scrollTo(null, ($xeTable.findRowIndexOf(afterFullData, row) - 1) * defaultRowHeight);
        }
        const rowRest = fullAllDataRowIdData[rowid] || {};
        const rHeight = rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
        const scrollTop = rowRest.oTop;
        if (scrollTop < bodyScrollTop) {
          return $xeTable.scrollTo(null, scrollTop - leftFixedWidth - 1);
        }
        return $xeTable.scrollTo(null, scrollTop + rHeight - (bodyHeight - rightFixedWidth - 1));
      }
    }
  }
  return Promise.resolve();
}
function colToVisible($xeTable, column, row) {
  const reactData = $xeTable.reactData;
  const internalData = $xeTable.internalData;
  const {
    computeLeftFixedWidth,
    computeRightFixedWidth
  } = $xeTable.getComputeMaps();
  const {
    scrollXLoad,
    scrollXLeft
  } = reactData;
  const {
    elemStore,
    visibleColumn
  } = internalData;
  const leftFixedWidth = computeLeftFixedWidth.value;
  const rightFixedWidth = computeRightFixedWidth.value;
  const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
  if (column.fixed) {
    return Promise.resolve();
  }
  if (bodyScrollElem) {
    const bodyWidth = bodyScrollElem.clientWidth;
    const bodyScrollLeft = bodyScrollElem.scrollLeft;
    let tdElem = null;
    if (row) {
      const rowid = getRowid($xeTable, row);
      tdElem = bodyScrollElem.querySelector(`[rowid="${rowid}"] .${column.id}`);
    }
    if (!tdElem) {
      tdElem = bodyScrollElem.querySelector(`.${column.id}`);
    }
    if (tdElem) {
      const tdOffsetLeft = tdElem.offsetLeft + (scrollXLoad ? scrollXLeft : 0);
      const cellWidth = tdElem.clientWidth;
      // 
      if (tdOffsetLeft < bodyScrollLeft + leftFixedWidth) {
        return $xeTable.scrollTo(tdOffsetLeft - leftFixedWidth - 1);
      } else if (tdOffsetLeft + cellWidth - bodyScrollLeft > bodyWidth - rightFixedWidth) {
        return $xeTable.scrollTo(tdOffsetLeft + cellWidth - (bodyWidth - rightFixedWidth - 1));
      }
    } else {
      // 
      if (scrollXLoad) {
        let scrollLeft = 0;
        const cellWidth = column.renderWidth;
        for (let i = 0; i < visibleColumn.length; i++) {
          const currCol = visibleColumn[i];
          if (currCol === column || currCol.id === column.id) {
            break;
          }
          scrollLeft += currCol.renderWidth;
        }
        if (scrollLeft < bodyScrollLeft) {
          return $xeTable.scrollTo(scrollLeft - leftFixedWidth - 1);
        }
        return $xeTable.scrollTo(scrollLeft + cellWidth - (bodyWidth - rightFixedWidth - 1));
      }
    }
  }
  return Promise.resolve();
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.every.js
var esnext_iterator_every = __webpack_require__(3215);
;// ./packages/ui/src/vn.ts

function getOnName(type) {
  return 'on' + type.substring(0, 1).toLocaleUpperCase() + type.substring(1);
}
function getModelEvent(renderOpts) {
  switch (renderOpts.name) {
    case 'input':
    case 'textarea':
      return 'input';
    case 'select':
      return 'change';
  }
  return 'update:modelValue';
}
function getChangeEvent(renderOpts) {
  switch (renderOpts.name) {
    case 'input':
    case 'textarea':
    case 'VxeInput':
    case 'VxeNumberInput':
    case 'VxeTextarea':
    case '$input':
    case '$textarea':
      return 'input';
  }
  return 'change';
}
function hasInputType(renderOpts) {
  switch (renderOpts.name) {
    case 'VxeInput':
    case 'VxeNumberInput':
    case 'VxeTextarea':
    case '$input':
    case '$textarea':
      return true;
  }
  return false;
}
function getSlotVNs(vns) {
  if (vns === null || vns === undefined) {
    return [];
  }
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(vns)) {
    return vns;
  }
  return [vns];
}
;// ./packages/table/src/cell.ts











const {
  getI18n: cell_getI18n,
  getIcon: cell_getIcon,
  renderer: cell_renderer,
  renderEmptyElement
} = core_.VxeUI;
function renderTitlePrefixIcon(params) {
  const {
    $table,
    column
  } = params;
  const titlePrefix = column.titlePrefix || column.titleHelp;
  if (titlePrefix) {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell-title-prefix-icon', titlePrefix.iconStatus ? `theme--${titlePrefix.iconStatus}` : ''],
      onMouseenter(evnt) {
        $table.triggerHeaderTitleEvent(evnt, titlePrefix, params);
      },
      onMouseleave(evnt) {
        $table.handleTargetLeaveEvent(evnt);
      }
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: titlePrefix.icon || cell_getIcon().TABLE_TITLE_PREFIX
    })]);
  }
  return renderEmptyElement($table);
}
function renderTitleSuffixIcon(params) {
  const {
    $table,
    column
  } = params;
  const titleSuffix = column.titleSuffix;
  if (titleSuffix) {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell-title-suffix-icon', titleSuffix.iconStatus ? `theme--${titleSuffix.iconStatus}` : ''],
      onMouseenter(evnt) {
        $table.triggerHeaderTitleEvent(evnt, titleSuffix, params);
      },
      onMouseleave(evnt) {
        $table.handleTargetLeaveEvent(evnt);
      }
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: titleSuffix.icon || cell_getIcon().TABLE_TITLE_SUFFIX
    })]);
  }
  return renderEmptyElement($table);
}
function renderCellDragIcon(params) {
  const {
    $table,
    column
  } = params;
  const {
    context
  } = $table;
  const tableSlots = context.slots;
  const tableProps = $table.props;
  const {
    slots
  } = column;
  const {
    dragConfig
  } = tableProps;
  const {
    computeRowDragOpts
  } = $table.getComputeMaps();
  const rowDragOpts = computeRowDragOpts.value;
  const {
    icon,
    trigger,
    disabledMethod
  } = rowDragOpts;
  const rDisabledMethod = disabledMethod || (dragConfig ? dragConfig.rowDisabledMethod : null);
  const isDisabled = rDisabledMethod && rDisabledMethod(params);
  const rowDragIconSlot = (slots ? slots.rowDragIcon || slots['row-drag-icon'] : null) || tableSlots.rowDragIcon || tableSlots['row-drag-icon'];
  const ons = {};
  if (trigger !== 'cell') {
    ons.onMousedown = evnt => {
      if (!isDisabled) {
        $table.handleCellDragMousedownEvent(evnt, params);
      }
    };
    ons.onMouseup = $table.handleCellDragMouseupEvent;
  }
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    key: 'dg',
    class: ['vxe-cell--drag-handle', {
      'is--disabled': isDisabled
    }],
    ...ons
  }, rowDragIconSlot ? $table.callSlot(rowDragIconSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
    class: icon || (dragConfig ? dragConfig.rowIcon : '') || cell_getIcon().TABLE_DRAG_ROW
  })]);
}
function renderCellBaseVNs(params, content) {
  const {
    $table,
    column,
    level
  } = params;
  const {
    dragSort
  } = column;
  const tableProps = $table.props;
  const {
    treeConfig,
    dragConfig
  } = tableProps;
  const {
    computeRowOpts,
    computeRowDragOpts,
    computeTreeOpts
  } = $table.getComputeMaps();
  const rowOpts = computeRowOpts.value;
  const rowDragOpts = computeRowDragOpts.value;
  const treeOpts = computeTreeOpts.value;
  const {
    showIcon,
    isPeerDrag,
    isCrossDrag,
    visibleMethod
  } = rowDragOpts;
  const rVisibleMethod = visibleMethod || (dragConfig ? dragConfig.rowVisibleMethod : null);
  const vns = [];
  if (dragSort && rowOpts.drag && (showIcon || (dragConfig ? dragConfig.showRowIcon : false)) && (!rVisibleMethod || rVisibleMethod(params))) {
    if (treeConfig) {
      if (treeOpts.transform && (isPeerDrag || isCrossDrag || !level)) {
        vns.push(renderCellDragIcon(params));
      }
    } else {
      vns.push(renderCellDragIcon(params));
    }
  }
  return vns.concat(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(content) ? content : [content]);
}
function renderHeaderCellDragIcon(params) {
  const {
    $table,
    column
  } = params;
  const {
    context
  } = $table;
  const tableSlots = context.slots;
  const {
    slots
  } = column;
  const {
    computeColumnOpts,
    computeColumnDragOpts
  } = $table.getComputeMaps();
  const columnOpts = computeColumnOpts.value;
  const columnDragOpts = computeColumnDragOpts.value;
  const {
    showIcon,
    icon,
    trigger,
    isPeerDrag,
    isCrossDrag,
    visibleMethod,
    disabledMethod
  } = columnDragOpts;
  if (columnOpts.drag && showIcon && (!visibleMethod || visibleMethod(params))) {
    if (!column.fixed && (isPeerDrag || isCrossDrag || !column.parentId)) {
      const isDisabled = disabledMethod && disabledMethod(params);
      const columnDragIconSlot = (slots ? slots.columnDragIcon || slots['column-drag-icon'] : null) || tableSlots.columnDragIcon || tableSlots['column-drag-icon'];
      const ons = {};
      if (trigger !== 'cell') {
        ons.onMousedown = evnt => {
          if (!isDisabled) {
            $table.handleHeaderCellDragMousedownEvent(evnt, params);
          }
        };
        ons.onMouseup = $table.handleHeaderCellDragMouseupEvent;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        key: 'dg',
        class: ['vxe-cell--drag-handle', {
          'is--disabled': isDisabled
        }],
        ...ons
      }, columnDragIconSlot ? $table.callSlot(columnDragIconSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon || cell_getIcon().TABLE_DRAG_COLUMN
      })]);
    }
  }
  return renderEmptyElement($table);
}
function renderHeaderCellBaseVNs(params, content) {
  const vns = [renderTitlePrefixIcon(params), renderHeaderCellDragIcon(params), ...(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(content) ? content : [content]), renderTitleSuffixIcon(params)];
  return vns;
}
function getRenderDefaultColumnTitle(column, content) {
  if (column.type === 'html' && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(content)) {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      key: 'ch',
      innerHTML: content
    });
  }
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    key: 'ct'
  }, getSlotVNs(content));
}
function renderTitleContent(params, content) {
  const {
    $table,
    column
  } = params;
  const tableProps = $table.props;
  const tableReactData = $table.reactData;
  const {
    computeHeaderTooltipOpts
  } = $table.getComputeMaps();
  const {
    showHeaderOverflow: allColumnHeaderOverflow
  } = tableProps;
  const {
    isRowGroupStatus
  } = tableReactData;
  const {
    showHeaderOverflow,
    slots
  } = column;
  const titleSlot = slots ? slots.title : null;
  const headerTooltipOpts = computeHeaderTooltipOpts.value;
  const showAllTip = headerTooltipOpts.showAll;
  const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showTitle = headOverflow === 'title';
  const showTooltip = headOverflow === true || headOverflow === 'tooltip';
  const ons = {};
  if (showTitle || showTooltip || showAllTip) {
    ons.onMouseenter = evnt => {
      if (tableReactData.isDragResize) {
        return;
      }
      if (showTitle) {
        updateCellTitle(evnt.currentTarget, column);
      } else if (showTooltip || showAllTip) {
        $table.triggerHeaderTooltipEvent(evnt, params);
      }
    };
  }
  if (showTooltip || showAllTip) {
    ons.onMouseleave = evnt => {
      if (tableReactData.isDragResize) {
        return;
      }
      if (showTooltip || showAllTip) {
        $table.handleTargetLeaveEvent(evnt);
      }
    };
  }
  const titleVN = getRenderDefaultColumnTitle(column, content);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-cell--title',
    ...ons
  }, isRowGroupStatus && column.aggFunc && $table.getPivotTableAggregateRenderColTitles ? $table.getPivotTableAggregateRenderColTitles(column, titleVN) : titleSlot ? $table.callSlot(titleSlot, params) : [titleVN])];
}
function getFooterContent(params) {
  const {
    $table,
    column,
    row
  } = params;
  const {
    slots,
    editRender,
    cellRender
  } = column;
  const renderOpts = editRender || cellRender;
  const footerSlot = slots ? slots.footer : null;
  if (footerSlot) {
    return $table.callSlot(footerSlot, params);
  }
  const itemValue = $table.getFooterCellLabel(row, column);
  if (renderOpts) {
    const compConf = cell_renderer.get(renderOpts.name);
    if (compConf) {
      const rtFooter = compConf.renderTableFooter || compConf.renderFooter;
      if (rtFooter) {
        const footParams = Object.assign(params, {
          cellValue: itemValue,
          itemValue
        });
        return getSlotVNs(rtFooter(renderOpts, footParams));
      }
    }
  }
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-cell--label'
  }, formatText(itemValue, 1))];
}
function getDefaultCellLabel(params) {
  const {
    $table,
    row,
    column
  } = params;
  return formatText($table.getCellLabel(row, column), 1);
}
function renderCellHandle(params) {
  const {
    column,
    row,
    $table
  } = params;
  const tableProps = $table.props;
  const tableReactData = $table.reactData;
  const {
    isRowGroupStatus
  } = tableReactData;
  const {
    editConfig
  } = tableProps;
  const {
    type,
    treeNode,
    rowGroupNode,
    editRender
  } = column;
  const {
    computeEditOpts,
    computeCheckboxOpts,
    computeAggregateOpts
  } = $table.getComputeMaps();
  const aggregateOpts = computeAggregateOpts.value;
  const {
    mode
  } = aggregateOpts;
  const checkboxOpts = computeCheckboxOpts.value;
  const editOpts = computeEditOpts.value;
  const isDeepCell = treeNode || isRowGroupStatus && (mode === 'column' ? column.field === row.groupField : rowGroupNode);
  switch (type) {
    case 'seq':
      return isDeepCell ? Cell.renderDeepIndexCell(params) : Cell.renderSeqCell(params);
    case 'radio':
      return isDeepCell ? Cell.renderDeepRadioCell(params) : Cell.renderRadioCell(params);
    case 'checkbox':
      return checkboxOpts.checkField ? isDeepCell ? Cell.renderDeepSelectionCellByProp(params) : Cell.renderCheckboxCellByProp(params) : isDeepCell ? Cell.renderDeepSelectionCell(params) : Cell.renderCheckboxCell(params);
    case 'expand':
      return Cell.renderExpandCell(params);
    case 'html':
      return isDeepCell ? Cell.renderDeepHTMLCell(params) : Cell.renderHTMLCell(params);
  }
  if (editConfig && isEnableConf(editOpts) && editRender) {
    return editOpts.mode === 'cell' ? isDeepCell ? Cell.renderDeepCellEdit(params) : Cell.renderCellEdit(params) : isDeepCell ? Cell.renderDeepRowEdit(params) : Cell.renderRowEdit(params);
  }
  return isDeepCell ? Cell.renderDeepCell(params) : Cell.renderDefaultCell(params);
}
function renderHeaderHandle(params) {
  const {
    column,
    $table
  } = params;
  const tableProps = $table.props;
  const {
    computeEditOpts
  } = $table.getComputeMaps();
  const {
    editConfig
  } = tableProps;
  const editOpts = computeEditOpts.value;
  const {
    type,
    filters,
    sortable,
    editRender
  } = column;
  switch (type) {
    case 'seq':
      return Cell.renderSeqHeader(params);
    case 'radio':
      return Cell.renderRadioHeader(params);
    case 'checkbox':
      return Cell.renderCheckboxHeader(params);
    case 'html':
      if (filters && sortable) {
        return Cell.renderSortAndFilterHeader(params);
      } else if (sortable) {
        return Cell.renderSortHeader(params);
      } else if (filters) {
        return Cell.renderFilterHeader(params);
      }
      break;
  }
  if (editConfig && isEnableConf(editOpts) && editRender) {
    return Cell.renderEditHeader(params);
  } else if (filters && sortable) {
    return Cell.renderSortAndFilterHeader(params);
  } else if (sortable) {
    return Cell.renderSortHeader(params);
  } else if (filters) {
    return Cell.renderFilterHeader(params);
  }
  return Cell.renderDefaultHeader(params);
}
function renderFooterHandle(params) {
  return Cell.renderDefaultFooter(params);
}
const Cell = {
  createColumn($xeTable, columnOpts) {
    const {
      type
    } = columnOpts;
    const renConfs = {
      renderHeader: renderHeaderHandle,
      renderCell: renderCellHandle,
      renderFooter: renderFooterHandle
    };
    if (type === 'expand') {
      renConfs.renderData = Cell.renderExpandData;
    }
    return createColumn($xeTable, columnOpts, renConfs);
  },
  /**
   * 
   */
  renderHeaderTitle(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots,
      editRender,
      cellRender
    } = column;
    const renderOpts = editRender || cellRender;
    const headerSlot = slots ? slots.header : null;
    if (headerSlot) {
      return renderTitleContent(params, $table.callSlot(headerSlot, params));
    }
    if (renderOpts) {
      const compConf = cell_renderer.get(renderOpts.name);
      if (compConf) {
        const rtHeader = compConf.renderTableHeader || compConf.renderHeader;
        if (rtHeader) {
          return renderTitleContent(params, getSlotVNs(rtHeader(renderOpts, params)));
        }
      }
    }
    return renderTitleContent(params, formatText(column.getTitle(), 1));
  },
  renderDefaultHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params));
  },
  renderDefaultCell(params) {
    const {
      $table,
      row,
      column
    } = params;
    const tableProps = $table.props;
    const tableReactData = $table.reactData;
    const tableInternalData = $table.internalData;
    const {
      isRowGroupStatus
    } = tableReactData;
    const {
      editConfig
    } = tableProps;
    const {
      field,
      slots,
      editRender,
      cellRender,
      rowGroupNode,
      aggFunc,
      formatter
    } = column;
    const renderOpts = editConfig && isEnableConf(editRender) ? editRender : isEnableConf(cellRender) ? cellRender : null;
    const defaultSlot = slots ? slots.default : null;
    const gcSlot = slots ? slots.groupContent || slots['group-content'] : null;
    let cellValue = '';
    if (isRowGroupStatus && field && row.isAggregate) {
      const aggRow = row;
      const {
        fullColumnFieldData
      } = tableInternalData;
      const {
        computeAggregateOpts
      } = $table.getComputeMaps();
      const aggregateOpts = computeAggregateOpts.value;
      const {
        mode,
        showTotal,
        totalMethod,
        countFields,
        contentMethod,
        mapChildrenField
      } = aggregateOpts;
      const aggCalcMethod = aggregateOpts.calcValuesMethod || aggregateOpts.countMethod || aggregateOpts.aggregateMethod;
      const groupField = aggRow.groupField;
      const groupContent = aggRow.groupContent;
      const childList = mapChildrenField ? aggRow[mapChildrenField] || [] : [];
      const childCount = aggRow.childCount;
      const colRest = fullColumnFieldData[groupField] || {};
      const ctParams = {
        $table,
        groupField,
        groupColumn: colRest ? colRest.column : null,
        column,
        groupValue: groupContent,
        childList,
        childCount,
        aggValue: null,
        /**
         * 
         * @deprecated
         */
        children: childList,
        /**
         * 
         * @deprecated
         */
        totalValue: childCount
      };
      if (gcSlot) {
        return renderCellBaseVNs(params, $table.callSlot(gcSlot, Object.assign({
          groupField,
          groupContent,
          childList,
          childCount
        }, params)));
      }
      if (mode === 'column' ? field === aggRow.groupField : rowGroupNode) {
        cellValue = groupContent;
        if (contentMethod) {
          cellValue = `${contentMethod(ctParams)}`;
        }
        if (showTotal) {
          cellValue = cell_getI18n('vxe.table.rowGroupContentTotal', [cellValue, totalMethod ? totalMethod(ctParams) : childCount, childCount]);
        }
      } else if ($table.getPivotTableAggregateCellAggValue) {
        cellValue = $table.getPivotTableAggregateCellAggValue(params);
      } else if (aggFunc === true || countFields && countFields.includes(field)) {
        if (aggCalcMethod) {
          ctParams.aggValue = childCount;
          cellValue = `${aggCalcMethod(ctParams)}`;
        }
      }
    } else {
      if (defaultSlot) {
        return renderCellBaseVNs(params, $table.callSlot(defaultSlot, params));
      }
      // formatter > (renderTableCell | renderTableDefault)
      if (renderOpts && !formatter) {
        const compConf = cell_renderer.get(renderOpts.name);
        if (compConf) {
          const rtCell = compConf.renderTableCell || compConf.renderCell;
          const rtDefault = compConf.renderTableDefault || compConf.renderDefault;
          const renderFn = editRender ? rtCell : rtDefault;
          if (renderFn) {
            return renderCellBaseVNs(params, getSlotVNs(renderFn(renderOpts, Object.assign({
              $type: editRender ? 'edit' : 'cell'
            }, params))));
          }
        }
      }
      cellValue = $table.getCellLabel(row, column);
    }
    const cellPlaceholder = editRender ? editRender.placeholder : '';
    return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-cell--label'
    }, [
    // 
    editRender && eqEmptyValue(cellValue) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-cell--placeholder'
    }, formatText(getFuncText(cellPlaceholder), 1)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', formatText(cellValue, 1))])]);
  },
  renderDeepCell(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderDefaultCell(params));
  },
  renderDefaultFooter(params) {
    return getFooterContent(params);
  },
  /**
   * 
   */
  renderRowGroupBtn(params, cellVNodes) {
    const {
      $table
    } = params;
    const tableReactData = $table.reactData;
    const tableInternalData = $table.internalData;
    const {
      row,
      level
    } = params;
    const {
      computeAggregateOpts
    } = $table.getComputeMaps();
    const {
      rowGroupExpandedFlag
    } = tableReactData;
    const {
      rowGroupExpandedMaps
    } = tableInternalData;
    const aggregateOpts = computeAggregateOpts.value;
    const {
      mode,
      padding,
      indent
    } = aggregateOpts;
    const rowid = getRowid($table, row);
    const isExpand = !!rowGroupExpandedFlag && !!rowGroupExpandedMaps[rowid];
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: ['vxe-row-group--tree-node', {
        'is--expanded': isExpand
      }],
      style: mode !== 'column' && padding && indent ? {
        paddingLeft: `${level * indent}px`
      } : undefined
    }, [row.isAggregate ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-row-group--node-btn',
      onClick(evnt) {
        $table.triggerRowGroupExpandEvent(evnt, params);
      }
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: isExpand ? cell_getIcon().TABLE_ROW_GROUP_OPEN : cell_getIcon().TABLE_ROW_GROUP_CLOSE
    })]) : renderEmptyElement($table), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-row-group-cell'
    }, cellVNodes)]);
  },
  /**
   * 
   */
  renderTreeNodeBtn(params, cellVNodes) {
    const {
      $table,
      isHidden
    } = params;
    const tableReactData = $table.reactData;
    const tableInternalData = $table.internalData;
    const {
      row,
      column,
      level
    } = params;
    const {
      slots
    } = column;
    const iconSlot = slots ? slots.icon : null;
    if (iconSlot) {
      return $table.callSlot(iconSlot, params);
    }
    const {
      computeTreeOpts
    } = $table.getComputeMaps();
    const {
      treeExpandedFlag
    } = tableReactData;
    const {
      fullAllDataRowIdData,
      treeExpandedMaps,
      treeExpandLazyLoadedMaps
    } = tableInternalData;
    const treeOpts = computeTreeOpts.value;
    const {
      padding,
      indent,
      lazy,
      trigger,
      iconLoaded,
      showIcon,
      iconOpen,
      iconClose
    } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
    const rowChilds = row[childrenField];
    const hasChild = rowChilds && rowChilds.length;
    let hasLazyChilds = false;
    let isActive = false;
    let isLazyLoading = false;
    let isLazyLoaded = false;
    const ons = {};
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isActive = !!treeExpandedFlag && !!treeExpandedMaps[rowid];
      if (lazy) {
        const rest = fullAllDataRowIdData[rowid];
        isLazyLoading = !!treeExpandLazyLoadedMaps[rowid];
        hasLazyChilds = row[hasChildField];
        isLazyLoaded = !!rest.treeLoaded;
      }
    }
    if (!trigger || trigger === 'default') {
      ons.onClick = evnt => {
        $table.triggerTreeExpandEvent(evnt, params);
      };
    }
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: ['vxe-cell--tree-node', {
        'is--active': isActive
      }],
      style: padding && indent ? {
        paddingLeft: `${level * indent}px`
      } : undefined
    }, [showIcon && (lazy ? isLazyLoaded ? hasChild : hasChild || hasLazyChilds : hasChild) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-cell--tree-btn',
      ...ons
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: isLazyLoading ? iconLoaded || cell_getIcon().TABLE_TREE_LOADED : isActive ? iconOpen || cell_getIcon().TABLE_TREE_OPEN : iconClose || cell_getIcon().TABLE_TREE_CLOSE
    })])] : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-tree-cell'
    }, cellVNodes)]);
  },
  /**
   * 
   * 
   */
  renderDeepNodeBtn(params, cellVNodes) {
    const {
      $table,
      row,
      column
    } = params;
    const {
      rowGroupNode
    } = column;
    const tableReactData = $table.reactData;
    const {
      rowGroupList
    } = tableReactData;
    if (rowGroupList.length) {
      const {
        computeAggregateOpts
      } = $table.getComputeMaps();
      const aggregateOpts = computeAggregateOpts.value;
      const {
        mode
      } = aggregateOpts;
      if (mode === 'column' ? column.field === row.groupField : rowGroupNode) {
        return [Cell.renderRowGroupBtn(params, cellVNodes)];
      }
    }
    return [Cell.renderTreeNodeBtn(params, cellVNodes)];
  },
  /**
   * 
   */
  renderSeqHeader(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots
    } = column;
    const headerSlot = slots ? slots.header : null;
    return renderHeaderCellBaseVNs(params, renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : formatText(column.getTitle(), 1)));
  },
  renderSeqCell(params) {
    const {
      $table,
      column
    } = params;
    const tableProps = $table.props;
    const {
      treeConfig
    } = tableProps;
    const {
      computeSeqOpts
    } = $table.getComputeMaps();
    const seqOpts = computeSeqOpts.value;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, params));
    }
    const {
      seq
    } = params;
    const seqMd = seqOpts.seqMethod;
    return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${formatText(seqMd ? seqMd(params) : treeConfig ? seq : (seqOpts.startIndex || 0) + seq, 1)}`)]);
  },
  renderDeepIndexCell(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderSeqCell(params));
  },
  /**
   * 
   */
  renderRadioHeader(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots
    } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    return renderHeaderCellBaseVNs(params, renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-radio--label'
    }, titleSlot ? $table.callSlot(titleSlot, params) : formatText(column.getTitle(), 1))]));
  },
  renderRadioCell(params) {
    const {
      $table,
      column,
      isHidden
    } = params;
    const tableReactData = $table.reactData;
    const {
      computeRadioOpts
    } = $table.getComputeMaps();
    const {
      selectRadioRow
    } = tableReactData;
    const radioOpts = computeRadioOpts.value;
    const {
      slots
    } = column;
    const {
      labelField,
      checkMethod,
      visibleMethod
    } = radioOpts;
    const {
      row
    } = params;
    const defaultSlot = slots ? slots.default : null;
    const radioSlot = slots ? slots.radio : null;
    const isChecked = $table.eqRow(row, selectRadioRow);
    const isVisible = !visibleMethod || visibleMethod({
      $table,
      row
    });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            $table.triggerRadioRowEvent(evnt, params);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({
          $table,
          row
        });
      }
    }
    const radioParams = {
      ...params,
      checked: isChecked,
      disabled: isDisabled,
      visible: isVisible
    };
    if (radioSlot) {
      return renderCellBaseVNs(params, $table.callSlot(radioSlot, radioParams));
    }
    const radioVNs = [];
    if (isVisible) {
      radioVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-radio--icon', isChecked ? cell_getIcon().TABLE_RADIO_CHECKED : isDisabled ? cell_getIcon().TABLE_RADIO_DISABLED_UNCHECKED : cell_getIcon().TABLE_RADIO_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      radioVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-radio--label'
      }, defaultSlot ? $table.callSlot(defaultSlot, radioParams) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)));
    }
    return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell--radio', {
        'is--checked': isChecked,
        'is--disabled': isDisabled
      }],
      ...ons
    }, radioVNs)]);
  },
  renderDeepRadioCell(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderRadioCell(params));
  },
  /**
   * 
   */
  renderCheckboxHeader(params) {
    const {
      $table,
      column,
      isHidden
    } = params;
    const tableReactData = $table.reactData;
    const {
      computeIsAllCheckboxDisabled,
      computeCheckboxOpts
    } = $table.getComputeMaps();
    const {
      isAllSelected: isAllCheckboxSelected,
      isIndeterminate: isAllCheckboxIndeterminate
    } = tableReactData;
    const isAllCheckboxDisabled = computeIsAllCheckboxDisabled.value;
    const {
      slots
    } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    const checkboxOpts = computeCheckboxOpts.value;
    const {
      checkStrictly,
      showHeader,
      headerTitle
    } = checkboxOpts;
    const colTitle = column.getTitle();
    const ons = {};
    if (!isHidden) {
      ons.onClick = evnt => {
        if (!isAllCheckboxDisabled) {
          $table.triggerCheckAllEvent(evnt, !isAllCheckboxSelected);
        }
      };
    }
    const checkboxParams = {
      ...params,
      checked: isAllCheckboxSelected,
      disabled: isAllCheckboxDisabled,
      indeterminate: isAllCheckboxIndeterminate
    };
    if (headerSlot) {
      return renderHeaderCellBaseVNs(params, renderTitleContent(checkboxParams, $table.callSlot(headerSlot, checkboxParams)));
    }
    if (checkStrictly ? !showHeader : showHeader === false) {
      return renderHeaderCellBaseVNs(params, renderTitleContent(checkboxParams, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : colTitle)]));
    }
    return renderHeaderCellBaseVNs(params, renderTitleContent(checkboxParams, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell--checkbox', {
        'is--checked': isAllCheckboxSelected,
        'is--disabled': isAllCheckboxDisabled,
        'is--indeterminate': isAllCheckboxIndeterminate
      }],
      title: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(headerTitle) ? cell_getI18n('vxe.table.allTitle') : `${headerTitle || ''}`,
      ...ons
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-checkbox--icon', isAllCheckboxIndeterminate ? cell_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllCheckboxSelected ? cell_getIcon().TABLE_CHECKBOX_CHECKED : isAllCheckboxDisabled ? cell_getIcon().TABLE_CHECKBOX_DISABLED_UNCHECKED : cell_getIcon().TABLE_CHECKBOX_UNCHECKED]
    })].concat(titleSlot || colTitle ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-checkbox--label'
    }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : colTitle)] : []))]));
  },
  renderCheckboxCell(params) {
    const {
      $table,
      row,
      column,
      isHidden
    } = params;
    const tableProps = $table.props;
    const tableReactData = $table.reactData;
    const tableInternalData = $table.internalData;
    const {
      treeConfig
    } = tableProps;
    const {
      updateCheckboxFlag,
      isRowGroupStatus
    } = tableReactData;
    const {
      selectCheckboxMaps,
      treeIndeterminateRowMaps
    } = tableInternalData;
    const {
      computeCheckboxOpts,
      computeAggregateOpts
    } = $table.getComputeMaps();
    const aggregateOpts = computeAggregateOpts.value;
    const {
      mapChildrenField
    } = aggregateOpts;
    const checkboxOpts = computeCheckboxOpts.value;
    const {
      labelField,
      checkMethod,
      visibleMethod
    } = checkboxOpts;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let indeterminate = false;
    let isChecked = false;
    let isVisible = true;
    let isDisabled = false;
    const ons = {};
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = !!updateCheckboxFlag && !!selectCheckboxMaps[rowid];
      if (checkMethod && isRowGroupStatus && $table.isAggregateRecord(row)) {
        const childList = row[mapChildrenField || ''];
        if (!childList || !childList.length || childList.every(item => !checkMethod({
          $table,
          row: item
        }))) {
          isDisabled = true;
        }
      } else {
        isVisible = !visibleMethod || visibleMethod({
          $table,
          row
        });
        isDisabled = checkMethod ? !checkMethod({
          $table,
          row
        }) : !!checkMethod;
      }
      if (treeConfig || isRowGroupStatus) {
        indeterminate = !!treeIndeterminateRowMaps[rowid];
      }
      ons.onClick = evnt => {
        if (!isDisabled && isVisible) {
          $table.triggerCheckRowEvent(evnt, params, !isChecked);
        }
      };
    }
    const checkboxParams = {
      ...params,
      checked: isChecked,
      disabled: isDisabled,
      visible: isVisible,
      indeterminate
    };
    if (checkboxSlot) {
      return renderCellBaseVNs(params, $table.callSlot(checkboxSlot, checkboxParams));
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', indeterminate ? cell_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? cell_getIcon().TABLE_CHECKBOX_CHECKED : isDisabled ? cell_getIcon().TABLE_CHECKBOX_DISABLED_UNCHECKED : cell_getIcon().TABLE_CHECKBOX_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      checkVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)));
    }
    return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell--checkbox', {
        'is--checked': isChecked,
        'is--disabled': isDisabled,
        'is--indeterminate': indeterminate,
        'is--hidden': !isVisible
      }],
      ...ons
    }, checkVNs)]);
  },
  renderDeepSelectionCell(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderCheckboxCell(params));
  },
  renderCheckboxCellByProp(params) {
    const {
      $table,
      row,
      column,
      isHidden
    } = params;
    const tableProps = $table.props;
    const tableReactData = $table.reactData;
    const tableInternalData = $table.internalData;
    const {
      treeConfig
    } = tableProps;
    const {
      updateCheckboxFlag,
      isRowGroupStatus
    } = tableReactData;
    const {
      treeIndeterminateRowMaps
    } = tableInternalData;
    const {
      computeCheckboxOpts,
      computeAggregateOpts
    } = $table.getComputeMaps();
    const aggregateOpts = computeAggregateOpts.value;
    const {
      mapChildrenField
    } = aggregateOpts;
    const checkboxOpts = computeCheckboxOpts.value;
    const {
      labelField,
      checkField,
      checkMethod,
      visibleMethod
    } = checkboxOpts;
    const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let indeterminate = false;
    let isChecked = false;
    let isVisible = true;
    let isDisabled = false;
    const ons = {};
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = !!updateCheckboxFlag && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField);
      if (checkMethod && isRowGroupStatus && $table.isAggregateRecord(row)) {
        const childList = row[mapChildrenField || ''];
        if (!childList || !childList.length || childList.every(item => !checkMethod({
          $table,
          row: item
        }))) {
          isDisabled = true;
        }
      } else {
        isVisible = !visibleMethod || visibleMethod({
          $table,
          row
        });
        isDisabled = checkMethod ? !checkMethod({
          $table,
          row
        }) : !!checkMethod;
      }
      if (treeConfig || isRowGroupStatus) {
        indeterminate = !!treeIndeterminateRowMaps[rowid];
      }
      ons.onClick = evnt => {
        if (!isDisabled && isVisible) {
          $table.triggerCheckRowEvent(evnt, params, !isChecked);
        }
      };
    }
    const checkboxParams = {
      ...params,
      checked: isChecked,
      disabled: isDisabled,
      visible: isVisible,
      indeterminate
    };
    if (checkboxSlot) {
      return renderCellBaseVNs(params, $table.callSlot(checkboxSlot, checkboxParams));
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', indeterminate ? cell_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? cell_getIcon().TABLE_CHECKBOX_CHECKED : isDisabled ? cell_getIcon().TABLE_CHECKBOX_DISABLED_UNCHECKED : cell_getIcon().TABLE_CHECKBOX_UNCHECKED]
      }));
      if (defaultSlot || labelField) {
        checkVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-checkbox--label'
        }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)));
      }
    }
    return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell--checkbox', {
        'is--checked': isChecked,
        'is--disabled': isDisabled,
        'is--indeterminate': indeterminateField && !isChecked ? row[indeterminateField] : indeterminate,
        'is--hidden': !isVisible
      }],
      ...ons
    }, checkVNs)]);
  },
  renderDeepSelectionCellByProp(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderCheckboxCellByProp(params));
  },
  /**
   * 
   */
  renderExpandCell(params) {
    const {
      $table,
      isHidden,
      row,
      column
    } = params;
    const tableReactData = $table.reactData;
    const tableInternalData = $table.internalData;
    const {
      isRowGroupStatus
    } = tableReactData;
    const {
      rowExpandedMaps,
      rowExpandLazyLoadedMaps
    } = tableInternalData;
    const {
      computeExpandOpts
    } = $table.getComputeMaps();
    const expandOpts = computeExpandOpts.value;
    const {
      lazy,
      labelField,
      iconLoaded,
      showIcon,
      iconOpen,
      iconClose,
      visibleMethod
    } = expandOpts;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const iconSlot = slots ? slots.icon : null;
    let isActive = false;
    let isLazyLoading = false;
    if (isRowGroupStatus && row.isAggregate) {
      return renderCellBaseVNs(params, []);
    }
    if (iconSlot) {
      return renderCellBaseVNs(params, $table.callSlot(iconSlot, params));
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isActive = !!rowExpandedMaps[rowid];
      if (lazy) {
        isLazyLoading = !!rowExpandLazyLoadedMaps[rowid];
      }
    }
    return renderCellBaseVNs(params, [showIcon && (!visibleMethod || visibleMethod(params)) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-table--expanded', {
        'is--active': isActive
      }],
      onMousedown(evnt) {
        evnt.stopPropagation();
      },
      onClick(evnt) {
        $table.triggerRowExpandEvent(evnt, params);
      }
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: ['vxe-table--expand-btn', isLazyLoading ? iconLoaded || cell_getIcon().TABLE_EXPAND_LOADED : isActive ? iconOpen || cell_getIcon().TABLE_EXPAND_OPEN : iconClose || cell_getIcon().TABLE_EXPAND_CLOSE]
    })]) : renderEmptyElement($table), defaultSlot || labelField ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-table--expand-label'
    }, defaultSlot ? $table.callSlot(defaultSlot, params) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)) : renderEmptyElement($table)]);
  },
  renderExpandData(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots,
      contentRender
    } = column;
    const contentSlot = slots ? slots.content : null;
    if (contentSlot) {
      return $table.callSlot(contentSlot, params);
    }
    if (contentRender) {
      const compConf = cell_renderer.get(contentRender.name);
      if (compConf) {
        const rtExpand = compConf.renderTableExpand || compConf.renderExpand;
        if (rtExpand) {
          return getSlotVNs(rtExpand(contentRender, params));
        }
      }
    }
    return [];
  },
  /**
   * HTML 
   */
  renderHTMLCell(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, params));
    }
    return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-cell--html',
      innerHTML: getDefaultCellLabel(params)
    })]);
  },
  renderDeepHTMLCell(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderHTMLCell(params));
  },
  /**
   * 
   */
  renderSortAndFilterHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params).concat(Cell.renderSortIcon(params).concat(Cell.renderFilterIcon(params))));
  },
  /**
   * 
   */
  renderSortHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params).concat(Cell.renderSortIcon(params)));
  },
  renderSortIcon(params) {
    const {
      $table,
      column
    } = params;
    const {
      computeSortOpts
    } = $table.getComputeMaps();
    const sortOpts = computeSortOpts.value;
    const {
      showIcon,
      allowBtn,
      ascTitle,
      descTitle,
      iconLayout,
      iconAsc,
      iconDesc,
      iconVisibleMethod
    } = sortOpts;
    const {
      order,
      slots
    } = column;
    if (showIcon && (!iconVisibleMethod || iconVisibleMethod(params))) {
      const sortSlot = slots ? slots.sort : null;
      return sortSlot ? getSlotVNs($table.callSlot(sortSlot, params)) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-cell--sort', `vxe-cell--sort-${iconLayout}-layout`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-sort--asc-btn', iconAsc || cell_getIcon().TABLE_SORT_ASC, {
          'sort--active': order === 'asc'
        }],
        title: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(ascTitle) ? cell_getI18n('vxe.table.sortAsc') : `${ascTitle || ''}`,
        onClick: allowBtn ? evnt => {
          evnt.stopPropagation();
          $table.triggerSortEvent(evnt, column, 'asc');
        } : undefined
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-sort--desc-btn', iconDesc || cell_getIcon().TABLE_SORT_DESC, {
          'sort--active': order === 'desc'
        }],
        title: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(descTitle) ? cell_getI18n('vxe.table.sortDesc') : `${descTitle || ''}`,
        onClick: allowBtn ? evnt => {
          evnt.stopPropagation();
          $table.triggerSortEvent(evnt, column, 'desc');
        } : undefined
      })])];
    }
    return [];
  },
  /**
   * 
   */
  renderFilterHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params).concat(Cell.renderFilterIcon(params)));
  },
  renderFilterIcon(params) {
    const {
      $table,
      column,
      hasFilter
    } = params;
    const tableReactData = $table.reactData;
    const {
      filterStore
    } = tableReactData;
    const {
      computeFilterOpts
    } = $table.getComputeMaps();
    const filterOpts = computeFilterOpts.value;
    const {
      showIcon,
      iconNone,
      iconMatch,
      iconVisibleMethod
    } = filterOpts;
    if (showIcon && (!iconVisibleMethod || iconVisibleMethod(params))) {
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-cell--filter', {
          'is--active': filterStore.visible && filterStore.column === column
        }],
        onClick(evnt) {
          if ($table.triggerFilterEvent) {
            $table.triggerFilterEvent(evnt, params.column, params);
          }
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-filter--btn', hasFilter ? iconMatch || cell_getIcon().TABLE_FILTER_MATCH : iconNone || cell_getIcon().TABLE_FILTER_NONE],
        title: cell_getI18n('vxe.table.filter')
      })])];
    }
    return [];
  },
  /**
   * 
   */
  renderEditHeader(params) {
    const {
      $table,
      column
    } = params;
    const tableProps = $table.props;
    const {
      computeEditOpts
    } = $table.getComputeMaps();
    const {
      editConfig,
      editRules
    } = tableProps;
    const editOpts = computeEditOpts.value;
    const {
      sortable,
      filters,
      editRender
    } = column;
    let isRequired = false;
    if (editRules) {
      const columnRules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(editRules, column.field);
      if (columnRules) {
        isRequired = columnRules.some(rule => rule.required);
      }
    }
    let editIconVNs = [];
    if (isEnableConf(editConfig)) {
      const {
        showAsterisk,
        showIcon,
        icon
      } = editOpts;
      editIconVNs = [isRequired && showAsterisk ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-cell--required-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i')]) : renderEmptyElement($table), isEnableConf(editRender) && showIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-cell--edit-icon'
      }, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(icon) ? getSlotVNs(icon({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon || cell_getIcon().TABLE_EDIT
      })]) : renderEmptyElement($table)];
    }
    return renderHeaderCellBaseVNs(params, editIconVNs.concat(Cell.renderHeaderTitle(params)).concat(sortable ? Cell.renderSortIcon(params) : []).concat(filters ? Cell.renderFilterIcon(params) : []));
  },
  // 
  renderRowEdit(params) {
    const {
      $table,
      column
    } = params;
    const tableReactData = $table.reactData;
    const {
      editStore
    } = tableReactData;
    const {
      actived
    } = editStore;
    const {
      editRender
    } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row);
  },
  renderDeepRowEdit(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderRowEdit(params));
  },
  // 
  renderCellEdit(params) {
    const {
      $table,
      column
    } = params;
    const tableReactData = $table.reactData;
    const {
      editStore
    } = tableReactData;
    const {
      actived
    } = editStore;
    const {
      editRender
    } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row && actived.column === params.column);
  },
  renderDeepCellEdit(params) {
    return Cell.renderDeepNodeBtn(params, Cell.renderCellEdit(params));
  },
  runRenderer(params, isEdit) {
    const {
      $table,
      row,
      column
    } = params;
    const tableReactData = $table.reactData;
    const {
      isRowGroupStatus
    } = tableReactData;
    const {
      slots,
      field,
      editRender,
      formatter
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const gcSlot = slots ? slots.groupContent || slots['group-content'] : null;
    const editSlot = slots ? slots.edit : null;
    const compConf = cell_renderer.get(editRender.name);
    const rtEdit = compConf ? compConf.renderTableEdit || compConf.renderEdit : null;
    const cellParams = Object.assign({
      $type: '',
      isEdit
    }, params);
    if (isEdit) {
      cellParams.$type = 'edit';
      if (editSlot) {
        return $table.callSlot(editSlot, cellParams);
      }
      if (rtEdit) {
        return getSlotVNs(rtEdit(editRender, cellParams));
      }
      return [];
    }
    if (isRowGroupStatus && field && row.isAggregate) {
      const aggRow = row;
      const {
        computeAggregateOpts
      } = $table.getComputeMaps();
      const aggregateOpts = computeAggregateOpts.value;
      const {
        mapChildrenField
      } = aggregateOpts;
      const groupField = aggRow.groupField;
      const groupContent = aggRow.groupContent;
      const childList = mapChildrenField ? aggRow[mapChildrenField] || [] : [];
      const childCount = aggRow.childCount;
      if (gcSlot) {
        return renderCellBaseVNs(params, $table.callSlot(gcSlot, Object.assign({
          groupField,
          groupContent,
          childList,
          childCount
        }, params)));
      }
    } else {
      if (defaultSlot) {
        return renderCellBaseVNs(params, $table.callSlot(defaultSlot, cellParams));
      }
    }
    if (formatter) {
      return renderCellBaseVNs(params, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-cell--label'
      }, getDefaultCellLabel(cellParams))]);
    }
    return Cell.renderDefaultCell(cellParams);
  }
};
/* harmony default export */ var cell = (Cell);
;// ./packages/table/src/column.ts




const columnProps = {
  // 
  colId: [String, Number],
  //  index,radio,checkbox,expand,html
  type: String,
  // 
  field: String,
  // 
  title: String,
  // 
  width: [Number, String],
  // 
  minWidth: [Number, String],
  // 
  maxWidth: [Number, String],
  // 
  resizable: {
    type: Boolean,
    default: null
  },
  // 
  fixed: String,
  // 
  align: String,
  // 
  headerAlign: String,
  // 
  footerAlign: String,
  // 
  showOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 
  showHeaderOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 
  showFooterOverflow: {
    type: [Boolean, String],
    default: null
  },
  //  className
  className: [String, Function],
  //  className
  headerClassName: [String, Function],
  //  className
  footerClassName: [String, Function],
  // 
  formatter: [Function, Array, String],
  // 
  headerFormatter: [Function, Array, String],
  // 
  footerFormatter: [Function, Array, String],
  // 
  padding: {
    type: Boolean,
    default: null
  },
  // 
  verticalAlign: {
    type: String,
    default: null
  },
  // 
  sortable: Boolean,
  // 
  sortBy: [String, Function],
  // 
  sortType: String,
  // 
  filters: {
    type: Array,
    default: null
  },
  // 
  filterMultiple: {
    type: Boolean,
    default: true
  },
  // 
  filterMethod: Function,
  // 
  filterResetMethod: Function,
  // 
  filterRecoverMethod: Function,
  // 
  filterRender: Object,
  // 
  floatingFilters: Object,
  // 
  rowGroupNode: Boolean,
  // 
  treeNode: Boolean,
  // 
  dragSort: Boolean,
  // 
  rowResize: Boolean,
  // 
  visible: {
    type: Boolean,
    default: null
  },
  // 
  headerExportMethod: Function,
  // 
  exportMethod: Function,
  // 
  footerExportMethod: Function,
  //  titlePrefix 
  titleHelp: Object,
  // 
  titlePrefix: Object,
  // 
  titleSuffix: Object,
  // 
  cellType: String,
  // 
  cellRender: Object,
  // 
  editRender: Object,
  // 
  contentRender: Object,
  // 
  aggFunc: [String, Boolean],
  // 
  copyMethod: Function,
  // 
  cutMethod: Function,
  // 
  pasteMethod: Function,
  // 
  params: Object
};
/* harmony default export */ var column = (defineVxeComponent({
  name: 'VxeColumn',
  props: columnProps,
  setup(props, {
    slots
  }) {
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeColgroup', null);
    if (!$xeTable) {
      return () => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    }
    const columnConfig = cell.createColumn($xeTable, props);
    columnConfig.slots = slots;
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    const $xeColumn = {
      columnConfig,
      renderVN
    };
    watchColumn($xeTable, props, columnConfig);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if (elem) {
        assembleColumn($xeTable, elem, columnConfig, $xeColgroup);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyColumn($xeTable, columnConfig);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeColumn', $xeColumn);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeGrid', null);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeGantt', null);
    return renderVN;
  }
}));
;// ./packages/column/index.ts


const VxeColumn = Object.assign({}, column, {
  install(app) {
    app.component(column.name, column);
    // 
    app.component('VxeTableColumn', column);
  }
});
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(column.name, column);
  // 
  core_.VxeUI.dynamicApp.component('VxeTableColumn', column);
}
core_.VxeUI.component(column);
const Column = VxeColumn;
/* harmony default export */ var packages_column = ((/* unused pure expression or super */ null && (VxeColumn)));
;// ./packages/table/src/group.ts





/* harmony default export */ var group = (defineVxeComponent({
  name: 'VxeColgroup',
  props: columnProps,
  setup(props, {
    slots
  }) {
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeParentColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeColgroup', null);
    if (!$xeTable) {
      return () => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    }
    const columnConfig = cell.createColumn($xeTable, props);
    const columnSlots = {};
    if (slots.header) {
      columnSlots.header = slots.header;
    }
    columnConfig.slots = columnSlots;
    columnConfig.children = [];
    watchColumn($xeTable, props, columnConfig);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if (elem) {
        assembleColumn($xeTable, elem, columnConfig, $xeParentColgroup);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyColumn($xeTable, columnConfig);
    });
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      }, slots.default ? slots.default() : []);
    };
    const $xeColgroup = {
      columnConfig
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeColgroup', $xeColgroup);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeGrid', null);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeGantt', null);
    return renderVN;
  }
}));
;// ./packages/colgroup/index.ts


const VxeColgroup = Object.assign({}, group, {
  install(app) {
    app.component(group.name, group);
    // 
    app.component('VxeTableColgroup', group);
  }
});
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(group.name, group);
  // 
  core_.VxeUI.dynamicApp.component('VxeTableColgroup', group);
}
core_.VxeUI.component(group);
const Colgroup = VxeColgroup;
/* harmony default export */ var colgroup = ((/* unused pure expression or super */ null && (VxeColgroup)));
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.filter.js
var esnext_iterator_filter = __webpack_require__(4520);
;// ./packages/table/src/props.ts

const {
  getConfig: props_getConfig
} = core_.VxeUI;
const tableProps = {
  /**  */
  id: [String, Function],
  // 
  data: Array,
  // 
  height: [Number, String],
  // 
  minHeight: {
    type: [Number, String],
    default: () => null
  },
  // 
  maxHeight: [Number, String],
  //  column-config.resizable 
  resizable: {
    type: Boolean,
    default: () => props_getConfig().table.resizable
  },
  // 
  stripe: {
    type: Boolean,
    default: () => props_getConfig().table.stripe
  },
  // 
  border: {
    type: [Boolean, String],
    default: () => props_getConfig().table.border
  },
  //  cell-config.padding 
  padding: {
    type: Boolean,
    default: null
  },
  // 
  round: {
    type: Boolean,
    default: () => props_getConfig().table.round
  },
  // 
  size: {
    type: String,
    default: () => props_getConfig().table.size || props_getConfig().size
  },
  // 
  fit: {
    type: Boolean,
    default: () => props_getConfig().table.fit
  },
  // 
  loading: Boolean,
  // 
  align: {
    type: String,
    default: () => props_getConfig().table.align
  },
  // 
  headerAlign: {
    type: String,
    default: () => props_getConfig().table.headerAlign
  },
  // 
  footerAlign: {
    type: String,
    default: () => props_getConfig().table.footerAlign
  },
  // 
  showHeader: {
    type: Boolean,
    default: () => props_getConfig().table.showHeader
  },
  // 
  highlightCurrentRow: {
    type: Boolean,
    default: () => props_getConfig().table.highlightCurrentRow
  },
  // 
  highlightHoverRow: {
    type: Boolean,
    default: () => props_getConfig().table.highlightHoverRow
  },
  /**
   * 
   * @deprecated
   */
  highlightCurrentColumn: {
    type: Boolean,
    default: () => props_getConfig().table.highlightCurrentColumn
  },
  /**
   * 
   * @deprecated
   */
  highlightHoverColumn: {
    type: Boolean,
    default: () => props_getConfig().table.highlightHoverColumn
  },
  // 
  highlightCell: Boolean,
  // 
  showFooter: Boolean,
  // 
  footerData: Array,
  // 
  footerMethod: Function,
  //  className
  rowClassName: [String, Function],
  //  className
  cellClassName: [String, Function],
  //  className
  headerRowClassName: [String, Function],
  //  className
  headerCellClassName: [String, Function],
  //  className
  footerRowClassName: [String, Function],
  //  className
  footerCellClassName: [String, Function],
  // 
  cellStyle: [Object, Function],
  // 
  headerCellStyle: [Object, Function],
  // 
  footerCellStyle: [Object, Function],
  // 
  rowStyle: [Object, Function],
  // 
  headerRowStyle: [Object, Function],
  // 
  footerRowStyle: [Object, Function],
  //  mergeHeaderCells 
  showCustomHeader: {
    type: Boolean,
    default: () => props_getConfig().table.showCustomHeader
  },
  // 
  mergeHeaderCells: Array,
  // 
  mergeCells: Array,
  // 
  mergeFooterCells: Array,
  mergeFooterItems: Array,
  // 
  spanMethod: Function,
  // 
  footerSpanMethod: Function,
  // 
  showOverflow: {
    type: [Boolean, String],
    default: () => props_getConfig().table.showOverflow
  },
  // 
  showHeaderOverflow: {
    type: [Boolean, String],
    default: () => props_getConfig().table.showHeaderOverflow
  },
  // 
  showFooterOverflow: {
    type: [Boolean, String],
    default: () => props_getConfig().table.showFooterOverflow
  },
  /**  */
  /**
   * columnKey  column-config.useKey 
   * @deprecated
   */
  columnKey: Boolean,
  /**
   * rowKey  row-config.useKey 
   * @deprecated
   */
  rowKey: Boolean,
  /**
   * rowId  row-config.keyField 
   * @deprecated
   */
  rowId: {
    type: String,
    default: () => props_getConfig().table.rowId
  },
  zIndex: Number,
  emptyText: {
    type: String,
    default: () => props_getConfig().table.emptyText
  },
  keepSource: {
    type: Boolean,
    default: () => props_getConfig().table.keepSource
  },
  // 
  autoResize: {
    type: Boolean,
    default: () => props_getConfig().table.autoResize
  },
  // 
  syncResize: [Boolean, String, Number],
  // 
  resizeConfig: Object,
  // 
  columnConfig: Object,
  // 
  currentColumnConfig: Object,
  // 
  cellConfig: Object,
  // 
  headerCellConfig: Object,
  // 
  footerCellConfig: Object,
  // 
  rowConfig: Object,
  // 
  aggregateConfig: Object,
  /**
   *  aggregateConfig 
   * @deprecated
   */
  rowGroupConfig: Object,
  // 
  currentRowConfig: Object,
  /**
   *  rowDragConfig 
   * @deprecated
   */
  dragConfig: Object,
  // 
  rowDragConfig: Object,
  // 
  columnDragConfig: Object,
  // 
  resizableConfig: Object,
  // 
  seqConfig: Object,
  // 
  sortConfig: Object,
  // 
  filterConfig: Object,
  // 
  floatingFilterConfig: Object,
  // 
  radioConfig: Object,
  // 
  checkboxConfig: Object,
  // tooltip 
  tooltipConfig: Object,
  //  tooltip 
  headerTooltipConfig: Object,
  //  tooltip 
  footerTooltipConfig: Object,
  // 
  exportConfig: Object,
  // 
  importConfig: Object,
  // 
  printConfig: Object,
  // 
  expandConfig: Object,
  // 
  treeConfig: Object,
  // 
  menuConfig: Object,
  // 
  mouseConfig: Object,
  // 
  areaConfig: Object,
  // 
  keyboardConfig: Object,
  // /
  clipConfig: Object,
  // /
  fnrConfig: Object,
  // 
  editConfig: Object,
  // 
  validConfig: Object,
  // 
  editRules: Object,
  // 
  loadingConfig: Object,
  // 
  emptyRender: Object,
  // 
  customConfig: Object,
  /**
   * 
   * @deprecated
   */
  scrollX: Object,
  /**
   * 
   * @deprecated
   */
  scrollY: Object,
  // 
  virtualXConfig: Object,
  // 
  virtualYConfig: Object,
  // 
  scrollbarConfig: Object,
  // 
  animat: {
    type: Boolean,
    default: () => props_getConfig().table.animat
  },
  // 
  delayHover: {
    type: Number,
    default: () => props_getConfig().table.delayHover
  },
  // 
  params: Object
};
;// ./packages/grid/src/props.ts


const {
  getConfig: src_props_getConfig
} = core_.VxeUI;
const gridProps = {
  ...tableProps,
  layouts: Array,
  columns: Array,
  pagerConfig: Object,
  proxyConfig: Object,
  toolbarConfig: Object,
  formConfig: Object,
  zoomConfig: Object,
  size: {
    type: String,
    default: () => src_props_getConfig().grid.size || src_props_getConfig().size
  }
};
;// ./packages/table/src/emits.ts
const tableEmits = ['update:data', 'keydown-start', 'keydown', 'keydown-end', 'paste', 'copy', 'cut', 'columns-change', 'data-change', 'footer-data-change', 'current-change', 'current-row-change', 'current-row-disabled', 'current-column-change', 'current-column-disabled', 'radio-change', 'checkbox-change', 'checkbox-all', 'checkbox-range-start', 'checkbox-range-change', 'checkbox-range-end', 'checkbox-range-select', 'cell-click', 'cell-dblclick', 'cell-menu', 'cell-mouseenter', 'cell-mouseleave', 'cell-selected', 'cell-delete-value', 'cell-backspace-value', 'header-cell-click', 'header-cell-dblclick', 'header-cell-menu', 'footer-cell-click', 'footer-cell-dblclick', 'footer-cell-menu', 'clear-merge', 'sort-change', 'clear-sort', 'clear-all-sort', 'filter-change', 'filter-visible', 'clear-filter', 'clear-all-filter', 'resizable-change', 'column-resizable-change', 'row-resizable-change', 'toggle-row-group-expand', 'toggle-row-expand', 'toggle-tree-expand', 'menu-click', 'edit-closed', 'row-dragstart', 'row-dragover', 'row-dragend', 'row-remove-dragend', 'row-insert-dragend', 'column-dragstart', 'column-dragover', 'column-dragend', 'enter-append-row', 'edit-actived', 'edit-activated', 'edit-disabled', 'valid-error', 'scroll', 'scroll-boundary', 'custom', 'custom-visible-change', 'custom-visible-all', 'custom-fixed-change', 'custom-sort-change', 'change-fnr', 'open-fnr', 'show-fnr', 'hide-fnr', 'fnr-change', 'fnr-find', 'fnr-find-all', 'fnr-replace', 'fnr-replace-all', 'cell-area-copy', 'cell-area-cut', 'cell-area-paste', 'cell-area-merge', 'clear-cell-area-selection', 'clear-cell-area-merge', 'header-cell-area-selection', 'cell-area-selection-invalid', 'cell-area-selection-start', 'cell-area-selection-drag', 'cell-area-selection-end', 'cell-area-extension-start', 'cell-area-extension-drag', 'cell-area-extension-end', 'cell-area-extension-fill', 'cell-area-selection-all-start', 'cell-area-selection-all-end', 'cell-area-arrows-start', 'cell-area-arrows-end', 'active-cell-change-start', 'active-cell-change-end'];
;// ./packages/grid/src/emits.ts

const gridEmits = [...tableEmits, 'page-change', 'form-submit', 'form-submit-invalid', 'form-reset', 'form-collapse', 'form-toggle-collapse', 'proxy-query', 'proxy-delete', 'proxy-save', 'toolbar-button-click', 'toolbar-tool-click', 'zoom'];
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.to-array.js
var esnext_iterator_to_array = __webpack_require__(1795);
;// ./packages/table/src/anime.ts



const rowMoveCls = 'row--drag-move';
const colMoveClass = 'col--drag-move';
/**
 * 
 */
function moveRowAnimateToTb(elemList, offsetTop) {
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(elemList, trEl => {
    trEl.style.transform = `translateY(${offsetTop}px)`;
  });
  requestAnimationFrame(() => {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(elemList, trEl => {
      addClass(trEl, rowMoveCls);
      trEl.style.transform = '';
    });
  });
}
function clearRowAnimate(elem, clss) {
  setTimeout(() => {
    if (elem) {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(elem.querySelectorAll(clss.map(cls => `${cls}.${rowMoveCls}`).join(',')), elem => removeClass(elem, rowMoveCls));
    }
  }, 500);
}
/**
 * 
 */
function moveColAnimateToLr(elemList, offsetLeft) {
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(elemList, trEl => {
    trEl.style.transform = `translateX(${offsetLeft}px)`;
  });
  requestAnimationFrame(() => {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(elemList, trEl => {
      addClass(trEl, colMoveClass);
      trEl.style.transform = '';
    });
  });
}
function clearColAnimate(elem, clss) {
  setTimeout(() => {
    if (elem) {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(elem.querySelectorAll(clss.map(cls => `${cls}.${rowMoveCls}`).join(',')), elem => removeClass(elem, colMoveClass));
    }
  }, 500);
}
;// ./packages/table/src/store.ts

// 
const crossTableDragRowInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
  row: null
});
function getCrossTableDragRowInfo() {
  return crossTableDragRowInfo;
}
;// ./packages/table/src/body.ts












const {
  getI18n: body_getI18n,
  renderer: body_renderer,
  renderEmptyElement: body_renderEmptyElement
} = core_.VxeUI;
const sourceType = 'table';
const renderType = 'body';
/* harmony default export */ var body = (defineVxeComponent({
  name: 'VxeTableBody',
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: ''
    }
  },
  setup(props) {
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      xID,
      props: tableProps,
      context: tableContext,
      reactData: tableReactData,
      internalData: tableInternalData
    } = $xeTable;
    const {
      computeEditOpts,
      computeMouseOpts,
      computeCellOffsetWidth,
      computeAreaOpts,
      computeDefaultRowHeight,
      computeEmptyOpts,
      computeTooltipOpts,
      computeRadioOpts,
      computeExpandOpts,
      computeTreeOpts,
      computeCheckboxOpts,
      computeCellOpts,
      computeValidOpts,
      computeRowOpts,
      computeColumnOpts,
      computeRowDragOpts,
      computeResizableOpts,
      computeVirtualXOpts,
      computeVirtualYOpts,
      computeIsBodyRenderOptimize
    } = $xeTable.getComputeMaps();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyScroll = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyTBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyXSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyYSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyEmptyBlock = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    // 
    const isVMScrollProcess = () => {
      const {
        delayHover
      } = tableProps;
      const {
        lastScrollTime,
        isDragResize
      } = tableReactData;
      return !!(isDragResize || lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const renderLine = (rowid, params, cellHeight) => {
      const {
        column
      } = params;
      const {
        treeConfig
      } = tableProps;
      const cellOpts = computeCellOpts.value;
      const rowOpts = computeRowOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const treeOpts = computeTreeOpts.value;
      const {
        slots,
        treeNode
      } = column;
      const {
        fullAllDataRowIdData
      } = tableInternalData;
      if (treeConfig && treeNode && (treeOpts.showLine || treeOpts.line)) {
        if (slots && slots.line) {
          return $xeTable.callSlot(slots.line, params);
        }
        const rowRest = fullAllDataRowIdData[rowid];
        let rLevel = 0;
        let prevRow = null;
        let parentRow = null;
        let lineHeight = '';
        if (rowRest) {
          rLevel = rowRest.level;
          prevRow = rowRest.items[rowRest.treeIndex - 1];
          parentRow = rowRest.parent;
        }
        if (!rLevel && !treeOpts.showRootLine) {
          return [];
        }
        if (prevRow) {
          const prevRowRest = fullAllDataRowIdData[getRowid($xeTable, prevRow)] || {};
          lineHeight = `${prevRowRest.lineHeight || 0}px`;
        } else if (rLevel && parentRow) {
          const parentRowRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)] || {};
          lineHeight = `calc(-1em + ${Math.floor(cellHeight / 2 + getCellRestHeight(parentRowRest, cellOpts, rowOpts, defaultRowHeight) / 2)}px)`;
        }
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'tl',
          class: 'vxe-tree--line-wrapper'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tree--line',
          style: {
            height: lineHeight,
            bottom: `-${Math.floor(cellHeight / 2)}px`,
            left: `calc(${rLevel * treeOpts.indent}px + 1em)`
          }
        })])];
      }
      return [];
    };
    /**
     * 
     */
    const renderTdColumn = (seq, rowid, fixedType, isOptimizeMode, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, columns, items) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const {
        columnKey,
        resizable: allResizable,
        showOverflow: allShowOverflow,
        border,
        height,
        treeConfig,
        cellClassName: allCellClassName,
        cellStyle,
        align: allAlign,
        spanMethod,
        mouseConfig,
        editConfig,
        editRules,
        tooltipConfig,
        padding: allPadding
      } = tableProps;
      const {
        tableData,
        tableColumn,
        dragRow,
        overflowX,
        overflowY,
        currentColumn,
        scrollXLoad,
        scrollYLoad,
        mergeBodyFlag,
        calcCellHeightFlag,
        resizeHeightFlag,
        resizeWidthFlag,
        editStore,
        isAllOverflow,
        validErrorMaps
      } = tableReactData;
      const {
        fullAllDataRowIdData,
        fullColumnIdData,
        mergeBodyCellMaps,
        visibleColumn,
        afterFullData,
        mergeBodyList,
        scrollXStore,
        scrollYStore
      } = tableInternalData;
      const cellOpts = computeCellOpts.value;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const editOpts = computeEditOpts.value;
      const tooltipOpts = computeTooltipOpts.value;
      const resizableOpts = computeResizableOpts.value;
      const virtualXOpts = computeVirtualXOpts.value;
      const virtualYOpts = computeVirtualYOpts.value;
      const {
        isAllColumnDrag,
        isAllRowDrag
      } = resizableOpts;
      const rowOpts = computeRowOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const customCellHeight = calcCellHeightFlag ? cellOpts.height || rowOpts.height : 0;
      const {
        disabledMethod: dragDisabledMethod,
        isCrossDrag,
        isPeerDrag
      } = rowDragOpts;
      const columnOpts = computeColumnOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const areaOpts = computeAreaOpts.value;
      const cellOffsetWidth = computeCellOffsetWidth.value;
      const {
        selectCellToRow
      } = areaOpts;
      const {
        type,
        cellRender,
        editRender,
        align,
        showOverflow,
        className,
        treeNode,
        rowResize,
        padding,
        verticalAlign,
        slots
      } = column;
      const {
        verticalAlign: allVerticalAlign
      } = cellOpts;
      const {
        actived
      } = editStore;
      const rowRest = fullAllDataRowIdData[rowid] || {};
      const colid = column.id;
      const colRest = fullColumnIdData[colid] || {};
      const renderOpts = editRender || cellRender;
      const compConf = renderOpts ? body_renderer.get(renderOpts.name) : null;
      const compCellClassName = compConf ? compConf.tableCellClassName || compConf.cellClassName : null;
      const compCellStyle = compConf ? compConf.tableCellStyle || compConf.cellStyle : '';
      const showAllTip = tooltipOpts.showAll;
      const columnIndex = colRest.index;
      const _columnIndex = colRest._index;
      const isEdit = isEnableConf(editRender);
      const resizeHeight = resizeHeightFlag ? rowRest.resizeHeight : 0;
      let fixedHiddenColumn = overflowX && (fixedType ? column.fixed !== fixedType : !!column.fixed);
      const isCellPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(padding) ? allPadding === null ? cellOpts.padding : allPadding : padding;
      const cellOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(showOverflow) ? allShowOverflow : showOverflow;
      const showEllipsis = cellOverflow === 'ellipsis';
      const showTitle = cellOverflow === 'title';
      const showTooltip = cellOverflow === true || cellOverflow === 'tooltip';
      const hasEllipsis = isAllOverflow || showTitle || showTooltip || showEllipsis;
      const showResizable = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
      const isCsHeight = !!customCellHeight;
      const isRsHeight = resizeHeight > 0;
      let isDirty;
      const tdOns = {};
      const cellAlign = align || (compConf ? compConf.tableCellAlign : '') || allAlign;
      const cellVerticalAlign = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(verticalAlign) ? allVerticalAlign : verticalAlign;
      const errorValidItem = validErrorMaps[`${rowid}:${colid}`];
      const showValidTip = editRules && validOpts.showMessage && (validOpts.message === 'default' ? height || tableData.length > 1 : validOpts.message === 'inline');
      const tdAttrs = {
        colid
      };
      const cellParams = {
        $table: $xeTable,
        $grid: $xeGrid,
        $gantt: $xeGantt,
        isEdit: false,
        seq,
        rowid,
        row,
        rowIndex,
        $rowIndex,
        _rowIndex,
        column,
        columnIndex,
        $columnIndex,
        _columnIndex,
        fixed: fixedType,
        source: sourceType,
        type: renderType,
        isHidden: !!fixedHiddenColumn,
        level: rowLevel,
        visibleData: afterFullData,
        data: tableData,
        items
      };
      let isRowDragCell = false;
      let isDisabledDrag = false;
      if (rowOpts.drag) {
        isRowDragCell = rowDragOpts.trigger === 'row' || column.dragSort && rowDragOpts.trigger === 'cell';
      }
      if (isRowDragCell) {
        isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(cellParams));
      }
      // hover 
      if (showTitle || showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseover = evnt => {
          if (!isVMScrollProcess()) {
            if (showTitle) {
              updateCellTitle(evnt.currentTarget, column);
            } else if (showTooltip || showAllTip) {
              //  tooltip
              $xeTable.triggerBodyTooltipEvent(evnt, cellParams);
            }
          }
          $xeTable.dispatchEvent('cell-mouseenter', Object.assign({
            cell: evnt.currentTarget
          }, cellParams), evnt);
        };
      }
      // hover 
      if (showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseleave = evnt => {
          if (!isVMScrollProcess()) {
            if (showTooltip || showAllTip) {
              $xeTable.handleTargetLeaveEvent(evnt);
            }
          }
          $xeTable.dispatchEvent('cell-mouseleave', Object.assign({
            cell: evnt.currentTarget
          }, cellParams), evnt);
        };
      }
      // 
      if (isRowDragCell || checkboxOpts.range || mouseConfig) {
        tdOns.onMousedown = evnt => {
          $xeTable.triggerCellMousedownEvent(evnt, cellParams);
        };
      }
      // 
      if (isRowDragCell) {
        tdOns.onMouseup = $xeTable.triggerCellMouseupEvent;
      }
      // 
      tdOns.onClick = evnt => {
        $xeTable.triggerCellClickEvent(evnt, cellParams);
      };
      // 
      tdOns.onDblclick = evnt => {
        $xeTable.triggerCellDblclickEvent(evnt, cellParams);
      };
      let isMergeCell = false;
      let mergeColspan = 1;
      let mergeRowspan = 1;
      // 
      if (mergeBodyFlag && mergeBodyList.length) {
        const spanRest = mergeBodyCellMaps[`${_rowIndex}:${_columnIndex}`];
        if (spanRest) {
          const {
            rowspan,
            colspan
          } = spanRest;
          if (!rowspan || !colspan) {
            return body_renderEmptyElement($xeTable);
          }
          if (rowspan > 1) {
            isMergeCell = true;
            mergeRowspan = rowspan;
            tdAttrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            isMergeCell = true;
            mergeColspan = colspan;
            tdAttrs.colspan = colspan;
          }
        }
      } else if (spanMethod) {
        // 
        const {
          rowspan = 1,
          colspan = 1
        } = spanMethod(cellParams) || {};
        if (!rowspan || !colspan) {
          return body_renderEmptyElement($xeTable);
        }
        if (rowspan > 1) {
          isMergeCell = true;
          mergeRowspan = rowspan;
          tdAttrs.rowspan = rowspan;
        }
        if (colspan > 1) {
          isMergeCell = true;
          mergeColspan = colspan;
          tdAttrs.colspan = colspan;
        }
      }
      // 
      if (fixedHiddenColumn && isMergeCell) {
        if (tdAttrs.colspan > 1 || tdAttrs.rowspan > 1) {
          fixedHiddenColumn = false;
        }
      }
      // 
      if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {
        isDirty = $xeTable.isUpdateByRow(row, column.field);
      }
      const isVNAutoHeight = !hasEllipsis && (scrollYLoad || scrollXLoad);
      let cellHeight = getCellRestHeight(rowRest, cellOpts, rowOpts, defaultRowHeight);
      const isLastColumn = $columnIndex === columns.length - 1;
      const isAutoCellWidth = !column.resizeWidth && (column.minWidth === 'auto' || column.width === 'auto');
      let isVNPreEmptyStatus = false;
      if (!isMergeCell) {
        if (!dragRow || getRowid($xeTable, dragRow) !== rowid) {
          if (overflowY && scrollYLoad && tableData.length > 16 && !treeConfig && !virtualYOpts.immediate && (_rowIndex < scrollYStore.visibleStartIndex - scrollYStore.preloadSize || _rowIndex > scrollYStore.visibleEndIndex + scrollYStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          } else if (overflowX && scrollXLoad && tableColumn.length > 10 && !virtualXOpts.immediate && !column.fixed && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          }
        }
      }
      if (mergeRowspan > 1) {
        const mEndRow = afterFullData[_rowIndex + mergeRowspan - 1];
        if (mEndRow) {
          const meRowRest = fullAllDataRowIdData[getRowid($xeTable, mEndRow)];
          if (meRowRest) {
            cellHeight += meRowRest.oTop + getCellRestHeight(meRowRest, cellOpts, rowOpts, defaultRowHeight) - rowRest.oTop - getCellRestHeight(rowRest, cellOpts, rowOpts, defaultRowHeight);
          }
        }
      }
      const tcStyle = {};
      if (hasEllipsis && resizeWidthFlag) {
        let mergeColWidth = 0;
        if (mergeColspan > 1) {
          for (let index = 1; index < mergeColspan; index++) {
            const nextColumn = visibleColumn[columnIndex + index];
            if (nextColumn) {
              mergeColWidth += nextColumn.renderWidth;
            }
          }
        }
        tcStyle.width = `${column.renderWidth + mergeColWidth - cellOffsetWidth}px`;
      }
      if (scrollYLoad || scrollXLoad || hasEllipsis || isCsHeight || isRsHeight) {
        tcStyle.height = `${cellHeight}px`;
      } else {
        tcStyle.minHeight = `${cellHeight}px`;
      }
      const tdVNs = [];
      if (fixedHiddenColumn && isAllOverflow) {
        tdVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'tc',
          class: ['vxe-cell', {
            'c--title': showTitle,
            'c--tooltip': showTooltip,
            'c--ellipsis': showEllipsis
          }],
          style: tcStyle
        }));
      } else {
        // 
        if (treeConfig) {
          tdVNs.push(...renderLine(rowid, cellParams, cellHeight));
        }
        tdVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'tc',
          class: ['vxe-cell', {
            'c--title': showTitle,
            'c--tooltip': showTooltip,
            'c--ellipsis': showEllipsis
          }],
          style: tcStyle,
          title: showTitle ? $xeTable.getCellLabel(row, column) : null
        }, isVNPreEmptyStatus ? [] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          colid,
          rowid,
          class: 'vxe-cell--wrapper vxe-body-cell--wrapper'
        }, column.renderCell(cellParams))]));
        if (showValidTip && errorValidItem) {
          const errRule = errorValidItem.rule;
          const validSlot = slots ? slots.valid : null;
          const validParams = {
            ...cellParams,
            ...errorValidItem,
            rule: errorValidItem
          };
          tdVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: 'tcv',
            class: ['vxe-cell--valid-error-tip', getPropClass(validOpts.className, validParams)],
            style: errRule && errRule.maxWidth ? {
              width: `${errRule.maxWidth}px`
            } : null
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: `vxe-cell--valid-error-wrapper vxe-cell--valid-error-theme-${validOpts.theme || 'normal'}`
          }, [validSlot ? $xeTable.callSlot(validSlot, validParams) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-cell--valid-error-msg'
          }, errorValidItem.content)]])]));
        }
      }
      let showAreaRowStatus = false;
      if (mouseConfig && mouseOpts.area && !_columnIndex && selectCellToRow) {
        showAreaRowStatus = true;
      }
      if (!fixedHiddenColumn && showResizable && isAllColumnDrag) {
        tdVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'tcc',
          class: ['vxe-cell--col-resizable', {
            'is--line': !border || border === 'none'
          }],
          onMousedown: evnt => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
          onDblclick: evnt => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
        }));
      }
      if ((rowResize || isAllRowDrag) && rowOpts.resizable) {
        tdVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'tcr',
          class: 'vxe-cell--row-resizable',
          onMousedown: evnt => $xeTable.handleRowResizeMousedownEvent(evnt, cellParams),
          onDblclick: evnt => $xeTable.handleRowResizeDblclickEvent(evnt, cellParams)
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
        class: ['vxe-table--column vxe-body--column', colid, cellVerticalAlign ? `col--vertical-${cellVerticalAlign}` : '', cellAlign ? `col--${cellAlign}` : '', type ? `col--${type}` : '', {
          'col--last': isLastColumn,
          'col--tree-node': treeNode,
          'col--edit': isEdit,
          'col--ellipsis': hasEllipsis,
          'col--cs-height': isCsHeight,
          'col--rs-height': isRsHeight,
          'col--to-row': showAreaRowStatus,
          'col--auto-height': isVNAutoHeight,
          'fixed--width': !isAutoCellWidth,
          'fixed--hidden': fixedHiddenColumn,
          'is--padding': isCellPadding,
          'is--progress': fixedHiddenColumn && isAllOverflow || isVNPreEmptyStatus,
          'is--drag-cell': isRowDragCell && (isCrossDrag || isPeerDrag || !rowLevel),
          'is--drag-disabled': isDisabledDrag,
          'col--dirty': isDirty,
          'col--active': editConfig && isEdit && actived.row === row && (actived.column === column || editOpts.mode === 'row'),
          'col--valid-error': !!errorValidItem,
          'col--current': currentColumn === column
        }, getPropClass(compCellClassName, cellParams), getPropClass(className, cellParams), getPropClass(allCellClassName, cellParams)],
        key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || rowOpts.useKey || columnOpts.drag ? colid : $columnIndex,
        ...tdAttrs,
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(compCellStyle) ? compCellStyle(cellParams) : compCellStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(cellStyle) ? cellStyle(cellParams) : cellStyle),
        ...tdOns
      }, isOptimizeMode && fixedHiddenColumn ? [] : tdVNs);
    };
    const renderRows = (fixedType, isOptimizeMode, tableData, tableColumn) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const {
        stripe,
        rowKey,
        highlightHoverRow,
        rowClassName,
        rowStyle,
        editConfig,
        treeConfig
      } = tableProps;
      const {
        hasFixedColumn,
        treeExpandedFlag,
        scrollXLoad,
        scrollYLoad,
        isAllOverflow,
        rowExpandedFlag,
        expandColumn,
        selectRadioRow,
        pendingRowFlag,
        rowExpandHeightFlag,
        isRowGroupStatus
      } = tableReactData;
      const {
        fullAllDataRowIdData,
        fullColumnIdData,
        treeExpandedMaps,
        pendingRowMaps,
        rowExpandedMaps
      } = tableInternalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const radioOpts = computeRadioOpts.value;
      const treeOpts = computeTreeOpts.value;
      const editOpts = computeEditOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const {
        transform,
        seqMode
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rows = [];
      const {
        handleGetRowId
      } = createHandleGetRowId($xeTable);
      const isDeepRow = treeConfig || isRowGroupStatus;
      tableData.forEach((row, $rowIndex) => {
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid] || {};
        let rowIndex = $rowIndex;
        let rowLevel = 0;
        let seq = -1;
        let _rowIndex = -1;
        const hasRowGroupAggregate = isRowGroupStatus && row.isAggregate;
        const trOn = {};
        // 
        if (rowOpts.isHover || highlightHoverRow) {
          trOn.onMouseover = evnt => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.triggerHoverEvent(evnt, {
              row,
              rowIndex
            });
          };
          trOn.onMouseleave = () => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.clearHoverRow();
          };
        }
        if (rowRest) {
          rowIndex = rowRest.index;
          _rowIndex = rowRest._index;
          rowLevel = rowRest.level;
          seq = rowRest.seq;
          if (hasRowGroupAggregate || treeConfig && transform && seqMode === 'increasing') {
            seq = rowRest._index + 1;
          } else if (treeConfig && seqMode === 'fixed') {
            seq = rowRest._tIndex + 1;
          }
        }
        const params = {
          $table: $xeTable,
          seq,
          rowid,
          fixed: fixedType,
          type: renderType,
          level: rowLevel,
          row,
          rowIndex,
          $rowIndex,
          _rowIndex
        };
        // 
        const isExpandRow = expandColumn && !!rowExpandedFlag && !!rowExpandedMaps[rowid];
        // 
        let isExpandTree = false;
        let rowChildren = [];
        let isNewRow = false;
        if (editConfig) {
          isNewRow = $xeTable.isInsertByRow(row);
        }
        if (treeConfig && !scrollYLoad && !transform) {
          rowChildren = row[childrenField];
          isExpandTree = !!treeExpandedFlag && rowChildren && rowChildren.length > 0 && !!treeExpandedMaps[rowid];
        }
        // 
        if (rowOpts.drag && !isRowGroupStatus && (!treeConfig || transform)) {
          trOn.onDragstart = $xeTable.handleRowDragDragstartEvent;
          trOn.onDragend = $xeTable.handleRowDragDragendEvent;
          trOn.onDragover = $xeTable.handleRowDragDragoverEvent;
        }
        const trClass = ['vxe-body--row', isDeepRow ? `row--level-${rowLevel}` : '', {
          'row--stripe': stripe && (_rowIndex + 1) % 2 === 0,
          'is--new': isNewRow,
          'is--expand-row': isExpandRow,
          'is--expand-tree': isExpandTree,
          'row--new': isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),
          'row--radio': radioOpts.highlight && $xeTable.eqRow(selectRadioRow, row),
          'row--checked': checkboxOpts.highlight && $xeTable.isCheckedByCheckboxRow(row),
          'row--pending': !!pendingRowFlag && !!pendingRowMaps[rowid],
          'row--group': hasRowGroupAggregate
        }, getPropClass(rowClassName, params)];
        const tdVNs = tableColumn.map((column, $columnIndex) => {
          return renderTdColumn(seq, rowid, fixedType, isOptimizeMode, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, tableColumn, tableData);
        });
        rows.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
          class: trClass,
          rowid: rowid,
          style: rowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rowStyle) ? rowStyle(params) : rowStyle : null,
          key: rowKey || scrollXLoad || scrollYLoad || rowOpts.useKey || rowOpts.drag || columnOpts.drag || isRowGroupStatus || treeConfig ? rowid : $rowIndex,
          ...trOn
        }, tdVNs));
        // 
        if (isExpandRow) {
          const expandOpts = computeExpandOpts.value;
          const {
            height: expandHeight,
            padding,
            mode: expandMode
          } = expandOpts;
          if (expandMode === 'fixed') {
            rows.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
              class: 'vxe-body--row-expanded-place',
              key: `expand_${rowid}`,
              rowid
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
              class: 'vxe-body--row-expanded-place-column',
              colspan: tableColumn.length,
              style: {
                height: `${rowExpandHeightFlag ? rowRest.expandHeight || expandHeight : 0}px`
              }
            })]));
          } else {
            const cellStyle = {};
            if (expandHeight) {
              cellStyle.height = `${expandHeight}px`;
            }
            if (treeConfig) {
              cellStyle.paddingLeft = `${rowLevel * treeOpts.indent + 30}px`;
            }
            const {
              showOverflow
            } = expandColumn || {};
            const colid = expandColumn.id;
            const colRest = fullColumnIdData[colid] || {};
            const hasEllipsis = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(showOverflow) ? isAllOverflow : showOverflow;
            let columnIndex = -1;
            let $columnIndex = -1;
            let _columnIndex = -1;
            if (colRest) {
              columnIndex = colRest.index;
              $columnIndex = colRest.$index;
              _columnIndex = colRest._index;
            }
            const expandParams = {
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt,
              seq,
              column: expandColumn,
              columnIndex,
              $columnIndex,
              _columnIndex,
              fixed: fixedType,
              source: sourceType,
              type: renderType,
              level: rowLevel,
              row,
              rowid,
              rowIndex,
              $rowIndex,
              _rowIndex,
              isHidden: false,
              isEdit: false,
              visibleData: [],
              data: [],
              items: []
            };
            rows.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
              class: ['vxe-body--expanded-row', {
                'is--padding': padding
              }],
              key: `expand_${rowid}`
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
              class: ['vxe-body--expanded-column', {
                'fixed--hidden': fixedType && !hasFixedColumn,
                'col--ellipsis': hasEllipsis
              }],
              colspan: tableColumn.length
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: ['vxe-body--expanded-cell', {
                'is--ellipsis': expandHeight
              }],
              style: cellStyle
            }, [expandColumn.renderData(expandParams)])])]));
          }
        }
        // 
        if (isExpandTree) {
          rows.push(...renderRows(fixedType, isOptimizeMode, rowChildren, tableColumn));
        }
      });
      return rows;
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          fixedType
        } = props;
        const {
          elemStore
        } = tableInternalData;
        const prefix = `${fixedType || 'main'}-body-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refBodyScroll;
        elemStore[`${prefix}table`] = refBodyTable;
        elemStore[`${prefix}colgroup`] = refBodyColgroup;
        elemStore[`${prefix}list`] = refBodyTBody;
        elemStore[`${prefix}xSpace`] = refBodyXSpace;
        elemStore[`${prefix}ySpace`] = refBodyYSpace;
        elemStore[`${prefix}emptyBlock`] = refBodyEmptyBlock;
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      const {
        fixedType
      } = props;
      const {
        elemStore
      } = tableInternalData;
      const prefix = `${fixedType || 'main'}-body-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}ySpace`] = null;
      elemStore[`${prefix}emptyBlock`] = null;
    });
    const renderVN = () => {
      const {
        slots
      } = tableContext;
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const {
        fixedColumn,
        fixedType,
        tableColumn
      } = props;
      const {
        mouseConfig
      } = tableProps;
      const {
        isGroup,
        tableData,
        isColLoading,
        overflowX,
        scrollXLoad,
        scrollYLoad,
        dragRow,
        dragCol
      } = tableReactData;
      const {
        visibleColumn,
        fullAllDataRowIdData,
        fullColumnIdData
      } = tableInternalData;
      const emptyOpts = computeEmptyOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const isBodyRenderOptimize = computeIsBodyRenderOptimize.value;
      let renderDataList = tableData;
      let renderColumnList = tableColumn;
      const isOptimizeMode = isBodyRenderOptimize;
      if (!isColLoading && (fixedType || !overflowX)) {
        renderColumnList = visibleColumn;
      }
      if (fixedType) {
        if (isOptimizeMode) {
          renderColumnList = fixedColumn || [];
        }
      }
      // 
      if (scrollYLoad && dragRow) {
        if (renderDataList.length > 2) {
          const dRowRest = fullAllDataRowIdData[getRowid($xeTable, dragRow)];
          if (dRowRest) {
            const drIndex = dRowRest._index;
            const firstRow = renderDataList[0];
            const lastRow = renderDataList[renderDataList.length - 1];
            const firstRowRest = fullAllDataRowIdData[getRowid($xeTable, firstRow)];
            const lastRowRest = fullAllDataRowIdData[getRowid($xeTable, lastRow)];
            if (firstRowRest && lastRowRest) {
              const frIndex = firstRowRest._index;
              const lrIndex = lastRowRest._index;
              if (drIndex < frIndex) {
                renderDataList = [dragRow].concat(renderDataList);
              } else if (drIndex > lrIndex) {
                renderDataList = renderDataList.concat([dragRow]);
              }
            }
          }
        }
      }
      if (!fixedType && !isGroup) {
        // 
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                }
              }
            }
          }
        }
      }
      let emptyContent;
      const emptySlot = slots ? slots.empty : null;
      const emptyParams = {
        $table: $xeTable,
        $grid: $xeGrid,
        $gantt: $xeGantt
      };
      if (emptySlot) {
        emptyContent = $xeTable.callSlot(emptySlot, emptyParams);
      } else {
        const compConf = emptyOpts.name ? body_renderer.get(emptyOpts.name) : null;
        const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (rtEmptyView) {
          emptyContent = getSlotVNs(rtEmptyView(emptyOpts, emptyParams));
        } else {
          emptyContent = tableProps.emptyText || body_getI18n('vxe.table.emptyText');
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--body-wrapper', fixedType ? `fixed-${fixedType}--wrapper` : 'body--wrapper'],
        xid: xID
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refBodyScroll,
        class: 'vxe-table--body-inner-wrapper',
        onScroll(evnt) {
          $xeTable.triggerBodyScrollEvent(evnt, fixedType);
        }
      }, [fixedType ? body_renderEmptyElement($xeTable) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refBodyXSpace,
        class: 'vxe-body--x-space'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refBodyYSpace,
        class: 'vxe-body--y-space'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        ref: refBodyTable,
        class: 'vxe-table--body',
        xid: xID,
        cellspacing: 0,
        cellpadding: 0,
        border: 0,
        xvm: isOptimizeMode ? '1' : null
      }, [
      /**
       * 
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('colgroup', {
        ref: refBodyColgroup
      }, renderColumnList.map((column, $columnIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
          name: column.id,
          key: $columnIndex,
          style: {
            width: `${column.renderWidth}px`
          }
        });
      })),
      /**
       * 
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', {
        ref: refBodyTBody
      }, renderRows(fixedType, isOptimizeMode, renderDataList, renderColumnList))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--checkbox-range'
      }), mouseConfig && mouseOpts.area ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--cell-area',
        xid: xID
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-main-area'
      }, mouseOpts.extension ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-main-area-btn',
        onMousedown(evnt) {
          if ($xeTable.triggerCellAreaExtendMousedownEvent) {
            $xeTable.triggerCellAreaExtendMousedownEvent(evnt, {
              $table: $xeTable,
              fixed: fixedType,
              type: renderType
            });
          }
        }
      })] : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-clip-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-extend-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-multi-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-active-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-row-status-area'
      })]) : body_renderEmptyElement($xeTable), !fixedType ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--empty-block',
        ref: refBodyEmptyBlock
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--empty-content'
      }, emptyContent)]) : body_renderEmptyElement($xeTable)])]);
    };
    return renderVN;
  }
}));
;// ./packages/table/src/header.ts











const {
  renderer: header_renderer,
  renderEmptyElement: header_renderEmptyElement
} = core_.VxeUI;
const header_sourceType = 'table';
const header_renderType = 'header';
function getColumnFirstChild(column) {
  const {
    children
  } = column;
  if (children && children.length) {
    return getColumnFirstChild(children[0]);
  }
  return column;
}
function getColumnLastChild(column) {
  const {
    children
  } = column;
  if (children && children.length) {
    return getColumnLastChild(children[children.length - 1]);
  }
  return column;
}
/* harmony default export */ var header = (defineVxeComponent({
  name: 'VxeTableHeader',
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      xID,
      props: tableProps,
      reactData: tableReactData,
      internalData: tableInternalData
    } = $xeTable;
    const {
      computeColumnOpts,
      computeColumnDragOpts,
      computeCellOpts,
      computeMouseOpts,
      computeHeaderCellOpts,
      computeDefaultRowHeight,
      computeVirtualXOpts,
      computeFloatingFilterOpts,
      computeIsHeaderRenderOptimize
    } = $xeTable.getComputeMaps();
    const headerColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderScroll = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderTHead = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderXSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderBorderRepair = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const uploadColumn = () => {
      const {
        showCustomHeader
      } = tableProps;
      const {
        collectColumn,
        visibleColumn
      } = tableInternalData;
      const {
        tableGroupColumn
      } = props;
      const {
        isGroup
      } = tableReactData;
      let spanColumns = isGroup ? convertHeaderColumnToRows(tableGroupColumn) : [];
      let visibleColgroups = [];
      if (showCustomHeader && spanColumns.length > 1) {
        visibleColgroups = convertHeaderToGridRows(spanColumns);
        spanColumns = visibleColgroups;
      }
      headerColumn.value = spanColumns;
      $xeTable.dispatchEvent('columns-change', {
        visibleColgroups,
        collectColumn,
        visibleColumn
      }, null);
    };
    const renderRows = (isGroup, isOptimizeMode, headerGroups, $rowIndex, cols) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const {
        fixedType
      } = props;
      const {
        resizable: allResizable,
        columnKey,
        showCustomHeader,
        headerCellClassName,
        headerCellStyle,
        showHeaderOverflow: allColumnHeaderOverflow,
        headerAlign: allHeaderAlign,
        align: allAlign,
        mouseConfig
      } = tableProps;
      const {
        currentColumn,
        dragCol,
        scrollXLoad,
        scrollYLoad,
        overflowX,
        mergeHeadFlag,
        tableColumn
      } = tableReactData;
      const {
        fullColumnIdData,
        scrollXStore,
        mergeHeaderList,
        mergeHeaderCellMaps
      } = tableInternalData;
      const virtualXOpts = computeVirtualXOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const headerCellOpts = computeHeaderCellOpts.value;
      const currCellHeight = getCalcHeight(headerCellOpts.height) || defaultRowHeight;
      const {
        disabledMethod: dragDisabledMethod,
        isCrossDrag,
        isPeerDrag
      } = columnDragOpts;
      const isLastRow = $rowIndex === headerGroups.length - 1;
      return cols.map((column, $columnIndex) => {
        const {
          type,
          showHeaderOverflow,
          headerAlign,
          align,
          filters,
          headerClassName,
          editRender,
          cellRender
        } = column;
        const colid = column.id;
        const colRest = fullColumnIdData[colid] || {};
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? header_renderer.get(renderOpts.name) : null;
        const isColGroup = column.children && column.children.length;
        const fixedHiddenColumn = overflowX && !isColGroup && (fixedType ? column.fixed !== fixedType : !!column.fixed);
        const isPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(headerCellOpts.padding) ? headerCellOpts.padding : cellOpts.padding;
        const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
        const headAlign = headerAlign || (compConf ? compConf.tableHeaderCellAlign : '') || allHeaderAlign || align || (compConf ? compConf.tableCellAlign : '') || allAlign;
        const showEllipsis = headOverflow === 'ellipsis';
        const showTitle = headOverflow === 'title';
        const showTooltip = headOverflow === true || headOverflow === 'tooltip';
        const hasEllipsis = showTitle || showTooltip || showEllipsis;
        let hasFilter = false;
        let firstFilterOption = null;
        if (filters) {
          firstFilterOption = filters[0];
          hasFilter = filters.some(item => item.checked);
        }
        const columnIndex = colRest.index;
        const _columnIndex = colRest._index;
        const cellParams = {
          $table: $xeTable,
          $grid: $xeGrid,
          $gantt: $xeGantt,
          $rowIndex,
          column,
          columnIndex,
          $columnIndex,
          _columnIndex,
          firstFilterOption: firstFilterOption,
          fixed: fixedType,
          source: header_sourceType,
          type: header_renderType,
          isHidden: fixedHiddenColumn,
          hasFilter
        };
        const thAttrs = {
          colid
        };
        let isMergeCell = false;
        // 
        if (!showCustomHeader) {
          thAttrs.colspan = column.colSpan > 1 ? column.colSpan : null;
          thAttrs.rowspan = column.rowSpan > 1 ? column.rowSpan : null;
        }
        if (mergeHeadFlag && mergeHeaderList.length && (showCustomHeader || isLastRow)) {
          const spanRest = mergeHeaderCellMaps[`${$rowIndex}:${showCustomHeader ? $columnIndex : _columnIndex}`];
          if (spanRest) {
            const {
              rowspan,
              colspan
            } = spanRest;
            if (!rowspan || !colspan) {
              return null;
            }
            if (rowspan > 1) {
              isMergeCell = true;
              thAttrs.rowspan = rowspan;
            }
            if (colspan > 1) {
              isMergeCell = true;
              thAttrs.colspan = colspan;
            }
          }
        }
        const thOns = {
          onClick: evnt => $xeTable.triggerHeaderCellClickEvent(evnt, cellParams),
          onDblclick: evnt => $xeTable.triggerHeaderCellDblclickEvent(evnt, cellParams)
        };
        const isColDragCell = columnOpts.drag && columnDragOpts.trigger === 'cell';
        let isDisabledDrag = false;
        if (isColDragCell) {
          isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(cellParams));
        }
        // 
        if (mouseConfig || isColDragCell) {
          thOns.onMousedown = evnt => $xeTable.triggerHeaderCellMousedownEvent(evnt, cellParams);
        }
        // 
        if (columnOpts.drag) {
          thOns.onDragstart = $xeTable.handleHeaderCellDragDragstartEvent;
          thOns.onDragend = $xeTable.handleHeaderCellDragDragendEvent;
          thOns.onDragover = $xeTable.handleHeaderCellDragDragoverEvent;
          if (isColDragCell) {
            thOns.onMouseup = $xeTable.handleHeaderCellDragMouseupEvent;
          }
        }
        const isLastColumn = $columnIndex === cols.length - 1;
        const showResizable = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
        const isAutoCellWidth = !column.resizeWidth && (column.minWidth === 'auto' || column.width === 'auto');
        let isVNPreEmptyStatus = false;
        if (isOptimizeMode && overflowX && !isGroup && !isMergeCell) {
          if (!dragCol || dragCol.id !== colid) {
            if (scrollXLoad && tableColumn.length > 10 && !column.fixed && !virtualXOpts.immediate && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
              isVNPreEmptyStatus = true;
            }
          }
        }
        const tcStyle = {};
        if (hasEllipsis) {
          tcStyle.height = `${currCellHeight}px`;
        } else {
          tcStyle.minHeight = `${currCellHeight}px`;
        }
        if (showCustomHeader) {
          // custom
        } else if (isColGroup && !isLastRow) {
          const firstCol = getColumnFirstChild(column);
          const lastCol = getColumnLastChild(column);
          if (firstCol && lastCol && firstCol.id !== lastCol.id) {
            const firstColRest = fullColumnIdData[firstCol.id];
            const lastColRest = fullColumnIdData[lastCol.id];
            if (firstColRest && lastColRest) {
              tcStyle.width = `${lastColRest.oLeft - firstColRest.oLeft + lastCol.renderWidth}px`;
            }
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {
          class: ['vxe-table--column vxe-header--column', colid, fixedHiddenColumn ? 'fixed--hidden' : 'fixed--visible', {
            [`col--${headAlign}`]: headAlign,
            [`col--${type}`]: type,
            'col--last': isLastColumn,
            'col--fixed': column.fixed,
            'col--group': isColGroup,
            'col--ellipsis': hasEllipsis,
            'fixed--width': !isAutoCellWidth,
            'is--padding': isPadding,
            'is--sortable': column.sortable,
            'col--filter': !!filters,
            'is--filter-active': hasFilter,
            'is--drag-active': columnOpts.drag && !column.fixed && !isDisabledDrag && (isCrossDrag || isPeerDrag || !column.parentId),
            'is--drag-disabled': columnOpts.drag && isDisabledDrag,
            'col--current': currentColumn === column
          }, headerClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerClassName) ? headerClassName(cellParams) : headerClassName : '', headerCellClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerCellClassName) ? headerCellClassName(cellParams) : headerCellClassName : ''],
          style: headerCellStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerCellStyle) ? headerCellStyle(cellParams) : headerCellStyle : null,
          ...thAttrs,
          ...thOns,
          key: showCustomHeader ? `${colid}${$columnIndex}` : columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || columnOpts.drag || isColGroup ? colid : $columnIndex
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-cell', {
            'c--title': showTitle,
            'c--tooltip': showTooltip,
            'c--ellipsis': showEllipsis
          }],
          style: tcStyle
        }, isVNPreEmptyStatus || isOptimizeMode && fixedHiddenColumn ? [] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          colid,
          class: 'vxe-cell--wrapper vxe-header-cell--wrapper'
        }, column.renderHeader(cellParams))]),
        /**
         * 
         */
        !fixedHiddenColumn && showResizable && (!showCustomHeader || isLastRow) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-cell--col-resizable',
          onMousedown: evnt => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
          onDblclick: evnt => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
        }) : header_renderEmptyElement($xeTable)]);
      });
    };
    const renderFilterRows = (isOptimizeMode, cols) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const {
        fixedType
      } = props;
      const {
        showHeaderOverflow: allColumnHeaderOverflow,
        headerAlign: allHeaderAlign,
        align: allAlign
      } = tableProps;
      const {
        currentColumn,
        overflowX
      } = tableReactData;
      const {
        fullColumnIdData
      } = tableInternalData;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const headerCellOpts = computeHeaderCellOpts.value;
      const currCellHeight = getCalcHeight(headerCellOpts.height) || defaultRowHeight;
      return cols.map((column, $columnIndex) => {
        const {
          type,
          showHeaderOverflow,
          headerAlign,
          align,
          filters,
          editRender,
          cellRender,
          floatingFilters,
          filterRender,
          slots
        } = column;
        const colid = column.id;
        const colRest = fullColumnIdData[colid] || {};
        const renderOpts = editRender || cellRender;
        const flSlot = slots ? slots.floatingFilter || slots['floating-filter'] : null;
        const compConf = renderOpts ? header_renderer.get(renderOpts.name) : null;
        const flCompConf = isEnableConf(filterRender) ? header_renderer.get(filterRender.name) : null;
        const rtFloatingFilter = flCompConf ? flCompConf.renderTableFloatingFilter : null;
        const fixedHiddenColumn = overflowX && (fixedType ? column.fixed !== fixedType : !!column.fixed);
        const isPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(headerCellOpts.padding) ? headerCellOpts.padding : cellOpts.padding;
        const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
        const headAlign = headerAlign || (compConf ? compConf.tableHeaderCellAlign : '') || allHeaderAlign || align || (compConf ? compConf.tableCellAlign : '') || allAlign;
        const showEllipsis = headOverflow === 'ellipsis';
        const showTitle = headOverflow === 'title';
        const showTooltip = headOverflow === true || headOverflow === 'tooltip';
        const hasEllipsis = showTitle || showTooltip || showEllipsis;
        let hasFilter = false;
        let firstFilterOption = null;
        if (filters) {
          firstFilterOption = filters[0];
          hasFilter = filters.some(item => item.checked);
        }
        const columnIndex = colRest.index;
        const _columnIndex = colRest._index;
        const cellParams = {
          $table: $xeTable,
          $grid: $xeGrid,
          $gantt: $xeGantt,
          column,
          columnIndex,
          $columnIndex,
          _columnIndex,
          option: firstFilterOption,
          fixed: fixedType,
          source: header_sourceType,
          type: header_renderType,
          isHidden: fixedHiddenColumn,
          hasFilter
        };
        const thAttrs = {
          colid
        };
        const isLastColumn = $columnIndex === cols.length - 1;
        const isAutoCellWidth = !column.resizeWidth && (column.minWidth === 'auto' || column.width === 'auto');
        const tcStyle = {};
        if (hasEllipsis) {
          tcStyle.height = `${currCellHeight}px`;
        } else {
          tcStyle.minHeight = `${currCellHeight}px`;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {
          class: ['vxe-table--column vxe-header--column', colid, fixedHiddenColumn ? 'fixed--hidden' : 'fixed--visible', {
            [`col--${headAlign}`]: headAlign,
            [`col--${type}`]: type,
            'col--last': isLastColumn,
            'col--fixed': column.fixed,
            'col--ellipsis': hasEllipsis,
            'fixed--width': !isAutoCellWidth,
            'is--padding': isPadding,
            'is--sortable': column.sortable,
            'col--current': currentColumn === column
          }],
          key: colid,
          ...thAttrs
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-cell', {
            'c--title': showTitle,
            'c--tooltip': showTooltip,
            'c--ellipsis': showEllipsis
          }],
          style: tcStyle
        }, isOptimizeMode && fixedHiddenColumn && !floatingFilters ? [] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          colid,
          class: 'vxe-cell--wrapper vxe-header-cell--wrapper'
        }, flSlot ? $xeTable.callSlot(flSlot, cellParams) : rtFloatingFilter && firstFilterOption ? getSlotVNs(rtFloatingFilter(filterRender, cellParams)) : [])])]);
      });
    };
    const renderHeads = (isGroup, isOptimizeMode, headerGroups) => {
      const {
        fixedType
      } = props;
      const {
        headerRowClassName,
        headerRowStyle
      } = tableProps;
      const floatingFilterOpts = computeFloatingFilterOpts.value;
      const rowVNs = headerGroups.map((cols, $rowIndex) => {
        const params = {
          $table: $xeTable,
          $rowIndex,
          fixed: fixedType,
          type: header_renderType
        };
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
          key: $rowIndex,
          class: ['vxe-header--row', headerRowClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ''],
          style: headerRowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : null
        }, renderRows(isGroup, isOptimizeMode, headerGroups, $rowIndex, cols));
      });
      if (floatingFilterOpts.enabled) {
        rowVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
          key: 'ff',
          class: ['vxe-header--row']
        }, renderFilterRows(isOptimizeMode, headerGroups[headerGroups.length - 1])));
      }
      return rowVNs;
    };
    const renderVN = () => {
      const {
        fixedType,
        fixedColumn,
        tableColumn
      } = props;
      const {
        mouseConfig
      } = tableProps;
      const {
        isGroup,
        isColLoading,
        overflowX,
        scrollXLoad,
        dragCol
      } = tableReactData;
      const {
        visibleColumn,
        fullColumnIdData
      } = tableInternalData;
      const mouseOpts = computeMouseOpts.value;
      const isHeaderRenderOptimize = computeIsHeaderRenderOptimize.value;
      let renderHeaderList = headerColumn.value || [];
      let renderColumnList = tableColumn;
      const isOptimizeMode = isHeaderRenderOptimize;
      if (isGroup) {
        renderColumnList = visibleColumn;
      } else {
        if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
          renderColumnList = visibleColumn;
        }
        if (fixedType) {
          // 
          if (isOptimizeMode) {
            renderColumnList = fixedColumn || [];
          }
        }
        renderHeaderList = [renderColumnList];
      }
      if (!fixedType && !isGroup) {
        // 
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                  renderHeaderList = [[dragCol].concat(renderHeaderList[0])].concat(renderHeaderList.slice(1));
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                  renderHeaderList = [renderHeaderList[0].concat([dragCol])].concat(renderHeaderList.slice(1));
                }
              }
            }
          }
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--header-wrapper', fixedType ? `fixed-${fixedType}--wrapper` : 'body--wrapper'],
        xid: xID
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeaderScroll,
        class: 'vxe-table--header-inner-wrapper',
        onScroll(evnt) {
          $xeTable.triggerHeaderScrollEvent(evnt, fixedType);
        }
      }, [fixedType ? header_renderEmptyElement($xeTable) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeaderXSpace,
        class: 'vxe-body--x-space'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        ref: refHeaderTable,
        class: 'vxe-table--header',
        xid: xID,
        cellspacing: 0,
        cellpadding: 0,
        border: 0,
        xvm: isOptimizeMode ? '1' : null
      }, [
      /**
       * 
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('colgroup', {
        ref: refHeaderColgroup
      }, renderColumnList.map((column, $columnIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
          name: column.id,
          key: $columnIndex,
          style: {
            width: `${column.renderWidth}px`
          }
        });
      })),
      /**
       * 
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', {
        ref: refHeaderTHead
      }, renderHeads(isGroup, isOptimizeMode, renderHeaderList))]), mouseConfig && mouseOpts.area ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--cell-area',
        xid: xID
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-main-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-clip-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-extend-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-multi-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-active-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-col-status-area'
      })]) : header_renderEmptyElement($xeTable)])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.tableColumn, uploadColumn);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          fixedType
        } = props;
        const {
          internalData
        } = $xeTable;
        const {
          elemStore
        } = internalData;
        const prefix = `${fixedType || 'main'}-header-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refHeaderScroll;
        elemStore[`${prefix}table`] = refHeaderTable;
        elemStore[`${prefix}colgroup`] = refHeaderColgroup;
        elemStore[`${prefix}list`] = refHeaderTHead;
        elemStore[`${prefix}xSpace`] = refHeaderXSpace;
        elemStore[`${prefix}repair`] = refHeaderBorderRepair;
        uploadColumn();
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      const {
        fixedType
      } = props;
      const {
        internalData
      } = $xeTable;
      const {
        elemStore
      } = internalData;
      const prefix = `${fixedType || 'main'}-header-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}repair`] = null;
    });
    return renderVN;
  }
}));
;// ./packages/table/src/footer.ts







const {
  renderer: footer_renderer,
  renderEmptyElement: footer_renderEmptyElement
} = core_.VxeUI;
const footer_sourceType = 'table';
const footer_renderType = 'footer';
/* harmony default export */ var footer = (defineVxeComponent({
  name: 'VxeTableFooter',
  props: {
    footerTableData: {
      type: Array,
      default: () => []
    },
    tableColumn: {
      type: Array,
      default: () => []
    },
    fixedColumn: {
      type: Array,
      default: () => []
    },
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      xID,
      props: tableProps,
      reactData: tableReactData,
      internalData: tableInternalData
    } = $xeTable;
    const {
      computeFooterTooltipOpts,
      computeColumnOpts,
      computeCellOpts,
      computeFooterCellOpts,
      computeDefaultRowHeight,
      computeResizableOpts,
      computeVirtualXOpts,
      computeIsFooterRenderOptimize
    } = $xeTable.getComputeMaps();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterScroll = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterTFoot = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterXSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const renderRows = (isOptimizeMode, tableColumn, footerTableData, row, $rowIndex, _rowIndex) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const {
        fixedType
      } = props;
      const {
        resizable: allResizable,
        border,
        footerCellClassName,
        footerCellStyle,
        footerAlign: allFooterAlign,
        footerSpanMethod,
        align: allAlign,
        columnKey,
        showFooterOverflow: allColumnFooterOverflow
      } = tableProps;
      const {
        scrollXLoad,
        scrollYLoad,
        overflowX,
        currentColumn,
        mergeFootFlag
      } = tableReactData;
      const {
        fullColumnIdData,
        mergeFooterList,
        mergeFooterCellMaps,
        scrollXStore
      } = tableInternalData;
      const virtualXOpts = computeVirtualXOpts.value;
      const footerTooltipOpts = computeFooterTooltipOpts.value;
      const resizableOpts = computeResizableOpts.value;
      const {
        isAllColumnDrag
      } = resizableOpts;
      const columnOpts = computeColumnOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const cellOpts = computeCellOpts.value;
      const footerCellOpts = computeFooterCellOpts.value;
      const currCellHeight = getCalcHeight(footerCellOpts.height) || defaultRowHeight;
      return tableColumn.map((column, $columnIndex) => {
        const {
          type,
          showFooterOverflow,
          footerAlign,
          align,
          footerClassName,
          editRender,
          cellRender
        } = column;
        const colid = column.id;
        const colRest = fullColumnIdData[colid] || {};
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? footer_renderer.get(renderOpts.name) : null;
        const showAllTip = footerTooltipOpts.showAll;
        const fixedHiddenColumn = overflowX && (fixedType ? column.fixed !== fixedType : !!column.fixed);
        const isPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(footerCellOpts.padding) ? footerCellOpts.padding : cellOpts.padding;
        const footOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
        const footAlign = footerAlign || (compConf ? compConf.tableFooterCellAlign : '') || allFooterAlign || align || (compConf ? compConf.tableCellAlign : '') || allAlign;
        const showEllipsis = footOverflow === 'ellipsis';
        const showTitle = footOverflow === 'title';
        const showTooltip = footOverflow === true || footOverflow === 'tooltip';
        const hasEllipsis = showTitle || showTooltip || showEllipsis;
        const showResizable = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
        const attrs = {
          colid
        };
        const tfOns = {};
        const columnIndex = colRest.index;
        const _columnIndex = colRest._index;
        const itemIndex = _columnIndex;
        const cellParams = {
          $table: $xeTable,
          $grid: $xeGrid,
          $gantt: $xeGantt,
          row,
          rowIndex: _rowIndex,
          _rowIndex,
          $rowIndex,
          column,
          columnIndex,
          $columnIndex,
          _columnIndex,
          itemIndex,
          items: row,
          fixed: fixedType,
          source: footer_sourceType,
          type: footer_renderType,
          data: footerTableData
        };
        if (showTitle || showTooltip || showAllTip) {
          tfOns.onMouseenter = evnt => {
            if (showTitle) {
              updateCellTitle(evnt.currentTarget, column);
            } else if (showTooltip || showAllTip) {
              $xeTable.triggerFooterTooltipEvent(evnt, cellParams);
            }
          };
        }
        if (showTooltip || showAllTip) {
          tfOns.onMouseleave = evnt => {
            if (showTooltip || showAllTip) {
              $xeTable.handleTargetLeaveEvent(evnt);
            }
          };
        }
        tfOns.onClick = evnt => {
          $xeTable.dispatchEvent('footer-cell-click', Object.assign({
            cell: evnt.currentTarget
          }, cellParams), evnt);
        };
        tfOns.onDblclick = evnt => {
          $xeTable.dispatchEvent('footer-cell-dblclick', Object.assign({
            cell: evnt.currentTarget
          }, cellParams), evnt);
        };
        let isMergeCell = false;
        // 
        if (mergeFootFlag && mergeFooterList.length) {
          const spanRest = mergeFooterCellMaps[`${_rowIndex}:${_columnIndex}`];
          if (spanRest) {
            const {
              rowspan,
              colspan
            } = spanRest;
            if (!rowspan || !colspan) {
              return null;
            }
            if (rowspan > 1) {
              isMergeCell = true;
              attrs.rowspan = rowspan;
            }
            if (colspan > 1) {
              isMergeCell = true;
              attrs.colspan = colspan;
            }
          }
        } else if (footerSpanMethod) {
          // 
          const {
            rowspan = 1,
            colspan = 1
          } = footerSpanMethod(cellParams) || {};
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            attrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            attrs.colspan = colspan;
          }
        }
        const isLastColumn = $columnIndex === tableColumn.length - 1;
        const isAutoCellWidth = !column.resizeWidth && (column.minWidth === 'auto' || column.width === 'auto');
        let isVNPreEmptyStatus = false;
        if (isOptimizeMode && overflowX && !isMergeCell) {
          if (scrollXLoad && tableColumn.length > 10 && !column.fixed && !virtualXOpts.immediate && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          }
        }
        const tcStyle = {};
        if (hasEllipsis) {
          tcStyle.height = `${currCellHeight}px`;
        } else {
          tcStyle.minHeight = `${currCellHeight}px`;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
          class: ['vxe-table--column vxe-footer--column', column.id, {
            [`col--${footAlign}`]: footAlign,
            [`col--${type}`]: type,
            'col--last': isLastColumn,
            'fixed--width': !isAutoCellWidth,
            'fixed--hidden': fixedHiddenColumn,
            'is--padding': isPadding,
            'col--ellipsis': hasEllipsis,
            'col--current': currentColumn === column
          }, getPropClass(footerClassName, cellParams), getPropClass(footerCellClassName, cellParams)],
          ...attrs,
          style: footerCellStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerCellStyle) ? footerCellStyle(cellParams) : footerCellStyle : null,
          ...tfOns,
          key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || columnOpts.drag ? column.id : $columnIndex
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-cell', {
            'c--title': showTitle,
            'c--tooltip': showTooltip,
            'c--ellipsis': showEllipsis
          }],
          style: tcStyle
        }, isVNPreEmptyStatus ? [] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          colid,
          class: 'vxe-cell--wrapper vxe-footer-cell--wrapper'
        }, column.renderFooter(cellParams))]),
        /**
         * 
         */
        !fixedHiddenColumn && showResizable && isAllColumnDrag ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-cell--col-resizable', {
            'is--line': !border || border === 'none'
          }],
          onMousedown: evnt => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
          onDblclick: evnt => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
        }) : footer_renderEmptyElement($xeTable)]);
      });
    };
    const renderHeads = (isOptimizeMode, renderColumnList) => {
      const {
        fixedType,
        footerTableData
      } = props;
      const {
        footerRowClassName,
        footerRowStyle
      } = tableProps;
      return footerTableData.map((row, $rowIndex) => {
        const _rowIndex = $rowIndex;
        const rowParams = {
          $table: $xeTable,
          row,
          _rowIndex,
          $rowIndex,
          fixed: fixedType,
          type: footer_renderType
        };
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
          key: $rowIndex,
          class: ['vxe-footer--row', footerRowClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ''],
          style: footerRowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
        }, renderRows(isOptimizeMode, renderColumnList, footerTableData, row, $rowIndex, _rowIndex));
      });
    };
    const renderVN = () => {
      const {
        fixedType,
        fixedColumn,
        tableColumn
      } = props;
      const {
        visibleColumn,
        fullColumnIdData
      } = tableInternalData;
      const {
        isGroup,
        isColLoading,
        overflowX,
        scrollXLoad,
        dragCol
      } = tableReactData;
      const isFooterRenderOptimize = computeIsFooterRenderOptimize.value;
      let renderColumnList = tableColumn;
      const isOptimizeMode = isFooterRenderOptimize;
      if (!isOptimizeMode || !isColLoading && (fixedType || !overflowX)) {
        renderColumnList = visibleColumn;
      }
      if (fixedType) {
        if (isOptimizeMode) {
          renderColumnList = fixedColumn || [];
        }
      }
      if (!fixedType && !isGroup) {
        // 
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                }
              }
            }
          }
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--footer-wrapper', fixedType ? `fixed-${fixedType}--wrapper` : 'body--wrapper'],
        xid: xID
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refFooterScroll,
        class: 'vxe-table--footer-inner-wrapper',
        onScroll(evnt) {
          $xeTable.triggerFooterScrollEvent(evnt, fixedType);
        }
      }, [fixedType ? footer_renderEmptyElement($xeTable) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refFooterXSpace,
        class: 'vxe-body--x-space'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        ref: refFooterTable,
        class: 'vxe-table--footer',
        xid: xID,
        cellspacing: 0,
        cellpadding: 0,
        border: 0,
        xvm: isOptimizeMode ? '1' : null
      }, [
      /**
      * 
      */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('colgroup', {
        ref: refFooterColgroup
      }, renderColumnList.map((column, $columnIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
          name: column.id,
          key: $columnIndex,
          style: {
            width: `${column.renderWidth}px`
          }
        });
      })),
      /**
      * 
      */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tfoot', {
        ref: refFooterTFoot
      }, renderHeads(isOptimizeMode, renderColumnList))])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          fixedType
        } = props;
        const {
          elemStore
        } = tableInternalData;
        const prefix = `${fixedType || 'main'}-footer-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refFooterScroll;
        elemStore[`${prefix}table`] = refFooterTable;
        elemStore[`${prefix}colgroup`] = refFooterColgroup;
        elemStore[`${prefix}list`] = refFooterTFoot;
        elemStore[`${prefix}xSpace`] = refFooterXSpace;
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      const {
        fixedType
      } = props;
      const {
        elemStore
      } = tableInternalData;
      const prefix = `${fixedType || 'main'}-footer-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
    });
    return renderVN;
  }
}));
;// ./packages/table/module/custom/panel.ts












const {
  getI18n: panel_getI18n,
  getIcon: panel_getIcon,
  renderEmptyElement: panel_renderEmptyElement
} = core_.VxeUI;
function panel_createInternalData() {
  return {
    // teleportTo: undefined,
    // prevDragCol: undefined,
    // prevDragGroupField: undefined,
    // prevDragAggFnColid: undefined,
    // prevDragToChild: false,
    // prevDragPos: null
  };
}
/* harmony default export */ var panel = (defineVxeComponent({
  name: 'TableCustomPanel',
  props: {
    customStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props, context) {
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const VxeUIModalComponent = core_.VxeUI.getComponent('VxeModal');
    const VxeUIDrawerComponent = core_.VxeUI.getComponent('VxeDrawer');
    const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
    const VxeUINumberInputComponent = core_.VxeUI.getComponent('VxeNumberInput');
    const VxeUIRadioGroupComponent = core_.VxeUI.getComponent('VxeRadioGroup');
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      props: tableProps,
      reactData: tableReactData,
      internalData: tableInternalData
    } = $xeTable;
    const {
      computeCustomOpts,
      computeColumnDragOpts,
      computeColumnOpts,
      computeIsMaxFixedColumn,
      computeResizableOpts
    } = $xeTable.getComputeMaps();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyWrapperElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refCustomBodyElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refDragLineElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refDragTipElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const customPanelReactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      dragCol: null,
      dragGroupField: null,
      dragAggFnCol: null,
      dragTipText: ''
    });
    let customPanelInternalData = panel_createInternalData();
    const refMaps = {
      refElem,
      refBodyWrapperElem,
      refCustomBodyElem,
      refDragLineElem,
      refDragTipElem
    };
    const computeMaps = {};
    const handleWrapperMouseenterEvent = evnt => {
      const {
        customStore
      } = props;
      customStore.activeWrapper = true;
      $xeTable.customOpenEvent(evnt);
    };
    const handleWrapperMouseleaveEvent = evnt => {
      const {
        customStore
      } = props;
      customStore.activeWrapper = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xeTable.customCloseEvent(evnt);
        }
      }, 300);
    };
    const confirmCustomEvent = ({
      $event
    }) => {
      tableReactData.isCustomStatus = true;
      $xeTable.saveCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent('confirm', $event);
      $xeTable.emitCustomEvent('close', $event);
    };
    const cancelCloseEvent = ({
      $event
    }) => {
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent('close', $event);
    };
    const cancelCustomEvent = ({
      $event
    }) => {
      $xeTable.cancelCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent('cancel', $event);
      $xeTable.emitCustomEvent('close', $event);
    };
    const handleResetCustomEvent = evnt => {
      $xeTable.resetCustom(true);
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent('reset', evnt);
      $xeTable.emitCustomEvent('close', evnt);
    };
    const resetCustomEvent = ({
      $event
    }) => {
      if (core_.VxeUI.modal) {
        core_.VxeUI.modal.confirm({
          content: panel_getI18n('vxe.custom.cstmConfirmRestore'),
          className: 'vxe-table--ignore-clear',
          escClosable: true
        }).then(type => {
          if (type === 'confirm') {
            handleResetCustomEvent($event);
          }
        });
      } else {
        handleResetCustomEvent($event);
      }
    };
    const handleOptionCheck = column => {
      const {
        customColumnList
      } = tableReactData;
      const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(customColumnList, item => item === column);
      if (matchObj && matchObj.parent) {
        const {
          parent
        } = matchObj;
        if (parent.children && parent.children.length) {
          parent.renderVisible = parent.children.every(column => column.renderVisible);
          parent.halfVisible = !parent.renderVisible && parent.children.some(column => column.renderVisible || column.halfVisible);
          handleOptionCheck(parent);
        }
      }
    };
    const changeCheckboxOption = (column, evnt) => {
      const isChecked = !column.renderVisible;
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
          item.visible = isChecked;
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
        tableReactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore('update:visible');
      } else {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
      }
      handleOptionCheck(column);
      $xeTable.checkCustomStatus();
      $xeTable.dispatchEvent('custom-visible-change', {
        column,
        checked: isChecked
      }, evnt);
    };
    const changeColumnWidth = column => {
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        if (column.renderResizeWidth !== column.renderWidth) {
          column.resizeWidth = column.renderResizeWidth;
          column.renderWidth = column.renderResizeWidth;
          tableReactData.isCustomStatus = true;
          $xeTable.handleCustom();
          $xeTable.saveCustomStore('update:width');
        }
      }
    };
    const changeFixedOption = (column, colFixed, evnt) => {
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const customOpts = computeCustomOpts.value;
      let targetFixed = null;
      if (customOpts.immediate) {
        if (column.renderFixed === colFixed) {
          targetFixed = '';
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], col => {
            col.fixed = '';
            col.renderFixed = '';
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            targetFixed = colFixed;
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], col => {
              col.fixed = colFixed;
              col.renderFixed = colFixed;
            });
          }
        }
        tableReactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore('update:fixed');
      } else {
        if (column.renderFixed === colFixed) {
          targetFixed = '';
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], col => {
            col.renderFixed = '';
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            targetFixed = colFixed;
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], col => {
              col.renderFixed = colFixed;
            });
          }
        }
      }
      if (targetFixed !== null) {
        $xeTable.dispatchEvent('custom-fixed-change', {
          column,
          fixed: targetFixed
        }, evnt);
      }
    };
    const allOptionEvent = evnt => {
      const {
        customStore
      } = tableReactData;
      const isAll = !customStore.isAll;
      $xeTable.toggleCustomAllCheckbox();
      $xeTable.dispatchEvent('custom-visible-all', {
        checked: isAll
      }, evnt);
    };
    const showDropTip = (evnt, optEl, showLine, dragPos) => {
      const bodyWrapperElem = refBodyWrapperElem.value;
      if (!bodyWrapperElem) {
        return;
      }
      const customBodyElem = refCustomBodyElem.value;
      if (!customBodyElem) {
        return;
      }
      const {
        prevDragToChild
      } = customPanelInternalData;
      const bodyWrapperRect = bodyWrapperElem.getBoundingClientRect();
      const customBodyRect = customBodyElem.getBoundingClientRect();
      const dragLineEl = refDragLineElem.value;
      if (optEl) {
        if (dragLineEl) {
          if (showLine) {
            const optRect = optEl.getBoundingClientRect();
            dragLineEl.style.display = 'block';
            dragLineEl.style.left = `${Math.max(0, customBodyRect.x - bodyWrapperRect.x)}px`;
            dragLineEl.style.top = `${Math.max(1, optRect.y + bodyWrapperElem.scrollTop - bodyWrapperRect.y)}px`;
            dragLineEl.style.height = `${optRect.height}px`;
            dragLineEl.style.width = `${optRect.width}px`;
            dragLineEl.setAttribute('drag-pos', dragPos);
            dragLineEl.setAttribute('drag-to-child', prevDragToChild ? 'y' : 'n');
          } else {
            dragLineEl.style.display = '';
          }
        }
      } else {
        if (dragLineEl) {
          dragLineEl.style.display = 'node';
        }
      }
      const dragTipEl = refDragTipElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = 'block';
        dragTipEl.style.top = `${Math.min(bodyWrapperElem.clientHeight + bodyWrapperElem.scrollTop - dragTipEl.clientHeight, evnt.clientY + bodyWrapperElem.scrollTop - bodyWrapperRect.y)}px`;
        dragTipEl.style.left = `${Math.min(bodyWrapperElem.clientWidth + bodyWrapperElem.scrollLeft - dragTipEl.clientWidth, evnt.clientX + bodyWrapperElem.scrollLeft - bodyWrapperRect.x)}px`;
        dragTipEl.setAttribute('drag-status', showLine ? prevDragToChild ? 'sub' : 'normal' : 'disabled');
      }
    };
    const updateColDropTipContent = () => {
      const {
        dragCol
      } = customPanelReactData;
      const columnDragOpts = computeColumnDragOpts.value;
      const {
        tooltipMethod
      } = columnDragOpts;
      let tipContent = '';
      if (tooltipMethod) {
        const dtParams = {
          $table: $xeTable,
          column: dragCol
        };
        tipContent = `${tooltipMethod(dtParams) || ''}`;
      } else {
        tipContent = panel_getI18n('vxe.custom.cstmDragTarget', [dragCol && dragCol.type !== 'html' ? dragCol.getTitle() : '']);
      }
      customPanelReactData.dragTipText = tipContent;
    };
    const hideDropTip = () => {
      const dragTipEl = refDragTipElem.value;
      const dragLineEl = refDragLineElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = '';
      }
      if (dragLineEl) {
        dragLineEl.style.display = '';
      }
    };
    const sortMousedownEvent = evnt => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      const colid = trEl.getAttribute('colid');
      const column = $xeTable.getColumnById(colid);
      trEl.draggable = true;
      customPanelReactData.dragCol = column;
      customPanelReactData.dragGroupField = null;
      customPanelReactData.dragAggFnCol = null;
      updateColDropTipContent();
      addClass(trEl, 'active--drag-origin');
    };
    const sortMouseupEvent = evnt => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      hideDropTip();
      trEl.draggable = false;
      customPanelReactData.dragCol = null;
      customPanelReactData.dragGroupField = null;
      customPanelReactData.dragAggFnCol = null;
      removeClass(trEl, 'active--drag-origin');
    };
    const sortDragstartEvent = evnt => {
      if (evnt.dataTransfer) {
        evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
      }
      customPanelInternalData.prevDragGroupField = null;
      customPanelInternalData.prevDragAggFnColid = null;
    };
    const sortDragendEvent = evnt => {
      const {
        mouseConfig
      } = tableProps;
      const {
        customColumnList
      } = tableReactData;
      const {
        collectColumn
      } = tableInternalData;
      const customOpts = computeCustomOpts.value;
      const {
        immediate
      } = customOpts;
      const trEl = evnt.currentTarget;
      const columnDragOpts = computeColumnDragOpts.value;
      const {
        isCrossDrag,
        isSelfToChildDrag,
        isToChildDrag,
        dragEndMethod
      } = columnDragOpts;
      const {
        dragCol
      } = customPanelReactData;
      const {
        prevDragCol,
        prevDragGroupField,
        prevDragAggFnColid,
        prevDragPos,
        prevDragToChild
      } = customPanelInternalData;
      const dragOffsetIndex = prevDragPos === 'bottom' ? 1 : 0;
      if (prevDragGroupField || prevDragAggFnColid) {
        if ($xeTable.handlePivotTableAggregatePanelDragendEvent) {
          $xeTable.handlePivotTableAggregatePanelDragendEvent(evnt);
        }
      } else if (prevDragCol && dragCol) {
        // 
        if (prevDragCol !== dragCol) {
          const dragColumn = dragCol;
          const newColumn = prevDragCol;
          Promise.resolve(dragEndMethod ? dragEndMethod({
            oldColumn: dragColumn,
            newColumn,
            dragColumn,
            dragPos: prevDragPos,
            dragToChild: !!prevDragToChild,
            offsetIndex: dragOffsetIndex
          }) : true).then(status => {
            if (!status) {
              return;
            }
            let oafIndex = -1;
            let nafIndex = -1;
            const oldAllMaps = {};
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([dragColumn], column => {
              oldAllMaps[column.id] = column;
            });
            let isSelfToChildStatus = false;
            // 
            if (immediate) {
              if (dragColumn.parentId && newColumn.parentId) {
                // 
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (core_.VxeUI.modal) {
                      core_.VxeUI.modal.message({
                        status: 'error',
                        content: panel_getI18n('vxe.error.treeDragChild')
                      });
                    }
                    return;
                  }
                }
              } else if (dragColumn.parentId) {
                // 
                if (!isCrossDrag) {
                  return;
                }
              } else if (newColumn.parentId) {
                // 
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (core_.VxeUI.modal) {
                      core_.VxeUI.modal.message({
                        status: 'error',
                        content: panel_getI18n('vxe.error.treeDragChild')
                      });
                    }
                    return;
                  }
                }
              } else {
                // 
              }
              const oldewMatchRest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(collectColumn, item => item.id === dragColumn.id);
              // 
              if (isSelfToChildStatus && isCrossDrag && isSelfToChildDrag) {
                if (oldewMatchRest) {
                  const {
                    items: oCols,
                    index: oIndex
                  } = oldewMatchRest;
                  const childList = dragColumn.children || [];
                  childList.forEach(column => {
                    column.parentId = dragColumn.parentId;
                  });
                  oCols.splice(oIndex, 1, ...childList);
                  dragColumn.children = [];
                }
              } else {
                if (oldewMatchRest) {
                  const {
                    items: oCols,
                    index: oIndex,
                    parent: oParent
                  } = oldewMatchRest;
                  oCols.splice(oIndex, 1);
                  if (!oParent) {
                    oafIndex = oIndex;
                  }
                }
              }
              const newMatchRest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(collectColumn, item => item.id === newColumn.id);
              if (newMatchRest) {
                const {
                  items: nCols,
                  index: nIndex,
                  parent: nParent
                } = newMatchRest;
                // 
                if (isCrossDrag && isToChildDrag && prevDragToChild) {
                  dragColumn.parentId = newColumn.id;
                  newColumn.children = (newColumn.children || []).concat([dragColumn]);
                } else {
                  dragColumn.parentId = newColumn.parentId;
                  nCols.splice(nIndex + dragOffsetIndex, 0, dragColumn);
                }
                if (!nParent) {
                  nafIndex = nIndex;
                }
              }
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, (column, index, items, path, parent) => {
                if (!parent) {
                  const sortIndex = index + 1;
                  column.renderSortNumber = sortIndex;
                }
              });
            } else {
              oafIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(customColumnList, item => item.id === dragColumn.id);
              customColumnList.splice(oafIndex, 1);
              nafIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(customColumnList, item => item.id === newColumn.id);
              customColumnList.splice(nafIndex + dragOffsetIndex, 0, dragColumn);
            }
            if (mouseConfig) {
              if ($xeTable.clearSelected) {
                $xeTable.clearSelected();
              }
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
            }
            const csParams = {
              oldColumn: dragColumn,
              newColumn,
              dragColumn,
              dragPos: prevDragPos,
              offsetIndex: dragOffsetIndex,
              _index: {
                newIndex: nafIndex,
                oldIndex: oafIndex
              }
            };
            $xeTable.dispatchEvent('custom-sort-change', csParams, evnt);
            $xeTable.dispatchEvent('column-dragend', csParams, evnt);
            if (immediate) {
              tableReactData.customColumnList = collectColumn.slice(0);
              $xeTable.handleColDragSwapColumn();
            }
          }).catch(() => {});
        }
      }
      hideDropTip();
      customPanelReactData.dragCol = null;
      customPanelReactData.dragGroupField = null;
      customPanelReactData.dragAggFnCol = null;
      customPanelInternalData.prevDragGroupField = null;
      customPanelInternalData.prevDragAggFnColid = null;
      trEl.draggable = false;
      trEl.removeAttribute('drag-pos');
      removeClass(trEl, 'active--drag-target');
      removeClass(trEl, 'active--drag-origin');
    };
    const sortDragoverEvent = evnt => {
      const customOpts = computeCustomOpts.value;
      const {
        immediate
      } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const {
        isCrossDrag,
        isToChildDrag
      } = columnDragOpts;
      const optEl = evnt.currentTarget;
      const isControlKey = hasControlKey(evnt);
      const colid = optEl.getAttribute('colid');
      const column = $xeTable.getColumnById(colid);
      const {
        dragCol
      } = customPanelReactData;
      customPanelInternalData.prevDragGroupField = null;
      customPanelInternalData.prevDragAggFnColid = null;
      // 
      if (column && (isCrossDrag || column.level === 1)) {
        evnt.preventDefault();
        const offsetY = evnt.clientY - optEl.getBoundingClientRect().y;
        const dragPos = offsetY < optEl.clientHeight / 2 ? 'top' : 'bottom';
        if (!dragCol || dragCol && dragCol.id === column.id || !isCrossDrag && column.level > 1 || !immediate && column.level > 1) {
          showDropTip(evnt, optEl, false, dragPos);
          return;
        }
        customPanelInternalData.prevDragToChild = !!(isCrossDrag && isToChildDrag && isControlKey && immediate);
        customPanelInternalData.prevDragCol = column;
        customPanelInternalData.prevDragPos = dragPos;
        showDropTip(evnt, optEl, true, dragPos);
      }
    };
    const renderDragTip = () => {
      const {
        dragTipText
      } = customPanelReactData;
      const columnDragOpts = computeColumnDragOpts.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refDragLineElem,
        class: ['vxe-table-custom-popup--drag-line', {
          'is--guides': columnDragOpts.showGuidesStatus
        }]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refDragTipElem,
        class: 'vxe-table-custom-popup--drag-tip'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom-popup--drag-tip-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom-popup--drag-tip-status'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-table-custom-popup--drag-tip-normal-status', panel_getIcon().TABLE_DRAG_STATUS_ROW]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-table-custom-popup--drag-tip-sub-status', panel_getIcon().TABLE_DRAG_STATUS_SUB_ROW]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-table-custom-popup--drag-tip-group-status', panel_getIcon().TABLE_DRAG_STATUS_AGG_GROUP]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-table-custom-popup--drag-tip-values-status', panel_getIcon().TABLE_DRAG_STATUS_AGG_VALUES]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-table-custom-popup--drag-tip-disabled-status', panel_getIcon().TABLE_DRAG_DISABLED]
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom-popup--drag-tip-content'
      }, `${dragTipText || ''}`)])])]);
    };
    const renderSimplePanel = () => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const tableProps = $xeTable.props;
      const {
        customStore
      } = props;
      const {
        treeConfig,
        rowGroupConfig,
        aggregateConfig
      } = tableProps;
      const {
        isCustomStatus,
        customColumnList
      } = tableReactData;
      const customOpts = computeCustomOpts.value;
      const {
        immediate
      } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const {
        maxHeight
      } = customStore;
      const {
        checkMethod,
        visibleMethod,
        allowVisible,
        allowSort,
        allowFixed,
        trigger,
        placement
      } = customOpts;
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const {
        isCrossDrag
      } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const colVNs = [];
      const customWrapperOns = {};
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      // hover 
      if (trigger === 'hover') {
        customWrapperOns.onMouseenter = handleWrapperMouseenterEvent;
        customWrapperOns.onMouseleave = handleWrapperMouseleaveEvent;
      }
      const params = {
        $table: $xeTable,
        $grid: $xeGrid,
        $gantt: $xeGantt,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({
          $table: $xeTable,
          column
        }) : true;
        if (isVisible) {
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const isColGroup = column.children && column.children.length;
          const colTitle = formatText(column.getTitle(), 1);
          const isDisabled = checkMethod ? !checkMethod({
            $table: $xeTable,
            column
          }) : false;
          const isHidden = !isChecked;
          colVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
            key: column.id,
            colid: column.id,
            class: ['vxe-table-custom--option', `level--${column.level}`, {
              'is--hidden': isDisabled || isHidden,
              'is--group': isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [allowVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-table-custom--checkbox-option', {
              'is--checked': isChecked,
              'is--indeterminate': isIndeterminate,
              'is--disabled': isDisabled
            }],
            title: panel_getI18n('vxe.custom.setting.colVisible'),
            onClick: evnt => {
              if (!isDisabled) {
                changeCheckboxOption(column, evnt);
              }
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-checkbox--icon', isIndeterminate ? panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? panel_getIcon().TABLE_CHECKBOX_CHECKED : panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
          })]) : panel_renderEmptyElement($xeTable), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom--name-option'
          }, [allowSort && ((isCrossDrag ? immediate : false) || column.level === 1) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom--sort-option'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-table-custom--sort-btn', {
              'is--disabled': isDisabled || isHidden
            }],
            title: panel_getI18n('vxe.custom.setting.sortHelpTip'),
            ...(isDisabled || isHidden ? {} : {
              onMousedown: sortMousedownEvent,
              onMouseup: sortMouseupEvent
            })
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: panel_getIcon().TABLE_CUSTOM_SORT
          })])]) : panel_renderEmptyElement($xeTable), column.type === 'html' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: '1',
            class: 'vxe-table-custom--checkbox-label',
            innerHTML: colTitle
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: '0',
            class: 'vxe-table-custom--checkbox-label'
          }, colTitle)]), !parent && allowFixed ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom--fixed-option'
          }, [VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            mode: 'text',
            icon: column.renderFixed === 'left' ? panel_getIcon().TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE : panel_getIcon().TOOLBAR_TOOLS_FIXED_LEFT,
            status: column.renderFixed === 'left' ? 'primary' : '',
            disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
            title: panel_getI18n(column.renderFixed === 'left' ? 'vxe.toolbar.cancelFixed' : 'vxe.toolbar.fixedLeft'),
            onClick: ({
              $event
            }) => {
              changeFixedOption(column, 'left', $event);
            }
          }) : panel_renderEmptyElement($xeTable), VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            mode: 'text',
            icon: column.renderFixed === 'right' ? panel_getIcon().TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE : panel_getIcon().TOOLBAR_TOOLS_FIXED_RIGHT,
            status: column.renderFixed === 'right' ? 'primary' : '',
            disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
            title: panel_getI18n(column.renderFixed === 'right' ? 'vxe.toolbar.cancelFixed' : 'vxe.toolbar.fixedRight'),
            onClick: ({
              $event
            }) => {
              changeFixedOption(column, 'right', $event);
            }
          }) : panel_renderEmptyElement($xeTable)]) : panel_renderEmptyElement($xeTable)]));
        }
      });
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        key: 'simple',
        class: ['vxe-table-custom-wrapper', `placement--${placement}`, {
          'is--active': customStore.visible
        }],
        style: maxHeight && !['left', 'right'].includes(placement || '') ? {
          maxHeight: `${maxHeight}px`
        } : {}
      }, customStore.visible ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refBodyWrapperElem,
        class: 'vxe-table-custom-simple--body-wrapper'
      }, [!treeConfig && (aggregateConfig || rowGroupConfig) && $xeTable.getPivotTableAggregateSimplePanel ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)($xeTable.getPivotTableAggregateSimplePanel(), {
        customStore
      }) : panel_renderEmptyElement($xeTable), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refCustomBodyElem,
        class: 'vxe-table-custom--handle-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--header'
      }, headerSlot ? $xeTable.callSlot(headerSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-table-custom--panel-list'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
        class: 'vxe-table-custom--option'
      }, [allowVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-table-custom--checkbox-option', {
          'is--checked': isAllChecked,
          'is--indeterminate': isAllIndeterminate
        }],
        title: panel_getI18n('vxe.table.allTitle'),
        onClick: allOptionEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', isAllIndeterminate ? panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? panel_getIcon().TABLE_CHECKBOX_CHECKED : panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, panel_getI18n('vxe.toolbar.customAll'))]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, panel_getI18n('vxe.table.customTitle'))])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--body'
      }, [topSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--panel-top'
      }, $xeTable.callSlot(topSlot, params)) : panel_renderEmptyElement($xeTable), defaultSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--panel-body'
      }, $xeTable.callSlot(defaultSlot, params)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
        class: 'vxe-table-custom--panel-list',
        name: 'vxe-table-custom--list',
        tag: 'ul',
        ...customWrapperOns
      }, {
        default: () => colVNs
      }), bottomSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--panel-bottom'
      }, $xeTable.callSlot(bottomSlot, params)) : panel_renderEmptyElement($xeTable)]), customOpts.showFooter ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--footer'
      }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--footer-buttons'
      }, [VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        mode: 'text',
        content: customOpts.resetButtonText || panel_getI18n('vxe.table.customRestore'),
        disabled: !isCustomStatus,
        onClick: resetCustomEvent
      }) : panel_renderEmptyElement($xeTable), immediate ? VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        mode: 'text',
        content: customOpts.closeButtonText || panel_getI18n('vxe.table.customClose'),
        onClick: cancelCloseEvent
      }) : panel_renderEmptyElement($xeTable) : VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        mode: 'text',
        content: customOpts.cancelButtonText || panel_getI18n('vxe.table.customCancel'),
        onClick: cancelCustomEvent
      }) : panel_renderEmptyElement($xeTable), immediate ? panel_renderEmptyElement($xeTable) : VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        mode: 'text',
        status: 'primary',
        content: customOpts.confirmButtonText || panel_getI18n('vxe.table.customConfirm'),
        onClick: confirmCustomEvent
      }) : panel_renderEmptyElement($xeTable)])]) : null]), renderDragTip()])] : []);
    };
    const renderPopupPanel = () => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const {
        customStore
      } = props;
      const {
        treeConfig,
        rowGroupConfig,
        aggregateConfig,
        resizable: allResizable
      } = tableProps;
      const {
        isCustomStatus,
        customColumnList
      } = tableReactData;
      const customOpts = computeCustomOpts.value;
      const {
        immediate
      } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const {
        mode,
        modalOptions,
        drawerOptions,
        allowVisible,
        allowSort,
        allowFixed,
        allowResizable,
        checkMethod,
        visibleMethod
      } = customOpts;
      const columnOpts = computeColumnOpts.value;
      const {
        maxFixedSize
      } = columnOpts;
      const resizableOpts = computeResizableOpts.value;
      const {
        minWidth: reMinWidth,
        maxWidth: reMaxWidth
      } = resizableOpts;
      const modalOpts = Object.assign({}, modalOptions);
      const drawerOpts = Object.assign({}, drawerOptions);
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const {
        isCrossDrag
      } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const trVNs = [];
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      const params = {
        $table: $xeTable,
        $grid: $xeGrid,
        $gantt: $xeGantt,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({
          $table: $xeTable,
          column
        }) : true;
        if (isVisible) {
          // 
          let customMinWidth = 0;
          let customMaxWidth = 0;
          if (allowResizable) {
            const resizeParams = {
              $table: $xeTable,
              column,
              columnIndex: index,
              $columnIndex: index,
              $rowIndex: -1
            };
            if (reMinWidth) {
              customMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(reMinWidth) ? reMinWidth(resizeParams) : reMinWidth);
            }
            if (reMaxWidth) {
              customMaxWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(reMaxWidth) ? reMaxWidth(resizeParams) : reMaxWidth);
            }
          }
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const colTitle = formatText(column.getTitle(), 1);
          const isColGroup = column.children && column.children.length;
          const isDisabled = checkMethod ? !checkMethod({
            $table: $xeTable,
            column
          }) : false;
          const isHidden = !isChecked;
          trVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
            key: column.id,
            colid: column.id,
            class: [`vxe-table-custom-popup--row level--${column.level}`, {
              'is--group': isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [allowVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: 'vxe-table-custom-popup--column-item col--visible'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-table-custom--checkbox-option', {
              'is--checked': isChecked,
              'is--indeterminate': isIndeterminate,
              'is--disabled': isDisabled
            }],
            title: panel_getI18n('vxe.custom.setting.colVisible'),
            onClick: evnt => {
              if (!isDisabled) {
                changeCheckboxOption(column, evnt);
              }
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-checkbox--icon', isIndeterminate ? panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? panel_getIcon().TABLE_CHECKBOX_CHECKED : panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
          })])]) : panel_renderEmptyElement($xeTable), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: 'vxe-table-custom-popup--column-item col--name'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--name'
          }, [allowSort ? (isCrossDrag ? immediate : false) || column.level === 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-table-custom-popup--column-sort-btn', {
              'is--disabled': isDisabled || isHidden
            }],
            title: panel_getI18n('vxe.custom.setting.sortHelpTip'),
            ...(isDisabled || isHidden ? {} : {
              onMousedown: sortMousedownEvent,
              onMouseup: sortMouseupEvent
            })
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: panel_getIcon().TABLE_CUSTOM_SORT
          })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--column-sort-placeholder'
          }) : panel_renderEmptyElement($xeTable), column.type === 'html' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: '1',
            class: 'vxe-table-custom-popup--title',
            innerHTML: colTitle
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: '0',
            class: 'vxe-table-custom-popup--title',
            title: colTitle
          }, colTitle)])]), allowResizable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: 'vxe-table-custom-popup--column-item col--resizable'
          }, [column.children && column.children.length || !(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', '-') : VxeUINumberInputComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUINumberInputComponent, {
            type: 'integer',
            immediate: false,
            disabled: isDisabled || isHidden,
            modelValue: column.renderResizeWidth,
            min: customMinWidth || undefined,
            max: customMaxWidth || undefined,
            'onUpdate:modelValue'(value) {
              const width = Math.max(0, Number(value));
              column.renderResizeWidth = width;
            },
            onChange() {
              changeColumnWidth(column);
            }
          }) : panel_renderEmptyElement($xeTable)]) : panel_renderEmptyElement($xeTable), allowFixed ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: 'vxe-table-custom-popup--column-item col--fixed'
          }, [parent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', '-') : VxeUIRadioGroupComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIRadioGroupComponent, {
            modelValue: column.renderFixed || '',
            type: 'button',
            size: 'mini',
            disabled: isDisabled || isHidden,
            options: [{
              label: panel_getI18n('vxe.custom.setting.fixedLeft'),
              value: 'left',
              disabled: isDisabled || isHidden || isMaxFixedColumn
            }, {
              label: panel_getI18n('vxe.custom.setting.fixedUnset'),
              value: '',
              disabled: isDisabled || isHidden
            }, {
              label: panel_getI18n('vxe.custom.setting.fixedRight'),
              value: 'right',
              disabled: isDisabled || isHidden || isMaxFixedColumn
            }],
            onChange({
              label,
              $event
            }) {
              changeFixedOption(column, label, $event);
            }
          }) : panel_renderEmptyElement($xeTable)]) : panel_renderEmptyElement($xeTable)]));
        }
      });
      const scopedSlots = {
        default: () => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            ref: refBodyWrapperElem,
            class: 'vxe-table-custom-popup--body-wrapper'
          }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            ref: refCustomBodyElem,
            class: 'vxe-table-custom-popup--handle-wrapper'
          }, [topSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--table-top'
          }, $xeTable.callSlot(topSlot, params)) : panel_renderEmptyElement($xeTable), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--table-wrapper'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('colgroup', {}, [allowVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
            class: 'vxe-table-custom-popup--table-col-seq'
          }) : panel_renderEmptyElement($xeTable), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
            class: 'vxe-table-custom-popup--table-col-title'
          }), allowResizable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
            class: 'vxe-table-custom-popup--table-col-width'
          }) : panel_renderEmptyElement($xeTable), allowFixed ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
            class: 'vxe-table-custom-popup--table-col-fixed'
          }) : panel_renderEmptyElement($xeTable)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {}, [allowVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-table-custom--checkbox-option', {
              'is--checked': isAllChecked,
              'is--indeterminate': isAllIndeterminate
            }],
            title: panel_getI18n('vxe.table.allTitle'),
            onClick: allOptionEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-checkbox--icon', isAllIndeterminate ? panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? panel_getIcon().TABLE_CHECKBOX_CHECKED : panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-checkbox--label'
          }, panel_getI18n('vxe.toolbar.customAll'))])]) : panel_renderEmptyElement($xeTable), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, panel_getI18n('vxe.custom.setting.colTitle')), allowResizable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, panel_getI18n('vxe.custom.setting.colResizable')) : panel_renderEmptyElement($xeTable), allowFixed ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, panel_getI18n(`vxe.custom.setting.${maxFixedSize ? 'colFixedMax' : 'colFixed'}`, [maxFixedSize])) : panel_renderEmptyElement($xeTable)])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
            class: 'vxe-table-custom--panel-list',
            tag: 'tbody',
            name: 'vxe-table-custom--list'
          }, {
            default: () => trVNs
          })])]), bottomSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--table-bottom'
          }, $xeTable.callSlot(bottomSlot, params)) : panel_renderEmptyElement($xeTable), renderDragTip()]), !treeConfig && (aggregateConfig || rowGroupConfig) && $xeTable.getPivotTableAggregatePopupPanel ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)($xeTable.getPivotTableAggregatePopupPanel(), {
            customStore
          }) : panel_renderEmptyElement($xeTable)]);
        },
        footer: () => {
          if (footerSlot) {
            return $xeTable.callSlot(footerSlot, params);
          }
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--footer'
          }, [VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            content: customOpts.resetButtonText || panel_getI18n('vxe.custom.cstmRestore'),
            disabled: !isCustomStatus,
            onClick: resetCustomEvent
          }) : panel_renderEmptyElement($xeTable), immediate ? VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            content: customOpts.closeButtonText || panel_getI18n('vxe.table.customClose'),
            onClick: cancelCloseEvent
          }) : panel_renderEmptyElement($xeTable) : VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            content: customOpts.cancelButtonText || panel_getI18n('vxe.table.customCancel'),
            onClick: cancelCustomEvent
          }) : panel_renderEmptyElement($xeTable), immediate ? panel_renderEmptyElement($xeTable) : VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            status: 'primary',
            content: customOpts.confirmButtonText || panel_getI18n('vxe.custom.cstmConfirm'),
            onClick: confirmCustomEvent
          }) : panel_renderEmptyElement($xeTable)]);
        }
      };
      if (headerSlot) {
        scopedSlots.header = () => $xeTable.callSlot(headerSlot, params);
      }
      if (mode === 'drawer') {
        return VxeUIDrawerComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIDrawerComponent, {
          key: 'drawer',
          className: ['vxe-table-custom-drawer-wrapper', 'vxe-table--ignore-clear', drawerOpts.className || ''].join(' '),
          modelValue: customStore.visible,
          title: drawerOpts.title || panel_getI18n('vxe.custom.cstmTitle'),
          width: drawerOpts.width || Math.min(880, Math.floor(document.documentElement.clientWidth * 0.6)),
          position: drawerOpts.position,
          resize: !!drawerOpts.resize,
          escClosable: !!drawerOpts.escClosable,
          maskClosable: !!drawerOpts.maskClosable,
          destroyOnClose: true,
          showFooter: true,
          'onUpdate:modelValue'(value) {
            customStore.visible = value;
          }
        }, scopedSlots) : panel_renderEmptyElement($xeTable);
      }
      return VxeUIModalComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIModalComponent, {
        key: 'modal',
        className: ['vxe-table-custom-modal-wrapper', 'vxe-table--ignore-clear', modalOpts.className || ''].join(' '),
        modelValue: customStore.visible,
        title: modalOpts.title || panel_getI18n('vxe.custom.cstmTitle'),
        width: modalOpts.width || Math.min(880, document.documentElement.clientWidth),
        minWidth: modalOpts.minWidth || 700,
        height: modalOpts.height || Math.min(680, document.documentElement.clientHeight),
        minHeight: modalOpts.minHeight || 400,
        showZoom: modalOpts.showZoom,
        showMaximize: modalOpts.showMaximize,
        showMinimize: modalOpts.showMinimize,
        mask: modalOpts.mask,
        lockView: modalOpts.lockView,
        resize: modalOpts.resize,
        escClosable: !!modalOpts.escClosable,
        maskClosable: !!modalOpts.maskClosable,
        destroyOnClose: true,
        showFooter: true,
        'onUpdate:modelValue'(value) {
          customStore.visible = value;
        }
      }, scopedSlots) : panel_renderEmptyElement($xeTable);
    };
    const renderVN = () => {
      const customOpts = computeCustomOpts.value;
      if (['modal', 'drawer', 'popup'].includes(`${customOpts.mode}`)) {
        return renderPopupPanel();
      }
      return renderSimplePanel();
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      const customOpts = computeCustomOpts.value;
      const {
        mode
      } = customOpts;
      if (!VxeUIModalComponent && mode === 'modal') {
        errLog('vxe.error.reqComp', ['vxe-modal']);
      }
      if (!VxeUIDrawerComponent && mode === 'drawer') {
        errLog('vxe.error.reqComp', ['vxe-drawer']);
      }
      if (!VxeUIButtonComponent) {
        errLog('vxe.error.reqComp', ['vxe-button']);
      }
      if (!VxeUINumberInputComponent) {
        errLog('vxe.error.reqComp', ['vxe-number-input']);
      }
      if (!VxeUIRadioGroupComponent) {
        errLog('vxe.error.reqComp', ['vxe-radio-group']);
      }
    });
    const $xeTableCustomPanel = {
      xID,
      props,
      context,
      reactData: customPanelReactData,
      internalData: customPanelInternalData,
      xeTable: $xeTable,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps,
      renderVN
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      customPanelInternalData = panel_createInternalData();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeTableCustomPanel', $xeTableCustomPanel);
    return $xeTableCustomPanel;
  },
  render() {
    return this.renderVN();
  }
}));
;// ./packages/table/module/filter/panel.ts













const {
  getI18n: filter_panel_getI18n,
  getIcon: filter_panel_getIcon,
  renderer: panel_renderer,
  renderEmptyElement: filter_panel_renderEmptyElement
} = core_.VxeUI;
/* harmony default export */ var filter_panel = (defineVxeComponent({
  name: 'VxeTableFilterPanel',
  props: {
    filterStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props, context) {
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      reactData: tableReactData,
      internalData: tableInternalData,
      getComputeMaps
    } = $xeTable;
    const {
      computeFilterOpts
    } = getComputeMaps();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeFilterPanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const computeHasCheckOption = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        filterStore
      } = props;
      const {
        column
      } = filterStore;
      return column && column.filters && column.filters.some(option => option.checked);
    });
    // 
    const filterCheckAllEvent = (evnt, value) => {
      const {
        filterStore
      } = props;
      const {
        column
      } = filterStore;
      if (column && column.filters) {
        column.filters.forEach(option => {
          option._checked = value;
          option.checked = value;
        });
      }
      filterStore.isAllSelected = value;
      filterStore.isIndeterminate = false;
    };
    /*************************
     * Publish methods
     *************************/
    // 
    const confirmFilter = evnt => {
      const {
        filterStore
      } = props;
      if (!evnt) {
        warnLog('vxe.error.delFunc', ['confirmFilter', 'saveFilterPanelByEvent']);
      }
      $xeTable.handleFilterConfirmFilter(evnt || new Event('click'), filterStore.column || null);
    };
    // 
    const changeRadioOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeRadioOption(evnt, checked, item);
    };
    /**
     * 
     * 
     * @param {Event} evnt 
     */
    const resetFilter = evnt => {
      const {
        filterStore
      } = props;
      $xeTable.handleFilterResetFilter(evnt, filterStore.column || null);
    };
    // 
    const changeMultipleOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeMultipleOption(evnt, checked, item);
    };
    // 
    const changeOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeOption(evnt, checked, item);
    };
    const changeAllOption = (evnt, checked) => {
      const {
        filterStore
      } = props;
      const {
        column
      } = filterStore;
      if (column && column.filterMultiple) {
        filterCheckAllEvent(evnt, checked);
      } else {
        resetFilter(evnt);
      }
    };
    /*************************
     * Publish methods
     *************************/
    const filterPanelMethods = {
      changeRadioOption,
      changeMultipleOption,
      changeAllOption,
      changeOption,
      confirmFilter,
      resetFilter
    };
    Object.assign($xeFilterPanel, filterPanelMethods);
    const renderOptions = (filterRender, compConf) => {
      const {
        filterStore
      } = props;
      const {
        column,
        maxHeight
      } = filterStore;
      if (!column) {
        return [];
      }
      const {
        filterMultiple,
        filters,
        slots
      } = column;
      const filterOptions = filters || [];
      const filterSlot = slots ? slots.filter : null;
      const params = Object.assign({}, tableInternalData._currFilterParams, {
        option: filterOptions[0],
        $panel: $xeFilterPanel,
        $table: $xeTable
      });
      const rtFilter = compConf ? compConf.renderTableFilter || compConf.renderFilter : null;
      if (filterSlot) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-table--filter-template',
          style: maxHeight ? {
            maxHeight: toCssUnit(maxHeight)
          } : {}
        }, $xeTable.callSlot(filterSlot, params))];
      } else if (filterRender && rtFilter) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-table--filter-template',
          style: maxHeight ? {
            maxHeight: toCssUnit(maxHeight)
          } : {}
        }, getSlotVNs(rtFilter(filterRender, params)))];
      }
      const isAllChecked = filterMultiple ? filterStore.isAllSelected : !filterOptions.some(item => item._checked);
      const isAllIndeterminate = filterMultiple && filterStore.isIndeterminate;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-table--filter-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
        class: ['vxe-table--filter-option', {
          'is--checked': isAllChecked,
          'is--indeterminate': isAllIndeterminate
        }],
        title: filter_panel_getI18n(filterMultiple ? 'vxe.table.allTitle' : 'vxe.table.allFilter'),
        onClick: evnt => {
          changeAllOption(evnt, !filterStore.isAllSelected);
        }
      }, (filterMultiple ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', isAllIndeterminate ? filter_panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? filter_panel_getIcon().TABLE_CHECKBOX_CHECKED : filter_panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
      })] : []).concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, filter_panel_getI18n('vxe.table.allFilter'))]))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-table--filter-body',
        style: maxHeight ? {
          maxHeight: toCssUnit(maxHeight)
        } : {}
      }, filterOptions.map(item => {
        const isChecked = item._checked;
        const isIndeterminate = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          class: ['vxe-table--filter-option', {
            'is--checked': item._checked
          }],
          title: item.label,
          onClick: evnt => {
            changeOption(evnt, !item._checked, item);
          }
        }, (filterMultiple ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-checkbox--icon', isIndeterminate ? filter_panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? filter_panel_getIcon().TABLE_CHECKBOX_CHECKED : filter_panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
        })] : []).concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-checkbox--label'
        }, formatText(item.label, 1))]));
      }))];
    };
    const renderFooters = () => {
      const {
        filterStore
      } = props;
      const {
        column
      } = filterStore;
      if (!column) {
        return [];
      }
      const filterOpts = computeFilterOpts.value;
      const hasCheckOption = computeHasCheckOption.value;
      const {
        filterRender,
        filterMultiple
      } = column;
      const compConf = isEnableConf(filterRender) ? panel_renderer.get(filterRender.name) : null;
      const isDisabled = !hasCheckOption && !filterStore.isAllSelected && !filterStore.isIndeterminate;
      return (compConf ? !(compConf.showTableFilterFooter === false || compConf.showFilterFooter === false || compConf.isFooter === false) : filterMultiple) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--filter-footer'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: {
          'is--disabled': isDisabled
        },
        disabled: isDisabled,
        onClick: confirmFilter
      }, filterOpts.confirmButtonText || filter_panel_getI18n('vxe.table.confirmFilter')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        onClick: resetFilter
      }, filterOpts.resetButtonText || filter_panel_getI18n('vxe.table.resetFilter'))])] : [];
    };
    const renderVN = () => {
      const {
        filterStore
      } = props;
      const {
        initStore
      } = tableReactData;
      const {
        visible,
        column
      } = filterStore;
      if (!column) {
        return filter_panel_renderEmptyElement($xeFilterPanel);
      }
      const filterRender = column ? column.filterRender : null;
      const compConf = filterRender && isEnableConf(filterRender) ? panel_renderer.get(filterRender.name) : null;
      const filterClassName = compConf ? compConf.tableFilterClassName || compConf.filterClassName : '';
      const params = Object.assign({}, tableInternalData._currFilterParams, {
        $panel: $xeFilterPanel,
        $table: $xeTable
      });
      const tableProps = $xeTable.props;
      const {
        computeSize
      } = $xeTable.getComputeMaps();
      const vSize = computeSize.value;
      const filterOpts = computeFilterOpts.value;
      const {
        transfer,
        destroyOnClose,
        className
      } = filterOpts;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: !transfer
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--filter-wrapper', 'filter--prevent-default', className, getPropClass(filterClassName, params), {
          [`size--${vSize}`]: vSize,
          'is--animat': tableProps.animat,
          'is--multiple': column.filterMultiple,
          'is--active': visible
        }],
        style: filterStore.style
      }, initStore.filter && (destroyOnClose ? visible : true) && column ? renderOptions(filterRender, compConf).concat(renderFooters()) : [])]);
    };
    $xeFilterPanel.renderVN = renderVN;
    return $xeFilterPanel;
  },
  render() {
    return this.renderVN();
  }
}));
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.iterator.find.js
var esnext_iterator_find = __webpack_require__(2577);
;// ./packages/table/module/export/import-panel.ts









const {
  getI18n: import_panel_getI18n,
  getIcon: import_panel_getIcon,
  renderEmptyElement: import_panel_renderEmptyElement
} = core_.VxeUI;
/* harmony default export */ var import_panel = (defineVxeComponent({
  name: 'VxeTableImportPanel',
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = core_.VxeUI.getComponent('VxeModal');
    const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
    const VxeUISelectComponent = core_.VxeUI.getComponent('VxeSelect');
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      computeImportOpts
    } = $xeTable.getComputeMaps();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      loading: false
    });
    const refFileBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const computeSelectName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData
      } = props;
      return `${storeData.filename}.${storeData.type}`;
    });
    const computeHasFile = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData
      } = props;
      return storeData.file && storeData.type;
    });
    const computeParseTypeLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData
      } = props;
      const {
        type,
        typeList
      } = storeData;
      if (type) {
        const selectItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(typeList, item => type === item.value);
        return selectItem ? selectItem.label : '*.*';
      }
      return `*.${typeList.map(item => item.value).join(', *.')}`;
    });
    const clearFileEvent = () => {
      const {
        storeData
      } = props;
      Object.assign(storeData, {
        filename: '',
        sheetName: '',
        type: ''
      });
    };
    const selectFileEvent = () => {
      const {
        storeData,
        defaultOptions
      } = props;
      $xeTable.readFile(defaultOptions).then(params => {
        const {
          file
        } = params;
        Object.assign(storeData, parseFile(file), {
          file
        });
      }).catch(e => e);
    };
    const showEvent = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const targetElem = refFileBtn.value;
        if (targetElem) {
          targetElem.focus();
        }
      });
    };
    const cancelEvent = () => {
      const {
        storeData
      } = props;
      storeData.visible = false;
    };
    const importEvent = () => {
      const {
        storeData,
        defaultOptions
      } = props;
      const importOpts = computeImportOpts.value;
      reactData.loading = true;
      $xeTable.importByFile(storeData.file, Object.assign({}, importOpts, defaultOptions)).then(() => {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const renderVN = () => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const {
        defaultOptions,
        storeData
      } = props;
      const selectName = computeSelectName.value;
      const hasFile = computeHasFile.value;
      const parseTypeLabel = computeParseTypeLabel.value;
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      return VxeUIModalComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIModalComponent, {
        id: 'VXE_IMPORT_MODAL',
        modelValue: storeData.visible,
        title: import_panel_getI18n('vxe.import.impTitle'),
        className: 'vxe-table-export-popup-wrapper',
        width: 540,
        minWidth: 360,
        minHeight: 240,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        'onUpdate:modelValue'(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel'
          }, [topSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-top'
          }, $xeTable.callSlot(topSlot, params)) : import_panel_renderEmptyElement($xeTable), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-body'
          }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
            class: 'vxe-table-export--panel-table',
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', import_panel_getI18n('vxe.import.impFile')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [hasFile ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--selected--file',
            title: selectName
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', selectName), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: import_panel_getIcon().INPUT_CLEAR,
            onClick: clearFileEvent
          })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
            ref: refFileBtn,
            class: 'vxe-table-export--select--file',
            onClick: selectFileEvent
          }, import_panel_getI18n('vxe.import.impSelect'))])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', import_panel_getI18n('vxe.import.impType')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', parseTypeLabel)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', import_panel_getI18n('vxe.import.impMode')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [VxeUISelectComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUISelectComponent, {
            modelValue: defaultOptions.mode,
            options: storeData.modeList,
            'onUpdate:modelValue'(value) {
              defaultOptions.mode = value;
            }
          }) : import_panel_renderEmptyElement($xeTable)])])])])]), bottomSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-bottom'
          }, $xeTable.callSlot(bottomSlot, params)) : import_panel_renderEmptyElement($xeTable)]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-footer'
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-btns'
          }, [VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            content: import_panel_getI18n('vxe.import.impCancel'),
            onClick: cancelEvent
          }) : import_panel_renderEmptyElement($xeTable), VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            status: 'primary',
            disabled: !hasFile || reactData.loading,
            content: import_panel_getI18n('vxe.import.impConfirm'),
            onClick: importEvent
          }) : import_panel_renderEmptyElement($xeTable)])]);
        }
      }) : import_panel_renderEmptyElement($xeTable);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      if (!VxeUIModalComponent) {
        errLog('vxe.error.reqComp', ['vxe-modal']);
      }
      if (!VxeUIButtonComponent) {
        errLog('vxe.error.reqComp', ['vxe-button']);
      }
      if (!VxeUISelectComponent) {
        errLog('vxe.error.reqComp', ['vxe-select']);
      }
    });
    return renderVN;
  }
}));
;// ./packages/table/module/export/export-panel.ts











const {
  getI18n: export_panel_getI18n,
  getIcon: export_panel_getIcon,
  renderEmptyElement: export_panel_renderEmptyElement
} = core_.VxeUI;
/* harmony default export */ var export_panel = (defineVxeComponent({
  name: 'VxeTableExportPanel',
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = core_.VxeUI.getComponent('VxeModal');
    const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
    const VxeUISelectComponent = core_.VxeUI.getComponent('VxeSelect');
    const VxeUIInputComponent = core_.VxeUI.getComponent('VxeInput');
    const VxeUICheckboxComponent = core_.VxeUI.getComponent('VxeCheckbox');
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      computeExportOpts,
      computePrintOpts
    } = $xeTable.getComputeMaps();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isAll: false,
      isIndeterminate: false,
      loading: false
    });
    const xButtonConfirm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const xInputFilename = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const xInputSheetname = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const computeCheckedAll = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData
      } = props;
      return storeData.columns.every(column => column.checked);
    });
    const computeShowSheet = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        defaultOptions
      } = props;
      return ['html', 'xml', 'xlsx', 'pdf'].indexOf(defaultOptions.type) > -1;
    });
    const computeSupportMerge = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData,
        defaultOptions
      } = props;
      return !defaultOptions.original && defaultOptions.mode === 'current' && (storeData.isPrint || ['html', 'xlsx'].indexOf(defaultOptions.type) > -1);
    });
    // const computeSupportGroup = computed(() => {
    //   const { defaultOptions } = props
    //   return ['html', 'xlsx', 'csv', 'txt'].indexOf(defaultOptions.type) > -1
    // })
    const computeSupportStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        defaultOptions
      } = props;
      return !defaultOptions.original && ['xlsx'].indexOf(defaultOptions.type) > -1;
    });
    const handleOptionCheck = column => {
      const {
        storeData
      } = props;
      const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(storeData.columns, item => item === column);
      if (matchObj && matchObj.parent) {
        const {
          parent
        } = matchObj;
        if (parent.children && parent.children.length) {
          parent.checked = parent.children.every(column => column.checked);
          parent.halfChecked = !parent.checked && parent.children.some(column => column.checked || column.halfChecked);
          handleOptionCheck(parent);
        }
      }
    };
    const checkStatus = () => {
      const {
        storeData
      } = props;
      const columns = storeData.columns;
      reactData.isAll = columns.every(column => column.disabled || column.checked);
      reactData.isIndeterminate = !reactData.isAll && columns.some(column => !column.disabled && (column.checked || column.halfChecked));
    };
    const changeOption = column => {
      const isChecked = !column.checked;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
        item.checked = isChecked;
        item.halfChecked = false;
      });
      handleOptionCheck(column);
      checkStatus();
    };
    const allColumnEvent = () => {
      const {
        storeData
      } = props;
      const isAll = !reactData.isAll;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(storeData.columns, column => {
        if (!column.disabled) {
          column.checked = isAll;
          column.halfChecked = false;
        }
      });
      reactData.isAll = isAll;
      checkStatus();
    };
    const showEvent = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const filenameInp = xInputFilename.value;
        const sheetnameInp = xInputSheetname.value;
        const confirmBtn = xButtonConfirm.value;
        const targetElem = filenameInp || sheetnameInp || confirmBtn;
        if (targetElem) {
          targetElem.focus();
        }
      });
      checkStatus();
    };
    const getExportOption = () => {
      const {
        storeData,
        defaultOptions
      } = props;
      const {
        hasMerge,
        columns
      } = storeData;
      const checkedAll = computeCheckedAll.value;
      const supportMerge = computeSupportMerge.value;
      const expColumns = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(columns, column => column.checked, {
        children: 'children',
        mapChildren: 'childNodes',
        original: true
      });
      return Object.assign({}, defaultOptions, {
        columns: expColumns,
        isMerge: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false
      });
    };
    const printEvent = () => {
      const {
        storeData
      } = props;
      const printOpts = computePrintOpts.value;
      storeData.visible = false;
      $xeTable.print(Object.assign({}, printOpts, getExportOption()));
    };
    const exportEvent = () => {
      const {
        storeData
      } = props;
      const exportOpts = computeExportOpts.value;
      reactData.loading = true;
      $xeTable.exportData(Object.assign({}, exportOpts, getExportOption())).then(() => {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const cancelEvent = () => {
      const {
        storeData
      } = props;
      storeData.visible = false;
    };
    const confirmEvent = () => {
      const {
        storeData
      } = props;
      if (storeData.isPrint) {
        printEvent();
      } else {
        exportEvent();
      }
    };
    const renderVN = () => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const {
        defaultOptions,
        storeData
      } = props;
      const {
        isAll: isAllChecked,
        isIndeterminate: isAllIndeterminate
      } = reactData;
      const {
        hasTree,
        hasMerge,
        isPrint,
        hasColgroup,
        columns
      } = storeData;
      const {
        isHeader
      } = defaultOptions;
      const cols = [];
      const checkedAll = computeCheckedAll.value;
      const showSheet = computeShowSheet.value;
      const supportMerge = computeSupportMerge.value;
      const supportStyle = computeSupportStyle.value;
      // const supportGroup = computeSupportGroup.value
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const parameterSlot = slots.parameter;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(columns, column => {
        const colTitle = formatText(column.getTitle(), 1);
        const isColGroup = column.children && column.children.length;
        const isChecked = column.checked;
        const indeterminate = column.halfChecked;
        const isHtml = column.type === 'html';
        cols.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: column.id,
          class: ['vxe-table-export--panel-column-option', `level--${column.level}`, {
            'is--group': isColGroup,
            'is--checked': isChecked,
            'is--indeterminate': indeterminate,
            'is--disabled': column.disabled
          }],
          title: isHtml ? '' : colTitle,
          onClick: () => {
            if (!column.disabled) {
              changeOption(column);
            }
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-checkbox--icon', indeterminate ? export_panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? export_panel_getIcon().TABLE_CHECKBOX_CHECKED : export_panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
        }), isHtml ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          key: '1',
          class: 'vxe-checkbox--label',
          innerHTML: colTitle
        }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          key: '0',
          class: 'vxe-checkbox--label'
        }, colTitle)]));
      });
      return VxeUIModalComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIModalComponent, {
        id: 'VXE_EXPORT_MODAL',
        modelValue: storeData.visible,
        title: export_panel_getI18n(isPrint ? 'vxe.export.printTitle' : 'vxe.export.expTitle'),
        className: 'vxe-table-export-popup-wrapper',
        width: 660,
        minWidth: 500,
        minHeight: 400,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        'onUpdate:modelValue'(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          const hasEmptyData = defaultOptions.mode === 'empty';
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel'
          }, [topSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-top'
          }, $xeTable.callSlot(topSlot, params)) : export_panel_renderEmptyElement($xeTable), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-body'
          }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
            class: 'vxe-table-export--panel-table',
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', [[isPrint ? export_panel_renderEmptyElement($xeTable) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', export_panel_getI18n('vxe.export.expName')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [VxeUIInputComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIInputComponent, {
            ref: xInputFilename,
            modelValue: defaultOptions.filename,
            type: 'text',
            clearable: true,
            placeholder: export_panel_getI18n('vxe.export.expNamePlaceholder'),
            'onUpdate:modelValue'(value) {
              defaultOptions.filename = value;
            }
          }) : export_panel_renderEmptyElement($xeTable)])]), isPrint ? export_panel_renderEmptyElement($xeTable) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', export_panel_getI18n('vxe.export.expType')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [VxeUISelectComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUISelectComponent, {
            modelValue: defaultOptions.type,
            options: storeData.typeList,
            'onUpdate:modelValue'(value) {
              defaultOptions.type = value;
            }
          }) : export_panel_renderEmptyElement($xeTable)])]), isPrint || showSheet ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', export_panel_getI18n('vxe.export.expSheetName')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [VxeUIInputComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIInputComponent, {
            ref: xInputSheetname,
            modelValue: defaultOptions.sheetName,
            type: 'text',
            clearable: true,
            placeholder: export_panel_getI18n('vxe.export.expSheetNamePlaceholder'),
            'onUpdate:modelValue'(value) {
              defaultOptions.sheetName = value;
            }
          }) : export_panel_renderEmptyElement($xeTable)])]) : export_panel_renderEmptyElement($xeTable), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', export_panel_getI18n('vxe.export.expMode')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [VxeUISelectComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUISelectComponent, {
            modelValue: defaultOptions.mode,
            options: storeData.modeList.map(item => {
              return {
                value: item.value,
                label: export_panel_getI18n(item.label)
              };
            }),
            'onUpdate:modelValue'(value) {
              defaultOptions.mode = value;
            }
          }) : export_panel_renderEmptyElement($xeTable)])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [export_panel_getI18n('vxe.export.expColumn')]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-column'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
            class: 'vxe-table-export--panel-column-header'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
            class: ['vxe-table-export--panel-column-option', {
              'is--checked': isAllChecked,
              'is--indeterminate': isAllIndeterminate
            }],
            title: export_panel_getI18n('vxe.table.allTitle'),
            onClick: allColumnEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-checkbox--icon', isAllIndeterminate ? export_panel_getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? export_panel_getIcon().TABLE_CHECKBOX_CHECKED : export_panel_getIcon().TABLE_CHECKBOX_UNCHECKED]
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-checkbox--label'
          }, export_panel_getI18n('vxe.export.expCurrentColumn'))])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
            class: 'vxe-table-export--panel-column-body'
          }, cols)])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', export_panel_getI18n('vxe.export.expOpts')), parameterSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-option-row'
          }, $xeTable.callSlot(parameterSlot, params))]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-option-row'
          }, [VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: hasEmptyData || isHeader,
            disabled: hasEmptyData,
            title: export_panel_getI18n('vxe.export.expHeaderTitle'),
            content: export_panel_getI18n('vxe.export.expOptHeader'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isHeader = value;
            }
          }) : export_panel_renderEmptyElement($xeTable), VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: isHeader ? defaultOptions.isTitle : false,
            disabled: !isHeader,
            title: export_panel_getI18n('vxe.export.expTitleTitle'),
            content: export_panel_getI18n('vxe.export.expOptTitle'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isTitle = value;
            }
          }) : export_panel_renderEmptyElement($xeTable), VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: isHeader && hasColgroup && supportMerge ? defaultOptions.isColgroup : false,
            title: export_panel_getI18n('vxe.export.expColgroupTitle'),
            disabled: !isHeader || !hasColgroup || !supportMerge,
            content: export_panel_getI18n('vxe.export.expOptColgroup'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isColgroup = value;
            }
          }) : export_panel_renderEmptyElement($xeTable)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-option-row'
          }, [VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: hasEmptyData ? false : defaultOptions.original,
            disabled: hasEmptyData,
            title: export_panel_getI18n('vxe.export.expOriginalTitle'),
            content: export_panel_getI18n('vxe.export.expOptOriginal'),
            'onUpdate:modelValue'(value) {
              defaultOptions.original = value;
            }
          }) : export_panel_renderEmptyElement($xeTable), VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false,
            title: export_panel_getI18n('vxe.export.expMergeTitle'),
            disabled: hasEmptyData || !hasMerge || !supportMerge || !checkedAll,
            content: export_panel_getI18n('vxe.export.expOptMerge'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isMerge = value;
            }
          }) : export_panel_renderEmptyElement($xeTable), isPrint || !VxeUICheckboxComponent ? export_panel_renderEmptyElement($xeTable) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: supportStyle ? defaultOptions.useStyle : false,
            disabled: !supportStyle,
            title: export_panel_getI18n('vxe.export.expUseStyleTitle'),
            content: export_panel_getI18n('vxe.export.expOptUseStyle'),
            'onUpdate:modelValue'(value) {
              defaultOptions.useStyle = value;
            }
          }), VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: hasTree ? defaultOptions.isAllExpand : false,
            disabled: hasEmptyData || !hasTree,
            title: export_panel_getI18n('vxe.export.expAllExpandTitle'),
            content: export_panel_getI18n('vxe.export.expOptAllExpand'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isAllExpand = value;
            }
          }) : export_panel_renderEmptyElement($xeTable)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-option-row'
          }, [VxeUICheckboxComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUICheckboxComponent, {
            modelValue: defaultOptions.isFooter,
            disabled: !storeData.hasFooter,
            title: export_panel_getI18n('vxe.export.expFooterTitle'),
            content: export_panel_getI18n('vxe.export.expOptFooter'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isFooter = value;
            }
          }) : export_panel_renderEmptyElement($xeTable)])])])]])])]), bottomSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-bottom'
          }, $xeTable.callSlot(bottomSlot, params)) : export_panel_renderEmptyElement($xeTable)]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-footer'
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-export--panel-btns'
          }, [VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            content: export_panel_getI18n('vxe.export.expCancel'),
            onClick: cancelEvent
          }) : export_panel_renderEmptyElement($xeTable), VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            ref: xButtonConfirm,
            status: 'primary',
            content: export_panel_getI18n(isPrint ? 'vxe.export.expPrint' : 'vxe.export.expConfirm'),
            onClick: confirmEvent
          }) : export_panel_renderEmptyElement($xeTable)])]);
        }
      }) : export_panel_renderEmptyElement($xeTable);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      if (!VxeUIModalComponent) {
        errLog('vxe.error.reqComp', ['vxe-modal']);
      }
      if (!VxeUIButtonComponent) {
        errLog('vxe.error.reqComp', ['vxe-button']);
      }
      if (!VxeUISelectComponent) {
        errLog('vxe.error.reqComp', ['vxe-select']);
      }
      if (!VxeUIInputComponent) {
        errLog('vxe.error.reqComp', ['vxe-input']);
      }
      if (!VxeUICheckboxComponent) {
        errLog('vxe.error.reqComp', ['vxe-checkbox']);
      }
    });
    return renderVN;
  }
}));
;// ./packages/table/module/menu/panel.ts










const {
  getIcon: menu_panel_getIcon,
  getI18n: menu_panel_getI18n,
  renderEmptyElement: menu_panel_renderEmptyElement
} = core_.VxeUI;
/* harmony default export */ var menu_panel = (defineVxeComponent({
  name: 'VxeTableMenuPanel',
  setup(props, context) {
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', {});
    const {
      reactData: tableReactData
    } = $xeTable;
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeMenuPanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const renderVN = () => {
      const {
        ctxMenuStore
      } = tableReactData;
      const {
        computeMenuOpts
      } = $xeTable.getComputeMaps();
      const menuOpts = computeMenuOpts.value;
      const {
        transfer,
        destroyOnClose
      } = menuOpts;
      const {
        visible,
        list,
        className
      } = ctxMenuStore;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: !transfer
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--context-menu-wrapper', className, {
          'is--visible': visible
        }],
        style: ctxMenuStore.style
      }, (destroyOnClose ? visible : true) ? list.map((options, gIndex) => {
        return options.every(item => item.visible === false) ? menu_panel_renderEmptyElement($xeTable) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
          class: 'vxe-context-menu--option-wrapper',
          key: gIndex
        }, options.map((item, index) => {
          const {
            children,
            loading
          } = item;
          const hasChildMenus = children && children.some(child => child.visible !== false);
          const prefixOpts = Object.assign({}, item.prefixConfig);
          const prefixIcon = prefixOpts.icon || item.prefixIcon;
          const suffixOpts = Object.assign({}, item.suffixConfig);
          const suffixIcon = suffixOpts.icon || item.suffixIcon;
          const menuContent = getFuncText(item.name);
          return item.visible === false ? menu_panel_renderEmptyElement($xeTable) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
            class: [item.className, {
              'link--loading': loading,
              'link--disabled': item.disabled,
              'link--active': item === ctxMenuStore.selected
            }],
            key: `${gIndex}_${index}`
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
            class: 'vxe-context-menu--link',
            onClick(evnt) {
              $xeTable.ctxMenuLinkEvent(evnt, item);
            },
            onMouseover(evnt) {
              $xeTable.ctxMenuMouseoverEvent(evnt, item);
            },
            onMouseout(evnt) {
              $xeTable.ctxMenuMouseoutEvent(evnt, item);
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-context-menu--link-prefix', prefixOpts.className || '']
          }, [loading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: menu_panel_getIcon('TABLE_MENU_OPTION_LOADING')
          }) : prefixIcon && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(prefixIcon) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, getSlotVNs(prefixIcon({}))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: prefixIcon
          })]), prefixOpts.content ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, `${prefixOpts.content}`) : menu_panel_renderEmptyElement($xeTable)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-context-menu--link-content',
            title: menuContent
          }, loading ? menu_panel_getI18n('vxe.table.menuLoading') : menuContent), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-context-menu--link-suffix', suffixOpts.className || '']
          }, [suffixIcon && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(suffixIcon) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, getSlotVNs(suffixIcon({}))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: suffixIcon || (hasChildMenus ? menu_panel_getIcon().TABLE_MENU_OPTIONS : '')
          }), suffixOpts.content ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${suffixOpts.content}`) : menu_panel_renderEmptyElement($xeTable)])]), hasChildMenus && item.children ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
            class: ['vxe-table--context-menu-clild-wrapper', {
              'is--show': item === ctxMenuStore.selected && ctxMenuStore.showChild
            }]
          }, item.children.map((child, cIndex) => {
            const {
              loading: childLoading
            } = child;
            const childPrefixOpts = Object.assign({}, child.prefixConfig);
            const childPrefixIcon = childPrefixOpts.icon || child.prefixIcon;
            const childSuffixOpts = Object.assign({}, child.suffixConfig);
            const childSuffixIcon = childSuffixOpts.icon || child.suffixIcon;
            const childMenuContent = getFuncText(child.name);
            return child.visible === false ? null : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
              class: [child.className, {
                'link--loading': childLoading,
                'link--disabled': child.disabled,
                'link--active': child === ctxMenuStore.selectChild
              }],
              key: `${gIndex}_${index}_${cIndex}`
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
              class: 'vxe-context-menu--link',
              onClick(evnt) {
                $xeTable.ctxMenuLinkEvent(evnt, child);
              },
              onMouseover(evnt) {
                $xeTable.ctxMenuMouseoverEvent(evnt, item, child);
              },
              onMouseout(evnt) {
                $xeTable.ctxMenuMouseoutEvent(evnt, item);
              }
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: ['vxe-context-menu--link-prefix', childPrefixOpts.className || '']
            }, [child.loading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
              class: menu_panel_getIcon('TABLE_MENU_OPTION_LOADING')
            }) : childPrefixIcon && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(childPrefixIcon) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, getSlotVNs(childPrefixIcon({}))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
              class: childPrefixIcon
            })]), childPrefixOpts.content ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${childPrefixOpts.content}`) : menu_panel_renderEmptyElement($xeTable)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: 'vxe-context-menu--link-content',
              title: childMenuContent
            }, childLoading ? menu_panel_getI18n('vxe.table.menuLoading') : childMenuContent), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: ['vxe-context-menu--link-suffix', childSuffixOpts.className || '']
            }, [childSuffixIcon && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(childSuffixIcon) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, getSlotVNs(childSuffixIcon({}))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
              class: childSuffixIcon
            }), childSuffixOpts.content ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${childSuffixOpts.content}`) : menu_panel_renderEmptyElement($xeTable)])])]);
          })) : null]);
        }));
      }) : [])]);
    };
    $xeMenuPanel.renderVN = renderVN;
    return $xeMenuPanel;
  },
  render() {
    return this.renderVN();
  }
}));
;// ./packages/table/module/filter/hook.ts












const {
  renderer: hook_renderer,
  hooks: hook_hooks
} = core_.VxeUI;
const tableFilterMethodKeys = ['openFilter', 'setFilter', 'clearFilter', 'saveFilter', 'saveFilterByEvent', 'saveFilterPanel', 'saveFilterPanelByEvent', 'resetFilter', 'resetFilterByEvent', 'resetFilterPanel', 'resetFilterPanelByEvent', 'getCheckedFilters', 'updateFilterOptionStatus'];
hook_hooks.add('tableFilterModule', {
  setupTable($xeTable) {
    const $xeGrid = $xeTable.xeGrid;
    const $xeGantt = $xeTable.xeGantt;
    const $xeGGWrapper = $xeGrid || $xeGantt;
    const {
      props,
      reactData,
      internalData
    } = $xeTable;
    const {
      refElem,
      refTableFilter
    } = $xeTable.getRefMaps();
    const {
      computeFilterOpts,
      computeMouseOpts
    } = $xeTable.getComputeMaps();
    const filterPrivateMethods = {
      checkFilterOptions() {
        const {
          filterStore
        } = reactData;
        const {
          column
        } = filterStore;
        if (column) {
          const filterOptions = column.filters || [];
          filterStore.isAllSelected = filterOptions.every(item => item._checked);
          filterStore.isIndeterminate = !filterStore.isAllSelected && filterOptions.some(item => item._checked);
        }
      },
      /**
       * 
       * 
       * 
       * 
       * @param {Event} evnt 
       * @param {ColumnInfo} column 
       * @param {Object} params 
       */
      triggerFilterEvent(evnt, column, params) {
        const {
          initStore,
          filterStore
        } = reactData;
        const {
          elemStore
        } = internalData;
        if (filterStore.column === column && filterStore.visible) {
          filterStore.visible = false;
        } else {
          const tableEl = refElem.value;
          const {
            scrollTop,
            scrollLeft,
            visibleHeight,
            visibleWidth
          } = getDomNode();
          const filterOpts = computeFilterOpts.value;
          const {
            transfer
          } = filterOpts;
          const tableRect = tableEl.getBoundingClientRect();
          const btnElem = evnt.currentTarget;
          const filterRender = column ? column.filterRender : null;
          const compConf = filterRender && isEnableConf(filterRender) ? hook_renderer.get(filterRender.name) : null;
          $xeTable.handleFilterOptions(column);
          internalData._currFilterParams = params;
          filterStore.style = null;
          filterStore.visible = true;
          initStore.filter = true;
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            const headerScrollElem = getRefElem(elemStore['main-header-scroll']);
            if (!headerScrollElem) {
              return;
            }
            const tableFilter = refTableFilter.value;
            const filterWrapperElem = tableFilter ? tableFilter.getRefMaps().refElem.value : null;
            if (!filterWrapperElem) {
              return;
            }
            const btnRect = btnElem.getBoundingClientRect();
            const filterHeadElem = filterWrapperElem.querySelector('.vxe-table--filter-header');
            const filterFootElem = filterWrapperElem.querySelector('.vxe-table--filter-footer');
            const filterWidth = filterWrapperElem.offsetWidth;
            const centerWidth = filterWidth / 2;
            let left = 0;
            let top = 0;
            let maxHeight = 0;
            if (transfer) {
              left = btnRect.left - centerWidth + scrollLeft;
              top = btnRect.top + btnElem.clientHeight + scrollTop;
              maxHeight = Math.min(Math.max(tableRect.height, Math.floor(visibleHeight / 2)), Math.max(80, visibleHeight - top - (filterHeadElem ? filterHeadElem.clientHeight : 0) - (filterFootElem ? filterFootElem.clientHeight : 0) - 28));
              if (left < 16) {
                left = 16;
              } else if (left > visibleWidth - filterWidth - 16) {
                left = visibleWidth - filterWidth - 16;
              }
            } else {
              left = btnRect.left - tableRect.left - centerWidth;
              top = btnRect.top - tableRect.top + btnElem.clientHeight;
              maxHeight = Math.max(40, tableEl.clientHeight - top - (filterHeadElem ? filterHeadElem.clientHeight : 0) - (filterFootElem ? filterFootElem.clientHeight : 0) - 14);
              if (left < 1) {
                left = 1;
              } else if (left > tableEl.clientWidth - filterWidth - 1) {
                left = tableEl.clientWidth - filterWidth - 1;
              }
              if ($xeGGWrapper) {
                const wrapperEl = $xeGGWrapper.getRefMaps().refElem.value;
                if (wrapperEl) {
                  const wrapperRect = wrapperEl.getBoundingClientRect();
                  top += tableRect.top - wrapperRect.top;
                }
              }
            }
            filterStore.style = {
              top: toCssUnit(top),
              left: toCssUnit(left)
            };
            // 
            if (compConf ? !compConf.tableFilterAutoHeight : false) {
              maxHeight = 0;
            }
            // 
            filterStore.maxHeight = maxHeight;
          });
        }
        $xeTable.dispatchEvent('filter-visible', {
          column,
          field: column.field,
          property: column.field,
          filterList: $xeTable.getCheckedFilters(),
          visible: filterStore.visible
        }, evnt);
      },
      handleClearFilter(column) {
        if (column) {
          const {
            filters,
            filterRender
          } = column;
          if (filters) {
            const compConf = isEnableConf(filterRender) ? hook_renderer.get(filterRender.name) : null;
            const frMethod = column.filterResetMethod || (compConf ? compConf.tableFilterResetMethod || compConf.filterResetMethod : null);
            filters.forEach(item => {
              item._checked = false;
              item.checked = false;
              if (!frMethod) {
                item.data = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(item.resetValue, true);
              }
            });
            if (frMethod) {
              frMethod({
                options: filters,
                column,
                $table: $xeTable
              });
            }
          }
        }
      },
      handleColumnConfirmFilter(column, evnt) {
        const {
          mouseConfig
        } = props;
        const {
          scrollXLoad: oldScrollXLoad,
          scrollYLoad: oldScrollYLoad
        } = reactData;
        const filterOpts = computeFilterOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const {
          field,
          filters
        } = column;
        const filterOptions = filters || [];
        const values = [];
        const datas = [];
        filterOptions.forEach(item => {
          if (item.checked) {
            values.push(item.value);
            datas.push(item.data);
          }
        });
        const filterList = $xeTable.getCheckedFilters();
        const params = {
          $table: $xeTable,
          $event: evnt,
          column,
          field,
          property: field,
          values,
          datas,
          filters: filterList,
          filterList
        };
        // 
        if (!filterOpts.remote) {
          $xeTable.handleTableData(true);
          $xeTable.checkSelectionStatus();
        }
        if (mouseConfig && mouseOpts.area && $xeTable.handleFilterEvent) {
          $xeTable.handleFilterEvent(evnt, params);
        }
        if (evnt) {
          $xeTable.dispatchEvent('filter-change', params, evnt);
        }
        $xeTable.closeFilter();
        return $xeTable.updateFooter().then(() => {
          const {
            scrollXLoad,
            scrollYLoad
          } = reactData;
          if (oldScrollXLoad || scrollXLoad || oldScrollYLoad || scrollYLoad) {
            if (oldScrollXLoad || scrollXLoad) {
              $xeTable.updateScrollXSpace();
            }
            if (oldScrollYLoad || scrollYLoad) {
              $xeTable.updateScrollYSpace();
            }
            return $xeTable.refreshScroll();
          }
        }).then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate(true);
        }).then(() => {
          // 
          setTimeout(() => $xeTable.recalculate(), 50);
        });
      },
      /**
       * 
       * 
       */
      confirmFilterEvent(evnt, column) {
        if (column) {
          $xeTable.handleColumnConfirmFilter(column, evnt);
        }
      },
      // 
      handleFilterChangeRadioOption(evnt, checked, item) {
        const {
          filterStore
        } = reactData;
        const {
          column
        } = filterStore;
        if (column) {
          const filterOptions = column.filters || [];
          filterOptions.forEach(option => {
            option._checked = false;
          });
          item._checked = checked;
          $xeTable.checkFilterOptions();
          $xeTable.handleFilterConfirmFilter(evnt, column);
        }
      },
      // 
      handleFilterChangeMultipleOption(evnt, checked, item) {
        item._checked = checked;
        $xeTable.checkFilterOptions();
      },
      // 
      handleFilterChangeOption(evnt, checked, item) {
        const {
          filterStore
        } = reactData;
        const {
          fullColumnIdData
        } = internalData;
        let column = filterStore.column;
        if (!column) {
          const colRest = fullColumnIdData[item._colId];
          if (colRest) {
            column = colRest.column;
            filterStore.column = column;
          }
        }
        if (column) {
          if (column.filterMultiple) {
            $xeTable.handleFilterChangeMultipleOption(evnt, checked, item);
          } else {
            $xeTable.handleFilterChangeRadioOption(evnt, checked, item);
          }
        }
      },
      // 
      handleFilterConfirmFilter(evnt, column) {
        if (column) {
          const filterOptions = column.filters || [];
          filterOptions.forEach(option => {
            option.checked = option._checked;
          });
          $xeTable.confirmFilterEvent(evnt, column);
        }
      },
      /**
       * 
       * 
       */
      handleFilterResetFilter(evnt, column) {
        if (column) {
          $xeTable.handleClearFilter(column);
          $xeTable.confirmFilterEvent(evnt, column);
          if (evnt) {
            $xeTable.dispatchEvent('clear-filter', {
              filterList: []
            }, evnt);
          }
        }
      }
    };
    const filterMethods = {
      /**
       * 
       * @param column
       */
      openFilter(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && column.filters) {
          const {
            elemStore
          } = internalData;
          const {
            fixed
          } = column;
          return $xeTable.scrollToColumn(column).then(() => {
            const headerWrapperElem = getRefElem(elemStore[`${fixed || 'main'}-header-wrapper`] || elemStore['main-header-wrapper']);
            if (headerWrapperElem) {
              const filterBtnElem = headerWrapperElem.querySelector(`.vxe-header--column.${column.id} .vxe-cell--filter`);
              triggerEvent(filterBtnElem, 'click');
            }
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 
       * @param {ColumnInfo} fieldOrColumn 
       * @param {Array} options 
       */
      setFilter(fieldOrColumn, options, isUpdate) {
        const {
          filterStore
        } = reactData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && column.filters) {
          column.filters = toFilters(options || [], column.id);
          if (isUpdate) {
            return $xeTable.handleColumnConfirmFilter(column, null);
          } else {
            if (filterStore.visible) {
              $xeTable.handleFilterOptions(column);
            }
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 
       * 
       * @param {String} fieldOrColumn 
       */
      clearFilter(fieldOrColumn) {
        const {
          filterStore
        } = reactData;
        const {
          tableFullColumn
        } = internalData;
        const filterOpts = computeFilterOpts.value;
        let column;
        if (fieldOrColumn) {
          column = handleFieldOrColumn($xeTable, fieldOrColumn);
          if (column) {
            $xeTable.handleClearFilter(column);
          }
        } else {
          tableFullColumn.forEach($xeTable.handleClearFilter);
        }
        if (!fieldOrColumn || column !== filterStore.column) {
          Object.assign(filterStore, {
            isAllSelected: false,
            isIndeterminate: false,
            style: null,
            options: [],
            column: null,
            multiple: false,
            visible: false
          });
        }
        if (!filterOpts.remote) {
          return $xeTable.updateData();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      saveFilter(fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          $xeTable.handleFilterConfirmFilter(null, column);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      saveFilterByEvent(evnt, fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          $xeTable.handleFilterConfirmFilter(evnt, column);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      resetFilter(fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          $xeTable.handleFilterResetFilter(null, column);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      resetFilterByEvent(evnt, fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          $xeTable.handleFilterResetFilter(evnt, column);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      saveFilterPanel() {
        const {
          filterStore
        } = reactData;
        $xeTable.handleFilterConfirmFilter(null, filterStore.column || null);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      saveFilterPanelByEvent(evnt) {
        const {
          filterStore
        } = reactData;
        $xeTable.handleFilterConfirmFilter(evnt, filterStore.column || null);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      resetFilterPanel() {
        const {
          filterStore
        } = reactData;
        $xeTable.handleFilterResetFilter(null, filterStore.column || null);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      resetFilterPanelByEvent(evnt) {
        const {
          filterStore
        } = reactData;
        $xeTable.handleFilterResetFilter(evnt, filterStore.column || null);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      getCheckedFilters() {
        const {
          tableFullColumn
        } = internalData;
        const filterList = [];
        tableFullColumn.forEach(column => {
          const {
            field,
            filters
          } = column;
          const filterOptions = filters || [];
          const valueList = [];
          const dataList = [];
          if (filterOptions) {
            filterOptions.forEach(item => {
              if (item.checked) {
                valueList.push(item.value);
                dataList.push(item.data);
              }
            });
            if (valueList.length) {
              filterList.push({
                column,
                field,
                property: field,
                values: valueList,
                datas: dataList
              });
            }
          }
        });
        return filterList;
      },
      updateFilterOptionStatus(item, checked) {
        item._checked = checked;
        item.checked = checked;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    return {
      ...filterMethods,
      ...filterPrivateMethods
    };
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableFilterMethodKeys);
  },
  setupGantt($xeGantt) {
    return $xeGantt.extendTableMethods(tableFilterMethodKeys);
  }
});
;// ./packages/table/module/menu/hook.ts





const {
  menus: hook_menus,
  hooks: menu_hook_hooks,
  globalEvents: hook_globalEvents,
  GLOBAL_EVENT_KEYS
} = core_.VxeUI;
const tableMenuMethodKeys = ['closeMenu'];
menu_hook_hooks.add('tableMenuModule', {
  setupTable($xeTable) {
    const {
      xID,
      props,
      reactData,
      internalData
    } = $xeTable;
    const {
      refElem,
      refTableFilter,
      refTableMenu
    } = $xeTable.getRefMaps();
    const {
      computeMouseOpts,
      computeIsContentMenu,
      computeMenuOpts
    } = $xeTable.getComputeMaps();
    const $xeGrid = $xeTable.xeGrid;
    const $xeGantt = $xeTable.xeGantt;
    const $xeGGWrapper = $xeGrid || $xeGantt;
    let menuMethods = {};
    let menuPrivateMethods = {};
    /**
     * 
     */
    const handleOpenMenuEvent = (evnt, type, params) => {
      const {
        ctxMenuStore
      } = reactData;
      const isContentMenu = computeIsContentMenu.value;
      const menuOpts = computeMenuOpts.value;
      const config = menuOpts[type];
      const {
        transfer,
        visibleMethod
      } = menuOpts;
      if (config) {
        const {
          options,
          disabled
        } = config;
        if (disabled) {
          evnt.preventDefault();
        } else if (isContentMenu && options && options.length) {
          params.options = options;
          $xeTable.preventEvent(evnt, 'event.showMenu', params, () => {
            if (!visibleMethod || visibleMethod(params)) {
              evnt.preventDefault();
              $xeTable.updateZindex();
              const el = $xeGGWrapper ? $xeGGWrapper.getRefMaps().refElem.value : refElem.value;
              if (!el) {
                return;
              }
              const tableRect = el.getBoundingClientRect();
              const {
                scrollTop,
                scrollLeft,
                visibleHeight,
                visibleWidth
              } = getDomNode();
              let top = evnt.clientY - tableRect.y;
              let left = evnt.clientX - tableRect.x;
              if (transfer) {
                top = evnt.clientY + scrollTop;
                left = evnt.clientX + scrollLeft;
              }
              const handleVisible = () => {
                internalData._currMenuParams = params;
                Object.assign(ctxMenuStore, {
                  visible: true,
                  list: options,
                  selected: null,
                  selectChild: null,
                  showChild: false,
                  style: {
                    zIndex: internalData.tZindex,
                    top: `${top}px`,
                    left: `${left}px`
                  }
                });
                (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                  const tableMenu = refTableMenu.value;
                  const ctxElem = tableMenu.getRefMaps().refElem.value;
                  const clientHeight = ctxElem.clientHeight;
                  const clientWidth = ctxElem.clientWidth;
                  const {
                    boundingTop,
                    boundingLeft
                  } = getAbsolutePos(ctxElem);
                  const offsetTop = boundingTop + clientHeight - visibleHeight;
                  const offsetLeft = boundingLeft + clientWidth - visibleWidth;
                  if (offsetTop > -10) {
                    ctxMenuStore.style.top = `${Math.max(scrollTop + 2, top - clientHeight - 2)}px`;
                  }
                  if (offsetLeft > -10) {
                    ctxMenuStore.style.left = `${Math.max(scrollLeft + 2, left - clientWidth - 2)}px`;
                  }
                });
              };
              const {
                keyboard,
                row,
                column
              } = params;
              if (keyboard && row && column) {
                $xeTable.scrollToRow(row, column).then(() => {
                  const cell = $xeTable.getCellElement(row, column);
                  if (cell) {
                    const {
                      boundingTop,
                      boundingLeft
                    } = getAbsolutePos(cell);
                    top = boundingTop + scrollTop + Math.floor(cell.offsetHeight / 2);
                    left = boundingLeft + scrollLeft + Math.floor(cell.offsetWidth / 2);
                  }
                  handleVisible();
                });
              } else {
                handleVisible();
              }
            } else {
              menuMethods.closeMenu();
            }
          });
        }
      }
      $xeTable.closeFilter();
    };
    menuMethods = {
      /**
       * 
       */
      closeMenu() {
        Object.assign(reactData.ctxMenuStore, {
          visible: false,
          selected: null,
          selectChild: null,
          showChild: false
        });
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    menuPrivateMethods = {
      /**
       * 
       */
      moveCtxMenu(evnt, ctxMenuStore, property, hasOper, operRest, menuList) {
        let selectItem;
        const selectIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(menuList, item => ctxMenuStore[property] === item);
        if (hasOper) {
          if (operRest && hasChildrenList(ctxMenuStore.selected)) {
            ctxMenuStore.showChild = true;
          } else {
            ctxMenuStore.showChild = false;
            ctxMenuStore.selectChild = null;
          }
        } else if (hook_globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP)) {
          for (let len = selectIndex - 1; len >= 0; len--) {
            if (menuList[len].visible !== false) {
              selectItem = menuList[len];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[menuList.length - 1];
        } else if (hook_globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN)) {
          for (let index = selectIndex + 1; index < menuList.length; index++) {
            if (menuList[index].visible !== false) {
              selectItem = menuList[index];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[0];
        } else if (ctxMenuStore[property] && (hook_globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER) || hook_globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR))) {
          $xeTable.ctxMenuLinkEvent(evnt, ctxMenuStore[property]);
        }
      },
      handleOpenMenuEvent,
      /**
       * 
       */
      handleGlobalContextmenuEvent(evnt) {
        const $xeGrid = $xeTable.xeGrid;
        const $xeGantt = $xeTable.xeGantt;
        const {
          mouseConfig,
          menuConfig
        } = props;
        const {
          editStore,
          ctxMenuStore
        } = reactData;
        const {
          visibleColumn
        } = internalData;
        const tableFilter = refTableFilter.value;
        const tableMenu = refTableMenu.value;
        const mouseOpts = computeMouseOpts.value;
        const menuOpts = computeMenuOpts.value;
        const el = refElem.value;
        const {
          selected
        } = editStore;
        const layoutList = ['header', 'body', 'footer'];
        if (isEnableConf(menuConfig)) {
          if (ctxMenuStore.visible && tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
            evnt.preventDefault();
            return;
          }
          if (internalData._keyCtx) {
            const type = 'body';
            const params = {
              source: 'table',
              type,
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt,
              keyboard: true,
              columns: visibleColumn.slice(0),
              $event: evnt
            };
            // 
            if (mouseConfig && mouseOpts.area) {
              const activeArea = $xeTable.getActiveCellArea();
              if (activeArea && activeArea.row && activeArea.column) {
                params.row = activeArea.row;
                params.column = activeArea.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            } else if (mouseConfig && mouseOpts.selected) {
              // 
              if (selected.row && selected.column) {
                params.row = selected.row;
                params.column = selected.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            }
          }
          // 
          for (let index = 0; index < layoutList.length; index++) {
            const layout = layoutList[index];
            const columnTargetNode = getEventTargetNode(evnt, el, `vxe-${layout}--column`, target => {
              // target=td|th table 
              return target.parentNode.parentNode.parentNode.getAttribute('xid') === xID;
            });
            const params = {
              source: 'table',
              type: layout,
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt,
              columns: visibleColumn.slice(0),
              $event: evnt
            };
            if (columnTargetNode.flag) {
              const cell = columnTargetNode.targetElem;
              const columnNodeRest = $xeTable.getColumnNode(cell);
              const column = columnNodeRest ? columnNodeRest.item : null;
              let typePrefix = `${layout}-`;
              if (column) {
                Object.assign(params, {
                  column,
                  columnIndex: $xeTable.getColumnIndex(column),
                  cell
                });
              }
              if (layout === 'body') {
                const rowNodeRest = $xeTable.getRowNode(cell.parentNode);
                const row = rowNodeRest ? rowNodeRest.item : null;
                typePrefix = '';
                if (row) {
                  params.row = row;
                  params.rowIndex = $xeTable.getRowIndex(row);
                }
              }
              const eventType = `${typePrefix}cell-menu`;
              handleOpenMenuEvent(evnt, layout, params);
              $xeTable.dispatchEvent(eventType, params, evnt);
              return;
            } else if (getEventTargetNode(evnt, el, `vxe-table--${layout}-wrapper`, target => target.getAttribute('xid') === xID).flag) {
              if (menuOpts.trigger === 'cell') {
                evnt.preventDefault();
              } else {
                handleOpenMenuEvent(evnt, layout, params);
              }
              return;
            }
          }
        }
        if (tableFilter && !getEventTargetNode(evnt, tableFilter.getRefMaps().refElem.value).flag) {
          $xeTable.closeFilter();
        }
        menuMethods.closeMenu();
      },
      ctxMenuMouseoverEvent(evnt, item, child) {
        const menuElem = evnt.currentTarget;
        const {
          ctxMenuStore
        } = reactData;
        evnt.preventDefault();
        evnt.stopPropagation();
        ctxMenuStore.selected = item;
        ctxMenuStore.selectChild = child;
        if (!child) {
          ctxMenuStore.showChild = hasChildrenList(item);
          if (ctxMenuStore.showChild) {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              const childWrapperElem = menuElem.nextElementSibling;
              if (childWrapperElem) {
                const {
                  boundingTop,
                  boundingLeft,
                  visibleHeight,
                  visibleWidth
                } = getAbsolutePos(menuElem);
                const posTop = boundingTop + menuElem.offsetHeight;
                const posLeft = boundingLeft + menuElem.offsetWidth;
                let left = '';
                let right = '';
                // 
                if (posLeft + childWrapperElem.offsetWidth > visibleWidth - 10) {
                  left = 'auto';
                  right = `${menuElem.offsetWidth}px`;
                }
                // 
                let top = '';
                let bottom = '';
                if (posTop + childWrapperElem.offsetHeight > visibleHeight - 10) {
                  top = 'auto';
                  bottom = '0';
                }
                childWrapperElem.style.left = left;
                childWrapperElem.style.right = right;
                childWrapperElem.style.top = top;
                childWrapperElem.style.bottom = bottom;
              }
            });
          }
        }
      },
      ctxMenuMouseoutEvent(evnt, item) {
        const {
          ctxMenuStore
        } = reactData;
        if (!item.children) {
          ctxMenuStore.selected = null;
        }
        ctxMenuStore.selectChild = null;
      },
      /**
       * 
       */
      ctxMenuLinkEvent(evnt, menu) {
        const $xeGrid = $xeTable.xeGrid;
        const $xeGantt = $xeTable.xeGantt;
        //  code 
        if (!menu.loading && !menu.disabled && (menu.code || !menu.children || !menu.children.length)) {
          const gMenuOpts = hook_menus.get(menu.code);
          const params = Object.assign({}, internalData._currMenuParams, {
            menu,
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt,
            $event: evnt
          });
          const tmMethod = gMenuOpts ? gMenuOpts.tableMenuMethod || gMenuOpts.menuMethod : null;
          if (tmMethod) {
            tmMethod(params, evnt);
          }
          $xeTable.dispatchEvent('menu-click', params, evnt);
          menuMethods.closeMenu();
        }
      }
    };
    return {
      ...menuMethods,
      ...menuPrivateMethods
    };
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableMenuMethodKeys);
  },
  setupGantt($xeGantt) {
    return $xeGantt.extendTableMethods(tableMenuMethodKeys);
  }
});
;// ./packages/table/module/edit/hook.ts














const {
  getConfig: hook_getConfig,
  renderer: edit_hook_renderer,
  hooks: edit_hook_hooks,
  getI18n: hook_getI18n
} = core_.VxeUI;
const tableEditMethodKeys = ['insert', 'insertAt', 'insertNextAt', 'insertChild', 'insertChildAt', 'insertChildNextAt', 'remove', 'removeCheckboxRow', 'removeRadioRow', 'removeCurrentRow', 'getRecordset', 'getInsertRecords', 'getRemoveRecords', 'getUpdateRecords', 'getEditRecord', 'getActiveRecord', 'getEditCell', 'getSelectedCell', 'clearEdit', 'clearActived', 'clearSelected', 'isEditByRow', 'isActiveByRow', 'setEditRow', 'setActiveRow', 'setEditCell', 'setActiveCell', 'setSelectCell'];
edit_hook_hooks.add('tableEditModule', {
  setupTable($xeTable) {
    const {
      props,
      reactData,
      internalData
    } = $xeTable;
    const {
      refElem
    } = $xeTable.getRefMaps();
    const {
      computeMouseOpts,
      computeEditOpts,
      computeCheckboxOpts,
      computeTreeOpts,
      computeValidOpts
    } = $xeTable.getComputeMaps();
    const browseObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
    let editMethods = {};
    let editPrivateMethods = {};
    const getEditColumnModel = (row, column) => {
      const {
        model,
        editRender
      } = column;
      if (editRender) {
        model.value = getCellValue(row, column);
        model.update = false;
      }
    };
    const setEditColumnModel = (row, column) => {
      const {
        model,
        editRender
      } = column;
      if (editRender && model.update) {
        setCellValue(row, column, model.value);
        model.update = false;
        model.value = null;
      }
    };
    const removeCellSelectedClass = () => {
      const el = refElem.value;
      if (el) {
        const cell = el.querySelector('.col--selected');
        if (cell) {
          removeClass(cell, 'col--selected');
        }
      }
    };
    const syncActivedCell = () => {
      const {
        editStore,
        tableColumn
      } = reactData;
      const editOpts = computeEditOpts.value;
      const {
        actived
      } = editStore;
      const {
        row,
        column
      } = actived;
      if (row || column) {
        if (editOpts.mode === 'row') {
          tableColumn.forEach(column => setEditColumnModel(row, column));
        } else {
          setEditColumnModel(row, column);
        }
      }
    };
    const insertTreeRow = (newRecords, isAppend) => {
      const {
        tableFullTreeData,
        afterFullData,
        fullDataRowIdData,
        fullAllDataRowIdData
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const {
        rowField,
        parentField,
        mapChildrenField
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const funcName = isAppend ? 'push' : 'unshift';
      newRecords.forEach(item => {
        const parentRowId = item[parentField];
        const rowid = getRowid($xeTable, item);
        const matchObj = parentRowId ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => parentRowId === item[rowField], {
          children: mapChildrenField
        }) : null;
        if (matchObj) {
          const {
            item: parentRow
          } = matchObj;
          const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
          const parentLevel = parentRest ? parentRest.level : 0;
          let pChilds = parentRow[childrenField];
          let pMapChilds = parentRow[mapChildrenField];
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(pChilds)) {
            pChilds = parentRow[childrenField] = [];
          }
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(pMapChilds)) {
            pMapChilds = parentRow[mapChildrenField] = [];
          }
          pChilds[funcName](item);
          pMapChilds[funcName](item);
          const rest = {
            row: item,
            rowid,
            seq: -1,
            index: -1,
            _index: -1,
            $index: -1,
            treeIndex: -1,
            _tIndex: -1,
            items: pChilds,
            parent: parentRow,
            level: parentLevel + 1,
            height: 0,
            resizeHeight: 0,
            oTop: 0,
            expandHeight: 0
          };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        } else {
          if (parentRowId) {
            warnLog('vxe.error.unableInsert');
          }
          afterFullData[funcName](item);
          tableFullTreeData[funcName](item);
          const rest = {
            row: item,
            rowid,
            seq: -1,
            index: -1,
            _index: -1,
            $index: -1,
            treeIndex: -1,
            _tIndex: -1,
            items: tableFullTreeData,
            parent: null,
            level: 0,
            height: 0,
            resizeHeight: 0,
            oTop: 0,
            expandHeight: 0
          };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        }
      });
    };
    // const insertGroupRow = (newRecords: any[], isAppend: boolean) => {
    // }
    const handleInsertRowAt = (records, targetRow, isInsertNextRow) => {
      const {
        treeConfig
      } = props;
      const {
        isRowGroupStatus
      } = reactData;
      const {
        tableFullTreeData,
        afterFullData,
        mergeBodyList,
        tableFullData,
        fullDataRowIdData,
        fullAllDataRowIdData,
        insertRowMaps,
        removeRowMaps
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const {
        transform,
        parentField,
        rowField,
        mapChildrenField
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records)) {
        records = [records];
      }
      const newRecords = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)($xeTable.defineField(records.map(record => Object.assign(treeConfig && transform ? {
        [mapChildrenField]: [],
        [childrenField]: []
      } : {}, record))));
      let treeRecords = [];
      if (treeConfig && transform) {
        treeRecords = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(newRecords, {
          key: rowField,
          parentKey: parentField,
          children: childrenField
        });
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(targetRow)) {
        // 
        if (treeConfig && transform) {
          insertTreeRow(newRecords, false);
        } else if (isRowGroupStatus) {
          // 
          if (treeConfig) {
            throw new Error(hook_getI18n('vxe.error.noTree', ['insert']));
          }
          warnLog(hook_getI18n('vxe.error.noGroup', ['remove']));
          // insertGroupRow(newRecords, false)
        } else {
          newRecords.forEach(item => {
            const rowid = getRowid($xeTable, item);
            const rest = {
              row: item,
              rowid,
              seq: -1,
              index: -1,
              _index: -1,
              $index: -1,
              treeIndex: -1,
              _tIndex: -1,
              items: afterFullData,
              parent: null,
              level: 0,
              height: 0,
              resizeHeight: 0,
              oTop: 0,
              expandHeight: 0
            };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
            afterFullData.unshift(item);
            tableFullData.unshift(item);
          });
          // 
          mergeBodyList.forEach(mergeItem => {
            const {
              row: mergeRowIndex
            } = mergeItem;
            if (mergeRowIndex >= 0) {
              mergeItem.row = mergeRowIndex + newRecords.length;
            }
          });
        }
      } else {
        if (targetRow === -1) {
          // 
          if (treeConfig && transform) {
            insertTreeRow(newRecords, true);
          } else if (isRowGroupStatus) {
            // 
            if (treeConfig) {
              throw new Error(hook_getI18n('vxe.error.noTree', ['insert']));
            }
            warnLog(hook_getI18n('vxe.error.noGroup', ['remove']));
            // insertGroupRow(newRecords, true)
          } else {
            newRecords.forEach(item => {
              const rowid = getRowid($xeTable, item);
              const rest = {
                row: item,
                rowid,
                seq: -1,
                index: -1,
                _index: -1,
                treeIndex: -1,
                _tIndex: -1,
                $index: -1,
                items: afterFullData,
                parent: null,
                level: 0,
                height: 0,
                resizeHeight: 0,
                oTop: 0,
                expandHeight: 0
              };
              fullDataRowIdData[rowid] = rest;
              fullAllDataRowIdData[rowid] = rest;
              afterFullData.push(item);
              tableFullData.push(item);
            });
          }
        } else {
          // 
          if (treeConfig && transform) {
            const matchMapObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => targetRow[rowField] === item[rowField], {
              children: mapChildrenField
            });
            if (matchMapObj) {
              const {
                parent: parentRow
              } = matchMapObj;
              const parentMapChilds = parentRow ? parentRow[mapChildrenField] : tableFullTreeData;
              const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
              const parentLevel = parentRest ? parentRest.level : 0;
              treeRecords.forEach((row, i) => {
                if (parentRow) {
                  if (row[parentField] !== parentRow[rowField]) {
                    errLog('vxe.error.errProp', [`${parentField}=${row[parentField]}`, `${parentField}=${parentRow[rowField]}`]);
                    row[parentField] = parentRow[rowField];
                  }
                } else {
                  if (row[parentField] !== null) {
                    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(row[parentField])) {
                      errLog('vxe.error.errProp', [`${parentField}=${row[parentField]}`, 'null']);
                    }
                    row[parentField] = null;
                  }
                }
                let targetIndex = matchMapObj.index + i;
                if (isInsertNextRow) {
                  targetIndex = targetIndex + 1;
                }
                parentMapChilds.splice(targetIndex, 0, row);
              });
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(treeRecords, item => {
                const rowid = getRowid($xeTable, item);
                const rest = {
                  row: item,
                  rowid,
                  seq: -1,
                  index: -1,
                  _index: -1,
                  $index: -1,
                  treeIndex: -1,
                  _tIndex: -1,
                  items: parentMapChilds,
                  parent: parentRow,
                  level: parentLevel + 1,
                  height: 0,
                  resizeHeight: 0,
                  oTop: 0,
                  expandHeight: 0
                };
                if (item[childrenField]) {
                  item[mapChildrenField] = item[childrenField];
                }
                fullDataRowIdData[rowid] = rest;
                fullAllDataRowIdData[rowid] = rest;
              }, {
                children: childrenField
              });
              // 
              if (parentRow) {
                const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => targetRow[rowField] === item[rowField], {
                  children: childrenField
                });
                if (matchObj) {
                  const parentChilds = matchObj.items;
                  let targetIndex = matchObj.index;
                  if (isInsertNextRow) {
                    targetIndex = targetIndex + 1;
                  }
                  parentChilds.splice(targetIndex, 0, ...treeRecords);
                }
              }
            } else {
              warnLog('vxe.error.unableInsert');
              insertTreeRow(newRecords, true);
            }
          } else if (isRowGroupStatus) {
            // 
            if (treeConfig) {
              throw new Error(hook_getI18n('vxe.error.noTree', ['insert']));
            }
            warnLog(hook_getI18n('vxe.error.noGroup', ['remove']));
          } else {
            if (treeConfig) {
              throw new Error(hook_getI18n('vxe.error.noTree', ['insert']));
            }
            let afIndex = -1;
            // 
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(targetRow)) {
              if (targetRow < afterFullData.length) {
                afIndex = targetRow;
              }
            } else {
              afIndex = $xeTable.findRowIndexOf(afterFullData, targetRow);
            }
            // 
            if (isInsertNextRow) {
              afIndex = Math.min(afterFullData.length, afIndex + 1);
            }
            if (afIndex === -1) {
              throw new Error(hook_getI18n('vxe.error.unableInsert'));
            }
            afterFullData.splice(afIndex, 0, ...newRecords);
            const tfIndex = $xeTable.findRowIndexOf(tableFullData, targetRow);
            if (tfIndex > -1) {
              tableFullData.splice(tfIndex + (isInsertNextRow ? 1 : 0), 0, ...newRecords);
            } else {
              tableFullData.push(...newRecords);
            }
            // 
            mergeBodyList.forEach(mergeItem => {
              const {
                row: mergeRowIndex,
                rowspan: mergeRowspan
              } = mergeItem;
              if (mergeRowIndex >= afIndex) {
                mergeItem.row = mergeRowIndex + newRecords.length;
              } else if (isInsertNextRow ? mergeRowIndex + mergeRowspan >= afIndex : mergeRowIndex + mergeRowspan > afIndex) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        }
      }
      const handleStatus = newRow => {
        const rowid = getRowid($xeTable, newRow);
        // 
        if (removeRowMaps[rowid]) {
          delete removeRowMaps[rowid];
          if (insertRowMaps[rowid]) {
            delete insertRowMaps[rowid];
          }
        } else {
          insertRowMaps[rowid] = newRow;
        }
      };
      // 
      if (treeConfig && transform) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(treeRecords, handleStatus, {
          children: mapChildrenField
        });
      } else {
        newRecords.forEach(handleStatus);
      }
      reactData.removeRowFlag++;
      reactData.insertRowFlag++;
      $xeTable.cacheRowMap(false);
      $xeTable.updateScrollYStatus();
      $xeTable.handleTableData(treeConfig && transform);
      if (!(treeConfig && transform)) {
        $xeTable.updateAfterDataIndex();
      }
      $xeTable.updateFooter();
      $xeTable.handleUpdateBodyMerge();
      $xeTable.checkSelectionStatus();
      if (reactData.scrollYLoad) {
        $xeTable.updateScrollYSpace();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        $xeTable.updateCellAreas();
        return $xeTable.recalculate(true);
      }).then(() => {
        return {
          row: newRecords.length ? newRecords[newRecords.length - 1] : null,
          rows: newRecords
        };
      });
    };
    const handleInsertChildRowAt = (records, parentRow, targetRow, isInsertNextRow) => {
      const {
        treeConfig
      } = props;
      const treeOpts = computeTreeOpts.value;
      const {
        transform,
        rowField,
        parentField
      } = treeOpts;
      if (treeConfig && transform) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records)) {
          records = [records];
        }
        return handleInsertRowAt(records.map(item => Object.assign({}, item, {
          [parentField]: parentRow[rowField]
        })), targetRow, isInsertNextRow);
      } else {
        errLog('vxe.error.errProp', ['tree-config.transform=false', 'tree-config.transform=true']);
      }
      return Promise.resolve({
        row: null,
        rows: []
      });
    };
    const handleClearEdit = (evnt, targetRow) => {
      const {
        editStore
      } = reactData;
      const {
        actived,
        focused
      } = editStore;
      const {
        row,
        column
      } = actived;
      const validOpts = computeValidOpts.value;
      if (row || column) {
        if (targetRow && getRowid($xeTable, targetRow) !== getRowid($xeTable, row)) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
        syncActivedCell();
        actived.args = null;
        actived.row = null;
        actived.column = null;
        $xeTable.updateFooter();
        $xeTable.dispatchEvent('edit-closed', {
          row,
          rowIndex: $xeTable.getRowIndex(row),
          $rowIndex: $xeTable.getVMRowIndex(row),
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          $columnIndex: $xeTable.getVMColumnIndex(column)
        }, evnt || null);
      }
      focused.row = null;
      focused.column = null;
      if (validOpts.autoClear) {
        if (validOpts.msgMode !== 'full' || hook_getConfig().cellVaildMode === 'obsolete') {
          if ($xeTable.clearValidate) {
            return $xeTable.clearValidate();
          }
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => $xeTable.updateCellAreas());
    };
    const handleEditActive = (params, evnt, isFocus, isPos) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const {
        editConfig,
        mouseConfig
      } = props;
      const {
        editStore,
        tableColumn
      } = reactData;
      const editOpts = computeEditOpts.value;
      const {
        mode
      } = editOpts;
      const {
        actived,
        focused
      } = editStore;
      const {
        row,
        column
      } = params;
      const {
        editRender
      } = column;
      const cell = params.cell || $xeTable.getCellElement(row, column);
      const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
      params.cell = cell;
      if (cell && isEnableConf(editConfig) && isEnableConf(editRender)) {
        // 
        if (!$xeTable.isPendingByRow(row) && !$xeTable.isAggregateRecord(row)) {
          if (actived.row !== row || (mode === 'cell' ? actived.column !== column : false)) {
            // 
            let type = 'edit-disabled';
            if (!beforeEditMethod || beforeEditMethod({
              ...params,
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt
            })) {
              if (mouseConfig) {
                $xeTable.clearSelected();
                if ($xeTable.clearCellAreas) {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                }
              }
              $xeTable.closeTooltip();
              if (actived.column) {
                handleClearEdit(evnt);
              }
              type = 'edit-activated';
              column.renderHeight = cell.offsetHeight;
              actived.args = params;
              actived.row = row;
              actived.column = column;
              if (mode === 'row') {
                tableColumn.forEach(column => getEditColumnModel(row, column));
              } else {
                getEditColumnModel(row, column);
              }
              const afterEditMethod = editOpts.afterEditMethod;
              (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                if (isFocus) {
                  $xeTable.handleFocus(params, evnt);
                }
                if (afterEditMethod) {
                  afterEditMethod({
                    ...params,
                    $table: $xeTable,
                    $grid: $xeGrid,
                    $gantt: $xeGantt
                  });
                }
              });
            }
            $xeTable.dispatchEvent(type, {
              row,
              rowIndex: $xeTable.getRowIndex(row),
              $rowIndex: $xeTable.getVMRowIndex(row),
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              $columnIndex: $xeTable.getVMColumnIndex(column)
            }, evnt);
            // v4
            if (type === 'edit-activated') {
              $xeTable.dispatchEvent('edit-actived', {
                row,
                rowIndex: $xeTable.getRowIndex(row),
                $rowIndex: $xeTable.getVMRowIndex(row),
                column,
                columnIndex: $xeTable.getColumnIndex(column),
                $columnIndex: $xeTable.getVMColumnIndex(column)
              }, evnt);
            }
          } else {
            const {
              column: oldColumn
            } = actived;
            if (mouseConfig) {
              $xeTable.clearSelected();
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
            }
            if (oldColumn !== column) {
              const {
                model: oldModel
              } = oldColumn;
              if (oldModel.update) {
                setCellValue(row, oldColumn, oldModel.value);
              }
              if ($xeTable.clearValidate) {
                $xeTable.clearValidate(row, column);
              }
            }
            column.renderHeight = cell.offsetHeight;
            actived.args = params;
            actived.column = column;
            if (isPos) {
              setTimeout(() => {
                $xeTable.handleFocus(params, evnt);
              });
            }
          }
          focused.column = null;
          focused.row = null;
          $xeTable.focus();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleEditCell = (row, fieldOrColumn, isPos) => {
      const {
        editConfig
      } = props;
      const column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
      if (row && column && isEnableConf(editConfig) && isEnableConf(column.editRender) && !$xeTable.isAggregateRecord(row)) {
        return Promise.resolve(isPos ? $xeTable.scrollToRow(row, column) : null).then(() => {
          const cell = $xeTable.getCellElement(row, column);
          if (cell) {
            handleEditActive({
              row,
              rowIndex: $xeTable.getRowIndex(row),
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              cell,
              $table: $xeTable
            }, null, isPos, isPos);
            internalData._lastCallTime = Date.now();
          }
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    editMethods = {
      /**
       * 
       *
       * @param {*} records
       */
      insert(records) {
        return handleInsertRowAt(records, null);
      },
      /**
       * 
       *  row 
       *  row  -1 
       *  row 
       * @param {Object/Array} records 
       * @param {Row} targetRow 
       */
      insertAt(records, targetRow) {
        return handleInsertRowAt(records, targetRow);
      },
      insertNextAt(records, targetRow) {
        return handleInsertRowAt(records, targetRow, true);
      },
      insertChild(records, parentRow) {
        return handleInsertChildRowAt(records, parentRow, null);
      },
      insertChildAt(records, parentRow, targetRow) {
        return handleInsertChildRowAt(records, parentRow, targetRow);
      },
      insertChildNextAt(records, parentRow, targetRow) {
        return handleInsertChildRowAt(records, parentRow, targetRow, true);
      },
      /**
       * 
       *  row 
       *  rows 
       * 
       */
      remove(rows) {
        const {
          treeConfig
        } = props;
        const {
          editStore,
          isRowGroupStatus
        } = reactData;
        const {
          tableFullTreeData,
          selectCheckboxMaps,
          afterFullData,
          mergeBodyList,
          tableFullData,
          pendingRowMaps,
          insertRowMaps,
          removeRowMaps
        } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const {
          transform,
          mapChildrenField
        } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const {
          actived
        } = editStore;
        const {
          checkField
        } = checkboxOpts;
        let delList = [];
        if (!rows) {
          rows = tableFullData;
        } else if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
          rows = [rows];
        }
        // 
        rows.forEach(row => {
          if (!$xeTable.isInsertByRow(row)) {
            const rowid = getRowid($xeTable, row);
            removeRowMaps[rowid] = row;
          }
        });
        // 
        if (!checkField) {
          rows.forEach(row => {
            const rowid = getRowid($xeTable, row);
            if (selectCheckboxMaps[rowid]) {
              delete selectCheckboxMaps[rowid];
            }
          });
          reactData.updateCheckboxFlag++;
        }
        // 
        if (tableFullData === rows) {
          rows = delList = tableFullData.slice(0);
          internalData.tableFullData = [];
          internalData.afterFullData = [];
          $xeTable.clearMergeCells();
        } else {
          // 
          if (treeConfig && transform) {
            rows.forEach(row => {
              const rowid = getRowid($xeTable, row);
              const matchMapObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => rowid === getRowid($xeTable, item), {
                children: mapChildrenField
              });
              if (matchMapObj) {
                const rItems = matchMapObj.items.splice(matchMapObj.index, 1);
                delList.push(rItems[0]);
              }
              const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => rowid === getRowid($xeTable, item), {
                children: childrenField
              });
              if (matchObj) {
                matchObj.items.splice(matchObj.index, 1);
              }
              const afIndex = $xeTable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                afterFullData.splice(afIndex, 1);
              }
            });
          } else if (isRowGroupStatus) {
            // 
            warnLog(hook_getI18n('vxe.error.noGroup', ['remove']));
          } else {
            rows.forEach(row => {
              const tfIndex = $xeTable.findRowIndexOf(tableFullData, row);
              if (tfIndex > -1) {
                const rItems = tableFullData.splice(tfIndex, 1);
                delList.push(rItems[0]);
              }
              const afIndex = $xeTable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                // 
                mergeBodyList.forEach(mergeItem => {
                  const {
                    row: mergeRowIndex,
                    rowspan: mergeRowspan
                  } = mergeItem;
                  if (mergeRowIndex > afIndex) {
                    mergeItem.row = mergeRowIndex - 1;
                  } else if (mergeRowIndex + mergeRowspan > afIndex) {
                    mergeItem.rowspan = mergeRowspan - 1;
                  }
                });
                afterFullData.splice(afIndex, 1);
              }
            });
          }
        }
        // 
        if (actived.row && $xeTable.findRowIndexOf(rows, actived.row) > -1) {
          editMethods.clearEdit();
        }
        // 
        rows.forEach(row => {
          const rowid = getRowid($xeTable, row);
          if (insertRowMaps[rowid]) {
            delete insertRowMaps[rowid];
          }
          if (pendingRowMaps[rowid]) {
            delete pendingRowMaps[rowid];
          }
        });
        reactData.removeRowFlag++;
        reactData.insertRowFlag++;
        reactData.pendingRowFlag++;
        $xeTable.cacheRowMap(false);
        $xeTable.handleTableData(treeConfig && transform);
        $xeTable.updateFooter();
        $xeTable.handleUpdateBodyMerge();
        if (!(treeConfig && transform)) {
          $xeTable.updateAfterDataIndex();
        }
        $xeTable.checkSelectionStatus();
        if (reactData.scrollYLoad) {
          $xeTable.updateScrollYSpace();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate(true);
        }).then(() => {
          return {
            row: delList.length ? delList[delList.length - 1] : null,
            rows: delList
          };
        });
      },
      /**
       * 
       */
      removeCheckboxRow() {
        return editMethods.remove($xeTable.getCheckboxRecords()).then(params => {
          $xeTable.clearCheckboxRow();
          return params;
        });
      },
      /**
       * 
       */
      removeRadioRow() {
        const radioRecord = $xeTable.getRadioRecord();
        return editMethods.remove(radioRecord || []).then(params => {
          $xeTable.clearRadioRow();
          return params;
        });
      },
      /**
       * 
       */
      removeCurrentRow() {
        const currentRecord = $xeTable.getCurrentRecord();
        return editMethods.remove(currentRecord || []).then(params => {
          $xeTable.clearCurrentRow();
          return params;
        });
      },
      /**
       * 
       */
      getRecordset() {
        const removeRecords = editMethods.getRemoveRecords();
        const pendingRecords = $xeTable.getPendingRecords();
        const delRecords = removeRecords.concat(pendingRecords);
        // 
        const updateRecords = editMethods.getUpdateRecords().filter(row => {
          return !delRecords.some(item => $xeTable.eqRow(item, row));
        });
        return {
          insertRecords: editMethods.getInsertRecords(),
          removeRecords,
          updateRecords,
          pendingRecords
        };
      },
      /**
       * 
       */
      getInsertRecords() {
        const {
          fullAllDataRowIdData,
          insertRowMaps
        } = internalData;
        const insertRecords = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(insertRowMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      /**
       * 
       */
      getRemoveRecords() {
        const {
          removeRowMaps
        } = internalData;
        const removeRecords = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(removeRowMaps, row => {
          removeRecords.push(row);
        });
        return removeRecords;
      },
      /**
       * 
       *  row 
       * 
       */
      getUpdateRecords() {
        const {
          keepSource,
          treeConfig
        } = props;
        const {
          tableFullData
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        if (keepSource) {
          syncActivedCell();
          if (treeConfig) {
            return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().filterTree(tableFullData, row => $xeTable.isUpdateByRow(row), treeOpts);
          }
          return tableFullData.filter(row => $xeTable.isUpdateByRow(row));
        }
        return [];
      },
      getActiveRecord() {
        warnLog('vxe.error.delFunc', ['getActiveRecord', 'getEditCell']);
        const {
          editStore
        } = reactData;
        const {
          fullAllDataRowIdData
        } = internalData;
        const {
          args,
          row
        } = editStore.actived;
        if (args && row && fullAllDataRowIdData[getRowid($xeTable, row)]) {
          return Object.assign({}, args, {
            row
          });
        }
        return null;
      },
      getEditRecord() {
        warnLog('vxe.error.delFunc', ['getEditRecord', 'getEditCell']);
        const {
          editStore
        } = reactData;
        const {
          fullAllDataRowIdData
        } = internalData;
        const {
          args,
          row
        } = editStore.actived;
        if (args && row && fullAllDataRowIdData[getRowid($xeTable, row)]) {
          return Object.assign({}, args, {
            row
          });
        }
        return null;
      },
      getEditCell() {
        const {
          editStore
        } = reactData;
        const {
          row,
          column
        } = editStore.actived;
        if (column && row) {
          return {
            row,
            rowIndex: $xeTable.getRowIndex(row),
            column,
            columnIndex: $xeTable.getColumnIndex(column)
          };
        }
        return null;
      },
      /**
       * 
       */
      getSelectedCell() {
        const {
          editStore
        } = reactData;
        const {
          row,
          column
        } = editStore.selected;
        if (row && column) {
          return {
            row,
            column
          };
        }
        return null;
      },
      clearActived(row) {
        // 
        warnLog('vxe.error.delFunc', ['clearActived', 'clearEdit']);
        return $xeTable.clearEdit(row);
      },
      /**
       * 
       */
      clearEdit(row) {
        return handleClearEdit(null, row);
      },
      /**
       * 
       */
      clearSelected() {
        const {
          editStore
        } = reactData;
        const {
          selected
        } = editStore;
        selected.row = null;
        selected.column = null;
        removeCellSelectedClass();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      isActiveByRow(row) {
        warnLog('vxe.error.delFunc', ['isActiveByRow', 'isEditByRow']);
        // 
        return $xeTable.isEditByRow(row);
      },
      /**
       * 
       * @param {Row} row 
       */
      isEditByRow(row) {
        const {
          editStore
        } = reactData;
        return editStore.actived.row === row;
      },
      setActiveRow(row) {
        warnLog('vxe.error.delFunc', ['setActiveRow', 'setEditRow']);
        // 
        return editMethods.setEditRow(row);
      },
      /**
       * 
       */
      setEditRow(row, fieldOrColumn) {
        const {
          visibleColumn
        } = internalData;
        let column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(visibleColumn, column => isEnableConf(column.editRender));
        let isPos = false;
        if (fieldOrColumn) {
          isPos = true;
          if (fieldOrColumn !== true) {
            column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
          }
        }
        return handleEditCell(row, column, isPos);
      },
      setActiveCell(row, fieldOrColumn) {
        warnLog('vxe.error.delFunc', ['setActiveCell', 'setEditCell']);
        // 
        return editMethods.setEditCell(row, fieldOrColumn);
      },
      /**
       * 
       */
      setEditCell(row, fieldOrColumn) {
        return handleEditCell(row, fieldOrColumn, true);
      },
      /**
       *  trigger=dblclick 
       */
      setSelectCell(row, fieldOrColumn) {
        const {
          tableData
        } = reactData;
        const editOpts = computeEditOpts.value;
        const column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && editOpts.trigger !== 'manual') {
          const rowIndex = $xeTable.findRowIndexOf(tableData, row);
          if (rowIndex > -1 && column) {
            const cell = $xeTable.getCellElement(row, column);
            const params = {
              row,
              rowIndex,
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              cell
            };
            $xeTable.handleSelected(params, {});
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    editPrivateMethods = {
      /**
       * 
       */
      handleEdit(params, evnt) {
        return handleEditActive(params, evnt, true, true);
      },
      /**
       * @deprecated
       */
      handleActived(params, evnt) {
        return editPrivateMethods.handleEdit(params, evnt);
      },
      /**
       * 
       * @param evnt
       * @returns
       */
      handleClearEdit,
      /**
       * 
       */
      handleFocus(params) {
        const {
          row,
          column,
          cell
        } = params;
        const {
          editRender
        } = column;
        const editOpts = computeEditOpts.value;
        if (isEnableConf(editRender)) {
          const compRender = edit_hook_renderer.get(editRender.name);
          let autoFocus = editRender.autofocus || editRender.autoFocus;
          let autoSelect = editRender.autoSelect || editRender.autoselect;
          let inputElem;
          // 
          if (editOpts.autoFocus) {
            if (!autoFocus && compRender) {
              autoFocus = compRender.tableAutoFocus || compRender.tableAutofocus || compRender.autofocus;
            }
            if (!autoSelect && compRender) {
              autoSelect = compRender.tableAutoSelect || compRender.autoselect;
            }
            //  class
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(autoFocus)) {
              inputElem = autoFocus(params);
            } else if (autoFocus) {
              if (autoFocus === true) {
                // 
                inputElem = cell.querySelector('input,textarea');
              } else {
                inputElem = cell.querySelector(autoFocus);
              }
              if (inputElem) {
                inputElem.focus();
              }
            }
          }
          if (inputElem) {
            if (autoSelect) {
              inputElem.select();
            } else {
              // 
              if (browseObj.msie) {
                const textRange = inputElem.createTextRange();
                textRange.collapse(false);
                textRange.select();
              }
            }
          } else {
            // 
            if (editOpts.autoPos) {
              if (!column.fixed) {
                // 
                $xeTable.scrollToRow(row, column);
              }
            }
          }
        }
      },
      /**
       * 
       */
      handleSelected(params, evnt) {
        const {
          mouseConfig
        } = props;
        const {
          editStore
        } = reactData;
        const mouseOpts = computeMouseOpts.value;
        const editOpts = computeEditOpts.value;
        const {
          actived,
          selected
        } = editStore;
        const {
          row,
          column
        } = params;
        const isMouseSelected = mouseConfig && mouseOpts.selected;
        const selectMethod = () => {
          if (isMouseSelected && (selected.row !== row || selected.column !== column)) {
            if (actived.row !== row || (editOpts.mode === 'cell' ? actived.column !== column : false)) {
              handleClearEdit(evnt);
              $xeTable.clearSelected();
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
              selected.args = params;
              selected.row = row;
              selected.column = column;
              if (isMouseSelected) {
                editPrivateMethods.addCellSelectedClass();
              }
              $xeTable.focus();
              if (evnt) {
                $xeTable.dispatchEvent('cell-selected', params, evnt);
              }
            }
          }
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        };
        return selectMethod();
      },
      addCellSelectedClass() {
        const {
          editStore
        } = reactData;
        const {
          selected
        } = editStore;
        const {
          row,
          column
        } = selected;
        removeCellSelectedClass();
        if (row && column) {
          const cell = $xeTable.getCellElement(row, column);
          if (cell) {
            addClass(cell, 'col--selected');
          }
        }
      }
    };
    return {
      ...editMethods,
      ...editPrivateMethods
    };
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableEditMethodKeys);
  },
  setupGantt($xeGantt) {
    return $xeGantt.extendTableMethods(tableEditMethodKeys);
  }
});
;// ./packages/table/module/export/util.ts
//  HTML 
const defaultHtmlStyle = 'body{margin:0;padding: 0 1px;color:#333333;font-size:14px;font-family:"Microsoft YaHei",,"MicrosoftJhengHei",,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function getExportBlobByContent(content, options) {
  return new Blob([content], {
    type: `text/${options.type};charset=utf-8;`
  });
}
function createHtmlPage(opts, content) {
  const {
    style
  } = opts;
  return ['<!DOCTYPE html><html>', '<head>', '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">', `<title>${opts.sheetName}</title>`, '<style media="print">.vxe-page-break-before{page-break-before:always;}.vxe-page-break-after{page-break-after:always;}</style>', `<style>${defaultHtmlStyle}</style>`, style ? `<style>${style}</style>` : '', '</head>', `<body>${content}</body>`, '</html>'].join('');
}
;// ./packages/table/module/export/hook.ts















const {
  getI18n: export_hook_getI18n,
  hooks: export_hook_hooks,
  renderer: export_hook_renderer
} = core_.VxeUI;
let htmlCellElem;
const csvBOM = '\ufeff';
const enterSymbol = '\r\n';
function defaultFilterExportColumn(column) {
  return !!column.field || ['seq', 'checkbox', 'radio'].indexOf(column.type || '') === -1;
}
const getConvertColumns = columns => {
  const result = [];
  columns.forEach(column => {
    if (column.childNodes && column.childNodes.length) {
      result.push(column);
      result.push(...getConvertColumns(column.childNodes));
    } else {
      result.push(column);
    }
  });
  return result;
};
const convertToRows = originColumns => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column._level = parent._level + 1;
      if (maxLevel < column._level) {
        maxLevel = column._level;
      }
    }
    if (column.childNodes && column.childNodes.length) {
      let colSpan = 0;
      column.childNodes.forEach(subColumn => {
        traverse(subColumn, column);
        colSpan += subColumn._colSpan;
      });
      column._colSpan = colSpan;
    } else {
      column._colSpan = 1;
    }
  };
  originColumns.forEach(column => {
    column._level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getConvertColumns(originColumns);
  allColumns.forEach(column => {
    if (column.childNodes && column.childNodes.length) {
      column._rowSpan = 1;
    } else {
      column._rowSpan = maxLevel - column._level + 1;
    }
    rows[column._level - 1].push(column);
  });
  return rows;
};
function toTableBorder(border) {
  if (border === true) {
    return 'full';
  }
  if (border) {
    return border;
  }
  return 'default';
}
function getBooleanValue(cellValue) {
  return cellValue === 'TRUE' || cellValue === 'true' || cellValue === true;
}
function getFooterData($xeTable, opts, footerTableData) {
  const $xeGrid = $xeTable.xeGrid;
  const $xeGantt = $xeTable.xeGantt;
  const {
    footerFilterMethod
  } = opts;
  return footerFilterMethod ? footerTableData.filter((items, index) => footerFilterMethod({
    $table: $xeTable,
    $grid: $xeGrid,
    $gantt: $xeGantt,
    items,
    $rowIndex: index
  })) : footerTableData;
}
function getCsvCellTypeLabel(column, cellValue) {
  if (cellValue) {
    if (column.type === 'seq') {
      return `\t${cellValue}`;
    }
    switch (column.cellType) {
      case 'string':
        if (!isNaN(cellValue)) {
          return `\t${cellValue}`;
        }
        break;
      case 'number':
        break;
      default:
        if (cellValue.length >= 12 && !isNaN(cellValue)) {
          return `\t${cellValue}`;
        }
        break;
    }
  }
  return cellValue;
}
function toTxtCellLabel(val) {
  if (/[",\s\n]/.test(val)) {
    return `"${val.replace(/"/g, '""')}"`;
  }
  return val;
}
function getElementsByTagName(elem, qualifiedName) {
  return elem.getElementsByTagName(qualifiedName);
}
function getTxtCellKey(now) {
  return `#${now}@${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId()}`;
}
function replaceTxtCell(cell, vMaps) {
  return cell.replace(/#\d+@\d+/g, key => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().hasOwnProp(vMaps, key) ? vMaps[key] : key);
}
function getTxtCellValue(val, vMaps) {
  const rest = replaceTxtCell(val, vMaps);
  return rest.replace(/^"+$/g, qVal => '"'.repeat(Math.ceil(qVal.length / 2)));
}
function toExportField(tableConf, field) {
  const {
    fieldMaps,
    titleMaps
  } = tableConf;
  // title  field
  if (!fieldMaps[field]) {
    const teCol = titleMaps[field];
    if (teCol && teCol.field) {
      field = teCol.field;
    }
  }
  return field;
}
function parseCsvAndTxt(tableConf, content, cellSeparator) {
  const list = content.split(enterSymbol);
  const rows = [];
  let fields = [];
  if (list.length) {
    const vMaps = {};
    const now = Date.now();
    list.forEach(rVal => {
      if (rVal) {
        const item = {};
        rVal = rVal.replace(/("")|(\n)/g, (text, dVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = dVal ? '"' : '\n';
          return key;
        }).replace(/"(.*?)"/g, (text, cVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = replaceTxtCell(cVal, vMaps);
          return key;
        });
        const cells = rVal.split(cellSeparator);
        if (!fields.length) {
          fields = cells.map(val => toExportField(tableConf, getTxtCellValue(val.trim(), vMaps)));
        } else {
          cells.forEach((val, colIndex) => {
            if (colIndex < fields.length) {
              item[fields[colIndex]] = getTxtCellValue(val.trim(), vMaps);
            }
          });
          rows.push(item);
        }
      }
    });
  }
  return {
    fields,
    rows
  };
}
function parseCsv(tableConf, content) {
  return parseCsvAndTxt(tableConf, content, ',');
}
function parseTxt(tableConf, content) {
  return parseCsvAndTxt(tableConf, content, '\t');
}
function parseHTML(tableConf, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, 'text/html');
  const bodyNodes = getElementsByTagName(xmlDoc, 'body');
  const rows = [];
  const fields = [];
  if (bodyNodes.length) {
    const tableNodes = getElementsByTagName(bodyNodes[0], 'table');
    if (tableNodes.length) {
      const theadNodes = getElementsByTagName(tableNodes[0], 'thead');
      if (theadNodes.length) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(theadNodes[0], 'tr'), rowNode => {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(rowNode, 'th'), cellNode => {
            fields.push(toExportField(tableConf, cellNode.textContent || ''));
          });
        });
        const tbodyNodes = getElementsByTagName(tableNodes[0], 'tbody');
        if (tbodyNodes.length) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(tbodyNodes[0], 'tr'), rowNode => {
            const item = {};
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(rowNode, 'td'), (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent || '';
              }
            });
            rows.push(item);
          });
        }
      }
    }
  }
  return {
    fields,
    rows
  };
}
function parseXML(tableConf, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, 'application/xml');
  const sheetNodes = getElementsByTagName(xmlDoc, 'Worksheet');
  const rows = [];
  const fields = [];
  if (sheetNodes.length) {
    const tableNodes = getElementsByTagName(sheetNodes[0], 'Table');
    if (tableNodes.length) {
      const rowNodes = getElementsByTagName(tableNodes[0], 'Row');
      if (rowNodes.length) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(rowNodes[0], 'Cell'), cellNode => {
          fields.push(toExportField(tableConf, cellNode.textContent || ''));
        });
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(rowNodes, (rowNode, index) => {
          if (index) {
            const item = {};
            const cellNodes = getElementsByTagName(rowNode, 'Cell');
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(cellNodes, (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent;
              }
            });
            rows.push(item);
          }
        });
      }
    }
  }
  return {
    fields,
    rows
  };
}
function clearColumnConvert(columns) {
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(columns, column => {
    delete column._level;
    delete column._colSpan;
    delete column._rowSpan;
    delete column._children;
    delete column.childNodes;
  }, {
    children: 'children'
  });
}
const tableExportMethodKeys = ['exportData', 'importByFile', 'importData', 'saveFile', 'readFile', 'print', 'getPrintHtml', 'openImport', 'closeImport', 'openExport', 'closeExport', 'openPrint', 'closePrint'];
export_hook_hooks.add('tableExportModule', {
  setupTable($xeTable) {
    const {
      props,
      reactData,
      internalData
    } = $xeTable;
    const {
      computeTreeOpts,
      computePrintOpts,
      computeExportOpts,
      computeImportOpts,
      computeCustomOpts,
      computeSeqOpts,
      computeRadioOpts,
      computeCheckboxOpts,
      computeColumnOpts
    } = $xeTable.getComputeMaps();
    const hasTreeChildren = row => {
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      return row[childrenField] && row[childrenField].length;
    };
    const getSeq = (cellValue, row, $rowIndex, column, $columnIndex) => {
      const seqOpts = computeSeqOpts.value;
      const seqMd = seqOpts.seqMethod || column.seqMethod;
      if (seqMd) {
        return seqMd({
          $table: $xeTable,
          row,
          rowIndex: $xeTable.getRowIndex(row),
          _rowIndex: $xeTable.getVTRowIndex(row),
          $rowIndex,
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          _columnIndex: $xeTable.getVTColumnIndex(column),
          $columnIndex
        });
      }
      return cellValue;
    };
    function getHeaderTitle(opts, column) {
      const columnOpts = computeColumnOpts.value;
      const headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;
      return headExportMethod ? headExportMethod({
        column,
        options: opts,
        $table: $xeTable
      }) : (opts.isTitle ? column.getTitle() : column.field) || '';
    }
    const toBooleanValue = cellValue => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(cellValue) ? cellValue ? 'TRUE' : 'FALSE' : cellValue;
    };
    const toStringValue = cellValue => {
      return eqEmptyValue(cellValue) ? '' : `${cellValue}`;
    };
    const getBodyLabelData = (opts, columns, datas) => {
      const {
        isAllExpand,
        mode
      } = opts;
      const {
        treeConfig
      } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const columnOpts = computeColumnOpts.value;
      if (!htmlCellElem) {
        htmlCellElem = document.createElement('div');
      }
      if (treeConfig) {
        const childrenField = treeOpts.children || treeOpts.childrenField;
        // 
        const rest = [];
        const expandMaps = {};
        const useMaps = {};
        const {
          handleGetRowId
        } = createHandleGetRowId($xeTable);
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(datas, (item, $rowIndex, items, path, parent, nodes) => {
          const row = item._row || item;
          const rowid = handleGetRowId(row);
          if (useMaps[rowid]) {
            return;
          }
          const parentRow = parent && parent._row ? parent._row : parent;
          const pRowid = parentRow ? handleGetRowId(parentRow) : '';
          if (isAllExpand || !parentRow || expandMaps[pRowid] && $xeTable.isTreeExpandByRow(parentRow)) {
            const hasRowChild = hasTreeChildren(row);
            const item = {
              _row: row,
              _level: nodes.length - 1,
              _hasChild: hasRowChild,
              _expand: hasRowChild && $xeTable.isTreeExpandByRow(row)
            };
            columns.forEach((column, $columnIndex) => {
              let cellValue = '';
              const renderOpts = column.editRender || column.cellRender;
              let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
              if (!bodyExportMethod && renderOpts && renderOpts.name) {
                const compConf = export_hook_renderer.get(renderOpts.name);
                if (compConf) {
                  bodyExportMethod = compConf.tableExportMethod || compConf.exportMethod;
                }
              }
              if (!bodyExportMethod) {
                bodyExportMethod = columnOpts.exportMethod;
              }
              if (bodyExportMethod) {
                cellValue = bodyExportMethod({
                  $table: $xeTable,
                  row,
                  column,
                  options: opts
                });
              } else {
                switch (column.type) {
                  case 'seq':
                    {
                      const seqVal = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : '.').join('');
                      cellValue = mode === 'all' ? seqVal : getSeq(seqVal, row, $rowIndex, column, $columnIndex);
                      break;
                    }
                  case 'checkbox':
                    cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
                    item._checkboxLabel = checkboxOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkboxOpts.labelField) : '';
                    item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({
                      $table: $xeTable,
                      row
                    });
                    break;
                  case 'radio':
                    cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
                    item._radioLabel = radioOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, radioOpts.labelField) : '';
                    item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({
                      $table: $xeTable,
                      row
                    });
                    break;
                  default:
                    if (opts.original) {
                      cellValue = getCellValue(row, column);
                    } else {
                      cellValue = $xeTable.getCellLabel(row, column);
                      if (column.type === 'html') {
                        htmlCellElem.innerHTML = cellValue;
                        cellValue = htmlCellElem.innerText.trim();
                      } else {
                        const cell = $xeTable.getCellElement(row, column);
                        if (cell && !hasClass(cell, 'is--progress')) {
                          cellValue = cell.innerText.trim();
                        }
                      }
                    }
                }
              }
              item[column.id] = toStringValue(cellValue);
            });
            useMaps[rowid] = true;
            if (pRowid) {
              expandMaps[pRowid] = true;
            }
            rest.push(Object.assign(item, row));
          }
        }, {
          children: childrenField
        });
        return rest;
      }
      return datas.map((row, $rowIndex) => {
        const item = {
          _row: row
        };
        columns.forEach((column, $columnIndex) => {
          let cellValue = '';
          const renderOpts = column.editRender || column.cellRender;
          let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
          if (!bodyExportMethod && renderOpts && renderOpts.name) {
            const compConf = export_hook_renderer.get(renderOpts.name);
            if (compConf) {
              bodyExportMethod = compConf.tableExportMethod || compConf.exportMethod;
            }
          }
          if (bodyExportMethod) {
            cellValue = bodyExportMethod({
              $table: $xeTable,
              row,
              column,
              options: opts
            });
          } else {
            switch (column.type) {
              case 'seq':
                {
                  const seqValue = $rowIndex + 1;
                  cellValue = mode === 'all' ? seqValue : getSeq(seqValue, row, $rowIndex, column, $columnIndex);
                  break;
                }
              case 'checkbox':
                cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
                item._checkboxLabel = checkboxOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkboxOpts.labelField) : '';
                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({
                  $table: $xeTable,
                  row
                });
                break;
              case 'radio':
                cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
                item._radioLabel = radioOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, radioOpts.labelField) : '';
                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({
                  $table: $xeTable,
                  row
                });
                break;
              default:
                if (opts.original) {
                  cellValue = getCellValue(row, column);
                } else {
                  cellValue = $xeTable.getCellLabel(row, column);
                  if (column.type === 'html') {
                    htmlCellElem.innerHTML = cellValue;
                    cellValue = htmlCellElem.innerText.trim();
                  } else {
                    const cell = $xeTable.getCellElement(row, column);
                    if (cell && !hasClass(cell, 'is--progress')) {
                      cellValue = cell.innerText.trim();
                    }
                  }
                }
            }
          }
          item[column.id] = toStringValue(cellValue);
        });
        return item;
      });
    };
    const getExportData = opts => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const {
        columns,
        dataFilterMethod
      } = opts;
      let datas = opts.data;
      if (dataFilterMethod) {
        datas = datas.filter((row, index) => dataFilterMethod({
          $table: $xeTable,
          $grid: $xeGrid,
          $gantt: $xeGantt,
          row,
          $rowIndex: index
        }));
      }
      return getBodyLabelData(opts, columns, datas);
    };
    const getFooterCellValue = (opts, row, column) => {
      const columnOpts = computeColumnOpts.value;
      const renderOpts = column.editRender || column.cellRender;
      let footLabelMethod = column.footerExportMethod;
      if (!footLabelMethod && renderOpts && renderOpts.name) {
        const compConf = export_hook_renderer.get(renderOpts.name);
        if (compConf) {
          footLabelMethod = compConf.tableFooterExportMethod || compConf.footerExportMethod;
        }
      }
      if (!footLabelMethod) {
        footLabelMethod = columnOpts.footerExportMethod;
      }
      if (footLabelMethod) {
        const _columnIndex = $xeTable.getVTColumnIndex(column);
        return footLabelMethod({
          $table: $xeTable,
          items: row,
          itemIndex: _columnIndex,
          row,
          _columnIndex,
          column,
          options: opts
        });
      }
      const cellValue = $xeTable.getFooterCellLabel(row, column);
      return cellValue;
    };
    const toCsv = ($xeTable, opts, columns, datas) => {
      let content = csvBOM;
      if (opts.isHeader) {
        content += columns.map(column => toTxtCellLabel(getHeaderTitle(opts, column))).join(',') + enterSymbol;
      }
      datas.forEach(row => {
        content += columns.map(column => toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id]))).join(',') + enterSymbol;
      });
      if (opts.isFooter) {
        const {
          footerTableData
        } = reactData;
        const footers = getFooterData($xeTable, opts, footerTableData);
        footers.forEach(row => {
          content += columns.map(column => toTxtCellLabel(getFooterCellValue(opts, row, column))).join(',') + enterSymbol;
        });
      }
      return content;
    };
    const toTxt = ($xeTable, opts, columns, datas) => {
      let content = '';
      if (opts.isHeader) {
        content += columns.map(column => toTxtCellLabel(getHeaderTitle(opts, column))).join('\t') + enterSymbol;
      }
      datas.forEach(row => {
        content += columns.map(column => toTxtCellLabel(row[column.id])).join('\t') + enterSymbol;
      });
      if (opts.isFooter) {
        const {
          footerTableData
        } = reactData;
        const footers = getFooterData($xeTable, opts, footerTableData);
        footers.forEach(row => {
          content += columns.map(column => toTxtCellLabel(getFooterCellValue(opts, row, column))).join('\t') + enterSymbol;
        });
      }
      return content;
    };
    const hasEllipsis = (column, property, allColumnOverflow) => {
      const columnOverflow = column[property];
      const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(columnOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(columnOverflow) ? allColumnOverflow : columnOverflow;
      const showEllipsis = headOverflow === 'ellipsis';
      const showTitle = headOverflow === 'title';
      const showTooltip = headOverflow === true || headOverflow === 'tooltip';
      let isEllipsis = showTitle || showTooltip || showEllipsis;
      // 
      const {
        scrollXLoad,
        scrollYLoad
      } = reactData;
      if ((scrollXLoad || scrollYLoad) && !isEllipsis) {
        isEllipsis = true;
      }
      return isEllipsis;
    };
    const toHtml = (opts, columns, datas) => {
      const {
        id,
        border,
        treeConfig,
        headerAlign: allHeaderAlign,
        align: allAlign,
        footerAlign: allFooterAlign,
        showOverflow: allColumnOverflow,
        showHeaderOverflow: allColumnHeaderOverflow
      } = props;
      const {
        isAllSelected,
        isIndeterminate
      } = reactData;
      const {
        mergeBodyCellMaps
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const {
        print: isPrint,
        isHeader,
        isFooter,
        isColgroup,
        isMerge,
        colgroups,
        original
      } = opts;
      const allCls = 'check-all';
      const clss = ['vxe-table', `border--${toTableBorder(border)}`, isPrint ? 'is--print' : '', isHeader ? 'is--header' : ''].filter(cls => cls);
      const tables = [`<table class="${clss.join(' ')}" border="0" cellspacing="0" cellpadding="0">`, `<colgroup>${columns.map(column => `<col style="width:${column.renderWidth}px">`).join('')}</colgroup>`];
      if (isHeader) {
        tables.push('<thead>');
        if (isColgroup && !original) {
          colgroups.forEach(cols => {
            tables.push(`<tr>${cols.map(column => {
              const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
              const classNames = hasEllipsis(column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];
              const cellTitle = getHeaderTitle(opts, column);
              let childWidth = 0;
              let countChild = 0;
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
                if (!item.childNodes || !column.childNodes.length) {
                  countChild++;
                }
                childWidth += item.renderWidth;
              }, {
                children: 'childNodes'
              });
              const cellWidth = childWidth - countChild;
              if (headAlign) {
                classNames.push(`col--${headAlign}`);
              }
              if (column.type === 'checkbox') {
                return `<th class="${classNames.join(' ')}" colspan="${column._colSpan}" rowspan="${column._rowSpan}"><div ${isPrint ? '' : `style="width: ${cellWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? 'checked' : ''}><span>${cellTitle}</span></div></th>`;
              }
              return `<th class="${classNames.join(' ')}" colspan="${column._colSpan}" rowspan="${column._rowSpan}" title="${cellTitle}"><div ${isPrint ? '' : `style="width: ${cellWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
            }).join('')}</tr>`);
          });
        } else {
          tables.push(`<tr>${columns.map(column => {
            const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
            const classNames = hasEllipsis(column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];
            const cellTitle = getHeaderTitle(opts, column);
            if (headAlign) {
              classNames.push(`col--${headAlign}`);
            }
            if (column.type === 'checkbox') {
              return `<th class="${classNames.join(' ')}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? 'checked' : ''}><span>${cellTitle}</span></div></th>`;
            }
            return `<th class="${classNames.join(' ')}" title="${cellTitle}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
          }).join('')}</tr>`);
        }
        tables.push('</thead>');
      }
      if (datas.length) {
        tables.push('<tbody>');
        if (treeConfig) {
          datas.forEach(item => {
            tables.push('<tr>' + columns.map(column => {
              const colid = column.id;
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];
              const cellValue = item[colid];
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.treeNode) {
                let treeIcon = '';
                if (item._hasChild) {
                  treeIcon = `<i class="${item._expand ? 'vxe-table--tree-fold-icon' : 'vxe-table--tree-unfold-icon'}"></i>`;
                }
                classNames.push('vxe-table--tree-node');
                if (column.type === 'radio') {
                  return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="radio" name="radio_${id}" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></div></div></td>`;
                } else if (column.type === 'checkbox') {
                  return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="checkbox" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></div></div></td>`;
                }
                return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell">${cellValue}</div></div></div></td>`;
              }
              if (column.type === 'radio') {
                return `<td class="${classNames.join(' ')}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === 'checkbox') {
                return `<td class="${classNames.join(' ')}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join('') + '</tr>');
          });
        } else {
          datas.forEach(item => {
            tables.push('<tr>' + columns.map(column => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];
              const cellValue = item[column.id];
              let rowSpan = 1;
              let colSpan = 1;
              if (isMerge) {
                const _rowIndex = $xeTable.getVTRowIndex(item._row);
                const _columnIndex = $xeTable.getVTColumnIndex(column);
                const spanRest = mergeBodyCellMaps[`${_rowIndex}:${_columnIndex}`];
                if (spanRest) {
                  const {
                    rowspan,
                    colspan
                  } = spanRest;
                  if (!rowspan || !colspan) {
                    return '';
                  }
                  if (rowspan > 1) {
                    rowSpan = rowspan;
                  }
                  if (colspan > 1) {
                    colSpan = colspan;
                  }
                }
              }
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.type === 'radio') {
                return `<td class="${classNames.join(' ')}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === 'checkbox') {
                return `<td class="${classNames.join(' ')}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(' ')}" rowspan="${rowSpan}" colspan="${colSpan}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join('') + '</tr>');
          });
        }
        tables.push('</tbody>');
      }
      if (isFooter) {
        const {
          footerTableData
        } = reactData;
        const footers = getFooterData($xeTable, opts, footerTableData);
        if (footers.length) {
          tables.push('<tfoot>');
          footers.forEach(row => {
            tables.push(`<tr>${columns.map(column => {
              const footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;
              const classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];
              const cellValue = getFooterCellValue(opts, row, column);
              if (footAlign) {
                classNames.push(`col--${footAlign}`);
              }
              return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join('')}</tr>`);
          });
          tables.push('</tfoot>');
        }
      }
      // 
      const script = !isAllSelected && isIndeterminate ? `<script>(function(){var a=document.querySelector(".${allCls}");if(a){a.indeterminate=true}})()</script>` : '';
      tables.push('</table>', script);
      return isPrint ? tables.join('') : createHtmlPage(opts, tables.join(''));
    };
    const toXML = (opts, columns, datas) => {
      let xml = ['<?xml version="1.0"?>', '<?mso-application progid="Excel.Sheet"?>', '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">', '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">', '<Version>16.00</Version>', '</DocumentProperties>', '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">', '<WindowHeight>7920</WindowHeight>', '<WindowWidth>21570</WindowWidth>', '<WindowTopX>32767</WindowTopX>', '<WindowTopY>32767</WindowTopY>', '<ProtectStructure>False</ProtectStructure>', '<ProtectWindows>False</ProtectWindows>', '</ExcelWorkbook>', `<Worksheet ss:Name="${opts.sheetName}">`, '<Table>', columns.map(column => `<Column ss:Width="${column.renderWidth}"/>`).join('')].join('');
      if (opts.isHeader) {
        xml += `<Row>${columns.map(column => `<Cell><Data ss:Type="String">${getHeaderTitle(opts, column)}</Data></Cell>`).join('')}</Row>`;
      }
      datas.forEach(row => {
        xml += '<Row>' + columns.map(column => `<Cell><Data ss:Type="String">${row[column.id]}</Data></Cell>`).join('') + '</Row>';
      });
      if (opts.isFooter) {
        const {
          footerTableData
        } = reactData;
        const footers = getFooterData($xeTable, opts, footerTableData);
        footers.forEach(row => {
          xml += `<Row>${columns.map(column => `<Cell><Data ss:Type="String">${getFooterCellValue(opts, row, column)}</Data></Cell>`).join('')}</Row>`;
        });
      }
      return `${xml}</Table></Worksheet></Workbook>`;
    };
    const getContent = ($xeTable, opts, columns, datas) => {
      if (columns.length) {
        switch (opts.type) {
          case 'csv':
            return toCsv($xeTable, opts, columns, datas);
          case 'txt':
            return toTxt($xeTable, opts, columns, datas);
          case 'html':
            return toHtml(opts, columns, datas);
          case 'xml':
            return toXML(opts, columns, datas);
        }
      }
      return '';
    };
    const downloadFile = (opts, content) => {
      const {
        filename,
        type,
        download
      } = opts;
      if (!download) {
        const blob = getExportBlobByContent(content, opts);
        return Promise.resolve({
          type,
          content,
          blob
        });
      }
      if (core_.VxeUI.saveFile) {
        core_.VxeUI.saveFile({
          filename,
          type,
          content
        }).then(() => {
          if (opts.message !== false) {
            if (core_.VxeUI.modal) {
              core_.VxeUI.modal.message({
                content: export_hook_getI18n('vxe.table.expSuccess'),
                status: 'success'
              });
            }
          }
        });
      }
    };
    const handleExport = opts => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const {
        remote,
        columns,
        colgroups,
        exportMethod,
        afterExportMethod
      } = opts;
      return new Promise(resolve => {
        if (remote) {
          const params = {
            options: opts,
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt
          };
          resolve(exportMethod ? exportMethod(params) : params);
        } else {
          const datas = getExportData(opts);
          resolve($xeTable.preventEvent(null, 'event.export', {
            options: opts,
            columns,
            colgroups,
            datas
          }, () => {
            return downloadFile(opts, getContent($xeTable, opts, columns, datas));
          }));
        }
      }).then(params => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({
              status: true,
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt
            });
          }
        }
        return Object.assign({
          status: true
        }, params);
      }).catch(() => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({
              status: false,
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt
            });
          }
        }
        const params = {
          status: false
        };
        return Promise.reject(params);
      });
    };
    const handleImport = (content, opts) => {
      const {
        tableFullColumn,
        _importResolve,
        _importReject
      } = internalData;
      let rest = {
        fields: [],
        rows: []
      };
      const tableFieldMaps = {};
      const tableTitleMaps = {};
      tableFullColumn.forEach(column => {
        const field = column.field;
        const title = column.getTitle();
        if (field) {
          tableFieldMaps[field] = column;
        }
        if (title) {
          tableTitleMaps[column.getTitle()] = column;
        }
      });
      const tableConf = {
        fieldMaps: tableFieldMaps,
        titleMaps: tableTitleMaps
      };
      switch (opts.type) {
        case 'csv':
          rest = parseCsv(tableConf, content);
          break;
        case 'txt':
          rest = parseTxt(tableConf, content);
          break;
        case 'html':
          rest = parseHTML(tableConf, content);
          break;
        case 'xml':
          rest = parseXML(tableConf, content);
          break;
      }
      const {
        fields,
        rows
      } = rest;
      const status = fields.some(field => tableFieldMaps[field] || tableTitleMaps[field]);
      if (status) {
        $xeTable.createData(rows).then(data => {
          let loadRest;
          if (opts.mode === 'insert' || opts.mode === 'insertBottom') {
            loadRest = $xeTable.insertAt(data, -1);
          } else if (opts.mode === 'insertTop') {
            loadRest = $xeTable.insert(data);
          } else {
            loadRest = $xeTable.reloadData(data);
          }
          if (opts.message !== false) {
            if (core_.VxeUI.modal) {
              core_.VxeUI.modal.message({
                content: export_hook_getI18n('vxe.table.impSuccess', [rows.length]),
                status: 'success'
              });
            }
          }
          return loadRest.then(() => {
            if (_importResolve) {
              _importResolve({
                status: true
              });
            }
          });
        });
      } else if (opts.message !== false) {
        if (core_.VxeUI.modal) {
          core_.VxeUI.modal.message({
            content: export_hook_getI18n('vxe.error.impFields'),
            status: 'error'
          });
        }
        if (_importReject) {
          _importReject({
            status: false
          });
        }
      }
    };
    const handleFileImport = (file, opts) => {
      const {
        importMethod,
        afterImportMethod
      } = opts;
      const {
        type,
        filename
      } = parseFile(file);
      const importOpts = computeImportOpts.value;
      // 
      if (!importMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps), type)) {
        if (opts.message !== false) {
          if (core_.VxeUI.modal) {
            core_.VxeUI.modal.message({
              content: export_hook_getI18n('vxe.error.notType', [type]),
              status: 'error'
            });
          }
        }
        const params = {
          status: false
        };
        return Promise.reject(params);
      }
      const rest = new Promise((resolve, reject) => {
        const _importResolve = params => {
          resolve(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        const _importReject = params => {
          reject(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        internalData._importResolve = _importResolve;
        internalData._importReject = _importReject;
        if (window.FileReader) {
          const options = Object.assign({
            mode: 'insertTop'
          }, opts, {
            type,
            filename
          });
          if (options.remote) {
            if (importMethod) {
              Promise.resolve(importMethod({
                file,
                options,
                $table: $xeTable
              })).then(() => {
                _importResolve({
                  status: true
                });
              }).catch(() => {
                _importResolve({
                  status: true
                });
              });
            } else {
              _importResolve({
                status: true
              });
            }
          } else {
            const {
              tableFullColumn
            } = internalData;
            $xeTable.preventEvent(null, 'event.import', {
              file,
              options,
              columns: tableFullColumn
            }, () => {
              const reader = new FileReader();
              reader.onerror = () => {
                errLog('vxe.error.notType', [type]);
                _importReject({
                  status: false
                });
              };
              reader.onload = e => {
                handleImport(e.target.result, options);
              };
              reader.readAsText(file, options.encoding || 'UTF-8');
            });
          }
        } else {
          // 
          errLog('vxe.error.notExp');
          _importResolve({
            status: true
          });
        }
      });
      return rest.then(() => {
        if (afterImportMethod) {
          afterImportMethod({
            status: true,
            options: opts,
            $table: $xeTable
          });
        }
      }).catch(e => {
        if (afterImportMethod) {
          afterImportMethod({
            status: false,
            options: opts,
            $table: $xeTable
          });
        }
        return Promise.reject(e);
      });
    };
    const handleFilterColumns = (exportOpts, column, columns) => {
      return columns.some(item => {
        if (isColumnInfo(item)) {
          return column.id === item.id;
        } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
          return column.field === item;
        } else {
          const colid = item.id || item.colId;
          const type = item.type;
          const field = item.field;
          if (colid) {
            return column.id === colid;
          } else if (field && type) {
            return column.field === field && column.type === type;
          } else if (field) {
            return column.field === field;
          } else if (type) {
            return column.type === type;
          }
        }
        return false;
      });
    };
    const handleFilterFields = (exportOpts, column, includeFields, excludeFields) => {
      if (excludeFields) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(excludeFields, column.field)) {
          return false;
        }
      }
      if (includeFields) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(includeFields, column.field)) {
          return true;
        }
        return false;
      }
      return exportOpts.original ? !!column.field : defaultFilterExportColumn(column);
    };
    const handleExportAndPrint = (options, isPrint) => {
      const $xeGrid = $xeTable.xeGrid;
      const $xeGantt = $xeTable.xeGantt;
      const $xeGGWrapper = $xeGrid || $xeGantt;
      const {
        treeConfig,
        showHeader,
        showFooter
      } = props;
      const {
        initStore,
        isGroup,
        footerTableData,
        exportStore,
        exportParams
      } = reactData;
      const {
        collectColumn,
        mergeBodyList,
        mergeFooterList
      } = internalData;
      const exportOpts = computeExportOpts.value;
      const hasTree = treeConfig;
      const customOpts = computeCustomOpts.value;
      const selectRecords = $xeTable.getCheckboxRecords();
      const proxyOpts = $xeGGWrapper ? $xeGGWrapper.getComputeMaps().computeProxyOpts.value : {};
      const hasFooter = !!footerTableData.length;
      const hasMerge = !!(mergeBodyList.length || mergeFooterList.length);
      const defOpts = Object.assign({
        message: true,
        isHeader: showHeader,
        isTitle: showHeader,
        isFooter: showFooter,
        isColgroup: isGroup,
        isMerge: hasMerge,
        useStyle: true,
        current: 'current',
        modes: (proxyOpts.ajax && proxyOpts.ajax.queryAll ? ['all'] : []).concat(['current', 'selected', 'empty'])
      }, options);
      const types = defOpts.types || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps);
      const modes = defOpts.modes || [];
      const checkMethod = customOpts.checkMethod;
      const exportColumns = collectColumn.slice(0);
      const {
        columns,
        excludeFields,
        includeFields
      } = defOpts;
      // 
      const typeList = types.map(value => {
        return {
          value,
          label: export_hook_getI18n(`vxe.export.types.${value}`)
        };
      });
      const modeList = modes.map(item => {
        if (item && item.value) {
          return {
            value: item.value,
            label: item.label || item.value
          };
        }
        return {
          value: item,
          label: export_hook_getI18n(`vxe.export.modes.${item}`)
        };
      });
      // 
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(exportColumns, (column, index, items, path, parent) => {
        const isColGroup = column.children && column.children.length > 0;
        let isChecked = false;
        if (columns && columns.length) {
          isChecked = handleFilterColumns(defOpts, column, columns);
        } else if (excludeFields || includeFields) {
          isChecked = handleFilterFields(defOpts, column, includeFields, excludeFields);
        } else {
          isChecked = column.visible && (isColGroup || defaultFilterExportColumn(column));
        }
        column.checked = isChecked;
        column.halfChecked = false;
        column.disabled = parent && parent.disabled || (checkMethod ? !checkMethod({
          $table: $xeTable,
          column
        }) : false);
      });
      // 
      Object.assign(exportStore, {
        columns: exportColumns,
        typeList,
        modeList,
        hasFooter,
        hasMerge,
        hasTree,
        isPrint,
        hasColgroup: isGroup,
        visible: true
      });
      // 
      Object.assign(exportParams, {
        mode: selectRecords.length ? 'selected' : 'current'
      }, defOpts);
      const {
        filename,
        sheetName,
        mode,
        type
      } = exportParams;
      if (filename) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(filename)) {
          exportParams.filename = filename({
            options: defOpts,
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt
          });
        } else {
          exportParams.filename = `${filename}`;
        }
      }
      if (sheetName) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(sheetName)) {
          exportParams.sheetName = sheetName({
            options: defOpts,
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt
          });
        } else {
          exportParams.sheetName = `${sheetName}`;
        }
      }
      if (!modeList.some(item => item.value === mode)) {
        exportParams.mode = modeList[0].value;
      }
      if (!typeList.some(item => item.value === type)) {
        exportParams.type = typeList[0].value;
      }
      initStore.export = true;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleCloseExport = () => {
      if (core_.VxeUI.modal) {
        return core_.VxeUI.modal.close('VXE_EXPORT_MODAL');
      }
      return Promise.resolve();
    };
    const exportMethods = {
      /**
       *  csv/html/xml/txt
       * 
       *  dataFilterMethod 
       * @param {Object} options 
       */
      exportData(options) {
        const $xeGrid = $xeTable.xeGrid;
        const $xeGantt = $xeTable.xeGantt;
        const $xeGGWrapper = $xeGrid || $xeGantt;
        const {
          treeConfig,
          showHeader,
          showFooter
        } = props;
        const {
          isGroup
        } = reactData;
        const {
          tableFullColumn,
          afterFullData,
          afterTreeFullData,
          collectColumn,
          mergeBodyList,
          mergeFooterList
        } = internalData;
        const exportOpts = computeExportOpts.value;
        const treeOpts = computeTreeOpts.value;
        const proxyOpts = $xeGGWrapper ? $xeGGWrapper.getComputeMaps().computeProxyOpts.value : {};
        const hasMerge = !!(mergeBodyList.length || mergeFooterList.length);
        const opts = Object.assign({
          message: true,
          isHeader: showHeader,
          isTitle: showHeader,
          isFooter: showFooter,
          isColgroup: isGroup,
          isMerge: hasMerge,
          useStyle: true,
          current: 'current',
          modes: (proxyOpts.ajax && proxyOpts.ajax.queryAll ? ['all'] : []).concat(['current', 'selected', 'empty']),
          download: true,
          type: 'csv'
          // filename: '',
          // sheetName: '',
          // original: false,
          // isAllExpand: false,
          // data: null,
          // remote: false,
          // dataFilterMethod: null,
          // footerFilterMethod: null,
          // exportMethod: null,
          // columnFilterMethod: null,
          // beforeExportMethod: null,
          // afterExportMethod: null
        }, exportOpts, options);
        let {
          filename,
          sheetName,
          type,
          mode,
          columns,
          original,
          columnFilterMethod,
          beforeExportMethod,
          includeFields,
          excludeFields
        } = opts;
        let groups = [];
        const selectRecords = $xeTable.getCheckboxRecords();
        if (!mode) {
          mode = selectRecords.length ? 'selected' : 'current';
        }
        let isCustomCol = false;
        let customCols = [];
        if (columns && columns.length) {
          isCustomCol = true;
          customCols = columns;
        } else {
          customCols = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(collectColumn, column => {
            const isColGroup = column.children && column.children.length > 0;
            let isChecked = false;
            if (columns && columns.length) {
              isChecked = handleFilterColumns(opts, column, columns);
            } else if (excludeFields || includeFields) {
              isChecked = handleFilterFields(opts, column, includeFields, excludeFields);
            } else {
              isChecked = column.visible && (isColGroup || defaultFilterExportColumn(column));
            }
            return isChecked;
          }, {
            children: 'children',
            mapChildren: 'childNodes',
            original: true
          });
        }
        const handleOptions = Object.assign({}, opts, {
          filename: '',
          sheetName: ''
        });
        // 
        if (!isCustomCol && !columnFilterMethod) {
          columnFilterMethod = ({
            column
          }) => {
            if (excludeFields) {
              if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(excludeFields, column.field)) {
                return false;
              }
            }
            if (includeFields) {
              if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(includeFields, column.field)) {
                return true;
              }
              return false;
            }
            return original ? !!column.field : defaultFilterExportColumn(column);
          };
          handleOptions.columnFilterMethod = columnFilterMethod;
        }
        if (customCols) {
          handleOptions._isCustomColumn = true;
          groups = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(customCols, item => {
            let targetColumn;
            if (item) {
              if (isColumnInfo(item)) {
                targetColumn = item;
              } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
                targetColumn = $xeTable.getColumnByField(item);
              } else {
                const colid = item.id || item.colId;
                const type = item.type;
                const field = item.field;
                if (colid) {
                  targetColumn = $xeTable.getColumnById(colid);
                } else if (field && type) {
                  targetColumn = tableFullColumn.find(column => column.field === field && column.type === type);
                } else if (field) {
                  targetColumn = $xeTable.getColumnByField(field);
                } else if (type) {
                  targetColumn = tableFullColumn.find(column => column.type === type);
                }
              }
              return targetColumn || {};
            }
          }, {
            children: 'childNodes',
            mapChildren: '_children'
          }), (column, index) => isColumnInfo(column) && (!columnFilterMethod || columnFilterMethod({
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt,
            column: column,
            $columnIndex: index
          })), {
            children: '_children',
            mapChildren: 'childNodes',
            original: true
          });
        } else {
          groups = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(isGroup ? collectColumn : tableFullColumn, (column, index) => column.visible && (!columnFilterMethod || columnFilterMethod({
            $table: $xeTable,
            $grid: $xeGrid,
            $gantt: $xeGantt,
            column,
            $columnIndex: index
          })), {
            children: 'children',
            mapChildren: 'childNodes',
            original: true
          });
        }
        // 
        const cols = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(groups, column => {
          const isColGroup = column.children && column.children.length;
          if (!isColGroup) {
            cols.push(column);
          }
        }, {
          children: 'childNodes'
        });
        // 
        handleOptions.columns = cols;
        handleOptions.colgroups = convertToRows(groups);
        if (filename) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(filename)) {
            handleOptions.filename = filename({
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt
            });
          } else {
            handleOptions.filename = `${filename}`;
          }
        }
        if (!handleOptions.filename) {
          handleOptions.filename = export_hook_getI18n(handleOptions.original ? 'vxe.table.expOriginFilename' : 'vxe.table.expFilename', [external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(Date.now(), 'yyyyMMddHHmmss')]);
        }
        if (sheetName) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(sheetName)) {
            handleOptions.sheetName = sheetName({
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt
            });
          } else {
            handleOptions.sheetName = `${sheetName}`;
          }
        }
        if (!handleOptions.sheetName) {
          handleOptions.sheetName = document.title || '';
        }
        // 
        if (!handleOptions.exportMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps), type)) {
          errLog('vxe.error.notType', [type]);
          if (['xlsx', 'pdf'].includes(type)) {
            warnLog('vxe.error.reqPlugin', [4, 'plugin-export-xlsx']);
          }
          const params = {
            status: false
          };
          return Promise.reject(params);
        }
        if (!handleOptions.print) {
          if (beforeExportMethod) {
            beforeExportMethod({
              options: handleOptions,
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt
            });
          }
        }
        if (!handleOptions.data) {
          handleOptions.data = [];
          if (mode === 'selected') {
            if (['html', 'pdf'].indexOf(type) > -1 && treeConfig) {
              handleOptions.data = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree($xeTable.getTableData().fullData, item => $xeTable.findRowIndexOf(selectRecords, item) > -1, Object.assign({}, treeOpts, {
                data: '_row'
              }));
            } else {
              handleOptions.data = selectRecords;
            }
          } else if (mode === 'all') {
            if (!$xeGGWrapper) {
              errLog('vxe.error.errProp', ['all', 'mode=current,selected']);
            }
            if ($xeGGWrapper && !handleOptions.remote) {
              const gridReactData = $xeGGWrapper.reactData;
              const {
                computeProxyOpts
              } = $xeGGWrapper.getComputeMaps();
              const proxyOpts = computeProxyOpts.value;
              const {
                sortData
              } = gridReactData;
              const {
                beforeQueryAll,
                afterQueryAll,
                ajax = {}
              } = proxyOpts;
              const resConfigs = proxyOpts.response || proxyOpts.props || {};
              const ajaxMethods = ajax.queryAll;
              const queryAllSuccessMethods = ajax.queryAllSuccess;
              const queryAllErrorMethods = ajax.queryAllError;
              if (!ajaxMethods) {
                errLog('vxe.error.notFunc', ['proxy-config.ajax.queryAll']);
              }
              if (ajaxMethods) {
                const params = {
                  $table: $xeTable,
                  $grid: $xeGrid,
                  $gantt: $xeGantt,
                  sort: sortData.length ? sortData[0] : {},
                  sorts: sortData,
                  filters: gridReactData.filterData,
                  form: gridReactData.formData,
                  options: handleOptions
                };
                return Promise.resolve((beforeQueryAll || ajaxMethods)(params)).then(rest => {
                  const listProp = resConfigs.list;
                  handleOptions.data = (listProp ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(listProp) ? listProp({
                    data: rest,
                    $table: $xeTable,
                    $grid: $xeGrid,
                    $gantt: $xeGantt
                  }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, listProp) : rest) || [];
                  if (afterQueryAll) {
                    afterQueryAll(params);
                  }
                  if (queryAllSuccessMethods) {
                    queryAllSuccessMethods({
                      ...params,
                      response: rest
                    });
                  }
                  return handleExport(handleOptions);
                }).catch(rest => {
                  if (queryAllErrorMethods) {
                    queryAllErrorMethods({
                      ...params,
                      response: rest
                    });
                  }
                });
              }
            }
          }
          if (mode === 'current') {
            handleOptions.data = treeConfig ? afterTreeFullData : afterFullData;
          }
        } else {
          handleOptions._isCustomData = true;
        }
        return handleExport(handleOptions);
      },
      importByFile(file, options) {
        const opts = Object.assign({}, options);
        const {
          beforeImportMethod
        } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({
            options: opts,
            $table: $xeTable
          });
        }
        return handleFileImport(file, opts);
      },
      importData(options) {
        const importOpts = computeImportOpts.value;
        const opts = Object.assign({
          types: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps)
          // beforeImportMethod: null,
          // afterImportMethod: null
        }, importOpts, options);
        const {
          beforeImportMethod,
          afterImportMethod
        } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({
            options: opts,
            $table: $xeTable
          });
        }
        return core_.VxeUI.readFile(opts).catch(e => {
          if (afterImportMethod) {
            afterImportMethod({
              status: false,
              options: opts,
              $table: $xeTable
            });
          }
          return Promise.reject(e);
        }).then(params => {
          const {
            file
          } = params;
          return handleFileImport(file, opts);
        });
      },
      saveFile(options) {
        return core_.VxeUI.saveFile(options);
      },
      readFile(options) {
        return core_.VxeUI.readFile(options);
      },
      print(options) {
        const $xeGrid = $xeTable.xeGrid;
        const $xeGantt = $xeTable.xeGantt;
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: 'html',
          download: false,
          remote: false,
          print: true
        });
        const {
          sheetName
        } = opts;
        let printTitle = '';
        if (sheetName) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(sheetName)) {
            printTitle = sheetName({
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid,
              $gantt: $xeGantt
            });
          } else {
            printTitle = `${sheetName}`;
          }
        }
        if (!printTitle) {
          printTitle = document.title || '';
        }
        const beforePrintMethod = opts.beforePrintMethod;
        const tableHtml = opts.html || opts.content;
        return new Promise((resolve, reject) => {
          if (core_.VxeUI.print) {
            if (tableHtml) {
              resolve(core_.VxeUI.print({
                title: printTitle,
                html: tableHtml,
                customStyle: opts.style,
                beforeMethod: beforePrintMethod ? ({
                  html
                }) => {
                  return beforePrintMethod({
                    html,
                    content: html,
                    options: opts,
                    $table: $xeTable,
                    $grid: $xeGrid,
                    $gantt: $xeGantt
                  });
                } : undefined
              }));
            } else {
              resolve(exportMethods.exportData(opts).then(({
                content
              }) => {
                return core_.VxeUI.print({
                  title: printTitle,
                  html: content,
                  customStyle: opts.style,
                  beforeMethod: beforePrintMethod ? ({
                    html
                  }) => {
                    return beforePrintMethod({
                      html,
                      content: html,
                      options: opts,
                      $table: $xeTable,
                      $grid: $xeGrid,
                      $gantt: $xeGantt
                    });
                  } : undefined
                });
              }));
            }
          } else {
            const e = {
              status: false
            };
            reject(e);
          }
        });
      },
      getPrintHtml(options) {
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: 'html',
          download: false,
          remote: false,
          print: true
        });
        return $xeTable.exportData(opts).then(({
          content
        }) => {
          return {
            html: content
          };
        });
      },
      closeImport() {
        if (core_.VxeUI.modal) {
          return core_.VxeUI.modal.close('VXE_IMPORT_MODAL');
        }
        return Promise.resolve();
      },
      openImport(options) {
        const {
          treeConfig,
          importConfig
        } = props;
        const {
          initStore,
          importStore,
          importParams
        } = reactData;
        const importOpts = computeImportOpts.value;
        const defOpts = Object.assign({
          mode: 'insertTop',
          message: true,
          types: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps),
          modes: ['insertTop', 'covering']
        }, importOpts, options);
        const types = defOpts.types || [];
        const modes = defOpts.modes || [];
        const isTree = !!treeConfig;
        if (isTree) {
          if (defOpts.message) {
            if (core_.VxeUI.modal) {
              core_.VxeUI.modal.message({
                content: export_hook_getI18n('vxe.error.treeNotImp'),
                status: 'error'
              });
            }
          }
          return;
        }
        if (!importConfig) {
          errLog('vxe.error.reqProp', ['import-config']);
        }
        // 
        const typeList = types.map(value => {
          return {
            value,
            label: export_hook_getI18n(`vxe.export.types.${value}`)
          };
        });
        const modeList = modes.map(item => {
          if (item && item.value) {
            return {
              value: item.value,
              label: item.label || item.value
            };
          }
          return {
            value: item,
            label: export_hook_getI18n(`vxe.import.modes.${item}`)
          };
        });
        Object.assign(importStore, {
          file: null,
          type: '',
          filename: '',
          modeList,
          typeList,
          visible: true
        });
        Object.assign(importParams, defOpts);
        if (!modeList.some(item => item.value === importParams.mode)) {
          importParams.mode = modeList[0].value;
        }
        initStore.import = true;
      },
      closeExport: handleCloseExport,
      openExport(options) {
        const exportOpts = computeExportOpts.value;
        const defOpts = Object.assign({
          message: true,
          types: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps)
        }, exportOpts, options);
        if (!props.exportConfig) {
          errLog('vxe.error.reqProp', ['export-config']);
        }
        return handleExportAndPrint(defOpts);
      },
      closePrint: handleCloseExport,
      openPrint(options) {
        const printOpts = computePrintOpts.value;
        const defOpts = Object.assign({
          message: true
        }, printOpts, options);
        if (!props.printConfig) {
          errLog('vxe.error.reqProp', ['print-config']);
        }
        return handleExportAndPrint(defOpts, true);
      }
    };
    return exportMethods;
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableExportMethodKeys);
  },
  setupGantt($xeGantt) {
    return $xeGantt.extendTableMethods(tableExportMethodKeys);
  }
});
;// ./packages/table/module/keyboard/hook.ts







const {
  hooks: keyboard_hook_hooks
} = core_.VxeUI;
keyboard_hook_hooks.add('tableKeyboardModule', {
  setupTable($xeTable) {
    const {
      props,
      reactData,
      internalData
    } = $xeTable;
    const {
      refElem
    } = $xeTable.getRefMaps();
    const {
      computeEditOpts,
      computeCheckboxOpts,
      computeMouseOpts,
      computeTreeOpts,
      computeRowOpts,
      computeColumnOpts,
      computeCellOpts,
      computeDefaultRowHeight,
      computeCurrentRowOpts,
      computeCurrentColumnOpts
    } = $xeTable.getComputeMaps();
    function getCheckboxRangeRows(evnt, params, targetTrElem, trRect, offsetClientTop, moveRange) {
      const {
        showOverflow
      } = props;
      const {
        fullAllDataRowIdData,
        isResizeCellHeight
      } = internalData;
      const rowOpts = computeRowOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const {
        row
      } = params;
      let countHeight = 0;
      let rangeRows = [];
      let moveSize = 0;
      const isDown = moveRange > 0;
      const {
        scrollYLoad
      } = reactData;
      const {
        afterFullData
      } = internalData;
      if (isDown) {
        moveSize = offsetClientTop + moveRange;
      } else {
        moveSize = trRect.height - offsetClientTop + Math.abs(moveRange);
      }
      if (scrollYLoad) {
        const _rowIndex = $xeTable.getVTRowIndex(row);
        const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
        if (!isCustomCellHeight && showOverflow) {
          if (isDown) {
            rangeRows = afterFullData.slice(_rowIndex, _rowIndex + Math.ceil(moveSize / defaultRowHeight));
          } else {
            rangeRows = afterFullData.slice(_rowIndex - Math.floor(moveSize / defaultRowHeight), _rowIndex + 1);
          }
        } else {
          if (isDown) {
            for (let i = _rowIndex; i < afterFullData.length; i++) {
              const item = afterFullData[i];
              const rowid = $xeTable.getRowid(item);
              const rowRest = fullAllDataRowIdData[rowid] || {};
              countHeight += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
              rangeRows.push(item);
              if (countHeight > moveSize) {
                return rangeRows;
              }
            }
          } else {
            for (let len = _rowIndex; len >= 0; len--) {
              const item = afterFullData[len];
              const rowid = $xeTable.getRowid(item);
              const rowRest = fullAllDataRowIdData[rowid] || {};
              countHeight += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
              rangeRows.push(item);
              if (countHeight > moveSize) {
                return rangeRows;
              }
            }
          }
        }
      } else {
        const siblingProp = isDown ? 'next' : 'previous';
        while (targetTrElem && countHeight < moveSize) {
          const rowNodeRest = $xeTable.getRowNode(targetTrElem);
          if (rowNodeRest) {
            rangeRows.push(rowNodeRest.item);
            countHeight += targetTrElem.offsetHeight;
            targetTrElem = targetTrElem[`${siblingProp}ElementSibling`];
          }
        }
      }
      return rangeRows;
    }
    const handleCheckboxRangeEvent = (evnt, params) => {
      const {
        elemStore
      } = internalData;
      const bodyScrollElem = getRefElem(elemStore['main-body-scroll']);
      const leftScrollElem = getRefElem(elemStore['left-body-scroll']);
      const rightScrollElem = getRefElem(elemStore['right-body-scroll']);
      const {
        column,
        cell
      } = params;
      if (column.type === 'checkbox') {
        let bodyWrapperElem = bodyScrollElem;
        if (leftScrollElem && column.fixed === 'left') {
          bodyWrapperElem = leftScrollElem;
        } else if (rightScrollElem && column.fixed === 'right') {
          bodyWrapperElem = rightScrollElem;
        }
        if (!bodyWrapperElem) {
          return;
        }
        const bodyRect = bodyWrapperElem.getBoundingClientRect();
        const el = refElem.value;
        const disX = evnt.clientX;
        const disY = evnt.clientY;
        const checkboxRangeElem = bodyWrapperElem.querySelector('.vxe-table--checkbox-range');
        const trElem = cell.parentElement;
        const selectRecords = $xeTable.getCheckboxRecords();
        let lastRangeRows = [];
        const marginSize = 1;
        const startTop = evnt.clientY - bodyRect.y + bodyWrapperElem.scrollTop;
        const startLeft = evnt.clientX - bodyRect.x + bodyWrapperElem.scrollLeft;
        const startScrollTop = bodyWrapperElem.scrollTop;
        const rowHeight = trElem.offsetHeight;
        const trRect = trElem.getBoundingClientRect();
        const offsetClientTop = disY - trRect.y;
        let mouseScrollTimeout = null;
        let isMouseScrollDown = false;
        let mouseScrollSpaceSize = 1;
        const triggerEvent = (type, evnt) => {
          $xeTable.dispatchEvent(`checkbox-range-${type}`, {
            records: () => $xeTable.getCheckboxRecords(),
            reserves: () => $xeTable.getCheckboxReserveRecords()
          }, evnt);
        };
        const handleChecked = evnt => {
          const {
            clientX,
            clientY
          } = evnt;
          const offsetLeft = clientX - disX;
          const offsetTop = clientY - disY + (bodyWrapperElem.scrollTop - startScrollTop);
          let rangeHeight = Math.abs(offsetTop);
          let rangeWidth = Math.abs(offsetLeft);
          let rangeTop = startTop;
          let rangeLeft = startLeft;
          if (offsetTop < marginSize) {
            // 
            rangeTop += offsetTop;
            if (rangeTop < marginSize) {
              rangeTop = marginSize;
              rangeHeight = startTop;
            }
          } else {
            // 
            rangeHeight = Math.min(rangeHeight, bodyWrapperElem.scrollHeight - startTop - marginSize);
          }
          if (offsetLeft < marginSize) {
            // 
            rangeLeft += offsetLeft;
            if (rangeWidth > startLeft) {
              rangeLeft = marginSize;
              rangeWidth = startLeft;
            }
          } else {
            // 
            rangeWidth = Math.min(rangeWidth, bodyWrapperElem.clientWidth - startLeft - marginSize);
          }
          checkboxRangeElem.style.height = `${rangeHeight}px`;
          checkboxRangeElem.style.width = `${rangeWidth}px`;
          checkboxRangeElem.style.left = `${rangeLeft}px`;
          checkboxRangeElem.style.top = `${rangeTop}px`;
          checkboxRangeElem.style.display = 'block';
          const rangeRows = getCheckboxRangeRows(evnt, params, trElem, trRect, offsetClientTop, offsetTop < marginSize ? -rangeHeight : rangeHeight);
          //  10px 
          if (rangeHeight > 10 && rangeRows.length !== lastRangeRows.length) {
            const isControlKey = hasControlKey(evnt);
            lastRangeRows = rangeRows;
            if (isControlKey) {
              rangeRows.forEach(row => {
                $xeTable.handleBatchSelectRows([row], selectRecords.indexOf(row) === -1);
              });
            } else {
              $xeTable.setAllCheckboxRow(false);
              $xeTable.handleCheckedCheckboxRow(rangeRows, true, false);
            }
            triggerEvent('change', evnt);
          }
        };
        // 
        const stopMouseScroll = () => {
          clearTimeout(mouseScrollTimeout);
          mouseScrollTimeout = null;
        };
        // 
        const startMouseScroll = evnt => {
          stopMouseScroll();
          mouseScrollTimeout = setTimeout(() => {
            if (mouseScrollTimeout) {
              const {
                scrollLeft,
                scrollTop,
                clientHeight,
                scrollHeight
              } = bodyWrapperElem;
              const topSize = Math.ceil(mouseScrollSpaceSize * 50 / rowHeight);
              if (isMouseScrollDown) {
                if (scrollTop + clientHeight < scrollHeight) {
                  $xeTable.scrollTo(scrollLeft, scrollTop + topSize);
                  startMouseScroll(evnt);
                  handleChecked(evnt);
                } else {
                  stopMouseScroll();
                }
              } else {
                if (scrollTop) {
                  $xeTable.scrollTo(scrollLeft, scrollTop - topSize);
                  startMouseScroll(evnt);
                  handleChecked(evnt);
                } else {
                  stopMouseScroll();
                }
              }
            }
          }, 50);
        };
        addClass(el, 'drag--range');
        document.onmousemove = evnt => {
          evnt.preventDefault();
          evnt.stopPropagation();
          const {
            clientY
          } = evnt;
          const {
            boundingTop
          } = getAbsolutePos(bodyWrapperElem);
          // 
          if (clientY < boundingTop) {
            isMouseScrollDown = false;
            mouseScrollSpaceSize = boundingTop - clientY;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt);
            }
          } else if (clientY > boundingTop + bodyWrapperElem.clientHeight) {
            isMouseScrollDown = true;
            mouseScrollSpaceSize = clientY - boundingTop - bodyWrapperElem.clientHeight;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt);
            }
          } else if (mouseScrollTimeout) {
            stopMouseScroll();
          }
          handleChecked(evnt);
        };
        document.onmouseup = evnt => {
          stopMouseScroll();
          removeClass(el, 'drag--range');
          checkboxRangeElem.removeAttribute('style');
          document.onmousemove = null;
          document.onmouseup = null;
          triggerEvent('end', evnt);
        };
        triggerEvent('start', evnt);
      }
    };
    const handleCellMousedownEvent = (evnt, params) => {
      const {
        editConfig,
        checkboxConfig,
        mouseConfig
      } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const editOpts = computeEditOpts.value;
      if (mouseConfig && mouseOpts.area && $xeTable.triggerCellAreaModnEvent) {
        return $xeTable.triggerCellAreaModnEvent(evnt, params);
      } else {
        if (checkboxConfig && checkboxOpts.range) {
          handleCheckboxRangeEvent(evnt, params);
        }
        if (mouseConfig && mouseOpts.selected) {
          if (!editConfig || editOpts.mode === 'cell') {
            $xeTable.handleSelected(params, evnt);
          }
        }
      }
    };
    const handleMoveSelected = (evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow) => {
      const {
        afterFullData,
        visibleColumn
      } = internalData;
      const params = Object.assign({}, args);
      const _rowIndex = $xeTable.getVTRowIndex(params.row);
      const _columnIndex = $xeTable.getVTColumnIndex(params.column);
      evnt.preventDefault();
      if (isUpArrow && _rowIndex > 0) {
        // 
        params.rowIndex = _rowIndex - 1;
        params.row = afterFullData[params.rowIndex];
      } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
        // 
        params.rowIndex = _rowIndex + 1;
        params.row = afterFullData[params.rowIndex];
      } else if (isLeftArrow && _columnIndex) {
        // 
        params.columnIndex = _columnIndex - 1;
        params.column = visibleColumn[params.columnIndex];
      } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
        // 
        params.columnIndex = _columnIndex + 1;
        params.column = visibleColumn[params.columnIndex];
      }
      $xeTable.scrollToRow(params.row, params.column).then(() => {
        params.cell = $xeTable.getCellElement(params.row, params.column);
        $xeTable.handleSelected(params, evnt);
      });
      return params;
    };
    const keyboardMethods = {
      //  Tab 
      moveTabSelected(args, isLeft, evnt) {
        const {
          editConfig
        } = props;
        const {
          afterFullData,
          visibleColumn
        } = internalData;
        const editOpts = computeEditOpts.value;
        const rowOpts = computeRowOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        let targetRow;
        let targetRowIndex;
        let targetColumnIndex;
        const params = Object.assign({}, args);
        const _rowIndex = $xeTable.getVTRowIndex(params.row);
        const _columnIndex = $xeTable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isLeft) {
          // 
          if (_columnIndex <= 0) {
            // 
            if (_rowIndex > 0) {
              targetRowIndex = _rowIndex - 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = visibleColumn.length - 1;
            }
          } else {
            targetColumnIndex = _columnIndex - 1;
          }
        } else {
          if (_columnIndex >= visibleColumn.length - 1) {
            // 
            if (_rowIndex < afterFullData.length - 1) {
              targetRowIndex = _rowIndex + 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = 0;
            }
          } else {
            targetColumnIndex = _columnIndex + 1;
          }
        }
        const targetColumn = visibleColumn[targetColumnIndex];
        if (targetColumn) {
          if (targetRow) {
            params.rowIndex = targetRowIndex;
            params.row = targetRow;
          } else {
            params.rowIndex = _rowIndex;
          }
          params.columnIndex = targetColumnIndex;
          params.column = targetColumn;
          params.cell = $xeTable.getCellElement(params.row, params.column);
          if (rowOpts.isCurrent && currentRowOpts.isFollowSelected) {
            $xeTable.triggerCurrentRowEvent(evnt, params);
          }
          if (columnOpts.isCurrent && currentColumnOpts.isFollowSelected) {
            $xeTable.triggerCurrentColumnEvent(evnt, params);
          }
          if (editConfig) {
            if (editOpts.trigger === 'click' || editOpts.trigger === 'dblclick') {
              if (editOpts.mode === 'row') {
                $xeTable.handleEdit(params, evnt);
              } else {
                $xeTable.scrollToRow(params.row, params.column).then(() => {
                  $xeTable.handleSelected(params, evnt);
                });
              }
            }
          } else {
            $xeTable.scrollToRow(params.row, params.column).then(() => {
              $xeTable.handleSelected(params, evnt);
            });
          }
        }
      },
      // 
      moveCurrentRow(isUpArrow, isDwArrow, evnt) {
        const {
          treeConfig
        } = props;
        const {
          currentRow
        } = reactData;
        const {
          afterFullData
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let targetRow;
        if (currentRow) {
          if (treeConfig) {
            const {
              index,
              items
            } = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(afterFullData, item => item === currentRow, {
              children: childrenField
            });
            if (isUpArrow && index > 0) {
              targetRow = items[index - 1];
            } else if (isDwArrow && index < items.length - 1) {
              targetRow = items[index + 1];
            }
          } else {
            const _rowIndex = $xeTable.getVTRowIndex(currentRow);
            if (isUpArrow && _rowIndex > 0) {
              targetRow = afterFullData[_rowIndex - 1];
            } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
              targetRow = afterFullData[_rowIndex + 1];
            }
          }
        } else {
          targetRow = afterFullData[0];
        }
        if (targetRow) {
          evnt.preventDefault();
          const params = {
            $table: $xeTable,
            row: targetRow,
            rowIndex: $xeTable.getRowIndex(targetRow),
            $rowIndex: $xeTable.getVMRowIndex(targetRow)
          };
          $xeTable.scrollToRow(targetRow).then(() => $xeTable.triggerCurrentRowEvent(evnt, params));
        }
      },
      // 
      moveCurrentColumn(isLeftArrow, isRightArrow, evnt) {
        const {
          currentColumn
        } = reactData;
        const {
          visibleColumn
        } = internalData;
        let targetCol = null;
        if (currentColumn) {
          const _columnIndex = $xeTable.getVTColumnIndex(currentColumn);
          if (isLeftArrow && _columnIndex > 0) {
            targetCol = visibleColumn[_columnIndex - 1];
          } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
            targetCol = visibleColumn[_columnIndex + 1];
          }
        } else {
          targetCol = visibleColumn[0];
        }
        if (targetCol) {
          evnt.preventDefault();
          const params = {
            $table: $xeTable,
            column: targetCol,
            columnIndex: $xeTable.getColumnIndex(targetCol),
            $columnIndex: $xeTable.getVMColumnIndex(targetCol)
          };
          $xeTable.scrollToColumn(targetCol).then(() => $xeTable.triggerCurrentColumnEvent(evnt, params));
        }
      },
      // 
      moveArrowSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        const {
          highlightCurrentRow,
          highlightCurrentColumn
        } = props;
        const rowOpts = computeRowOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const params = handleMoveSelected(evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
        if (rowOpts.isCurrent || highlightCurrentRow) {
          if (currentRowOpts.isFollowSelected) {
            $xeTable.triggerCurrentRowEvent(evnt, params);
          } else {
            // 
            if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
              $xeTable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
            }
          }
        }
        if (columnOpts.isCurrent || highlightCurrentColumn) {
          if (currentColumnOpts.isFollowSelected) {
            $xeTable.triggerCurrentColumnEvent(evnt, params);
          } else {
            // 
            if ((isLeftArrow || isRightArrow) && (columnOpts.isCurrent || highlightCurrentColumn)) {
              $xeTable.moveCurrentColumn(isLeftArrow, isRightArrow, evnt);
            }
          }
        }
      },
      moveEnterSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        const {
          highlightCurrentRow,
          highlightCurrentColumn
        } = props;
        const rowOpts = computeRowOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const params = handleMoveSelected(evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
        if ((rowOpts.isCurrent || highlightCurrentRow) && currentRowOpts.isFollowSelected) {
          $xeTable.triggerCurrentRowEvent(evnt, params);
        }
        if ((columnOpts.isCurrent || highlightCurrentColumn) && currentColumnOpts.isFollowSelected) {
          $xeTable.triggerCurrentColumnEvent(evnt, params);
        }
      },
      // 
      moveSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        handleMoveSelected(evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
      },
      handleCellMousedownEvent
    };
    return keyboardMethods;
  }
});
;// ./packages/table/module/validator/hook.ts












const {
  getConfig: validator_hook_getConfig,
  validators: hook_validators,
  hooks: validator_hook_hooks
} = core_.VxeUI;
/**
 * 
 */
class Rule {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.max,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  /**
   * 
   * 
   */
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
}
//  pattern
function validREValue(pattern, val) {
  if (pattern && !(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return false;
  }
  return true;
}
//  max
function validMaxValue(max, num) {
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(max) && num > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max)) {
    return false;
  }
  return true;
}
//  min
function validMinValue(min, num) {
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(min) && num < external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min)) {
    return false;
  }
  return true;
}
function validRuleValue(rule, val, required) {
  const {
    type,
    min,
    max,
    pattern
  } = rule;
  const isArrType = type === 'array';
  const isNumType = type === 'number';
  const isStrType = type === 'string';
  const strVal = `${val}`;
  if (!validREValue(pattern, strVal)) {
    return false;
  }
  if (isArrType) {
    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(val)) {
      return false;
    }
    if (required) {
      if (!val.length) {
        return false;
      }
    }
    if (!validMinValue(min, val.length)) {
      return false;
    }
    if (!validMaxValue(max, val.length)) {
      return false;
    }
  } else if (isNumType) {
    const numVal = Number(val);
    if (isNaN(numVal)) {
      return false;
    }
    if (!validMinValue(min, numVal)) {
      return false;
    }
    if (!validMaxValue(max, numVal)) {
      return false;
    }
  } else {
    if (isStrType) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val)) {
        return false;
      }
    }
    if (required) {
      if (!strVal) {
        return false;
      }
    }
    if (!validMinValue(min, strVal.length)) {
      return false;
    }
    if (!validMaxValue(max, strVal.length)) {
      return false;
    }
  }
  return true;
}
function checkRuleStatus(rule, val) {
  const {
    required
  } = rule;
  const isEmptyVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(val) ? !val.length : eqEmptyValue(val);
  if (required) {
    if (isEmptyVal) {
      return false;
    }
    if (!validRuleValue(rule, val, required)) {
      return false;
    }
  } else {
    if (!isEmptyVal) {
      if (!validRuleValue(rule, val, required)) {
        return false;
      }
    }
  }
  return true;
}
const tableValidatorMethodKeys = ['fullValidate', 'validate', 'fullValidateField', 'validateField', 'clearValidate'];
validator_hook_hooks.add('tableValidatorModule', {
  setupTable($xeTable) {
    const {
      props,
      reactData,
      internalData
    } = $xeTable;
    const {
      refValidTooltip
    } = $xeTable.getRefMaps();
    const {
      computeValidOpts,
      computeTreeOpts,
      computeEditOpts,
      computeAggregateOpts
    } = $xeTable.getComputeMaps();
    let validatorMethods = {};
    let validatorPrivateMethods = {};
    let validRuleErr;
    /**
     * 
     */
    const handleValidError = params => {
      return new Promise(resolve => {
        const validOpts = computeValidOpts.value;
        if (validOpts.autoPos === false) {
          $xeTable.dispatchEvent('valid-error', params, null);
          resolve();
        } else {
          $xeTable.handleEdit(params, {
            type: 'valid-error',
            trigger: 'call'
          }).then(() => {
            resolve(validatorPrivateMethods.showValidTooltip(params));
          });
        }
      });
    };
    const handleErrMsgMode = validErrMaps => {
      const validOpts = computeValidOpts.value;
      if (validOpts.msgMode === 'single') {
        const keys = Object.keys(validErrMaps);
        const resMaps = {};
        if (keys.length) {
          const firstKey = keys[0];
          resMaps[firstKey] = validErrMaps[firstKey];
        }
        return resMaps;
      }
      return validErrMaps;
    };
    /**
     * 
     * 
     *  true 
     *  row 
     *  rows 
     *  callback 
     *  Promise 
     */
    const beginValidate = (rows, cols, cb, isFull) => {
      const validRest = {};
      const {
        editRules,
        treeConfig
      } = props;
      const {
        isRowGroupStatus
      } = reactData;
      const {
        afterFullData,
        pendingRowMaps,
        removeRowMaps
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const aggregateOpts = computeAggregateOpts.value;
      const validOpts = computeValidOpts.value;
      let validList;
      if (rows === true) {
        validList = afterFullData;
      } else if (rows) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rows)) {
          cb = rows;
        } else {
          validList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows) ? rows : [rows];
        }
      }
      if (!validList) {
        if ($xeTable.getInsertRecords) {
          validList = $xeTable.getInsertRecords().concat($xeTable.getUpdateRecords());
        } else {
          validList = [];
        }
      }
      const rowValidErrs = [];
      internalData._lastCallTime = Date.now();
      validRuleErr = false; // 
      validatorMethods.clearValidate();
      const validErrMaps = {};
      if (editRules) {
        const columns = cols && cols.length ? cols : $xeTable.getColumns();
        const handleVaild = row => {
          const rowid = getRowid($xeTable, row);
          // 
          if (removeRowMaps[rowid]) {
            return;
          }
          // 
          if (pendingRowMaps[rowid]) {
            return;
          }
          if ($xeTable.isAggregateRecord(row)) {
            return;
          }
          if (isFull || !validRuleErr) {
            const colVailds = [];
            columns.forEach(column => {
              const field = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(column) ? column : column.field;
              if ((isFull || !validRuleErr) && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().has(editRules, field)) {
                colVailds.push(validatorPrivateMethods.validCellRules('all', row, column).catch(({
                  rule,
                  rules
                }) => {
                  const rest = {
                    rule,
                    rules,
                    rowIndex: $xeTable.getRowIndex(row),
                    row,
                    columnIndex: $xeTable.getColumnIndex(column),
                    column,
                    field,
                    $table: $xeTable
                  };
                  if (!validRest[field]) {
                    validRest[field] = [];
                  }
                  validErrMaps[`${getRowid($xeTable, row)}:${column.id}`] = {
                    column,
                    row,
                    rule,
                    content: rule.content
                  };
                  validRest[field].push(rest);
                  if (!isFull) {
                    validRuleErr = true;
                    return Promise.reject(rest);
                  }
                }));
              }
            });
            rowValidErrs.push(Promise.all(colVailds));
          }
        };
        if (isRowGroupStatus) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(validList, handleVaild, {
            children: aggregateOpts.mapChildrenField
          });
        } else if (treeConfig) {
          const childrenField = treeOpts.children || treeOpts.childrenField;
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(validList, handleVaild, {
            children: childrenField
          });
        } else {
          validList.forEach(handleVaild);
        }
        return Promise.all(rowValidErrs).then(() => {
          const ruleProps = Object.keys(validRest);
          reactData.validErrorMaps = handleErrMsgMode(validErrMaps);
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
            if (ruleProps.length) {
              return Promise.reject(validRest[ruleProps[0]][0]);
            }
            if (cb) {
              cb();
            }
          });
        }).catch(firstErrParams => {
          return new Promise((resolve, reject) => {
            const finish = () => {
              (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                if (cb) {
                  cb(validRest);
                  resolve();
                } else {
                  if (validator_hook_getConfig().validToReject === 'obsolete') {
                    // catch
                    reject(validRest);
                  } else {
                    resolve(validRest);
                  }
                }
              });
            };
            const posAndFinish = () => {
              firstErrParams.cell = $xeTable.getCellElement(firstErrParams.row, firstErrParams.column);
              scrollToView(firstErrParams.cell);
              handleValidError(firstErrParams).then(finish);
            };
            /**
             * 
             * 
             * 
             */
            if (validOpts.autoPos === false) {
              finish();
            } else {
              const row = firstErrParams.row;
              const column = firstErrParams.column;
              $xeTable.scrollToRow(row, column).then(posAndFinish);
            }
          });
        });
      } else {
        reactData.validErrorMaps = {};
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        if (cb) {
          cb();
        }
      });
    };
    validatorMethods = {
      /**
       *  validate 
       */
      fullValidate(rows, cb) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(cb)) {
          warnLog('vxe.error.notValidators', ['fullValidate(rows, callback)', 'fullValidate(rows)']);
        }
        return beginValidate(rows, null, cb, true);
      },
      /**
       * 
       */
      validate(rows, cb) {
        return beginValidate(rows, null, cb);
      },
      /**
       *  validateField 
       */
      fullValidateField(rows, fieldOrColumn) {
        const colList = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map(column => handleFieldOrColumn($xeTable, column));
        if (colList.length) {
          return beginValidate(rows, colList, null, true);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 
       */
      validateField(rows, fieldOrColumn) {
        const colList = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map(column => handleFieldOrColumn($xeTable, column));
        if (colList.length) {
          return beginValidate(rows, colList, null);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      clearValidate(rows, fieldOrColumn) {
        const {
          validErrorMaps
        } = reactData;
        const validTip = refValidTooltip.value;
        const validOpts = computeValidOpts.value;
        const rowList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows) ? rows : rows ? [rows] : [];
        const colList = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map(column => handleFieldOrColumn($xeTable, column));
        let validErrMaps = {};
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        // 
        if (validOpts.msgMode === 'single') {
          reactData.validErrorMaps = {};
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
        if (rowList.length && colList.length) {
          validErrMaps = Object.assign({}, validErrorMaps);
          rowList.forEach(row => {
            colList.forEach(column => {
              const validKey = `${getRowid($xeTable, row)}:${column.id}`;
              if (validErrMaps[validKey]) {
                delete validErrMaps[validKey];
              }
            });
          });
        } else if (rowList.length) {
          const rowIdList = rowList.map(row => `${getRowid($xeTable, row)}`);
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(validErrorMaps, (item, key) => {
            if (rowIdList.indexOf(key.split(':')[0]) > -1) {
              validErrMaps[key] = item;
            }
          });
        } else if (colList.length) {
          const colidList = colList.map(column => `${column.id}`);
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(validErrorMaps, (item, key) => {
            if (colidList.indexOf(key.split(':')[1]) > -1) {
              validErrMaps[key] = item;
            }
          });
        }
        reactData.validErrorMaps = validErrMaps;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    validatorPrivateMethods = {
      /**
       * 
       * 
       * 
       * Promise<>
       * 
       *
       * rule 
       *  required=Boolean 
       *  min=Number 
       *  max=Number 
       *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex })  Promise
       *  trigger=blur|change 
       */
      validCellRules(validType, row, column, val) {
        const $xeGrid = $xeTable.xeGrid;
        const $xeGantt = $xeTable.xeGantt;
        const {
          editRules
        } = props;
        const {
          field
        } = column;
        const errorRules = [];
        const syncValidList = [];
        if (field && editRules) {
          const rules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(editRules, field);
          if (rules) {
            const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(val) ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, field) : val;
            rules.forEach(rule => {
              const {
                trigger,
                validator
              } = rule;
              if (validType === 'all' || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    cellValue,
                    rule,
                    rules,
                    row,
                    rowIndex: $xeTable.getRowIndex(row),
                    column,
                    columnIndex: $xeTable.getColumnIndex(column),
                    field: column.field,
                    $table: $xeTable,
                    $grid: $xeGrid,
                    $gantt: $xeGantt
                  };
                  let customValid;
                  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(validator)) {
                    const gvItem = hook_validators.get(validator);
                    if (gvItem) {
                      const tcvMethod = gvItem.tableCellValidatorMethod || gvItem.cellValidatorMethod;
                      if (tcvMethod) {
                        customValid = tcvMethod(validParams);
                      } else {
                        errLog('vxe.error.notValidators', [validator]);
                      }
                    } else {
                      errLog('vxe.error.notValidators', [validator]);
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(customValid)) {
                      validRuleErr = true;
                      errorRules.push(new Rule({
                        type: 'custom',
                        trigger,
                        content: customValid.message,
                        rule: new Rule(rule)
                      }));
                    } else if (customValid.catch) {
                      // 
                      syncValidList.push(customValid.catch(e => {
                        validRuleErr = true;
                        errorRules.push(new Rule({
                          type: 'custom',
                          trigger,
                          content: e && e.message ? e.message : rule.content || rule.message,
                          rule: new Rule(rule)
                        }));
                      }));
                    }
                  }
                } else {
                  if (!checkRuleStatus(rule, cellValue)) {
                    validRuleErr = true;
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncValidList).then(() => {
          if (errorRules.length) {
            const rest = {
              rules: errorRules,
              rule: errorRules[0]
            };
            return Promise.reject(rest);
          }
        });
      },
      hasCellRules(type, row, column) {
        const {
          editRules
        } = props;
        const {
          field
        } = column;
        if (field && editRules) {
          const rules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(editRules, field);
          return rules && !!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(rules, rule => type === 'all' || !rule.trigger || type === rule.trigger);
        }
        return false;
      },
      /**
       * 
       */
      triggerValidate(type) {
        const {
          editConfig,
          editRules
        } = props;
        const {
          editStore
        } = reactData;
        const {
          actived
        } = editStore;
        const editOpts = computeEditOpts.value;
        const validOpts = computeValidOpts.value;
        // 
        if (editRules && validOpts.msgMode === 'single') {
          reactData.validErrorMaps = {};
        }
        // 
        if (editConfig && editRules && actived.row) {
          const {
            row,
            column,
            cell
          } = actived.args;
          if (validatorPrivateMethods.hasCellRules(type, row, column)) {
            return validatorPrivateMethods.validCellRules(type, row, column).then(() => {
              if (editOpts.mode === 'row') {
                validatorMethods.clearValidate(row, column);
              }
            }).catch(({
              rule
            }) => {
              // 
              if (!rule.trigger || type === rule.trigger) {
                const rest = {
                  rule,
                  row,
                  column,
                  cell
                };
                validatorPrivateMethods.showValidTooltip(rest);
                return Promise.reject(rest);
              }
              return Promise.resolve();
            });
          }
        }
        return Promise.resolve();
      },
      /**
       * 
       */
      showValidTooltip(params) {
        const {
          height
        } = props;
        const {
          tableData,
          validStore,
          validErrorMaps
        } = reactData;
        const {
          rule,
          row,
          column,
          cell
        } = params;
        const validOpts = computeValidOpts.value;
        const validTip = refValidTooltip.value;
        const content = rule.content;
        validStore.visible = true;
        if (validOpts.msgMode === 'single') {
          reactData.validErrorMaps = {
            [`${getRowid($xeTable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          };
        } else {
          reactData.validErrorMaps = Object.assign({}, validErrorMaps, {
            [`${getRowid($xeTable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          });
        }
        $xeTable.dispatchEvent('valid-error', params, null);
        if (validTip) {
          if (validTip && (validOpts.message === 'tooltip' || validOpts.message === 'default' && !height && tableData.length < 2)) {
            return validTip.open(cell, content);
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    return {
      ...validatorMethods,
      ...validatorPrivateMethods
    };
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableValidatorMethodKeys);
  },
  setupGantt($xeGantt) {
    return $xeGantt.extendTableMethods(tableValidatorMethodKeys);
  }
});
;// ./packages/table/module/custom/hook.ts








const tableCustomMethodKeys = ['openCustom', 'closeCustom', 'getCustomVisible', 'toggleCustom', 'saveCustom', 'cancelCustom', 'resetCustom', 'toggleCustomAllCheckbox', 'setCustomAllCheckbox'];
core_.VxeUI.hooks.add('tableCustomModule', {
  setupTable($xeTable) {
    const {
      reactData,
      internalData
    } = $xeTable;
    const {
      computeCustomOpts,
      computeRowGroupFields
    } = $xeTable.getComputeMaps();
    const {
      refElem
    } = $xeTable.getRefMaps();
    const $xeGantt = $xeTable.xeGantt;
    const calcMaxHeight = () => {
      const {
        customStore
      } = reactData;
      let wrapperEl = refElem.value;
      // 
      let tableHeight = 0;
      if ($xeGantt) {
        const {
          refGanttContainerElem
        } = $xeGantt.getRefMaps();
        const ganttContainerElem = refGanttContainerElem.value;
        if (ganttContainerElem) {
          wrapperEl = ganttContainerElem;
        }
      }
      if (wrapperEl) {
        tableHeight = wrapperEl.clientHeight - 28;
      }
      customStore.maxHeight = Math.max(88, tableHeight);
    };
    const openCustom = () => {
      const {
        initStore,
        customStore
      } = reactData;
      customStore.visible = true;
      initStore.custom = true;
      handleUpdateCustomColumn();
      checkCustomStatus();
      calcMaxHeight();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => calcMaxHeight());
    };
    const handleUpdateCustomColumn = () => {
      const {
        customStore
      } = reactData;
      const {
        collectColumn
      } = internalData;
      if (customStore.visible) {
        const sortMaps = {};
        const fixedMaps = {};
        const visibleMaps = {};
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, column => {
          const colid = column.getKey();
          column.renderFixed = column.fixed;
          column.renderVisible = column.visible;
          column.renderResizeWidth = column.renderWidth;
          sortMaps[colid] = column.renderSortNumber;
          fixedMaps[colid] = column.fixed;
          visibleMaps[colid] = column.visible;
        });
        customStore.oldSortMaps = sortMaps;
        customStore.oldFixedMaps = fixedMaps;
        customStore.oldVisibleMaps = visibleMaps;
        reactData.customColumnList = collectColumn.slice(0);
      }
    };
    const closeCustom = () => {
      const {
        customStore
      } = reactData;
      const customOpts = computeCustomOpts.value;
      if (customStore.visible) {
        customStore.visible = false;
        if (!customOpts.immediate) {
          $xeTable.handleCustom();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const toggleCustom = () => {
      const {
        customStore
      } = reactData;
      if (customStore.visible) {
        return closeCustom();
      }
      return openCustom();
    };
    const saveCustom = () => {
      const {
        customColumnList,
        aggHandleFields,
        rowGroupList
      } = reactData;
      const customOpts = computeCustomOpts.value;
      const {
        allowVisible,
        allowSort,
        allowFixed,
        allowResizable,
        allowGroup,
        allowValues
      } = customOpts;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, (column, index, items, path, parentColumn) => {
        if (parentColumn) {
          // 
          column.fixed = parentColumn.fixed;
        } else {
          if (allowSort) {
            const sortIndex = index + 1;
            column.renderSortNumber = sortIndex;
          }
          if (allowFixed) {
            column.fixed = column.renderFixed;
          }
        }
        if (allowResizable) {
          if (column.renderVisible && (!column.children || !column.children.length)) {
            if (column.renderResizeWidth !== column.renderWidth) {
              column.resizeWidth = column.renderResizeWidth;
              column.renderWidth = column.renderResizeWidth;
            }
          }
        }
        if (allowVisible) {
          column.visible = column.renderVisible;
        }
        if (allowGroup && allowValues) {
          column.aggFunc = column.renderAggFn;
        }
      });
      reactData.isCustomStatus = true;
      if (allowGroup && !!$xeTable.handlePivotTableAggregateData) {
        if (rowGroupList.length !== aggHandleFields.length || rowGroupList.some((conf, i) => conf.field !== aggHandleFields[i])) {
          // 
          if (aggHandleFields.length) {
            $xeTable.setRowGroups(aggHandleFields);
          } else {
            $xeTable.clearRowGroups();
          }
        } else if (allowValues) {
          // 
          $xeTable.handleUpdateAggData();
        }
      }
      if (allowSort) {
        internalData.collectColumn = customColumnList;
      }
      return $xeTable.saveCustomStore('confirm');
    };
    const cancelCustom = () => {
      const {
        customColumnList,
        customStore
      } = reactData;
      const {
        oldSortMaps,
        oldFixedMaps,
        oldVisibleMaps
      } = customStore;
      const customOpts = computeCustomOpts.value;
      const {
        allowVisible,
        allowSort,
        allowFixed,
        allowResizable
      } = customOpts;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, column => {
        const colid = column.getKey();
        const visible = !!oldVisibleMaps[colid];
        const fixed = oldFixedMaps[colid] || '';
        if (allowVisible) {
          column.renderVisible = visible;
          column.visible = visible;
        }
        if (allowFixed) {
          column.renderFixed = fixed;
          column.fixed = fixed;
        }
        if (allowSort) {
          column.renderSortNumber = oldSortMaps[colid] || 0;
        }
        if (allowResizable) {
          column.renderResizeWidth = column.renderWidth;
        }
      }, {
        children: 'children'
      });
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const setCustomAllCheckbox = checked => {
      const {
        customStore
      } = reactData;
      const {
        customColumnList
      } = reactData;
      const customOpts = computeCustomOpts.value;
      const {
        checkMethod,
        visibleMethod
      } = customOpts;
      const isAll = !!checked;
      if (customOpts.immediate) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, column => {
          if (visibleMethod && !visibleMethod({
            $table: $xeTable,
            column
          })) {
            return;
          }
          if (checkMethod && !checkMethod({
            $table: $xeTable,
            column
          })) {
            return;
          }
          column.visible = isAll;
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore('update:visible');
      } else {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, column => {
          if (visibleMethod && !visibleMethod({
            $table: $xeTable,
            column
          })) {
            return;
          }
          if (checkMethod && !checkMethod({
            $table: $xeTable,
            column
          })) {
            return;
          }
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
      }
      $xeTable.checkCustomStatus();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const customMethods = {
      getCustomVisible() {
        const {
          customStore
        } = reactData;
        return customStore.visible;
      },
      openCustom,
      closeCustom,
      toggleCustom,
      saveCustom,
      cancelCustom,
      resetCustom(options) {
        const {
          rowGroupList
        } = reactData;
        const {
          collectColumn
        } = internalData;
        const customOpts = computeCustomOpts.value;
        const {
          checkMethod
        } = customOpts;
        const opts = Object.assign({
          visible: true,
          resizable: options === true,
          fixed: options === true,
          sort: options === true,
          aggFunc: options === true
        }, options);
        const allCols = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, column => {
          if (opts.resizable) {
            column.resizeWidth = 0;
          }
          if (opts.fixed) {
            column.fixed = column.defaultFixed;
          }
          if (opts.sort) {
            column.renderSortNumber = column.sortNumber;
            column.parentId = column.defaultParentId;
          }
          if (!checkMethod || checkMethod({
            $table: $xeTable,
            column
          })) {
            column.visible = column.defaultVisible;
          }
          if (opts.aggFunc) {
            column.aggFunc = column.defaultAggFunc;
            column.renderAggFn = column.defaultAggFunc;
          }
          column.renderResizeWidth = column.renderWidth;
          allCols.push(column);
        });
        if (opts.sort) {
          const newCollectCols = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(allCols, 'renderSortNumber'), {
            key: 'id',
            parentKey: 'parentId',
            children: 'children'
          });
          internalData.collectColumn = newCollectCols;
          internalData.tableFullColumn = getColumnList(newCollectCols);
        }
        reactData.isCustomStatus = false;
        return $xeTable.handleCustom().then(() => {
          if (opts.aggFunc && $xeTable.handlePivotTableAggregateData) {
            const rowGroupFields = computeRowGroupFields.value;
            if (rowGroupFields ? rowGroupFields.length : rowGroupList.length) {
              if (rowGroupFields && rowGroupFields.length) {
                $xeTable.setRowGroups(rowGroupFields);
              } else {
                $xeTable.clearRowGroups();
              }
            } else {
              $xeTable.handleUpdateAggData();
            }
          }
          $xeTable.saveCustomStore('reset');
        });
      },
      toggleCustomAllCheckbox() {
        const {
          customStore
        } = reactData;
        const isAll = !customStore.isAll;
        return setCustomAllCheckbox(isAll);
      },
      setCustomAllCheckbox
    };
    const checkCustomStatus = () => {
      const {
        customStore
      } = reactData;
      const {
        collectColumn
      } = internalData;
      const customOpts = computeCustomOpts.value;
      const {
        checkMethod
      } = customOpts;
      customStore.isAll = collectColumn.every(column => (checkMethod ? !checkMethod({
        $table: $xeTable,
        column
      }) : false) || column.renderVisible);
      customStore.isIndeterminate = !customStore.isAll && collectColumn.some(column => (!checkMethod || checkMethod({
        $table: $xeTable,
        column
      })) && (column.renderVisible || column.halfVisible));
    };
    const emitCustomEvent = (type, evnt) => {
      $xeTable.dispatchEvent('custom', {
        type
      }, evnt);
    };
    const customPrivateMethods = {
      checkCustomStatus,
      emitCustomEvent,
      triggerCustomEvent(evnt) {
        const reactData = $xeTable.reactData;
        const {
          customStore
        } = reactData;
        if (customStore.visible) {
          closeCustom();
          emitCustomEvent('close', evnt);
        } else {
          customStore.btnEl = evnt.target;
          openCustom();
          emitCustomEvent('open', evnt);
        }
      },
      customOpenEvent(evnt) {
        const reactData = $xeTable.reactData;
        const {
          customStore
        } = reactData;
        if (!customStore.visible) {
          customStore.activeBtn = true;
          customStore.btnEl = evnt.target;
          $xeTable.openCustom();
          $xeTable.emitCustomEvent('open', evnt);
        }
      },
      customCloseEvent(evnt) {
        const reactData = $xeTable.reactData;
        const {
          customStore
        } = reactData;
        if (customStore.visible) {
          customStore.activeBtn = false;
          $xeTable.closeCustom();
          $xeTable.emitCustomEvent('close', evnt);
        }
      },
      handleUpdateCustomColumn
    };
    return {
      ...customMethods,
      ...customPrivateMethods
    };
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableCustomMethodKeys);
  },
  setupGantt($xeGantt) {
    return $xeGantt.extendTableMethods(tableCustomMethodKeys);
  }
});
;// ./packages/table/render/index.ts










const {
  getConfig: render_getConfig,
  renderer: render_renderer,
  getI18n: render_getI18n,
  getComponent
} = core_.VxeUI;
const componentDefaultModelProp = 'modelValue';
const defaultCompProps = {};
function handleDefaultValue(value, defaultVal, initVal) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(value) ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(defaultVal) ? initVal : defaultVal : value;
}
function parseDate(value, props) {
  return value && props.valueFormat ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value, props.valueFormat) : value;
}
function getFormatDate(value, props, defaultFormat) {
  const {
    dateConfig = {}
  } = props;
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(parseDate(value, props), dateConfig.labelFormat || defaultFormat);
}
function getLabelFormatDate(value, props) {
  return getFormatDate(value, props, render_getI18n(`vxe.input.date.labelFormat.${props.type || 'date'}`));
}
/**
 * 
 * @deprecated
 */
function getOldComponentName(name) {
  return `vxe-${name.replace('$', '')}`;
}
function getDefaultComponent({
  name
}) {
  return getComponent(name);
}
/**
 * 
 * @deprecated
 */
function getOldComponent({
  name
}) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(getOldComponentName(name));
}
function updateFilterChangeOption(params, checked, option) {
  const {
    $table
  } = params;
  $table.updateFilterOptionStatus(option, checked);
}
function saveFilterEvent(params) {
  const {
    $table,
    column
  } = params;
  $table.saveFilterByEvent(new Event('change'), column);
}
function getNativeAttrs(renderOpts) {
  let {
    name,
    attrs
  } = renderOpts;
  if (name === 'input') {
    attrs = Object.assign({
      type: 'text'
    }, attrs);
  }
  return attrs;
}
function getInputImmediateModel(renderOpts) {
  const {
    name,
    immediate,
    props
  } = renderOpts;
  if (!immediate) {
    if (name === 'VxeInput' || name === '$input') {
      const {
        type
      } = props || {};
      return !(!type || type === 'text' || type === 'number' || type === 'integer' || type === 'float');
    }
    if (name === 'input' || name === 'textarea' || name === '$textarea') {
      return false;
    }
    return true;
  }
  return immediate;
}
function getCellEditProps(renderOpts, params, value, defaultProps) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({
    immediate: getInputImmediateModel(renderOpts)
  }, defaultCompProps, defaultProps, renderOpts.props, {
    [componentDefaultModelProp]: value
  });
}
function getCellEditFilterProps(renderOpts, params, value, defaultProps) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({}, defaultCompProps, defaultProps, renderOpts.props, {
    [componentDefaultModelProp]: value
  });
}
function isImmediateCell(renderOpts, params) {
  return params.$type === 'cell' || getInputImmediateModel(renderOpts);
}
function getCellLabelVNs(renderOpts, params, cellLabel, opts) {
  const {
    placeholder
  } = renderOpts;
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: ['vxe-cell--label', opts ? opts.class : '']
  }, placeholder && isEmptyValue(cellLabel) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-cell--placeholder'
  }, formatText(getFuncText(placeholder), 1))] : formatText(cellLabel, 1))];
}
/**
 * 
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getNativeElementOns(renderOpts, params, eFns) {
  const {
    events
  } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const {
    model: modelFunc,
    change: changeFunc,
    blur: blurFunc
  } = eFns || {};
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
      ons[getOnName(key)] = function (...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function (evnt) {
      changeFunc(evnt);
      if (events && events[changeEvent]) {
        events[changeEvent](params, evnt);
      }
    };
  }
  if (blurFunc) {
    ons[getOnName(blurEvent)] = function (evnt) {
      blurFunc(evnt);
      if (events && events[blurEvent]) {
        events[blurEvent](params, evnt);
      }
    };
  }
  return ons;
}
const blurEvent = 'blur';
const clearEvent = 'clear';
/**
 * 
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getComponentOns(renderOpts, params, eFns, eventOns) {
  const {
    events
  } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const {
    model: modelFunc,
    change: changeFunc,
    blur: blurFunc,
    clear: clearFunc
  } = eFns || {};
  const ons = {};
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
    ons[getOnName(key)] = function (...args) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
        errLog('vxe.error.errFunc', [func]);
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function (...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  if (blurFunc) {
    ons[getOnName(blurEvent)] = function (...args) {
      blurFunc(...args);
      if (events && events[blurEvent]) {
        events[blurEvent](params, ...args);
      }
    };
  }
  if (clearFunc) {
    ons[getOnName(clearEvent)] = function (...args) {
      clearFunc(...args);
      if (events && events[clearEvent]) {
        events[clearEvent](params, ...args);
      }
    };
  }
  return eventOns ? Object.assign(ons, eventOns) : ons;
}
function getEditOns(renderOpts, params) {
  const {
    $table,
    row,
    column
  } = params;
  const {
    name
  } = renderOpts;
  const {
    model
  } = column;
  const isImmediate = isImmediateCell(renderOpts, params);
  return getComponentOns(renderOpts, params, {
    model(cellValue) {
      //  model 
      model.update = true;
      model.value = cellValue;
      if (isImmediate) {
        setCellValue(row, column, cellValue);
      }
    },
    change(eventParams) {
      //  change 
      if (!isImmediate && name && ['VxeInput', 'VxeNumberInput', 'VxeTextarea', '$input', '$textarea'].includes(name)) {
        const cellValue = eventParams.value;
        model.update = true;
        model.value = cellValue;
        $table.updateStatus(params, cellValue);
      } else {
        $table.updateStatus(params);
      }
    },
    blur() {
      if (isImmediate) {
        $table.handleCellRuleUpdateStatus('blur', params);
      } else {
        $table.handleCellRuleUpdateStatus('blur', params, model.value);
      }
    }
  });
}
function getFilterOns(renderOpts, params, option) {
  return getComponentOns(renderOpts, params, {
    model(value) {
      //  model 
      option.data = value;
    },
    change() {
      updateFilterChangeOption(params, !isEmptyValue(option.data), option);
    },
    blur() {
      updateFilterChangeOption(params, !isEmptyValue(option.data), option);
    }
  });
}
function getFloatingFilterOns(renderOpts, params, option) {
  const {
    $table,
    column
  } = params;
  if (hasInputType(renderOpts)) {
    return getComponentOns(renderOpts, params, {
      model(value) {
        //  model 
        option.data = value;
      },
      change() {
        updateFilterChangeOption(params, !isEmptyValue(option.data), option);
      },
      clear() {
        updateFilterChangeOption(params, !isEmptyValue(option.data), option);
        saveFilterEvent(params);
      },
      blur() {
        $table.saveFilterByEvent(new Event('change'), column);
      }
    }, renderOpts.name === 'VxeNumberInput' ? {
      [getOnName('plus-number')]() {
        updateFilterChangeOption(params, !isEmptyValue(option.data), option);
        saveFilterEvent(params);
      },
      [getOnName('minus-number')]() {
        updateFilterChangeOption(params, !isEmptyValue(option.data), option);
        saveFilterEvent(params);
      }
    } : {});
  }
  return getComponentOns(renderOpts, params, {
    model(value) {
      //  model 
      option.data = value;
    },
    clear() {
      updateFilterChangeOption(params, !isEmptyValue(option.data), option);
      $table.saveFilterByEvent(new Event('change'), column);
    },
    change() {
      updateFilterChangeOption(params, !isEmptyValue(option.data), option);
      $table.saveFilterByEvent(new Event('change'), column);
    }
  });
}
function getNativeEditOns(renderOpts, params) {
  const {
    $table,
    row,
    column
  } = params;
  const {
    model
  } = column;
  return getNativeElementOns(renderOpts, params, {
    model(evnt) {
      //  model 
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        if (isImmediateCell(renderOpts, params)) {
          setCellValue(row, column, cellValue);
        } else {
          model.update = true;
          model.value = cellValue;
        }
      }
    },
    change(evnt) {
      //  change 
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        $table.updateStatus(params, cellValue);
      }
    },
    blur(evnt) {
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        $table.updateStatus(params, cellValue);
      }
    }
  });
}
function getNativeFilterOns(renderOpts, params, option) {
  return getNativeElementOns(renderOpts, params, {
    model(evnt) {
      //  model 
      const targetEl = evnt.target;
      if (targetEl) {
        option.data = targetEl.value;
      }
    },
    change() {
      updateFilterChangeOption(params, !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(option.data), option);
    },
    blur() {
      updateFilterChangeOption(params, !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(option.data), option);
    }
  });
}
/**
 * -
 * inputtextareaselect
 */
function nativeEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    name
  } = renderOpts;
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(`${name}`, {
    class: `vxe-default-${name}`,
    ...getNativeAttrs(renderOpts),
    value: cellValue,
    ...getNativeEditOns(renderOpts, params)
  })];
}
function buttonCellRender(renderOpts, params) {
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, null),
    ...getComponentOns(renderOpts, params)
  })];
}
function defaultEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue),
    ...getEditOns(renderOpts, params)
  })];
}
function checkboxEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue),
    ...getEditOns(renderOpts, params)
  })];
}
function radioAndCheckboxGroupEditRender(renderOpts, params) {
  const {
    options
  } = renderOpts;
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    options,
    ...getCellEditProps(renderOpts, params, cellValue),
    ...getEditOns(renderOpts, params)
  })];
}
/**
 * 
 * @deprecated
 */
function oldEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue),
    ...getEditOns(renderOpts, params)
  })];
}
/**
 * 
 * @deprecated
 */
function oldButtonEditRender(renderOpts, params) {
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getComponent('vxe-button'), {
    ...getCellEditProps(renderOpts, params, null),
    ...getComponentOns(renderOpts, params)
  })];
}
/**
 * 
 * @deprecated
 */
function oldButtonsEditRender(renderOpts, params) {
  const {
    children
  } = renderOpts;
  return children ? children.map(childRenderOpts => oldButtonEditRender(childRenderOpts, params)[0]) : [];
}
function renderNativeOptgroups(renderOpts, params, renderOptionsMethods) {
  const {
    optionGroups,
    optionGroupProps = {}
  } = renderOpts;
  const groupOptions = optionGroupProps.options || 'options';
  const groupLabel = optionGroupProps.label || 'label';
  if (optionGroups) {
    return optionGroups.map((group, gIndex) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('optgroup', {
        key: gIndex,
        label: group[groupLabel]
      }, renderOptionsMethods(group[groupOptions], renderOpts, params));
    });
  }
  return [];
}
/**
 *  option 
 */
function renderNativeOptions(options, renderOpts, params) {
  const {
    optionProps = {}
  } = renderOpts;
  const {
    row,
    column
  } = params;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const disabledProp = optionProps.disabled || 'disabled';
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  if (options) {
    return options.map((option, oIndex) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('option', {
        key: oIndex,
        value: option[valueProp],
        disabled: option[disabledProp],
        /* eslint-disable eqeqeq */
        selected: option[valueProp] == cellValue
      }, option[labelProp]);
    });
  }
  return [];
}
function nativeFilterRender(renderOpts, params) {
  const {
    column
  } = params;
  const {
    name
  } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  return column.filters.map((option, oIndex) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(`${name}`, {
      key: oIndex,
      class: `vxe-default-${name}`,
      ...attrs,
      value: option.data,
      ...getNativeFilterOns(renderOpts, params, option)
    });
  });
}
function defaultFilterRender(renderOpts, params) {
  const {
    column
  } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
      key: oIndex,
      ...getCellEditFilterProps(renderOpts, renderOpts, optionValue),
      ...getFilterOns(renderOpts, params, option)
    });
  });
}
function defaultFloatingFilterRender(renderOpts, params) {
  const {
    option
  } = params;
  const optionValue = option.data;
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditFilterProps(renderOpts, renderOpts, optionValue),
    ...getFloatingFilterOns(renderOpts, params, option)
  })];
}
function defaultFilterOptions() {
  return [{
    data: null
  }];
}
/**
 * 
 * @deprecated
 */
function oldFilterRender(renderOpts, params) {
  const {
    column
  } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
      key: oIndex,
      ...getCellEditFilterProps(renderOpts, renderOpts, optionValue),
      ...getFilterOns(renderOpts, params, option)
    });
  });
}
function handleFilterMethod({
  option,
  row,
  column
}) {
  const {
    data
  } = option;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  /* eslint-disable eqeqeq */
  return cellValue == data;
}
function handleInputFilterMethod({
  option,
  row,
  column
}) {
  const {
    data
  } = option;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  /* eslint-disable eqeqeq */
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(cellValue).indexOf(data) > -1;
}
function nativeSelectEditRender(renderOpts, params) {
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('select', {
    class: 'vxe-default-select',
    ...getNativeAttrs(renderOpts),
    ...getNativeEditOns(renderOpts, params)
  }, renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params))];
}
function defaultSelectEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    options,
    optionProps,
    optionGroups,
    optionGroupProps
  } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue, {
      options,
      optionProps,
      optionGroups,
      optionGroupProps
    }),
    ...getEditOns(renderOpts, params)
  })];
}
function defaultTableOrTreeSelectEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    options,
    optionProps
  } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue, {
      options,
      optionProps
    }),
    ...getEditOns(renderOpts, params)
  })];
}
/**
 * 
 * @deprecated
 */
function oldSelectEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    options,
    optionProps,
    optionGroups,
    optionGroupProps
  } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue, {
      options,
      optionProps,
      optionGroups,
      optionGroupProps
    }),
    ...getEditOns(renderOpts, params)
  })];
}
function getSelectCellValue(renderOpts, {
  row,
  column
}) {
  const {
    options,
    optionGroups,
    optionProps = {},
    optionGroupProps = {},
    props = {}
  } = renderOpts;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  let selectItem;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  if (!(cellValue === null || cellValue === undefined)) {
    let vals = [];
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(cellValue)) {
      vals = cellValue;
    } else {
      if (props.multiple && `${cellValue}`.indexOf(',') > -1) {
        vals = `${cellValue}`.split(',');
      } else {
        vals = [cellValue];
      }
    }
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().map(vals, optionGroups ? value => {
      const groupOptions = optionGroupProps.options || 'options';
      for (let index = 0; index < optionGroups.length; index++) {
        /* eslint-disable eqeqeq */
        selectItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(optionGroups[index][groupOptions], item => item[valueProp] == value);
        if (selectItem) {
          break;
        }
      }
      return selectItem ? selectItem[labelProp] : value;
    } : value => {
      /* eslint-disable eqeqeq */
      selectItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(options, item => item[valueProp] == value);
      return selectItem ? selectItem[labelProp] : value;
    }).join(', ');
  }
  return '';
}
function handleExportSelectMethod(params) {
  const {
    row,
    column,
    options
  } = params;
  return options.original ? getCellValue(row, column) : getSelectCellValue(column.editRender || column.cellRender, params);
}
function getTreeSelectCellValue(renderOpts, {
  row,
  column
}) {
  const {
    options,
    optionProps = {}
  } = renderOpts;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const childrenProp = optionProps.children || 'children';
  if (!(cellValue === null || cellValue === undefined)) {
    const keyMaps = {};
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(options, item => {
      keyMaps[external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item, valueProp)] = item;
    }, {
      children: childrenProp
    });
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().map(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(cellValue) ? cellValue : [cellValue], value => {
      const item = keyMaps[value];
      return item ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item, labelProp) : item;
    }).join(', ');
  }
  return '';
}
function handleExportTreeSelectMethod(params) {
  const {
    row,
    column,
    options
  } = params;
  return options.original ? getCellValue(row, column) : getTreeSelectCellValue(column.editRender || column.cellRender, params);
}
function handleNumberCell(renderOpts, params) {
  const {
    props = {},
    showNegativeStatus
  } = renderOpts;
  const {
    row,
    column
  } = params;
  const {
    type
  } = props;
  let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
  let isNegative = false;
  if (!isEmptyValue(cellValue)) {
    const numberInputConfig = render_getConfig().numberInput || {};
    if (type === 'float') {
      const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
      const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 1);
      cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(cellValue, digits), digits);
      if (!autoFill) {
        cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);
      }
      if (showNegativeStatus) {
        if (cellValue < 0) {
          isNegative = true;
        }
      }
    } else if (type === 'amount') {
      const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
      const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 2);
      const showCurrency = handleDefaultValue(props.showCurrency, numberInputConfig.showCurrency, false);
      cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);
      if (showNegativeStatus) {
        if (cellValue < 0) {
          isNegative = true;
        }
      }
      cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().commafy(cellValue, {
        digits
      });
      if (!autoFill) {
        const [iStr, dStr] = cellValue.split('.');
        if (dStr) {
          const dRest = dStr.replace(/0+$/, '');
          cellValue = dRest ? [iStr, '.', dRest].join('') : iStr;
        }
      }
      if (showCurrency) {
        cellValue = `${props.currencySymbol || numberInputConfig.currencySymbol || render_getI18n('vxe.numberInput.currencySymbol') || ''}${cellValue}`;
      }
    } else {
      if (showNegativeStatus) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue) < 0) {
          isNegative = true;
        }
      }
    }
  }
  return getCellLabelVNs(renderOpts, params, cellValue, isNegative ? {
    class: 'is--negative'
  } : {});
}
/**
 *  - 
 */
render_renderer.mixin({
  input: {
    tableAutoFocus: 'input',
    renderTableEdit: nativeEditRender,
    renderTableDefault: nativeEditRender,
    renderTableFilter: nativeFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  textarea: {
    tableAutoFocus: 'textarea',
    renderTableEdit: nativeEditRender
  },
  select: {
    renderTableEdit: nativeSelectEditRender,
    renderTableDefault: nativeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const {
        column
      } = params;
      return column.filters.map((option, oIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('select', {
          key: oIndex,
          class: 'vxe-default-select',
          ...getNativeAttrs(renderOpts),
          ...getNativeFilterOns(renderOpts, params, option)
        }, renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeInput: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column
      } = params;
      const inputConfig = render_getConfig().input || {};
      const digits = props.digits || inputConfig.digits || 2;
      let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case 'date':
          case 'week':
          case 'month':
          case 'quarter':
          case 'year':
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case 'float':
            cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    createTableFilterOptions: defaultFilterOptions,
    renderTableFilter: defaultFilterRender,
    renderTableFloatingFilter: defaultFloatingFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  FormatNumberInput: {
    renderTableDefault: handleNumberCell,
    tableFilterDefaultMethod: handleInputFilterMethod,
    tableExportMethod(params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return cellValue;
    }
  },
  VxeNumberInput: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultEditRender,
    renderTableCell: handleNumberCell,
    renderTableFooter(renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column,
        _columnIndex
      } = params;
      const {
        type
      } = props;
      // 
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(row) ? row[_columnIndex] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(itemValue)) {
        const numberInputConfig = render_getConfig().numberInput || {};
        if (type === 'float') {
          const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
          const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 1);
          let amountLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(itemValue, digits), digits);
          if (!autoFill) {
            amountLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(amountLabel);
          }
          return amountLabel;
        } else if (type === 'amount') {
          const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
          const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 2);
          const showCurrency = handleDefaultValue(props.showCurrency, numberInputConfig.showCurrency, false);
          let amountLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().commafy(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(itemValue), {
            digits
          });
          if (!autoFill) {
            const [iStr, dStr] = amountLabel.split('.');
            if (dStr) {
              const dRest = dStr.replace(/0+$/, '');
              amountLabel = dRest ? [iStr, '.', dRest].join('') : iStr;
            }
          }
          if (showCurrency) {
            amountLabel = `${props.currencySymbol || numberInputConfig.currencySymbol || render_getI18n('vxe.numberInput.currencySymbol') || ''}${amountLabel}`;
          }
          return amountLabel;
        }
      }
      return getFuncText(itemValue, 1);
    },
    renderTableDefault: defaultEditRender,
    createTableFilterOptions: defaultFilterOptions,
    renderTableFilter: defaultFilterRender,
    renderTableFloatingFilter: defaultFloatingFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod,
    tableExportMethod(params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return cellValue;
    }
  },
  VxeDatePicker: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column
      } = params;
      let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      if (cellValue) {
        if (props.type !== 'time') {
          cellValue = getLabelFormatDate(cellValue, props);
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    createTableFilterOptions: defaultFilterOptions,
    renderTableFilter: defaultFilterRender,
    renderTableFloatingFilter: defaultFloatingFilterRender,
    tableFilterDefaultMethod: handleFilterMethod
  },
  VxeDateRangePicker: {
    tableAutoFocus: 'input',
    renderTableEdit(renderOpts, params) {
      const {
        startField,
        endField
      } = renderOpts;
      const {
        $table,
        row,
        column
      } = params;
      const {
        model
      } = column;
      const cellValue = getCellValue(row, column);
      const seProps = {};
      const seOs = {};
      if (startField && endField) {
        seProps.startValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, startField);
        seProps.endValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, endField);
        seOs['onUpdate:startValue'] = value => {
          if (startField) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, startField, value);
          }
        };
        seOs['onUpdate:endValue'] = value => {
          if (endField) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, endField, value);
          }
        };
      }
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getCellEditProps(renderOpts, params, cellValue, seProps),
        ...getComponentOns(renderOpts, params, {
          model(cellValue) {
            model.update = true;
            model.value = cellValue;
            setCellValue(row, column, cellValue);
          },
          change() {
            $table.updateStatus(params);
          },
          blur() {
            $table.handleCellRuleUpdateStatus('blur', params);
          }
        }, seOs)
      })];
    },
    renderTableCell(renderOpts, params) {
      const {
        startField,
        endField
      } = renderOpts;
      const {
        row,
        column
      } = params;
      let startValue = '';
      let endValue = '';
      if (startField && endField) {
        startValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, startField);
        endValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, endField);
      } else {
        const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
        if (cellValue) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(cellValue)) {
            startValue = cellValue[0];
            endValue = cellValue[1];
          } else {
            const strs = `${cellValue}`.split(',');
            startValue = strs[0];
            endValue = strs[1];
          }
        }
      }
      let cellLabel = '';
      if (startValue && endValue) {
        cellLabel = `${startValue} ~ ${endValue}`;
      }
      return getCellLabelVNs(renderOpts, params, cellLabel);
    }
  },
  VxeTextarea: {
    tableAutoFocus: 'textarea',
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return getCellLabelVNs(renderOpts, params, cellValue);
    }
  },
  VxeButton: {
    renderTableDefault: buttonCellRender
  },
  VxeButtonGroup: {
    renderTableDefault(renderOpts, params) {
      const {
        options
      } = renderOpts;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        options,
        ...getCellEditProps(renderOpts, params, null),
        ...getComponentOns(renderOpts, params)
      })];
    }
  },
  VxeSelect: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultSelectEditRender,
    renderTableDefault: defaultSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    createTableFilterOptions: defaultFilterOptions,
    renderTableFilter(renderOpts, params) {
      const {
        column
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
          key: oIndex,
          ...getCellEditFilterProps(renderOpts, params, optionValue, {
            options,
            optionProps,
            optionGroups,
            optionGroupProps
          }),
          ...getFilterOns(renderOpts, params, option)
        });
      });
    },
    renderTableFloatingFilter(renderOpts, params) {
      const {
        option
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      const optionValue = option.data;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getCellEditFilterProps(renderOpts, params, optionValue, {
          options,
          optionProps,
          optionGroups,
          optionGroupProps
        }),
        ...getFloatingFilterOns(renderOpts, params, option)
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeText: {
    renderTableDefault(renderOpts, params) {
      const {
        $table,
        row,
        column
      } = params;
      const {
        props
      } = renderOpts;
      const cellLabel = $table.getCellLabel(row, column);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...(props || {}),
        content: cellLabel,
        ...getComponentOns(renderOpts, params)
      })];
    }
  },
  VxeLink: {
    renderTableDefault(renderOpts, params) {
      const {
        $table,
        row,
        column
      } = params;
      const {
        props
      } = renderOpts;
      const {
        href
      } = props || {};
      const cellLabel = $table.getCellLabel(row, column);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...(props || {}),
        content: cellLabel,
        href: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFormatString(href, params),
        ...getComponentOns(renderOpts, params)
      })];
    }
  },
  /**
   *  FormatSelect 
   * @deprecated
   */
  formatOption: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    }
  },
  FormatSelect: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeTreeSelect: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultTableOrTreeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  /**
   *  FormatTreeSelect 
   * @deprecated
   */
  formatTree: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    }
  },
  FormatTreeSelect: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeTableSelect: {
    tableAutoFocus: 'input',
    renderTableEdit: defaultTableOrTreeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeColorPicker: {
    tableAutoFocus: 'input',
    renderTableEdit(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        options
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getCellEditProps(renderOpts, params, cellValue, {
          colors: options
        }),
        ...getEditOns(renderOpts, params)
      })];
    },
    renderTableCell(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-color-picker--readonly'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--readonly-color',
        style: {
          backgroundColor: cellValue
        }
      })]);
    }
  },
  VxeIconPicker: {
    tableAutoFocus: 'input',
    renderTableEdit(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        options
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getCellEditProps(renderOpts, params, cellValue, {
          icons: options
        }),
        ...getEditOns(renderOpts, params)
      })];
    },
    renderTableCell(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: cellValue
      });
    }
  },
  VxeRadioGroup: {
    renderTableDefault: radioAndCheckboxGroupEditRender
  },
  VxeCheckbox: {
    renderTableDefault: checkboxEditRender
  },
  VxeCheckboxGroup: {
    renderTableDefault: radioAndCheckboxGroupEditRender
  },
  VxeSwitch: {
    tableAutoFocus: 'button',
    renderTableEdit: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeUpload: {
    renderTableEdit: defaultEditRender,
    renderTableCell: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeImage: {
    renderTableDefault(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        props
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...props,
        src: cellValue,
        ...getEditOns(renderOpts, params)
      })];
    }
  },
  VxeImageGroup: {
    renderTableDefault(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        props
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...props,
        urlList: cellValue,
        ...getEditOns(renderOpts, params)
      })];
    }
  },
  VxeTextEllipsis: {
    renderTableDefault(renderOpts, params) {
      const {
        row,
        column
      } = params;
      const {
        props
      } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...props,
        content: cellValue,
        ...getEditOns(renderOpts, params)
      })];
    }
  },
  VxeRate: {
    renderTableDefault: defaultEditRender
  },
  VxeSlider: {
    renderTableDefault: defaultEditRender
  },
  // 
  $input: {
    tableAutoFocus: '.vxe-input--inner',
    renderTableEdit: oldEditRender,
    renderTableCell(renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column
      } = params;
      const digits = props.digits || render_getConfig().input?.digits || 2;
      let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case 'date':
          case 'week':
          case 'month':
          case 'year':
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case 'float':
            cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: oldEditRender,
    renderTableFilter: oldFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  $textarea: {
    tableAutoFocus: '.vxe-textarea--inner'
  },
  $button: {
    renderTableDefault: oldButtonEditRender
  },
  $buttons: {
    renderTableDefault: oldButtonsEditRender
  },
  $select: {
    tableAutoFocus: '.vxe-input--inner',
    renderTableEdit: oldSelectEditRender,
    renderTableDefault: oldSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const {
        column
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
          key: oIndex,
          ...getCellEditFilterProps(renderOpts, params, optionValue, {
            options,
            optionProps,
            optionGroups,
            optionGroupProps
          }),
          ...getFilterOns(renderOpts, params, option)
        });
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  $radio: {
    tableAutoFocus: '.vxe-radio--input'
  },
  $checkbox: {
    tableAutoFocus: '.vxe-checkbox--input'
  },
  $switch: {
    tableAutoFocus: '.vxe-switch--button',
    renderTableEdit: oldEditRender,
    renderTableDefault: oldEditRender
  }
  // 
});
;// ./packages/table/src/table.ts
const{getConfig: table_getConfig,getIcon: table_getIcon,getI18n: table_getI18n,renderer: table_renderer,formats: table_formats,createEvent,globalResize: table_globalResize,interceptor: table_interceptor,hooks: table_hooks,globalEvents: table_globalEvents,GLOBAL_EVENT_KEYS: table_GLOBAL_EVENT_KEYS,useFns,renderEmptyElement: table_renderEmptyElement}=core_.VxeUI;const supportMaxRow=5e6;const customStorageKey='VXE_CUSTOM_STORE';const maxYHeight=5e6;const maxXWidth=5e6;let crossTableDragRowObj=null;/* harmony default export */ var table = (defineVxeComponent({name:'VxeTable',props:tableProps,emits:tableEmits,setup(props,context){const{slots,emit}=context;const xID=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();const browseObj=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();// 
const VxeUILoadingComponent=core_.VxeUI.getComponent('VxeLoading');const VxeUITooltipComponent=core_.VxeUI.getComponent('VxeTooltip');const $xeTabs=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTabs',null);const $xeParentTable=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable',null);const $xeGrid=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeGrid',null);const $xeGantt=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeGantt',null);const $xeGGWrapper=$xeGrid||$xeGantt;const{computeSize}=useFns.useSize(props);const crossTableDragRowInfo=getCrossTableDragRowInfo();const reactData=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({// 
staticColumns:[],// 
tableGroupColumn:[],// 
tableColumn:[],// 
tableData:[],//  X 
scrollXLoad:false,//  Y 
scrollYLoad:false,// 
overflowY:true,// 
overflowX:false,// 
scrollbarWidth:0,// 
scrollbarHeight:0,// 
lastScrollTime:0,// 
rowHeight:0,// 
parentHeight:0,// 
isGroup:false,isAllOverflow:false,// 
isAllSelected:false,// 
isIndeterminate:false,// 
currentRow:null,// 
currentColumn:null,// 
selectRadioRow:null,// 
footerTableData:[],// 
rowGroupColumn:null,// 
expandColumn:null,checkboxColumn:null,radioColumn:null,// 
treeNodeColumn:null,hasFixedColumn:false,// 
upDataFlag:0,// 
reColumnFlag:0,// 
initStore:{filter:false,import:false,export:false,custom:false},// 
customStore:{btnEl:null,isAll:false,isIndeterminate:false,activeBtn:false,activeWrapper:false,visible:false,maxHeight:0,oldSortMaps:{},oldFixedMaps:{},oldVisibleMaps:{}},customColumnList:[],// 
filterStore:{isAllSelected:false,isIndeterminate:false,style:null,column:null,visible:false,maxHeight:null},// 
columnStore:{leftList:[],centerList:[],rightList:[],resizeList:[],pxList:[],pxMinList:[],autoMinList:[],scaleList:[],scaleMinList:[],autoList:[],remainList:[]},// 
ctxMenuStore:{selected:null,visible:false,showChild:false,selectChild:null,list:[],style:null},// 
editStore:{indexs:{columns:[]},titles:{columns:[]},// 
selected:{row:null,column:null},// 
copyed:{cut:false,rows:[],columns:[]},// 
actived:{row:null,column:null},// 
focused:{row:null,column:null}},//  tooltip 
tooltipStore:{row:null,column:null,content:null,visible:false,type:null,currOpts:{}},// 
validStore:{visible:false},validErrorMaps:{},// 
importStore:{inited:false,file:null,type:'',modeList:[],typeList:[],filename:'',visible:false},importParams:{mode:'',types:null,message:true},// 
exportStore:{inited:false,name:'',modeList:[],typeList:[],columns:[],isPrint:false,hasFooter:false,hasMerge:false,hasTree:false,hasColgroup:false,visible:false},exportParams:{filename:'',sheetName:'',mode:'',type:'',isColgroup:false,isMerge:false,isAllExpand:false,useStyle:false,original:false,message:true,isHeader:false,isTitle:false,isFooter:false},visiblwRowsFlag:1,isRowGroupStatus:false,rowGroupList:[],aggHandleFields:[],aggHandleAggColumns:[],rowGroupExpandedFlag:1,rowExpandedFlag:1,treeExpandedFlag:1,updateCheckboxFlag:1,pendingRowFlag:1,insertRowFlag:1,removeRowFlag:1,mergeHeadFlag:1,mergeBodyFlag:1,mergeFootFlag:1,rowHeightStore:{large:52,default:48,medium:44,small:40,mini:36},scrollVMLoading:false,scrollYHeight:0,scrollYTop:0,isScrollYBig:false,scrollXLeft:0,scrollXWidth:0,isScrollXBig:false,lazScrollLoading:false,rowExpandHeightFlag:1,calcCellHeightFlag:1,resizeHeightFlag:1,resizeWidthFlag:1,isCustomStatus:false,isCrossDragRow:false,dragRow:null,isCrossDragCol:false,dragCol:null,dragTipText:'',isDragResize:false,isRowLoading:false,isColLoading:false});const internalData=createInternalData();let tableMethods={};let tablePrivateMethods={};const refElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refVarElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTooltip=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refCommTooltip=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refValidTooltip=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableMenu=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableFilter=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableCustom=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableViewportElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableHeader=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableBody=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableFooter=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableLeftHeader=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableLeftBody=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableLeftFooter=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableRightHeader=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableRightBody=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTableRightFooter=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refTeleportWrapper=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refPopupWrapperElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refLeftContainer=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refRightContainer=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refColResizeBar=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refRowResizeBar=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refEmptyPlaceholder=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refDragTipElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refDragRowLineElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refDragColLineElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refRowExpandElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refRowExpandYSpaceElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollXVirtualElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollYVirtualElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollXHandleElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollXLeftCornerElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollXRightCornerElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollYHandleElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollYTopCornerElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollXWrapperElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollYWrapperElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollYBottomCornerElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollXSpaceElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();const refScrollYSpaceElem=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();let $xeToolbar;const computeTableId=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{id}=props;if(id){if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(id)){return`${id({$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt})||''}`;}return`${id}`;}return'';});const computeRowField=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const rowOpts=computeRowOpts.value;return`${props.rowId||rowOpts.keyField||'_X_ROW_KEY'}`;});const computeValidOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.validConfig,props.validConfig);});/**
         * @deprecated
         */const computeSXOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const virtualXOpts=computeVirtualXOpts.value;return virtualXOpts;});const computeScrollXThreshold=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const virtualXOpts=computeVirtualXOpts.value;const{threshold}=virtualXOpts;if(threshold){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(threshold);}return 0;});/**
         * @deprecated
         */const computeSYOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const virtualYOpts=computeVirtualYOpts.value;return virtualYOpts;});const computeVirtualXOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{virtualXConfig,scrollX}=props;const globalVirtualXConfig=table_getConfig().table.virtualXConfig;const globalScrollX=table_getConfig().table.scrollX;if(virtualXConfig){return Object.assign({},globalVirtualXConfig,virtualXConfig);}if(scrollX){// 
return Object.assign({},globalScrollX,scrollX);}if(globalVirtualXConfig){return Object.assign({},globalVirtualXConfig,virtualXConfig);}// 
return Object.assign({},globalScrollX,scrollX);});const computeVirtualYOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{virtualYConfig,scrollY}=props;const globalVirtualYConfig=table_getConfig().table.virtualYConfig;const globalScrollY=table_getConfig().table.scrollY;if(virtualYConfig){return Object.assign({},globalVirtualYConfig,virtualYConfig);}if(scrollY){// 
return Object.assign({},globalScrollY,scrollY);}if(globalVirtualYConfig){return Object.assign({},globalVirtualYConfig,virtualYConfig);}// 
return Object.assign({},globalScrollY,scrollY);});const computeScrollbarOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.scrollbarConfig,props.scrollbarConfig);});const computeScrollbarXOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const scrollbarOpts=computeScrollbarOpts.value;return Object.assign({},scrollbarOpts.x,props.scrollbarConfig?.x||{});});const computeScrollbarYOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const scrollbarOpts=computeScrollbarOpts.value;return Object.assign({},scrollbarOpts.y,props.scrollbarConfig?.y||{});});const computeScrollbarXToTop=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const scrollbarXOpts=computeScrollbarXOpts.value;return scrollbarXOpts.position==='top';});const computeScrollbarYToLeft=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const scrollbarYOpts=computeScrollbarYOpts.value;return scrollbarYOpts.position==='left';});const computeScrollYThreshold=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const virtualYOpts=computeVirtualYOpts.value;const{threshold}=virtualYOpts;if(threshold){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(threshold);}return 0;});const computeRowHeightMaps=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return reactData.rowHeightStore;});const computeDefaultRowHeight=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const vSize=computeSize.value;const rowHeightMaps=computeRowHeightMaps.value;return rowHeightMaps[vSize||'default']||18;});const computeColumnOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.columnConfig,props.columnConfig);});const computeCurrentColumnOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.currentColumnConfig,props.currentColumnConfig);});const computeCellOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const cellOpts=Object.assign({},table_getConfig().table.cellConfig,props.cellConfig);if(cellOpts.height){cellOpts.height=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellOpts.height);}return cellOpts;});const computeHeaderCellOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const headerCellOpts=Object.assign({},table_getConfig().table.headerCellConfig,props.headerCellConfig);const defaultRowHeight=computeDefaultRowHeight.value;const cellOpts=computeCellOpts.value;let headCellHeight=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getCalcHeight(headerCellOpts.height||cellOpts.height));if($xeGantt){const{computeTaskScaleConfs}=$xeGantt.getComputeMaps();const taskScaleConfs=computeTaskScaleConfs.value;if(taskScaleConfs&&taskScaleConfs.length>2){const ganttMinHeadCellHeight=defaultRowHeight/2*taskScaleConfs.length;headCellHeight=Math.max(ganttMinHeadCellHeight,headCellHeight);}}headerCellOpts.height=headCellHeight;return headerCellOpts;});const computeFooterCellOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const footerCellOpts=Object.assign({},table_getConfig().table.footerCellConfig,props.footerCellConfig);const cellOpts=computeCellOpts.value;footerCellOpts.height=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getCalcHeight(footerCellOpts.height||cellOpts.height));return footerCellOpts;});const computeRowOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.rowConfig,props.rowConfig);});const computeAggregateOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.aggregateConfig||table_getConfig().table.rowGroupConfig,props.aggregateConfig||props.rowGroupConfig);});const computeRowGroupOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return computeAggregateOpts.value;});const computeCurrentRowOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.currentRowConfig,props.currentRowConfig);});const computeRowDragOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.rowDragConfig,props.rowDragConfig);});const computeColumnDragOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.columnDragConfig,props.columnDragConfig);});const computeResizeOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.resizeConfig,props.resizeConfig);});const computeResizableOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.resizableConfig,props.resizableConfig);});const computeSeqOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({startIndex:0},table_getConfig().table.seqConfig,props.seqConfig);});const computeRadioOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.radioConfig,props.radioConfig);});const computeCheckboxOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.checkboxConfig,props.checkboxConfig);});const computeTooltipOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().tooltip,table_getConfig().table.tooltipConfig,props.tooltipConfig);});const computeHeaderTooltipOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().tooltip,table_getConfig().table.headerTooltipConfig,props.headerTooltipConfig);});const computeFooterTooltipOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().tooltip,table_getConfig().table.footerTooltipConfig,props.footerTooltipConfig);});const computeTableTipConfig=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{tooltipStore}=reactData;const tooltipOpts=computeTooltipOpts.value;return Object.assign({},tooltipOpts,tooltipStore.currOpts);});const computeValidTipConfig=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const tooltipOpts=computeTooltipOpts.value;return Object.assign({},tooltipOpts);});const computeEditOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.editConfig,props.editConfig);});const computeSortOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({orders:['asc','desc',null]},table_getConfig().table.sortConfig,props.sortConfig);});const computeFilterOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.filterConfig,props.filterConfig);});const computeFloatingFilterOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.floatingFilterConfig,props.floatingFilterConfig);});const computeMouseOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.mouseConfig,props.mouseConfig);});const computeAreaOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.areaConfig,props.areaConfig);});const computeKeyboardOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.keyboardConfig,props.keyboardConfig);});const computeClipOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.clipConfig,props.clipConfig);});const computeFNROpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const fnrOpts=computeFnrOpts.value;return fnrOpts;});const computeFnrOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.fnrConfig,props.fnrConfig);});const computeMenuOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.menuConfig,props.menuConfig);});const computeLeftFixedWidth=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{columnStore}=reactData;const{leftList}=columnStore;let leftWidth=0;for(let i=0;i<leftList.length;i++){const column=leftList[i];leftWidth+=column.renderWidth;}return leftWidth;});const computeRightFixedWidth=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{columnStore}=reactData;const{rightList}=columnStore;let leftWidth=0;for(let i=0;i<rightList.length;i++){const column=rightList[i];leftWidth+=column.renderWidth;}return leftWidth;});const computeBodyMergeCoverFixed=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{columnStore,mergeBodyFlag}=reactData;const{mergeBodyList,visibleColumn}=internalData;const{leftList,rightList}=columnStore;const rscIndex=visibleColumn.length-rightList.length;if(mergeBodyFlag&&(leftList.length||rightList.length)){const lecIndex=leftList.length;for(let i=0;i<mergeBodyList.length;i++){const{col,colspan}=mergeBodyList[i];if(col<lecIndex||col+colspan>rscIndex){return true;}}}return false;});const computeIsHeaderRenderOptimize=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{spanMethod,footerSpanMethod,showHeaderOverflow:allColumnHeaderOverflow}=props;const{isGroup,scrollXLoad}=reactData;let isOptimizeMode=false;if(isGroup){// 
}else{// 
if(scrollXLoad&&allColumnHeaderOverflow){if(spanMethod||footerSpanMethod){// 
}else{isOptimizeMode=true;}}}return isOptimizeMode;});const computeIsBodyRenderOptimize=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{spanMethod,footerSpanMethod}=props;const{scrollXLoad,scrollYLoad,isAllOverflow,expandColumn}=reactData;const bodyMergeCoverFixed=computeBodyMergeCoverFixed.value;const expandOpts=computeExpandOpts.value;let isOptimizeMode=false;// 
if(scrollXLoad||scrollYLoad||isAllOverflow){// 
// 
// 
if(expandColumn&&expandOpts.mode!=='fixed'||bodyMergeCoverFixed||spanMethod||footerSpanMethod){// 
}else{isOptimizeMode=true;}}return isOptimizeMode;});const computeIsFooterRenderOptimize=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{spanMethod,footerSpanMethod,showFooterOverflow:allColumnFooterOverflow}=props;const{scrollXLoad}=reactData;let isOptimizeMode=false;// 
if(scrollXLoad&&allColumnFooterOverflow){if(spanMethod||footerSpanMethod){// 
}else{isOptimizeMode=true;}}return isOptimizeMode;});const computeHeaderMenu=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const menuOpts=computeMenuOpts.value;const headerOpts=menuOpts.header;return headerOpts&&headerOpts.options?headerOpts.options:[];});const computeBodyMenu=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const menuOpts=computeMenuOpts.value;const bodyOpts=menuOpts.body;return bodyOpts&&bodyOpts.options?bodyOpts.options:[];});const computeFooterMenu=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const menuOpts=computeMenuOpts.value;const footerOpts=menuOpts.footer;return footerOpts&&footerOpts.options?footerOpts.options:[];});const computeIsMenu=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const isContentMenu=computeIsContentMenu.value;return isContentMenu;});const computeIsContentMenu=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const menuOpts=computeMenuOpts.value;const headerMenu=computeHeaderMenu.value;const bodyMenu=computeBodyMenu.value;const footerMenu=computeFooterMenu.value;return!!(props.menuConfig&&isEnableConf(menuOpts)&&(headerMenu.length||bodyMenu.length||footerMenu.length));});const computeMenuList=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{ctxMenuStore}=reactData;const rest=[];ctxMenuStore.list.forEach(list=>{list.forEach(item=>{rest.push(item);});});return rest;});const computeExportOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.exportConfig,props.exportConfig);});const computeImportOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.importConfig,props.importConfig);});const computePrintOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.printConfig,props.printConfig);});const computeExpandOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.expandConfig,props.expandConfig);});const computeTreeOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.treeConfig,props.treeConfig);});const computeEmptyOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.emptyRender,props.emptyRender);});const computeLoadingOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.loadingConfig,props.loadingConfig);});const computeCellOffsetWidth=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return props.border?Math.max(2,Math.ceil(reactData.scrollbarWidth/reactData.tableColumn.length)):1;});const computeCustomOpts=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{return Object.assign({},table_getConfig().table.customConfig,props.customConfig);});const computeTableRowExpandedList=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{tableData,rowExpandedFlag,expandColumn,rowGroupExpandedFlag,treeExpandedFlag}=reactData;const{visibleDataRowIdData,rowExpandedMaps}=internalData;const expandList=[];if(tableData.length&&expandColumn&&rowExpandedFlag&&rowGroupExpandedFlag&&treeExpandedFlag){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(rowExpandedMaps,(row,rowid)=>{if(visibleDataRowIdData[rowid]){expandList.push(row);}});}return expandList;});const computeAutoWidthColumnList=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{visibleColumn}=internalData;const{tableColumn}=reactData;return tableColumn.length||visibleColumn.length?visibleColumn.filter(column=>column.width==='auto'||column.minWidth==='auto'):[];});const computeFixedColumnSize=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{tableColumn}=reactData;const{collectColumn}=internalData;let fixedSize=0;// 
if(tableColumn.length&&collectColumn.length){collectColumn.forEach(column=>{if(column.renderFixed){fixedSize++;}});}return fixedSize;});const computeIsMaxFixedColumn=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const fixedColumnSize=computeFixedColumnSize.value;const columnOpts=computeColumnOpts.value;const{maxFixedSize}=columnOpts;if(maxFixedSize){return fixedColumnSize>=maxFixedSize;}return false;});const computeTableBorder=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{border}=props;if(border===true){return'full';}if(border){return border;}return'default';});const computeIsAllCheckboxDisabled=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{treeConfig}=props;const{tableData}=reactData;const{tableFullData}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{strict,checkMethod}=checkboxOpts;if(strict){if(tableData.length||tableFullData.length){if(checkMethod){if(treeConfig){// 
}// 
return tableFullData.every(row=>!checkMethod({$table:$xeTable,row}));}return false;}return true;}return false;});const computeVirtualScrollBars=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{overflowX,scrollXLoad,overflowY,scrollYLoad}=reactData;return{x:overflowX&&scrollXLoad,y:overflowY&&scrollYLoad};});const computeRowGroupFields=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const rowGroupOpts=computeRowGroupOpts.value;return rowGroupOpts.groupFields;});const computeRowGroupColumns=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(()=>{const{rowGroupList}=reactData;const{fullColumnFieldData}=internalData;const rgColumns=[];rowGroupList.forEach(aggConf=>{const colRest=fullColumnFieldData[aggConf.field];if(colRest){rgColumns.push(colRest.column);}});return rgColumns;});const refMaps={refElem,refTooltip,refValidTooltip,refTableFilter,refTableCustom,refTableMenu,refTableHeader,refTableBody,refTableFooter,refTableLeftHeader,refTableLeftBody,refTableLeftFooter,refTableRightHeader,refTableRightBody,refTableRightFooter,refLeftContainer,refRightContainer,refColResizeBar,refRowResizeBar,refScrollXVirtualElem,refScrollYVirtualElem,refScrollXHandleElem,refScrollYHandleElem,refScrollXSpaceElem,refScrollYSpaceElem};const computeMaps={computeSize,computeTableId,computeValidOpts,computeRowField,computeVirtualXOpts,computeVirtualYOpts,computeScrollbarOpts,computeScrollbarXOpts,computeScrollbarYOpts,computeScrollbarXToTop,computeScrollbarYToLeft,computeColumnOpts,computeCurrentColumnOpts,computeScrollXThreshold,computeScrollYThreshold,computeRowHeightMaps,computeDefaultRowHeight,computeCellOpts,computeHeaderCellOpts,computeFooterCellOpts,computeRowOpts,computeAggregateOpts,computeRowGroupOpts,computeCurrentRowOpts,computeRowDragOpts,computeColumnDragOpts,computeResizeOpts,computeResizableOpts,computeSeqOpts,computeRadioOpts,computeCheckboxOpts,computeTooltipOpts,computeHeaderTooltipOpts,computeFooterTooltipOpts,computeEditOpts,computeSortOpts,computeFilterOpts,computeFloatingFilterOpts,computeMouseOpts,computeAreaOpts,computeKeyboardOpts,computeClipOpts,computeFnrOpts,computeHeaderMenu,computeBodyMenu,computeFooterMenu,computeIsMenu,computeIsContentMenu,computeMenuList,computeMenuOpts,computeExportOpts,computeImportOpts,computePrintOpts,computeExpandOpts,computeTreeOpts,computeEmptyOpts,computeLoadingOpts,computeCellOffsetWidth,computeCustomOpts,computeLeftFixedWidth,computeRightFixedWidth,computeBodyMergeCoverFixed,computeFixedColumnSize,computeIsMaxFixedColumn,computeIsAllCheckboxDisabled,computeIsHeaderRenderOptimize,computeIsBodyRenderOptimize,computeIsFooterRenderOptimize,computeVirtualScrollBars,computeRowGroupFields,computeRowGroupColumns,computeFNROpts,computeSXOpts,computeSYOpts};const $xeTable={xID,props:props,context,reactData,internalData,getRefMaps:()=>refMaps,getComputeMaps:()=>computeMaps,xeGrid:$xeGrid,xeGantt:$xeGantt,// 
xegrid:$xeGrid};const eqCellValue=(row1,row2,field)=>{const val1=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row1,field);const val2=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row2,field);if(eqEmptyValue(val1)&&eqEmptyValue(val2)){return true;}if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val1)||external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(val1)){return''+val1===''+val2;}return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val1,val2);};const handleKeyField=()=>{const keyField=computeRowField.value;internalData.currKeyField=keyField;internalData.isCurrDeepKey=hasDeepKey(keyField);};const hangleStorageDefaultValue=(value,isAll)=>{return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(value)?value:isAll;};const getNextSortOrder=column=>{const sortOpts=computeSortOpts.value;const{orders=[]}=sortOpts;const currOrder=column.order||null;const oIndex=orders.indexOf(currOrder)+1;return orders[oIndex<orders.length?oIndex:0];};const getCustomStorageMap=id=>{const version=table_getConfig().version;const rest=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringJSON(localStorage.getItem(customStorageKey)||'');const maps=rest&&rest._v===version?rest:{_v:version};return(id?maps[id]:maps)||{};};const setCustomStorageMap=(id,data)=>{const version=table_getConfig().version;const maps=getCustomStorageMap();maps[id]=data||undefined;maps._v=version;localStorage.setItem(customStorageKey,external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toJSONString(maps));};const getRecoverRowMaps=keyMaps=>{const{fullAllDataRowIdData}=internalData;const restKeys={};external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(keyMaps,(row,rowid)=>{if(fullAllDataRowIdData[rowid]){restKeys[rowid]=row;}});return restKeys;};const handleReserveRow=reserveRowMap=>{const{fullDataRowIdData}=internalData;const reserveList=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(reserveRowMap,(item,rowid)=>{if(fullDataRowIdData[rowid]&&$xeTable.findRowIndexOf(reserveList,fullDataRowIdData[rowid].row)===-1){reserveList.push(fullDataRowIdData[rowid].row);}});return reserveList;};const handleVirtualXVisible=()=>{const{isScrollXBig,scrollXWidth}=reactData;const{elemStore,visibleColumn,fullColumnIdData}=internalData;const leftFixedWidth=computeLeftFixedWidth.value;const rightFixedWidth=computeRightFixedWidth.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);if(bodyScrollElem){const clientWidth=bodyScrollElem.clientWidth;let scrollLeft=bodyScrollElem.scrollLeft;if(isScrollXBig){scrollLeft=Math.ceil((scrollXWidth-clientWidth)*Math.min(1,scrollLeft/(maxXWidth-clientWidth)));}const startLeft=scrollLeft+leftFixedWidth;const endLeft=scrollLeft+clientWidth-rightFixedWidth;let leftIndex=0;let rightIndex=visibleColumn.length;while(leftIndex<rightIndex){const cIndex=Math.floor((leftIndex+rightIndex)/2);const column=visibleColumn[cIndex];const colid=column.id;const colRest=fullColumnIdData[colid]||{};if(colRest.oLeft<=startLeft){leftIndex=cIndex+1;}else{rightIndex=cIndex;}}let visibleSize=0;const toVisibleIndex=leftIndex===visibleColumn.length?leftIndex:Math.max(0,leftIndex<visibleColumn.length?leftIndex-2:0);for(let cIndex=toVisibleIndex,cLen=visibleColumn.length;cIndex<cLen;cIndex++){const column=visibleColumn[cIndex];const colid=column.id;const colRest=fullColumnIdData[colid]||{};visibleSize++;if(colRest.oLeft>endLeft||visibleSize>=60){break;}}return{toVisibleIndex:Math.max(0,toVisibleIndex),visibleSize:Math.max(1,visibleSize)};}return{toVisibleIndex:0,visibleSize:6};};const calcVarRowHeightConfig=(sizeKey,sizeEl)=>{const{rowHeightStore}=reactData;if(sizeEl&&sizeEl.clientHeight){rowHeightStore[sizeKey]=sizeEl.clientHeight;}};const computeRowHeight=()=>{const{isAllOverflow}=reactData;const tableHeader=refTableHeader.value;const tableBody=refTableBody.value;const tableBodyElem=tableBody?tableBody.$el:null;const defaultRowHeight=computeDefaultRowHeight.value;let rowHeight=0;if(isAllOverflow){if(tableBodyElem){const tableHeaderElem=tableHeader?tableHeader.$el:null;let firstTrElem;firstTrElem=tableBodyElem.querySelector('tr');if(!firstTrElem&&tableHeaderElem){firstTrElem=tableHeaderElem.querySelector('tr');}if(firstTrElem){rowHeight=firstTrElem.clientHeight;}}if(!rowHeight){rowHeight=defaultRowHeight;}}else{rowHeight=defaultRowHeight;}//  18px 
return Math.max(18,rowHeight);};const handleVirtualYVisible=()=>{const{isAllOverflow,expandColumn,isScrollYBig,scrollYHeight}=reactData;const{elemStore,isResizeCellHeight,afterFullData,fullAllDataRowIdData}=internalData;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);if(bodyScrollElem){const clientHeight=bodyScrollElem.clientHeight;let scrollTop=bodyScrollElem.scrollTop;if(isScrollYBig){scrollTop=Math.ceil((scrollYHeight-clientHeight)*Math.min(1,scrollTop/(maxYHeight-clientHeight)));}const startTop=scrollTop;const endTop=scrollTop+clientHeight;let toVisibleIndex=-1;let visibleSize=0;const isCustomCellHeight=isResizeCellHeight||cellOpts.height||rowOpts.height;if(!isCustomCellHeight&&!expandColumn&&isAllOverflow){toVisibleIndex=Math.floor(startTop/defaultRowHeight)-1;visibleSize=Math.ceil(clientHeight/defaultRowHeight)+1;}else{const{handleGetRowId}=createHandleGetRowId($xeTable);let leftIndex=0;let rightIndex=afterFullData.length;while(leftIndex<rightIndex){const rIndex=Math.floor((leftIndex+rightIndex)/2);const row=afterFullData[rIndex];const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid]||{};if(rowRest.oTop<=startTop){leftIndex=rIndex+1;}else{rightIndex=rIndex;}}toVisibleIndex=leftIndex===afterFullData.length?leftIndex:Math.max(0,leftIndex<afterFullData.length?leftIndex-2:0);for(let rIndex=toVisibleIndex,rLen=afterFullData.length;rIndex<rLen;rIndex++){const row=afterFullData[rIndex];const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid]||{};visibleSize++;if(rowRest.oTop>endTop||visibleSize>=100){break;}}}return{toVisibleIndex:Math.max(0,toVisibleIndex),visibleSize:Math.max(6,visibleSize)};}return{toVisibleIndex:0,visibleSize:6};};const calculateMergerOffsetIndex=(list,offsetItem,type)=>{for(let mcIndex=0,len=list.length;mcIndex<len;mcIndex++){const mergeItem=list[mcIndex];const{startIndex,endIndex}=offsetItem;const mergeStartIndex=mergeItem[type];const mergeSpanNumber=mergeItem[type+'span'];const mergeEndIndex=mergeStartIndex+mergeSpanNumber;if(mergeStartIndex<startIndex&&startIndex<mergeEndIndex){offsetItem.startIndex=mergeStartIndex;}if(mergeStartIndex<endIndex&&endIndex<mergeEndIndex){offsetItem.endIndex=mergeEndIndex;}if(offsetItem.startIndex!==startIndex||offsetItem.endIndex!==endIndex){mcIndex=-1;}}};function buildMergeData(mergeConfigs){const mergeMaps={};if(mergeConfigs&&mergeConfigs.length){for(let mIndex=0;mIndex<mergeConfigs.length;mIndex++){const{row:_rowIndex,col:_columnIndex,rowspan:mergeRowspan,colspan:mergeColspan}=mergeConfigs[mIndex];for(let i=0;i<mergeRowspan;i++){for(let j=0;j<mergeColspan;j++){mergeMaps[`${_rowIndex+i}:${_columnIndex+j}`]=!i&&!j?{rowspan:mergeRowspan,colspan:mergeColspan}:{rowspan:0,colspan:0};}}}}return mergeMaps;}const handleUpdateMergeBodyCells=merges=>{internalData.mergeBodyList=[];internalData.mergeBodyMaps={};internalData.mergeBodyCellMaps={};$xeTable.setMergeCells(merges);};const handleBodyMerge=merges=>{const{fullAllDataRowIdData,fullColumnIdData,visibleColumn,afterFullData,mergeBodyList,mergeBodyMaps}=internalData;if(merges){const{handleGetRowId}=createHandleGetRowId($xeTable);if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)){merges=[merges];}merges.forEach(item=>{let{row:margeRow,col:margeCol,rowspan,colspan}=item;let mergeRowIndex=-1;let mergeColumnIndex=-1;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeRow)){mergeRowIndex=margeRow;}else{const rowid=margeRow?handleGetRowId(margeRow):null;const rowRest=rowid?fullAllDataRowIdData[rowid]:null;if(rowRest){mergeRowIndex=rowRest._index;}}if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeCol)){mergeColumnIndex=margeCol;}else{const colid=margeCol?margeCol.id:null;const colRest=colid?fullColumnIdData[colid]:null;if(colRest){mergeColumnIndex=colRest._index;}}if(mergeRowIndex>-1&&mergeColumnIndex>-1&&(rowspan||colspan)){rowspan=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(rowspan)||1;colspan=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(colspan)||1;if(rowspan>1||colspan>1){const row=afterFullData[mergeRowIndex];const column=visibleColumn[mergeColumnIndex];let mergeItem=mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`];if(mergeItem){mergeItem.rowspan=rowspan;mergeItem.colspan=colspan;mergeItem._rowspan=rowspan;mergeItem._colspan=colspan;}else{mergeItem={row:mergeRowIndex,col:mergeColumnIndex,rowspan,colspan,_row:row,_col:column,_rowspan:rowspan,_colspan:colspan};mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`]=mergeItem;mergeBodyList.push(mergeItem);}}}});}};const removeBodyMerges=merges=>{const{mergeBodyList,fullColumnIdData,fullAllDataRowIdData,mergeBodyMaps}=internalData;const rest=[];if(merges){const{handleGetRowId}=createHandleGetRowId($xeTable);if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)){merges=[merges];}merges.forEach(item=>{const{row:margeRow,col:margeCol}=item;let mergeRowIndex=-1;let mergeColumnIndex=-1;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeRow)){mergeRowIndex=margeRow;}else{const rowid=margeRow?handleGetRowId(margeRow):null;const rowRest=rowid?fullAllDataRowIdData[rowid]:null;if(rowRest){mergeRowIndex=rowRest._index;}}if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeCol)){mergeColumnIndex=margeCol;}else{const colid=margeCol?margeCol.id:null;const colRest=colid?fullColumnIdData[colid]:null;if(colRest){mergeColumnIndex=colRest._index;}}const mcIndex=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(mergeBodyList,item=>item.row===mergeRowIndex&&item.col===mergeColumnIndex);if(mcIndex>-1){const rItems=mergeBodyList.splice(mcIndex,1);const item=rItems[0];if(item){rest.push(rItems[0]);if(mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`]){delete mergeBodyMaps[`${mergeRowIndex}:${mergeColumnIndex}`];}}}});}return rest;};const handleUpdateMergeHeaderCells=merges=>{internalData.mergeHeaderList=[];internalData.mergeHeaderMaps={};internalData.mergeHeaderCellMaps={};$xeTable.setMergeHeaderCells(merges);};const handleHeaderMerge=merges=>{const{showCustomHeader}=props;const{footerTableData}=reactData;const{mergeHeaderList,mergeHeaderMaps,fullColumnIdData}=internalData;if(merges){const{visibleColumn}=internalData;if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)){merges=[merges];}merges.forEach(item=>{let{row:margeRow,col:margeCol,rowspan,colspan}=item;const mergeRowIndex=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeRow)?margeRow:-1;let mergeColumnIndex=-1;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeCol)){mergeColumnIndex=margeCol;}else{const colid=margeCol?margeCol.id:null;const colRest=colid?fullColumnIdData[colid]:null;if(colRest){mergeColumnIndex=colRest._index;}}if(mergeRowIndex>-1&&mergeColumnIndex>-1&&(rowspan||colspan)){rowspan=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(rowspan)||1;colspan=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(colspan)||1;if(!showCustomHeader&&rowspan>1){errLog('vxe.error.notSupportProp',['[table] show-custom-header=false',`rowspan=${rowspan}`,'rowspan=1']);return;}if(rowspan>1||colspan>1){const row=footerTableData[mergeRowIndex];const column=visibleColumn[mergeColumnIndex];let mergeItem=mergeHeaderMaps[`${mergeRowIndex}:${mergeColumnIndex}`];if(mergeItem){mergeItem.rowspan=rowspan;mergeItem.colspan=colspan;mergeItem._rowspan=rowspan;mergeItem._colspan=colspan;}else{mergeItem={row:mergeRowIndex,col:mergeColumnIndex,rowspan,colspan,_row:row,_col:column,_rowspan:rowspan,_colspan:colspan};mergeHeaderMaps[`${mergeRowIndex}:${mergeColumnIndex}`]=mergeItem;mergeHeaderList.push(mergeItem);}}}});}};const removeHeaderMerges=merges=>{const{mergeHeaderList,fullColumnIdData,mergeHeaderMaps}=internalData;const rest=[];if(merges){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)){merges=[merges];}merges.forEach(item=>{const{row:margeRow,col:margeCol}=item;const mergeRowIndex=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeRow)?margeRow:-1;let mergeColumnIndex=-1;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeCol)){mergeColumnIndex=margeCol;}else{const colid=margeCol?margeCol.id:null;const colRest=colid?fullColumnIdData[colid]:null;if(colRest){mergeColumnIndex=colRest._index;}}const mcIndex=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(mergeHeaderList,item=>item.row===mergeRowIndex&&item.col===mergeColumnIndex);if(mcIndex>-1){const rItems=mergeHeaderList.splice(mcIndex,1);const item=rItems[0];if(item){rest.push(item);if(mergeHeaderMaps[`${mergeRowIndex}:${mergeColumnIndex}`]){delete mergeHeaderMaps[`${mergeRowIndex}:${mergeColumnIndex}`];}}}});}return rest;};const handleUpdateMergeFooterCells=merges=>{internalData.mergeFooterList=[];internalData.mergeFooterMaps={};internalData.mergeFooterCellMaps={};$xeTable.setMergeFooterCells(merges);};const handleFooterMerge=merges=>{const{footerTableData}=reactData;const{mergeFooterList,mergeFooterMaps,fullColumnIdData}=internalData;if(merges){const{visibleColumn}=internalData;if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)){merges=[merges];}merges.forEach(item=>{let{row:margeRow,col:margeCol,rowspan,colspan}=item;const mergeRowIndex=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeRow)?margeRow:-1;let mergeColumnIndex=-1;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeCol)){mergeColumnIndex=margeCol;}else{const colid=margeCol?margeCol.id:null;const colRest=colid?fullColumnIdData[colid]:null;if(colRest){mergeColumnIndex=colRest._index;}}if(mergeRowIndex>-1&&mergeColumnIndex>-1&&(rowspan||colspan)){rowspan=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(rowspan)||1;colspan=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(colspan)||1;if(rowspan>1||colspan>1){const row=footerTableData[mergeRowIndex];const column=visibleColumn[mergeColumnIndex];let mergeItem=mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`];if(mergeItem){mergeItem.rowspan=rowspan;mergeItem.colspan=colspan;mergeItem._rowspan=rowspan;mergeItem._colspan=colspan;}else{mergeItem={row:mergeRowIndex,col:mergeColumnIndex,rowspan,colspan,_row:row,_col:column,_rowspan:rowspan,_colspan:colspan};mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`]=mergeItem;mergeFooterList.push(mergeItem);}}}});}};const removeFooterMerges=merges=>{const{mergeFooterList,fullColumnIdData,mergeFooterMaps}=internalData;const rest=[];if(merges){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)){merges=[merges];}merges.forEach(item=>{const{row:margeRow,col:margeCol}=item;const mergeRowIndex=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeRow)?margeRow:-1;let mergeColumnIndex=-1;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(margeCol)){mergeColumnIndex=margeCol;}else{const colid=margeCol?margeCol.id:null;const colRest=colid?fullColumnIdData[colid]:null;if(colRest){mergeColumnIndex=colRest._index;}}const mcIndex=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(mergeFooterList,item=>item.row===mergeRowIndex&&item.col===mergeColumnIndex);if(mcIndex>-1){const rItems=mergeFooterList.splice(mcIndex,1);const item=rItems[0];if(item){rest.push(item);if(mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`]){delete mergeFooterMaps[`${mergeRowIndex}:${mergeColumnIndex}`];}}}});}return rest;};const handleSortEvent=(evnt,sortConfs,isUpdate)=>{const{tableFullColumn}=internalData;const sortOpts=computeSortOpts.value;const{multiple,remote,orders}=sortOpts;if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortConfs)){sortConfs=[sortConfs];}if(sortConfs&&sortConfs.length){const orderActiveMaps={};if(!multiple){sortConfs=[sortConfs[0]];tableFullColumn.forEach(column=>{if(column.order){orderActiveMaps[column.id]=column;}});}const sortColMpps={};let firstColumn=null;sortConfs.forEach((confs,index)=>{let{field,order}=confs;let column=field;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(field)){column=$xeTable.getColumnByField(field);}if(!firstColumn){firstColumn=column;}if(column&&column.sortable){if(orders&&orders.indexOf(order)===-1){order=getNextSortOrder(column);}if(column.order!==order){column.order=order;}column.sortTime=Date.now()+index;sortColMpps[column.id]=column;}});if(!multiple){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(orderActiveMaps,(oaCol,oaId)=>{if(!sortColMpps[oaId]){oaCol.order=null;}});}if(isUpdate){if(!remote){$xeTable.handleTableData(true);}}if(evnt){$xeTable.handleColumnSortEvent(evnt,firstColumn);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateRowOffsetTop();$xeTable.updateCellAreas();return updateStyle();});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};const clearAllSort=()=>{const{tableFullColumn}=internalData;tableFullColumn.forEach(column=>{column.order=null;});};const calcTableHeight=key=>{const{editConfig,editRules}=props;const{parentHeight}=reactData;let val=props[key];if(key==='minHeight'){const defMinHeight=table_getConfig().table.minHeight;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(val)){if(eqEmptyValue(defMinHeight)){// 
if(editRules&&isEnableConf(editConfig)){val=144;}}else{val=defMinHeight;}}}let num=0;if(val){if(val==='100%'||val==='auto'){num=parentHeight;}else{const excludeHeight=$xeTable.getExcludeHeight();if(isScale(val)){num=Math.floor((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(val)||1)/100*parentHeight);}else{num=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val);}num=Math.max(40,num-excludeHeight);}}return num;};const handleCustomRestore=storeData=>{const{aggregateConfig,rowGroupConfig}=props;const{collectColumn}=internalData;const customOpts=computeCustomOpts.value;const{storage,storeOptions}=customOpts;const isAllCustom=storage===true;const storageOpts=Object.assign({},isAllCustom?{}:storage||{},storeOptions);const isCustomResizable=hangleStorageDefaultValue(storageOpts.resizable,isAllCustom);const isCustomVisible=hangleStorageDefaultValue(storageOpts.visible,isAllCustom);const isCustomFixed=hangleStorageDefaultValue(storageOpts.fixed,isAllCustom);const isCustomSort=hangleStorageDefaultValue(storageOpts.sort,isAllCustom);const isCustomAggGroup=hangleStorageDefaultValue(storageOpts.aggGroup,isAllCustom);const isCustomAggFunc=hangleStorageDefaultValue(storageOpts.aggFunc,isAllCustom);let{resizableData,sortData,visibleData,fixedData,aggGroupData,aggFuncData}=storeData;// 
if(isCustomResizable&&resizableData||isCustomSort&&sortData||isCustomVisible&&visibleData||isCustomFixed&&fixedData||isCustomAggGroup&&aggGroupData||isCustomAggFunc&&aggFuncData){const sortColMaps={};if(isCustomSort&&sortData){// 
if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortData)){const sortRests=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(sortData,(index,colKey)=>{sortRests.push({key:colKey,index});});sortData=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(sortRests,{field:'index',order:'asc'}).map(item=>({k:item.key}));}let colNum=1;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(sortData,(sObj,index,sOjs,path,pSObj)=>{sortColMaps[sObj.k]={key:sObj.k,sNum:colNum++,pKey:pSObj?pSObj.k:null};},{children:'c'});}const colKeyMaps={};const allCols=[];const aggGroupConfs=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn,(column,index,items,path,parentColumn)=>{const colKey=column.getKey();// 
if(!parentColumn){if(isCustomFixed&&fixedData&&fixedData[colKey]!==undefined){column.fixed=fixedData[colKey];}}if(isCustomResizable&&resizableData&&external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(resizableData[colKey])){column.resizeWidth=resizableData[colKey];}if(isCustomVisible&&visibleData&&external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(visibleData[colKey])){column.visible=visibleData[colKey];}if(isCustomAggFunc&&aggFuncData&&(aggregateConfig||rowGroupConfig)&&aggFuncData[colKey]){column.aggFunc=aggFuncData[colKey];}if(isCustomAggGroup&&aggGroupData&&aggGroupData[colKey]){aggGroupConfs.push({field:column.field});}colKeyMaps[colKey]=column;allCols.push(column);});if((aggregateConfig||rowGroupConfig)&&aggGroupConfs.length){const groupRest=handleGroupData(internalData.tableFullData,aggGroupConfs);internalData.tableFullTreeData=[];internalData.tableFullGroupData=groupRest.treeData;reactData.isRowGroupStatus=true;reactData.rowGroupList=aggGroupConfs;$xeTable.cacheRowMap(false);}// 
if(isCustomSort&&sortData){allCols.forEach(column=>{const colKey=column.getKey();const scItem=sortColMaps[colKey];if(scItem){const parentColumn=scItem.pKey?colKeyMaps[scItem.pKey]:null;column.parentId=parentColumn?parentColumn.id:null;column.renderSortNumber=scItem.sNum;}});const newCollectCols=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(allCols,'renderSortNumber'),{key:'id',parentKey:'parentId',children:'children'});internalData.collectColumn=newCollectCols;internalData.tableFullColumn=getColumnList(newCollectCols);}reactData.isCustomStatus=true;}else{reactData.isCustomStatus=false;}};/**
         * 
         */const restoreCustomStorage=()=>{const{customConfig}=props;const tableId=computeTableId.value;const customOpts=computeCustomOpts.value;const{storage,restoreStore,storeOptions}=customOpts;const isAllCustom=storage===true;const storageOpts=Object.assign({},isAllCustom?{}:storage||{},storeOptions);const isCustomResizable=hangleStorageDefaultValue(storageOpts.resizable,isAllCustom);const isCustomVisible=hangleStorageDefaultValue(storageOpts.visible,isAllCustom);const isCustomFixed=hangleStorageDefaultValue(storageOpts.fixed,isAllCustom);const isCustomSort=hangleStorageDefaultValue(storageOpts.sort,isAllCustom);const isCustomAggGroup=hangleStorageDefaultValue(storageOpts.aggGroup,isAllCustom);const isCustomAggFunc=hangleStorageDefaultValue(storageOpts.aggFunc,isAllCustom);if(storage&&(customConfig?isEnableConf(customOpts):customOpts.enabled)&&(isCustomResizable||isCustomVisible||isCustomFixed||isCustomSort||isCustomAggGroup||isCustomAggFunc)){if(!tableId){errLog('vxe.error.reqProp',['id']);return;}const storeData=getCustomStorageMap(tableId);if(restoreStore){return Promise.resolve(restoreStore({$table:$xeTable,id:tableId,type:'restore',storeData})).then(storeData=>{if(!storeData){return;}return handleCustomRestore(storeData);}).catch(e=>e);}else{return handleCustomRestore(storeData);}}};/**
         *  Map
         * 
         */const cacheColumnMap=()=>{const{treeConfig,showOverflow}=props;const{tableFullColumn,collectColumn}=internalData;const fullColIdData=internalData.fullColumnIdData={};const fullColFieldData=internalData.fullColumnFieldData={};const mouseOpts=computeMouseOpts.value;const expandOpts=computeExpandOpts.value;const columnOpts=computeColumnOpts.value;const columnDragOpts=computeColumnDragOpts.value;const virtualYOpts=computeVirtualYOpts.value;const{isCrossDrag,isSelfToChildDrag}=columnDragOpts;const customOpts=computeCustomOpts.value;const treeOpts=computeTreeOpts.value;const{storage}=customOpts;const rowOpts=computeRowOpts.value;const isGroup=collectColumn.some(hasChildrenList);let isAllOverflow=!!showOverflow;let rowGroupColumn;let expandColumn;let treeNodeColumn;let checkboxColumn;let radioColumn;let htmlColumn;let hasFixed;const handleFunc=(column,index,items,path,parentColumn)=>{const{id:colid,field,fixed,type,treeNode,rowGroupNode}=column;const rest={$index:-1,_index:-1,column,colid,index,items,parent:parentColumn||null,width:0,oLeft:0};if(field){if(fullColFieldData[field]){errLog('vxe.error.colRepet',['field',field]);}fullColFieldData[field]=rest;}else{if(storage&&!type){errLog('vxe.error.reqSupportProp',['storage',`[${type?`type=${type}`:`title=${column.getTitle()}`}]field=?`]);}if(columnOpts.drag&&(isCrossDrag||isSelfToChildDrag)){errLog('vxe.error.reqSupportProp',['column-drag-config.isCrossDrag | column-drag-config.isSelfToChildDrag',`${column.getTitle()||type||''} -> field=?`]);}}if(!hasFixed&&fixed){hasFixed=fixed;}if(!htmlColumn&&type==='html'){htmlColumn=column;}if(treeNode){if(treeNodeColumn){warnLog('vxe.error.colRepet',['tree-node',treeNode]);}if(!treeNodeColumn){treeNodeColumn=column;}}if(rowGroupNode){if(treeNodeColumn){warnLog('vxe.error.colRepet',['row-group-node',rowGroupNode]);}if(!rowGroupColumn){rowGroupColumn=column;}}if(type==='expand'){if(expandColumn){warnLog('vxe.error.colRepet',['type',type]);}if(!expandColumn){expandColumn=column;}}if(type==='checkbox'){if(checkboxColumn){warnLog('vxe.error.colRepet',['type',type]);}if(!checkboxColumn){checkboxColumn=column;}}else if(type==='radio'){if(radioColumn){warnLog('vxe.error.colRepet',['type',type]);}if(!radioColumn){radioColumn=column;}}if(isAllOverflow&&column.showOverflow===false){isAllOverflow=false;}if(fullColIdData[colid]){errLog('vxe.error.colRepet',['colId',colid]);}fullColIdData[colid]=rest;};if(isGroup){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn,(column,index,items,path,parentColumn,nodes)=>{column.level=nodes.length;handleFunc(column,index,items,path,parentColumn);});}else{tableFullColumn.forEach(handleFunc);}if(expandColumn&&expandOpts.mode!=='fixed'&&virtualYOpts.enabled){warnLog('vxe.error.notConflictProp',['column.type="expand','virtual-y-config.enabled=false']);}if(expandColumn&&expandOpts.mode!=='fixed'&&mouseOpts.area){errLog('vxe.error.errConflicts',['mouse-config.area','column.type=expand']);}if(expandColumn&&expandOpts.mode!=='inside'&&treeConfig&&!treeOpts.transform){errLog('vxe.error.notConflictProp',['tree-config.transform=false','expand-config.mode=fixed']);}if(htmlColumn){if(!columnOpts.useKey){errLog('vxe.error.notSupportProp',['column.type=html','column-config.useKey=false','column-config.useKey=true']);}if(!rowOpts.useKey){errLog('vxe.error.notSupportProp',['column.type=html','row-config.useKey=false','row-config.useKey=true']);}}reactData.isGroup=isGroup;reactData.rowGroupColumn=rowGroupColumn;reactData.treeNodeColumn=treeNodeColumn;reactData.expandColumn=expandColumn;reactData.checkboxColumn=checkboxColumn;reactData.radioColumn=radioColumn;reactData.isAllOverflow=isAllOverflow;};const updateHeight=()=>{internalData.customHeight=calcTableHeight('height');internalData.customMinHeight=calcTableHeight('minHeight');internalData.customMaxHeight=calcTableHeight('maxHeight');// 
if(reactData.scrollYLoad&&!(internalData.customHeight||internalData.customMinHeight||internalData.customMaxHeight)){internalData.customHeight=300;}};/**
         * 
         */const calcColumnAutoWidth=(column,wrapperEl)=>{const columnOpts=computeColumnOpts.value;const{autoOptions}=columnOpts;const{isCalcHeader,isCalcBody,isCalcFooter}=autoOptions||{};const querySelections=[];if(isCalcHeader){querySelections.push(`.vxe-header-cell--wrapper[colid="${column.id}"]`);}if(isCalcBody){querySelections.push(`.vxe-body-cell--wrapper[colid="${column.id}"]`);}if(isCalcFooter){querySelections.push(`.vxe-footer-cell--wrapper[colid="${column.id}"]`);}const cellElemList=querySelections.length?wrapperEl.querySelectorAll(querySelections.join(',')):[];let leftRightPadding=0;const firstCellEl=cellElemList[0];if(firstCellEl&&firstCellEl.parentElement){const cellStyle=getComputedStyle(firstCellEl.parentElement);leftRightPadding=Math.ceil(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellStyle.paddingLeft)+external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellStyle.paddingRight));}let colWidth=column.renderAutoWidth-leftRightPadding;for(let i=0;i<cellElemList.length;i++){const celEl=cellElemList[i];colWidth=Math.max(colWidth,celEl?Math.ceil(celEl.scrollWidth)+4:0);}return colWidth+leftRightPadding;};/**
         * 
         */const calcCellWidth=()=>{const autoWidthColumnList=computeAutoWidthColumnList.value;const{fullColumnIdData}=internalData;const el=refElem.value;if(el){el.setAttribute('data-calc-col','Y');autoWidthColumnList.forEach(column=>{const colid=column.id;const colRest=fullColumnIdData[colid];const colWidth=calcColumnAutoWidth(column,el);if(colRest){colRest.width=Math.max(colWidth,colRest.width);}column.renderAutoWidth=colWidth;});$xeTable.analyColumnWidth();el.removeAttribute('data-calc-col');}};/**
         * 
         *  px% 
         * 
         * 
         *  width=60 width=60px width=10% min-width=60 min-width=60px min-width=10%
         */const autoCellWidth=()=>{const{elemStore}=internalData;const bodyWrapperElem=getRefElem(elemStore['main-body-wrapper']);if(!bodyWrapperElem){return;}const yHandleEl=refScrollYHandleElem.value;if(!yHandleEl){return;}const xHandleEl=refScrollXHandleElem.value;if(!xHandleEl){return;}let tWidth=0;const minCellWidth=40;//  40px
const bodyWidth=bodyWrapperElem.clientWidth;let remainWidth=bodyWidth;let meanWidth=remainWidth/100;const{fit}=props;const{columnStore}=reactData;const{resizeList,pxMinList,autoMinList,pxList,scaleList,scaleMinList,autoList,remainList}=columnStore;// 
pxMinList.forEach(column=>{const minWidth=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.minWidth);tWidth+=minWidth;column.renderWidth=minWidth;});// 
autoMinList.forEach(column=>{const caWidth=Math.max(60,external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.renderAutoWidth));tWidth+=caWidth;column.renderWidth=caWidth;});// 
scaleMinList.forEach(column=>{const smWidth=Math.floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.minWidth)*meanWidth);tWidth+=smWidth;column.renderWidth=smWidth;});// 
scaleList.forEach(column=>{const sfWidth=Math.floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.width)*meanWidth);tWidth+=sfWidth;column.renderWidth=sfWidth;});// 
pxList.forEach(column=>{const pWidth=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.width);tWidth+=pWidth;column.renderWidth=pWidth;});// 
autoList.forEach(column=>{const aWidth=Math.max(60,external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.renderAutoWidth));tWidth+=aWidth;column.renderWidth=aWidth;});// 
resizeList.forEach(column=>{const reWidth=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.resizeWidth);tWidth+=reWidth;column.renderWidth=reWidth;});remainWidth-=tWidth;meanWidth=remainWidth>0?Math.floor(remainWidth/(scaleMinList.length+pxMinList.length+autoMinList.length+remainList.length)):0;if(fit){if(remainWidth>0){scaleMinList.concat(pxMinList).concat(autoMinList).forEach(column=>{tWidth+=meanWidth;column.renderWidth+=meanWidth;});}}else{meanWidth=minCellWidth;}// 
remainList.forEach(column=>{const width=Math.max(meanWidth,minCellWidth);column.renderWidth=width;tWidth+=width;});if(fit){/**
                 * 
                 * 
                 */const dynamicList=scaleList.concat(scaleMinList).concat(pxMinList).concat(autoMinList).concat(remainList);let dynamicSize=dynamicList.length-1;if(dynamicSize>0){let i=bodyWidth-tWidth;if(i>0){while(i>0&&dynamicSize>=0){i--;dynamicList[dynamicSize--].renderWidth++;}tWidth=bodyWidth;}}}reactData.scrollXWidth=tWidth;reactData.resizeWidthFlag++;updateColumnOffsetLeft();updateHeight();};/**
         * 
         */const calcCellAutoHeight=(rowRest,wrapperEl)=>{const{scrollXLoad}=reactData;const wrapperElemList=wrapperEl.querySelectorAll(`.vxe-cell--wrapper[rowid="${rowRest.rowid}"]`);let colHeight=0;let firstCellStyle=null;let topBottomPadding=0;for(let i=0;i<wrapperElemList.length;i++){const wrapperElem=wrapperElemList[i];const cellElem=wrapperElem.parentElement;const cellStyle=cellElem.style;const orHeight=cellStyle.height;if(!scrollXLoad){cellStyle.height='';}if(!firstCellStyle){firstCellStyle=getComputedStyle(cellElem);topBottomPadding=firstCellStyle?Math.ceil(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(firstCellStyle.paddingTop)+external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(firstCellStyle.paddingBottom)):0;}if(!scrollXLoad){cellStyle.height=orHeight;}const cellHeight=wrapperElem?wrapperElem.clientHeight:0;colHeight=Math.max(colHeight,Math.ceil(cellHeight+topBottomPadding));}if(scrollXLoad){colHeight=Math.max(colHeight,rowRest.height);}return colHeight;};/**
         * 
         */const calcCellHeight=()=>{const{treeConfig}=props;const{tableData,isAllOverflow,scrollYLoad,scrollXLoad}=reactData;const{fullAllDataRowIdData}=internalData;const treeOpts=computeTreeOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const el=refElem.value;if(el&&!isAllOverflow&&(scrollYLoad||scrollXLoad||treeConfig&&treeOpts.showLine)){const{handleGetRowId}=createHandleGetRowId($xeTable);el.setAttribute('data-calc-row','Y');tableData.forEach(row=>{const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){const reHeight=calcCellAutoHeight(rowRest,el);rowRest.height=Math.max(defaultRowHeight,reHeight);}el.removeAttribute('data-calc-row');});reactData.calcCellHeightFlag++;}};const getOrderField=column=>{const{sortBy,sortType}=column;return row=>{let cellValue;if(sortBy){cellValue=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(sortBy)?sortBy({row,column}):external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,sortBy);}else{cellValue=tableMethods.getCellLabel(row,column);}if(!sortType||sortType==='auto'){return isNaN(cellValue)?cellValue:external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);}else if(sortType==='number'){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);}else if(sortType==='string'){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(cellValue);}return cellValue;};};const updateAfterListIndex=()=>{const{treeConfig}=props;const{afterFullData,fullDataRowIdData,fullAllDataRowIdData}=internalData;const{handleGetRowId}=createHandleGetRowId($xeTable);const fullMaps={};afterFullData.forEach((row,index)=>{const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];const seq=index+1;if(rowRest){if(!treeConfig){rowRest.seq=seq;}rowRest._index=index;}else{const rest={row,rowid,seq,index:-1,$index:-1,_index:index,treeIndex:-1,_tIndex:-1,items:[],parent:null,level:0,height:0,resizeHeight:0,oTop:0,expandHeight:0};fullAllDataRowIdData[rowid]=rest;fullDataRowIdData[rowid]=rest;}fullMaps[rowid]=row;});internalData.afterFullRowMaps=fullMaps;};/**
         * 
         * 
         */const updateAfterDataIndex=()=>{const{treeConfig}=props;const{fullDataRowIdData,fullAllDataRowIdData,afterFullData,afterTreeFullData}=internalData;const treeOpts=computeTreeOpts.value;const{transform}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const fullMaps={};if(treeConfig){let _treeIndex=0;const{handleGetRowId}=createHandleGetRowId($xeTable);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeFullData,(row,index,items,path)=>{const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];const seq=path.map((num,i)=>i%2===0?Number(num)+1:'.').join('');if(rowRest){rowRest.seq=seq;rowRest.treeIndex=index;rowRest._tIndex=_treeIndex;}else{const rest={row,rowid,seq,index:-1,$index:-1,_index:-1,treeIndex:-1,_tIndex:_treeIndex,items:[],parent:null,level:0,height:0,resizeHeight:0,oTop:0,expandHeight:0};fullAllDataRowIdData[rowid]=rest;fullDataRowIdData[rowid]=rest;}_treeIndex++;fullMaps[rowid]=row;},{children:transform?treeOpts.mapChildrenField:childrenField});if(transform){afterFullData.forEach((row,index)=>{const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];const seq=index+1;if(rowRest){if(!treeConfig){rowRest.seq=seq;}rowRest._index=index;}});}internalData.afterFullRowMaps=fullMaps;}else{updateAfterListIndex();}};/**
         * 
         * @returns
         */const handleVirtualTreeToList=()=>{const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{fullAllDataRowIdData,treeExpandedMaps,rowGroupExpandedMaps}=internalData;const aggregateOpts=computeAggregateOpts.value;const treeOpts=computeTreeOpts.value;const{handleGetRowId}=createHandleGetRowId($xeTable);const fullData=[];const expandMaps={};if(treeConfig&&treeOpts.transform){const childrenField=treeOpts.children||treeOpts.childrenField;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(internalData.afterTreeFullData,(row,index,items,path,parentRow)=>{const rowid=handleGetRowId(row);const parentRowid=handleGetRowId(parentRow);if(!parentRow||expandMaps[parentRowid]&&treeExpandedMaps[parentRowid]){const rowRest=fullAllDataRowIdData[rowid];if(rowRest){rowRest._index=fullData.length;}expandMaps[rowid]=1;fullData.push(row);}},{children:childrenField});internalData.afterFullData=fullData;updateScrollYStatus(fullData);return fullData;}else if(isRowGroupStatus){const{childrenField}=aggregateOpts;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(internalData.afterGroupFullData,(row,index,items,path,parentRow)=>{const rowid=handleGetRowId(row);const parentRowid=handleGetRowId(parentRow);if(!parentRow||expandMaps[parentRowid]&&rowGroupExpandedMaps[parentRowid]){const rowRest=fullAllDataRowIdData[rowid];if(rowRest){rowRest._index=fullData.length;}expandMaps[rowid]=1;fullData.push(row);}},{children:childrenField});internalData.afterFullData=fullData;updateScrollYStatus(fullData);return fullData;}return internalData.afterFullData;};/**
         * 
         * 
         */const updateAfterFullData=()=>{const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{tableFullColumn,tableFullData,tableFullTreeData,tableFullGroupData}=internalData;const filterOpts=computeFilterOpts.value;const sortOpts=computeSortOpts.value;const aggregateOpts=computeAggregateOpts.value;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const{transform,rowField,parentField,mapChildrenField}=treeOpts;const{isEvery,remote:allRemoteFilter,filterMethod:allFilterMethod}=filterOpts;const{remote:allRemoteSort,sortMethod:allSortMethod,multiple:sortMultiple,chronological}=sortOpts;let tableData=[];let tableTree=[];// 
if(!allRemoteFilter||!allRemoteSort){const filterColumns=[];let orderColumns=[];tableFullColumn.forEach(column=>{const{field,sortable,order,filters}=column;if(!allRemoteFilter&&filters&&filters.length){const valueList=[];const itemList=[];filters.forEach(item=>{if(item.checked){itemList.push(item);valueList.push(item.value);}});if(itemList.length){filterColumns.push({column,valueList,itemList});}}if(!allRemoteSort&&sortable&&order){orderColumns.push({column,field,property:field,order:order,sortTime:column.sortTime});}});if(sortMultiple&&chronological&&orderColumns.length>1){orderColumns=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(orderColumns,'sortTime');}// 
// 
if(!allRemoteFilter&&filterColumns.length){const handleFilter=row=>{return filterColumns.every(({column,valueList,itemList})=>{const{filterMethod,filterRender}=column;const compConf=isEnableConf(filterRender)?table_renderer.get(filterRender.name):null;const compFilterMethod=compConf?compConf.tableFilterMethod||compConf.filterMethod:null;const tdFilterMethod=compConf?compConf.tableFilterDefaultMethod||compConf.defaultTableFilterMethod||compConf.defaultFilterMethod:null;const cellValue=getCellValue(row,column);if(filterMethod){return itemList.some(item=>filterMethod({value:item.value,option:item,cellValue,row,column,$table:$xeTable}));}else if(compFilterMethod){return itemList.some(item=>compFilterMethod({value:item.value,option:item,cellValue,row,column,$table:$xeTable}));}else if(allFilterMethod){return allFilterMethod({$table:$xeTable,options:itemList,values:valueList,cellValue,row,column});}else if(tdFilterMethod){return itemList.some(item=>tdFilterMethod({value:item.value,option:item,cellValue,row,column,$table:$xeTable}));}return valueList.indexOf(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,column.field))>-1;});};if(isRowGroupStatus){// 
tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullGroupData,handleFilter,{original:true,isEvery:true,children:aggregateOpts.mapChildrenField,mapChildren:aggregateOpts.childrenField});tableData=tableTree;}else if(treeConfig&&transform){// 
tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullTreeData,handleFilter,{original:true,isEvery,children:mapChildrenField,mapChildren:childrenField});tableData=tableTree;}else{tableData=treeConfig?tableFullTreeData.filter(handleFilter):tableFullData.filter(handleFilter);tableTree=tableData;}}else{if(isRowGroupStatus){// 
tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullGroupData,()=>true,{original:true,isEvery:true,children:aggregateOpts.mapChildrenField,mapChildren:aggregateOpts.childrenField});tableData=tableTree;}else if(treeConfig&&transform){// 
tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullTreeData,()=>true,{original:true,isEvery,children:mapChildrenField,mapChildren:childrenField});tableData=tableTree;}else{tableData=treeConfig?tableFullTreeData.slice(0):tableFullData.slice(0);tableTree=tableData;}}// 
// 
if(!allRemoteSort&&orderColumns.length){if(isRowGroupStatus){// 
if(allSortMethod){const sortRests=allSortMethod({data:tableTree,sortList:orderColumns,$table:$xeTable});tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortRests)?sortRests:tableTree;}else{const treeList=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray(tableTree,{key:aggregateOpts.rowField,parentKey:aggregateOpts.parentField,children:aggregateOpts.mapChildrenField});tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(treeList,orderColumns.map(({column,order})=>[getOrderField(column),order])),{key:aggregateOpts.rowField,parentKey:aggregateOpts.parentField,children:aggregateOpts.childrenField,mapChildren:aggregateOpts.mapChildrenField});}tableData=tableTree;}else if(treeConfig&&transform){// 
if(allSortMethod){const sortRests=allSortMethod({data:tableTree,sortList:orderColumns,$table:$xeTable});tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortRests)?sortRests:tableTree;}else{const treeList=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray(tableTree,{children:mapChildrenField});tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(treeList,orderColumns.map(({column,order})=>[getOrderField(column),order])),{key:rowField,parentKey:parentField,children:childrenField,mapChildren:mapChildrenField});}tableData=tableTree;}else{if(allSortMethod){const sortRests=allSortMethod({data:tableData,sortList:orderColumns,$table:$xeTable});tableData=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortRests)?sortRests:tableData;}else{tableData=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(tableData,orderColumns.map(({column,order})=>[getOrderField(column),order]));}tableTree=tableData;}}}else{if(isRowGroupStatus){// 
// 
tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullGroupData,()=>true,{original:true,isEvery:true,children:aggregateOpts.mapChildrenField,mapChildren:aggregateOpts.childrenField});tableData=tableTree;}else if(treeConfig&&transform){// 
tableTree=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullTreeData,()=>true,{original:true,isEvery,children:mapChildrenField,mapChildren:childrenField});tableData=tableTree;}else{tableData=treeConfig?tableFullTreeData.slice(0):tableFullData.slice(0);tableTree=tableData;}}internalData.afterFullData=tableData;internalData.afterTreeFullData=tableTree;internalData.afterGroupFullData=tableTree;updateAfterDataIndex();};const updateStyle=()=>{const{mouseConfig}=props;const{isGroup,currentRow,tableColumn,overflowX,scrollbarWidth,overflowY,scrollbarHeight,scrollXWidth,columnStore,editStore,isColLoading}=reactData;const{visibleColumn,tableHeight,elemStore,customHeight,customMinHeight,customMaxHeight,tHeaderHeight,tFooterHeight}=internalData;const $xeGanttView=internalData.xeGanttView;const el=refElem.value;if(!el||internalData.tBodyHeight&&!el.clientHeight){return;}const containerList=['main','left','right'];const{leftList,rightList}=columnStore;let osbWidth=overflowY?scrollbarWidth:0;let osbHeight=overflowX?scrollbarHeight:0;const emptyPlaceholderElem=refEmptyPlaceholder.value;const isHeaderRenderOptimize=computeIsHeaderRenderOptimize.value;const isBodyRenderOptimize=computeIsBodyRenderOptimize.value;const isFooterRenderOptimize=computeIsFooterRenderOptimize.value;const scrollbarOpts=computeScrollbarOpts.value;const mouseOpts=computeMouseOpts.value;const bodyWrapperElem=getRefElem(elemStore['main-body-wrapper']);const bodyTableElem=getRefElem(elemStore['main-body-table']);if(emptyPlaceholderElem){emptyPlaceholderElem.style.top=`${tHeaderHeight}px`;emptyPlaceholderElem.style.height=bodyWrapperElem?`${bodyWrapperElem.offsetHeight-osbHeight}px`:'';}const scrollbarXConf=scrollbarOpts.x||{};const scrollbarYConf=scrollbarOpts.y||{};const scrollbarYToLeft=computeScrollbarYToLeft.value;let xScrollbarVisible=overflowX?'visible':'hidden';if(scrollbarXConf.visible==='visible'||$xeGanttView){osbHeight=scrollbarHeight;xScrollbarVisible='visible';}else if(scrollbarXConf.visible==='hidden'||scrollbarXConf.visible===false){osbHeight=0;xScrollbarVisible='hidden';}let yScrollbarVisible=overflowY?'visible':'hidden';if(scrollbarYConf.visible==='hidden'||scrollbarYConf.visible===false||$xeGanttView&&!scrollbarYToLeft){osbWidth=0;yScrollbarVisible='hidden';}else if(scrollbarYConf.visible==='visible'){osbWidth=scrollbarWidth;yScrollbarVisible='visible';}let tbHeight=0;let bodyMaxHeight=0;const bodyMinHeight=customMinHeight-tHeaderHeight-tFooterHeight-osbHeight;if(customMaxHeight){bodyMaxHeight=Math.max(bodyMinHeight,customMaxHeight-tHeaderHeight-tFooterHeight-osbHeight);}if(customHeight){tbHeight=customHeight-tHeaderHeight-tFooterHeight-osbHeight;}if(!tbHeight){if(bodyTableElem){tbHeight=bodyTableElem.clientHeight;}}if(tbHeight){if(bodyMaxHeight){tbHeight=Math.min(bodyMaxHeight,tbHeight);}tbHeight=Math.max(bodyMinHeight,tbHeight);}const xLeftCornerEl=refScrollXLeftCornerElem.value;const xRightCornerEl=refScrollXRightCornerElem.value;const scrollXVirtualEl=refScrollXVirtualElem.value;if(scrollXVirtualEl){scrollXVirtualEl.style.height=`${osbHeight}px`;scrollXVirtualEl.style.visibility=xScrollbarVisible;}const xWrapperEl=refScrollXWrapperElem.value;if(xWrapperEl){xWrapperEl.style.width=`${el.clientWidth-osbWidth}px`;if(scrollbarYToLeft){xWrapperEl.style.left=`${osbWidth}px`;}else{xWrapperEl.style.left='';}}if(xLeftCornerEl){if(scrollbarYToLeft){xLeftCornerEl.style.width=`${osbWidth}px`;xLeftCornerEl.style.display=overflowY&&osbWidth?'block':'';}else{xLeftCornerEl.style.display='';}}if(xRightCornerEl){if(scrollbarYToLeft){xRightCornerEl.style.display='';}else{xRightCornerEl.style.width=`${osbWidth}px`;xRightCornerEl.style.display=xScrollbarVisible==='visible'?'block':'';}}const scrollYVirtualEl=refScrollYVirtualElem.value;if(scrollYVirtualEl){scrollYVirtualEl.style.width=`${osbWidth}px`;scrollYVirtualEl.style.height=`${tbHeight+tHeaderHeight+tFooterHeight}px`;scrollYVirtualEl.style.visibility=yScrollbarVisible;}const yTopCornerEl=refScrollYTopCornerElem.value;if(yTopCornerEl){yTopCornerEl.style.height=`${tHeaderHeight}px`;yTopCornerEl.style.display=tHeaderHeight&&yScrollbarVisible==='visible'?'block':'';}const yWrapperEl=refScrollYWrapperElem.value;if(yWrapperEl){yWrapperEl.style.height=`${tbHeight}px`;yWrapperEl.style.top=`${tHeaderHeight}px`;}const yBottomCornerEl=refScrollYBottomCornerElem.value;if(yBottomCornerEl){yBottomCornerEl.style.height=`${tFooterHeight}px`;yBottomCornerEl.style.top=`${tHeaderHeight+tbHeight}px`;yBottomCornerEl.style.display=tFooterHeight&&yScrollbarVisible==='visible'?'block':'';}const rowExpandEl=refRowExpandElem.value;if(rowExpandEl){rowExpandEl.style.height=`${tbHeight}px`;rowExpandEl.style.top=`${tHeaderHeight}px`;}internalData.tBodyHeight=tbHeight;containerList.forEach((name,index)=>{const fixedType=index>0?name:'';const layoutList=['header','body','footer'];const isFixedLeft=fixedType==='left';let fixedColumn=[];let fixedWrapperElem;if(fixedType){fixedColumn=isFixedLeft?leftList:rightList;fixedWrapperElem=isFixedLeft?refLeftContainer.value:refRightContainer.value;}layoutList.forEach(layout=>{const wrapperElem=getRefElem(elemStore[`${name}-${layout}-wrapper`]);const currScrollElem=getRefElem(elemStore[`${name}-${layout}-scroll`]);const tableElem=getRefElem(elemStore[`${name}-${layout}-table`]);if(layout==='header'){// 
// 
let renderColumnList=tableColumn;const isOptimizeMode=isHeaderRenderOptimize;if(isGroup){renderColumnList=visibleColumn;}else{if(!isOptimizeMode||!isColLoading&&(fixedType||!overflowX)){renderColumnList=visibleColumn;}if(fixedType){// 
if(isOptimizeMode){renderColumnList=fixedColumn||[];}}}const tWidth=renderColumnList.reduce((previous,column)=>previous+column.renderWidth,0);if(fixedType){if(isGroup){if(wrapperElem){wrapperElem.style.width=scrollXWidth?`${scrollXWidth}px`:'';}}else{if(isOptimizeMode){if(wrapperElem){wrapperElem.style.width=tWidth?`${tWidth}px`:'';}}else{if(wrapperElem){wrapperElem.style.width=scrollXWidth?`${scrollXWidth}px`:'';}}}}if(currScrollElem){currScrollElem.style.height=`${tHeaderHeight}px`;}if(tableElem){tableElem.style.width=tWidth?`${tWidth}px`:'';}}else if(layout==='body'){if(currScrollElem){currScrollElem.style.maxHeight=customMaxHeight?`${bodyMaxHeight}px`:'';currScrollElem.style.height=customHeight?`${tbHeight}px`:'';currScrollElem.style.minHeight=`${bodyMinHeight}px`;}// 
if(fixedWrapperElem){if(wrapperElem){wrapperElem.style.top=`${tHeaderHeight}px`;}fixedWrapperElem.style.height=`${customHeight>0?customHeight:tableHeight+tHeaderHeight+tFooterHeight+osbHeight}px`;fixedWrapperElem.style.width=`${fixedColumn.reduce((previous,column)=>previous+column.renderWidth,0)}px`;}let renderColumnList=tableColumn;const isOptimizeMode=isBodyRenderOptimize;if(fixedType){renderColumnList=visibleColumn;if(isOptimizeMode){renderColumnList=fixedColumn||[];}}const tWidth=renderColumnList.reduce((previous,column)=>previous+column.renderWidth,0);if(fixedType){if(isOptimizeMode){if(wrapperElem){wrapperElem.style.width=tWidth?`${tWidth}px`:'';}}else{if(wrapperElem){wrapperElem.style.width=scrollXWidth?`${scrollXWidth}px`:'';}}}if(tableElem){tableElem.style.width=tWidth?`${tWidth}px`:'';// 
tableElem.style.paddingRight=osbWidth&&fixedType&&(browseObj.firefox||browseObj.safari)?`${osbWidth}px`:'';}const emptyBlockElem=getRefElem(elemStore[`${name}-${layout}-emptyBlock`]);if(emptyBlockElem){emptyBlockElem.style.width=tWidth?`${tWidth}px`:'';}}else if(layout==='footer'){let renderColumnList=tableColumn;const isOptimizeMode=isFooterRenderOptimize;if(!isOptimizeMode||!isColLoading&&(fixedType||!overflowX)){renderColumnList=visibleColumn;}if(fixedType){if(isOptimizeMode){renderColumnList=fixedColumn||[];}}const tWidth=renderColumnList.reduce((previous,column)=>previous+column.renderWidth,0);if(fixedType){if(isOptimizeMode){if(wrapperElem){wrapperElem.style.width=tWidth?`${tWidth}px`:'';}}else{if(wrapperElem){wrapperElem.style.width=scrollXWidth?`${scrollXWidth}px`:'';}}}if(currScrollElem){currScrollElem.style.height=`${tFooterHeight}px`;// 
if(fixedWrapperElem){if(wrapperElem){wrapperElem.style.top=`${customHeight>0?customHeight-tFooterHeight-osbHeight:tableHeight+tHeaderHeight}px`;}}}if(tableElem){tableElem.style.width=tWidth?`${tWidth}px`:'';}}});});if(currentRow){$xeTable.setCurrentRow(currentRow);}if(mouseConfig&&mouseOpts.selected&&editStore.selected.row&&editStore.selected.column){$xeTable.addCellSelectedClass();}if($xeGanttView&&$xeGanttView.handleUpdateStyle){$xeGanttView.handleUpdateStyle();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};const checkValidate=type=>{if($xeTable.triggerValidate){return $xeTable.triggerValidate(type);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};/**
         * 
         * 
         */const handleChangeCell=(evnt,params)=>{checkValidate('blur').catch(e=>e).then(()=>{$xeTable.handleEdit(params,evnt).then(()=>checkValidate('change')).catch(e=>e);});};const handleDefaultSort=()=>{const{sortConfig}=props;if(sortConfig){const sortOpts=computeSortOpts.value;let{defaultSort}=sortOpts;if(defaultSort){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(defaultSort)){defaultSort=[defaultSort];}if(defaultSort.length){(sortConfig.multiple?defaultSort:defaultSort.slice(0,1)).forEach((item,index)=>{const{field,order}=item;if(field&&order){const column=$xeTable.getColumnByField(field);if(column&&column.sortable){column.order=order;column.sortTime=Date.now()+index;}}});if(!sortOpts.remote){$xeTable.handleTableData(true).then(updateStyle);}}}}};/**
         * 
         */const handleDefaultSelectionChecked=()=>{const{checkboxConfig}=props;if(checkboxConfig){const{fullDataRowIdData}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{checkAll,checkRowKeys}=checkboxOpts;if(checkAll){handleCheckedAllCheckboxRow(true,true);}else if(checkRowKeys){const defSelection=[];checkRowKeys.forEach(rowid=>{if(fullDataRowIdData[rowid]){defSelection.push(fullDataRowIdData[rowid].row);}});handleCheckedCheckboxRow(defSelection,true,true);}}};/**
         * 
         */const handleDefaultRadioChecked=()=>{const{radioConfig}=props;if(radioConfig){const{fullDataRowIdData}=internalData;const radioOpts=computeRadioOpts.value;const{checkRowKey:rowid,reserve}=radioOpts;if(rowid){if(fullDataRowIdData[rowid]){handleCheckedRadioRow(fullDataRowIdData[rowid].row,true);}if(reserve){const rowkey=getRowkey($xeTable);internalData.radioReserveRow={[rowkey]:rowid};}}}};/**
         * 
         */const handleDefaultRowExpand=()=>{const{expandConfig}=props;if(expandConfig){const{fullDataRowIdData}=internalData;const expandOpts=computeExpandOpts.value;const{expandAll,expandRowKeys}=expandOpts;if(expandAll){$xeTable.setAllRowExpand(true);}else if(expandRowKeys){const defExpandeds=[];expandRowKeys.forEach(rowid=>{if(fullDataRowIdData[rowid]){defExpandeds.push(fullDataRowIdData[rowid].row);}});$xeTable.setRowExpand(defExpandeds,true);}}};const handleRadioReserveRow=row=>{const radioOpts=computeRadioOpts.value;if(radioOpts.reserve){internalData.radioReserveRow=row;}};const handleCheckboxReserveRow=(row,checked)=>{const{checkboxReserveRowMap}=internalData;const checkboxOpts=computeCheckboxOpts.value;if(checkboxOpts.reserve){const rowid=getRowid($xeTable,row);if(checked){checkboxReserveRowMap[rowid]=row;}else if(checkboxReserveRowMap[rowid]){delete checkboxReserveRowMap[rowid];}}};const handleCheckedRadioRow=(row,isForce)=>{const radioOpts=computeRadioOpts.value;const{checkMethod}=radioOpts;if(row&&(isForce||!checkMethod||checkMethod({$table:$xeTable,row}))){reactData.selectRadioRow=row;handleRadioReserveRow(row);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};const handleCheckedCheckboxRow=(rows,value,isForce)=>{if(rows&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}$xeTable.handleBatchSelectRows(rows,!!value,isForce);$xeTable.checkSelectionStatus();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};const handleCheckedAllCheckboxRow=(checked,isForce)=>{const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{afterFullData,afterTreeFullData,afterGroupFullData,checkboxReserveRowMap,selectCheckboxMaps}=internalData;const treeOpts=computeTreeOpts.value;const aggregateOpts=computeAggregateOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const checkboxOpts=computeCheckboxOpts.value;const{checkField,reserve,checkMethod}=checkboxOpts;const{handleGetRowId}=createHandleGetRowId($xeTable);// indeterminateField 
const indeterminateField=checkboxOpts.indeterminateField||checkboxOpts.halfField;const selectRowMaps={};/**
             * 
             * 
             */if(checkField){const checkValFn=row=>{if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){if(checked){selectRowMaps[handleGetRowId(row)]=row;}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,checkField,checked);}if((treeConfig||isRowGroupStatus)&&indeterminateField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,indeterminateField,false);}};// 
// 
if(treeConfig||isRowGroupStatus){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterFullData,checkValFn,{children:childrenField});}else{afterFullData.forEach(checkValFn);}}else{/**
                 * 
                 * 
                 */if(isRowGroupStatus){if(checked){/**
                         * 
                         * 
                         */external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterGroupFullData,row=>{if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){const rowid=handleGetRowId(row);selectRowMaps[rowid]=row;}},{children:aggregateOpts.mapChildrenField});}else{/**
                         * 
                         * 
                         */if(!isForce&&checkMethod){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterGroupFullData,row=>{const rowid=handleGetRowId(row);if(checkMethod({$table:$xeTable,row})?false:selectCheckboxMaps[rowid]){selectRowMaps[rowid]=row;}},{children:aggregateOpts.mapChildrenField});}}}else if(treeConfig){if(checked){/**
                         * 
                         * 
                         */external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeFullData,row=>{if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){const rowid=handleGetRowId(row);selectRowMaps[rowid]=row;}},{children:childrenField});}else{/**
                         * 
                         * 
                         */if(!isForce&&checkMethod){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeFullData,row=>{const rowid=handleGetRowId(row);if(checkMethod({$table:$xeTable,row})?false:selectCheckboxMaps[rowid]){selectRowMaps[rowid]=row;}},{children:childrenField});}}}else{if(checked){/**
                         * 
                         * 
                         * 
                         */if(!isForce&&checkMethod){afterFullData.forEach(row=>{const rowid=handleGetRowId(row);if(selectCheckboxMaps[rowid]||checkMethod({$table:$xeTable,row})){selectRowMaps[rowid]=row;}});}else{afterFullData.forEach(row=>{const rowid=handleGetRowId(row);selectRowMaps[rowid]=row;});}}else{/**
                         * 
                         * 
                         * 
                         */if(!isForce&&checkMethod){afterFullData.forEach(row=>{const rowid=handleGetRowId(row);if(checkMethod({$table:$xeTable,row})?false:selectCheckboxMaps[rowid]){selectRowMaps[rowid]=row;}});}}}}if(reserve){if(checked){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(selectRowMaps,(row,rowid)=>{checkboxReserveRowMap[rowid]=row;});}else{afterFullData.forEach(row=>handleCheckboxReserveRow(row,false));}}reactData.updateCheckboxFlag++;internalData.selectCheckboxMaps=checkField?{}:selectRowMaps;reactData.isAllSelected=checked;reactData.isIndeterminate=false;internalData.treeIndeterminateRowMaps={};$xeTable.checkSelectionStatus();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};// 
const handleReserveStatus=()=>{const{treeConfig}=props;const{expandColumn,currentRow,selectRadioRow}=reactData;const{fullDataRowIdData,fullAllDataRowIdData,radioReserveRow,selectCheckboxMaps,treeExpandedMaps,rowExpandedMaps}=internalData;const expandOpts=computeExpandOpts.value;const treeOpts=computeTreeOpts.value;const radioOpts=computeRadioOpts.value;const checkboxOpts=computeCheckboxOpts.value;// 
if(selectRadioRow&&!fullAllDataRowIdData[getRowid($xeTable,selectRadioRow)]){reactData.selectRadioRow=null;// 
}// 
if(radioOpts.reserve&&radioReserveRow){const rowid=getRowid($xeTable,radioReserveRow);if(fullDataRowIdData[rowid]){handleCheckedRadioRow(fullDataRowIdData[rowid].row,true);}}// 
internalData.selectCheckboxMaps=getRecoverRowMaps(selectCheckboxMaps);// 
reactData.updateCheckboxFlag++;// 
if(checkboxOpts.reserve){handleCheckedCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap),true,true);}if(currentRow&&!fullAllDataRowIdData[getRowid($xeTable,currentRow)]){reactData.currentRow=null;// 
}// 
internalData.rowExpandedMaps=expandColumn?getRecoverRowMaps(rowExpandedMaps):{};// 
reactData.rowExpandedFlag++;// 
if(expandColumn&&expandOpts.reserve){$xeTable.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap),true);}// 
internalData.treeExpandedMaps=treeConfig?getRecoverRowMaps(treeExpandedMaps):{};// 
reactData.treeExpandedFlag++;if(treeConfig&&treeOpts.reserve){$xeTable.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap),true);}};/**
         * 
         */const handleDefaultTreeExpand=()=>{const{treeConfig}=props;if(treeConfig){const{fullAllDataRowIdData}=internalData;const treeOpts=computeTreeOpts.value;const{expandAll,expandRowKeys}=treeOpts;if(expandAll){$xeTable.setAllTreeExpand(true);}else if(expandRowKeys){const defExpandeds=[];expandRowKeys.forEach(rowid=>{const rowRest=fullAllDataRowIdData[rowid];if(rowRest){defExpandeds.push(rowRest.row);}});$xeTable.setTreeExpand(defExpandeds,true);}}};const handleAsyncTreeExpandChilds=row=>{const treeOpts=computeTreeOpts.value;const checkboxOpts=computeCheckboxOpts.value;const{transform,loadMethod}=treeOpts;const{checkStrictly}=checkboxOpts;return new Promise(resolve=>{if(loadMethod){const{fullAllDataRowIdData,treeExpandLazyLoadedMaps}=internalData;const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];treeExpandLazyLoadedMaps[rowid]=row;Promise.resolve(loadMethod({$table:$xeTable,row})).then(childRecords=>{if(rowRest){rowRest.treeLoaded=true;}if(treeExpandLazyLoadedMaps[rowid]){delete treeExpandLazyLoadedMaps[rowid];}if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(childRecords)){childRecords=[];}if(childRecords){return $xeTable.loadTreeChildren(row,childRecords).then(childRows=>{const{treeExpandedMaps}=internalData;if(childRows.length&&!treeExpandedMaps[rowid]){treeExpandedMaps[rowid]=row;}reactData.treeExpandedFlag++;// 
if(!checkStrictly&&$xeTable.isCheckedByCheckboxRow(row)){handleCheckedCheckboxRow(childRows,true);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{if(transform){$xeTable.handleTableData();updateAfterDataIndex();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}});});}}).catch(()=>{const{treeExpandLazyLoadedMaps}=internalData;if(rowRest){rowRest.treeLoaded=false;}if(treeExpandLazyLoadedMaps[rowid]){delete treeExpandLazyLoadedMaps[rowid];}}).finally(()=>{reactData.treeExpandedFlag++;(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>$xeTable.recalculate()).then(()=>resolve());});}else{resolve();}});};const handleTreeExpandReserve=(row,expanded)=>{const{treeExpandedReserveRowMap}=internalData;const treeOpts=computeTreeOpts.value;if(treeOpts.reserve){const rowid=getRowid($xeTable,row);if(expanded){treeExpandedReserveRowMap[rowid]=row;}else if(treeExpandedReserveRowMap[rowid]){delete treeExpandedReserveRowMap[rowid];}}};const handleAsyncRowExpand=row=>{return new Promise(resolve=>{const expandOpts=computeExpandOpts.value;const{loadMethod}=expandOpts;if(loadMethod){const{fullAllDataRowIdData,rowExpandLazyLoadedMaps}=internalData;const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];rowExpandLazyLoadedMaps[rowid]=row;loadMethod({$table:$xeTable,row,rowIndex:$xeTable.getRowIndex(row),$rowIndex:$xeTable.getVMRowIndex(row)}).then(()=>{const{rowExpandedMaps}=internalData;if(rowRest){rowRest.expandLoaded=true;}rowExpandedMaps[rowid]=row;reactData.rowExpandedFlag++;}).catch(()=>{if(rowRest){rowRest.expandLoaded=false;}}).finally(()=>{const{rowExpandLazyLoadedMaps}=internalData;if(rowExpandLazyLoadedMaps[rowid]){delete rowExpandLazyLoadedMaps[rowid];}reactData.rowExpandedFlag++;(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>$xeTable.recalculate()).then(()=>$xeTable.updateCellAreas()).then(()=>resolve());});}else{resolve();}});};const handleRowExpandReserve=(row,expanded)=>{const{rowExpandedReserveRowMap}=internalData;const expandOpts=computeExpandOpts.value;if(expandOpts.reserve){const rowid=getRowid($xeTable,row);if(expanded){rowExpandedReserveRowMap[rowid]=row;}else if(rowExpandedReserveRowMap[rowid]){delete rowExpandedReserveRowMap[rowid];}}};const handleDefaultMergeCells=()=>{const{mergeCells}=props;if(mergeCells){$xeTable.setMergeCells(mergeCells);}};const handleDefaultMergeHeaderItems=()=>{const{mergeHeaderCells}=props;if(mergeHeaderCells){$xeTable.setMergeHeaderCells(mergeHeaderCells);}};const handleDefaultMergeFooterItems=()=>{const{mergeFooterCells,mergeFooterItems}=props;const mFooterCells=mergeFooterCells||mergeFooterItems;if(mFooterCells){$xeTable.setMergeFooterCells(mFooterCells);}};// 
const computeScrollLoad=()=>{return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{const{scrollXLoad,scrollYLoad}=reactData;const{scrollXStore,scrollYStore}=internalData;const virtualYOpts=computeVirtualYOpts.value;const virtualXOpts=computeVirtualXOpts.value;//  X 
if(scrollXLoad){const{toVisibleIndex:toXVisibleIndex,visibleSize:visibleXSize}=handleVirtualXVisible();const offsetXSize=Math.max(0,virtualXOpts.oSize?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualXOpts.oSize):0);scrollXStore.preloadSize=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualXOpts.preSize);scrollXStore.offsetSize=offsetXSize;scrollXStore.visibleSize=visibleXSize;scrollXStore.endIndex=Math.max(scrollXStore.startIndex+scrollXStore.visibleSize+offsetXSize,scrollXStore.endIndex);scrollXStore.visibleStartIndex=Math.max(scrollXStore.startIndex,toXVisibleIndex);scrollXStore.visibleEndIndex=Math.min(scrollXStore.endIndex,toXVisibleIndex+visibleXSize);$xeTable.updateScrollXData().then(()=>{loadScrollXData();});}else{$xeTable.updateScrollXSpace();}//  Y 
const rowHeight=computeRowHeight();scrollYStore.rowHeight=rowHeight;// 
reactData.rowHeight=rowHeight;const{toVisibleIndex:toYVisibleIndex,visibleSize:visibleYSize}=handleVirtualYVisible();if(scrollYLoad){const offsetYSize=Math.max(0,virtualYOpts.oSize?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualYOpts.oSize):0);scrollYStore.preloadSize=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualYOpts.preSize);scrollYStore.offsetSize=offsetYSize;scrollYStore.visibleSize=visibleYSize;scrollYStore.endIndex=Math.max(scrollYStore.startIndex+visibleYSize+offsetYSize,scrollYStore.endIndex);scrollYStore.visibleStartIndex=Math.max(scrollYStore.startIndex,toYVisibleIndex);scrollYStore.visibleEndIndex=Math.min(scrollYStore.endIndex,toYVisibleIndex+visibleYSize);$xeTable.updateScrollYData().then(()=>{loadScrollYData();});}else{$xeTable.updateScrollYSpace();}});};const calcScrollbar=()=>{const{scrollXWidth,scrollYHeight}=reactData;const{elemStore}=internalData;const scrollbarOpts=computeScrollbarOpts.value;const bodyWrapperElem=getRefElem(elemStore['main-body-wrapper']);const headerTableElem=getRefElem(elemStore['main-header-table']);const footerTableElem=getRefElem(elemStore['main-footer-table']);const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;let overflowY=false;let overflowX=false;if(bodyWrapperElem){overflowY=scrollYHeight>bodyWrapperElem.clientHeight;if(yHandleEl){reactData.scrollbarWidth=scrollbarOpts.width||yHandleEl.offsetWidth-yHandleEl.clientWidth||14;}reactData.overflowY=overflowY;overflowX=scrollXWidth>bodyWrapperElem.clientWidth;if(xHandleEl){reactData.scrollbarHeight=scrollbarOpts.height||xHandleEl.offsetHeight-xHandleEl.clientHeight||14;}const hHeight=headerTableElem?headerTableElem.clientHeight:0;const fHeight=footerTableElem?footerTableElem.clientHeight:0;internalData.tableHeight=bodyWrapperElem.offsetHeight;internalData.tHeaderHeight=hHeight;internalData.tFooterHeight=fHeight;reactData.overflowX=overflowX;reactData.parentHeight=Math.max(hHeight+fHeight+20,$xeTable.getParentHeight());}if(overflowX){$xeTable.checkScrolling();}};const handleRecalculateStyle=(reFull,reWidth,reHeight)=>{const el=refElem.value;internalData.rceRunTime=Date.now();if(!el||!el.clientWidth){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}const varEl=refVarElem.value;if(varEl){const[defEl,mediumEl,smallEl,miniEl]=varEl.children;calcVarRowHeightConfig('default',defEl);calcVarRowHeightConfig('medium',mediumEl);calcVarRowHeightConfig('small',smallEl);calcVarRowHeightConfig('mini',miniEl);}if(reWidth){calcCellWidth();}if(reFull){autoCellWidth();}calcScrollbar();updateStyle();updateRowExpandStyle();if(reFull){updateTreeLineStyle();}return computeScrollLoad().then(()=>{// 
if(reWidth){calcCellWidth();}if(reFull){autoCellWidth();}if(reHeight){calcCellHeight();}updateStyle();calcScrollbar();if(reFull){updateRowOffsetTop();}updateRowExpandStyle();if(reFull){updateTreeLineStyle();}if(reFull){return computeScrollLoad();}});};const handleLazyRecalculate=(reFull,reWidth,reHeight)=>{return new Promise(resolve=>{const $xeGanttView=internalData.xeGanttView;const{rceTimeout,rceRunTime}=internalData;const resizeOpts=computeResizeOpts.value;const refreshDelay=resizeOpts.refreshDelay||20;const el=refElem.value;if(el&&el.clientWidth){autoCellWidth();updateRowExpandStyle();}if(rceTimeout){clearTimeout(rceTimeout);if(rceRunTime&&rceRunTime+(refreshDelay-5)<Date.now()){resolve(handleRecalculateStyle(reFull,reWidth,reHeight));}else{(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{resolve();});}}else{resolve(handleRecalculateStyle(reFull,reWidth,reHeight));}if($xeGanttView&&$xeGanttView.handleLazyRecalculate){$xeGanttView.handleLazyRecalculate();}internalData.rceTimeout=setTimeout(()=>{internalData.rceTimeout=undefined;handleRecalculateStyle(reFull,reWidth,reHeight);},refreshDelay);});};const handleResizeEvent=()=>{handleLazyRecalculate(true,true,true);};const handleUpdateAggValues=()=>{const{visibleColumn}=internalData;const aggCols=[];visibleColumn.forEach(column=>{if(column.aggFunc){aggCols.push(column);}});reactData.aggHandleAggColumns=aggCols;};const handleUpdateRowGroup=groupFields=>{const aggGroupFields=[];const aggGroupConfs=[];if(groupFields){(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(groupFields)?groupFields:[groupFields]).forEach(field=>{aggGroupFields.push(field);aggGroupConfs.push({field});});}reactData.rowGroupList=aggGroupConfs;reactData.aggHandleFields=aggGroupFields;handleUpdateAggValues();};const handleeGroupSummary=aggList=>{const aggregateOpts=computeAggregateOpts.value;const{mapChildrenField}=aggregateOpts;if(mapChildrenField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().lastEach(aggList,aggRow=>{let count=0;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(aggRow[mapChildrenField],row=>{if(row.isAggregate){count+=row.childCount||0;}else{count++;}});aggRow.childCount=count;});if($xeTable.handlePivotTableAggregateData){$xeTable.handlePivotTableAggregateData(aggList);}}};const updateGroupData=()=>{const{aggregateConfig,rowGroupConfig}=props;const{isRowGroupStatus}=reactData;const{tableFullGroupData}=internalData;const aggregateOpts=computeAggregateOpts.value;const{mapChildrenField}=aggregateOpts;if((aggregateConfig||rowGroupConfig)&&isRowGroupStatus){const aggList=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullGroupData,row=>{if(row.isAggregate){aggList.push(row);}},{children:mapChildrenField});handleeGroupSummary(aggList);}};const handleGroupData=(list,rowGroups)=>{let fullData=list;let treeData=list;if(rowGroups){const aggregateOpts=computeAggregateOpts.value;const{rowField,parentField,childrenField,mapChildrenField}=aggregateOpts;const checkboxOpts=computeCheckboxOpts.value;const{checkField}=checkboxOpts;const indeterminateField=checkboxOpts.indeterminateField||checkboxOpts.halfField;const rgItem=rowGroups[0];if(rgItem&&rowField&&parentField&&childrenField&&mapChildrenField){fullData=[];treeData=[];const groupField=rgItem.field;const groupColumn=$xeTable.getColumnByField(groupField);const groupMaps={};const aggList=[];const rowkey=getRowkey($xeTable);list.forEach(row=>{const cellValue=groupColumn?$xeTable.getCellLabel(row,groupColumn):external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,groupField);const groupValue=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cellValue)?'':cellValue;let childList=groupMaps[groupValue];if(!childList){childList=[];groupMaps[groupValue]=childList;}if(row.isAggregate){row.isAggregate=undefined;}childList.push(row);});external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(groupMaps,(childList,groupValue)=>{const{fullData:childFullData,treeData:childTreeData}=handleGroupData(childList,rowGroups.slice(1));const aggRow={isAggregate:true,aggData:{},groupContent:groupValue,groupField,childCount:0,[rowField]:getRowUniqueId(),[parentField]:null,[rowkey]:getRowUniqueId(),[childrenField]:childTreeData,[mapChildrenField]:childTreeData};if(checkField){aggRow[checkField]=false;}if(indeterminateField){aggRow[indeterminateField]=false;}aggList.push(aggRow);treeData.push(aggRow);fullData.push(aggRow);if(childFullData.length){fullData.push(...childFullData);}});handleeGroupSummary(aggList);}}return{treeData,fullData};};const initData=()=>{const{data}=props;loadTableData(data||[],true).then(()=>{if(data&&data.length){internalData.inited=true;internalData.initStatus=true;handleLoadDefaults();}handleInitDefaults();updateStyle();if(!reactData.isAllOverflow){calcCellHeight();updateRowOffsetTop();}});};/**
         * 
         * @param {Array} datas 
         */const loadTableData=(datas,isReset)=>{const{keepSource,treeConfig,rowGroupConfig,aggregateConfig}=props;const{rowGroupList,scrollYLoad:oldScrollYLoad}=reactData;const{scrollYStore,scrollXStore,lastScrollLeft,lastScrollTop}=internalData;const rowOpts=computeRowOpts.value;const treeOpts=computeTreeOpts.value;const expandOpts=computeExpandOpts.value;const{transform}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;let treeData=[];let fullData=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(datas?datas.slice(0):[]);// 
if(fullData.length>supportMaxRow){errLog('vxe.error.errMaxRow',[supportMaxRow]);}if(treeConfig&&rowGroupList.length){errLog('vxe.error.noTree',['aggregate-config']);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}if(rowOpts.drag&&rowGroupList.length){errLog('vxe.error.errConflicts',['row-config.drag','aggregate-config']);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}let isRGroup=false;if(treeConfig){if(transform){// 
if(!treeOpts.rowField){errLog('vxe.error.reqProp',['tree-config.rowField']);}if(!treeOpts.parentField){errLog('vxe.error.reqProp',['tree-config.parentField']);}if(!childrenField){errLog('vxe.error.reqProp',['tree-config.childrenField']);}if(!treeOpts.mapChildrenField){errLog('vxe.error.reqProp',['tree-config.mapChildrenField']);}if(childrenField===treeOpts.mapChildrenField){errLog('vxe.error.errConflicts',['tree-config.childrenField','tree-config.mapChildrenField']);}// fullData.forEach(row => {
//   if (row[treeOpts.children] && row[treeOpts.children].length) {
//     warnLog('vxe.error.errConflicts', ['tree-config.transform', `row.${treeOpts.children}`])
//   }
// })
treeData=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(fullData,{key:treeOpts.rowField,parentKey:treeOpts.parentField,children:childrenField,mapChildren:treeOpts.mapChildrenField});fullData=treeData.slice(0);}else{treeData=fullData.slice(0);}}else if((aggregateConfig||rowGroupConfig)&&rowGroupList.length){const groupRest=handleGroupData(fullData,rowGroupList);treeData=groupRest.treeData;fullData=groupRest.fullData;isRGroup=true;}reactData.isRowGroupStatus=isRGroup;scrollYStore.startIndex=0;scrollYStore.endIndex=1;scrollXStore.startIndex=0;scrollXStore.endIndex=1;internalData.cvCacheMaps={};reactData.isRowLoading=true;reactData.scrollVMLoading=false;reactData.treeExpandedFlag++;reactData.rowExpandedFlag++;internalData.insertRowMaps={};reactData.insertRowFlag++;internalData.removeRowMaps={};reactData.removeRowFlag++;const sYLoad=updateScrollYStatus(fullData);// 
internalData.tableFullData=fullData;internalData.tableFullTreeData=isRGroup?[]:treeData;internalData.tableFullGroupData=isRGroup?treeData:[];// 
$xeTable.cacheRowMap(isReset);// 
internalData.tableSynchData=datas;if(isReset){internalData.isResizeCellHeight=false;}// 
if(keepSource){$xeTable.cacheSourceMap(fullData);}if($xeTable.clearCellAreas&&props.mouseConfig){$xeTable.clearCellAreas();$xeTable.clearCopyCellArea();}$xeTable.clearMergeCells();$xeTable.clearMergeFooterItems();$xeTable.handleTableData(true);$xeTable.updateFooter();$xeTable.handleUpdateBodyMerge();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateHeight();updateStyle();}).then(()=>{computeScrollLoad();}).then(()=>{const virtualYOpts=computeVirtualYOpts.value;// 
if(sYLoad){scrollYStore.endIndex=scrollYStore.visibleSize;}if(sYLoad){if(reactData.expandColumn&&expandOpts.mode!=='fixed'){errLog('vxe.error.notConflictProp',['column.type="expand','expand-config.mode="fixed"']);}if(virtualYOpts.mode==='scroll'&&expandOpts.mode==='fixed'){warnLog('vxe.error.notConflictProp',['virtual-y-config.mode=scroll','expand-config.mode=inside']);}// if (showOverflow) {
//   if (!rowOpts.height) {
//     const errColumn = internalData.tableFullColumn.find(column => column.showOverflow === false)
//     if (errColumn) {
//       errLog('vxe.error.errProp', [`column[field="${errColumn.field}"].show-overflow=false`, 'show-overflow=true'])
//     }
//   }
// }
if(!(props.height||props.maxHeight)){errLog('vxe.error.reqProp',['height | max-height | virtual-y-config={enabled: false}']);}// if (!props.showOverflow) {
//   warnLog('vxe.error.reqProp', ['table.show-overflow'])
// }
// if (props.spanMethod) {
//   warnLog('vxe.error.scrollErrProp', ['span-method'])
// }
}handleReserveStatus();$xeTable.checkSelectionStatus();$xeTable.dispatchEvent('data-change',{visibleColumn:internalData.visibleColumn,visibleData:internalData.afterFullData},null);return new Promise(resolve=>{(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>handleRecalculateStyle(false,false,false)).then(()=>{handleRecalculateStyle(false,true,true);updateRowOffsetTop();}).then(()=>{let targetScrollLeft=lastScrollLeft;let targetScrollTop=lastScrollTop;const virtualXOpts=computeVirtualXOpts.value;const virtualYOpts=computeVirtualYOpts.value;// 
if(virtualXOpts.scrollToLeftOnChange){targetScrollLeft=0;}if(virtualYOpts.scrollToTopOnChange){targetScrollTop=0;}reactData.isRowLoading=false;handleRecalculateStyle(false,false,false);updateTreeLineStyle();//  recalculate 
if(!props.showOverflow){setTimeout(()=>{handleLazyRecalculate(false,true,true);setTimeout(()=>handleLazyRecalculate(false,true,true),3000);},2000);}// 
if(oldScrollYLoad===sYLoad){restoreScrollLocation($xeTable,targetScrollLeft,targetScrollTop).then(()=>{handleRecalculateStyle(false,true,true);updateRowOffsetTop();updateTreeLineStyle();resolve();});}else{setTimeout(()=>{restoreScrollLocation($xeTable,targetScrollLeft,targetScrollTop).then(()=>{handleRecalculateStyle(false,true,true);updateRowOffsetTop();updateTreeLineStyle();resolve();});});}});});});};/**
         * 
         * 
         */const handleLoadDefaults=()=>{handleDefaultSelectionChecked();handleDefaultRadioChecked();handleDefaultRowExpand();handleDefaultTreeExpand();handleDefaultRowGroupExpand();handleDefaultMergeCells();handleDefaultMergeHeaderItems();handleDefaultMergeFooterItems();(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>setTimeout(()=>$xeTable.recalculate()));};/**
         * 
         * 
         */const handleInitDefaults=()=>{handleDefaultSort();};const handleTableColumn=()=>{const{scrollXLoad}=reactData;const{visibleColumn,scrollXStore,fullColumnIdData}=internalData;const tableColumn=scrollXLoad?visibleColumn.slice(scrollXStore.startIndex,scrollXStore.endIndex):visibleColumn.slice(0);tableColumn.forEach((column,$index)=>{const colid=column.id;const colRest=fullColumnIdData[colid];if(colRest){colRest.$index=$index;}});reactData.tableColumn=tableColumn;};const handleUpdateColumn=()=>{const columnList=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(internalData.collectColumn,'renderSortNumber');internalData.collectColumn=columnList;const tableFullColumn=getColumnList(columnList);internalData.tableFullColumn=tableFullColumn;cacheColumnMap();};const loadScrollXData=()=>{const{isScrollXBig}=reactData;const{mergeBodyList,mergeFooterList,scrollXStore}=internalData;const{preloadSize,startIndex,endIndex,offsetSize}=scrollXStore;const{toVisibleIndex,visibleSize}=handleVirtualXVisible();const offsetItem={startIndex:Math.max(0,isScrollXBig?toVisibleIndex-1:toVisibleIndex-1-offsetSize-preloadSize),endIndex:isScrollXBig?toVisibleIndex+visibleSize:toVisibleIndex+visibleSize+offsetSize+preloadSize};scrollXStore.visibleStartIndex=toVisibleIndex-1;scrollXStore.visibleEndIndex=toVisibleIndex+visibleSize+1;calculateMergerOffsetIndex(mergeBodyList.concat(mergeFooterList),offsetItem,'col');const{startIndex:offsetStartIndex,endIndex:offsetEndIndex}=offsetItem;if(toVisibleIndex<=startIndex||toVisibleIndex>=endIndex-visibleSize-1){if(startIndex!==offsetStartIndex||endIndex!==offsetEndIndex){scrollXStore.startIndex=offsetStartIndex;scrollXStore.endIndex=offsetEndIndex;$xeTable.updateScrollXData();}}$xeTable.closeTooltip();};const parseColumns=isReset=>{// const { showOverflow } = props
// const rowOpts = computeRowOpts.value
const leftList=[];const centerList=[];const rightList=[];const{isGroup,columnStore}=reactData;const{collectColumn,tableFullColumn,scrollXStore,fullColumnIdData}=internalData;// 
if(isGroup){const leftGroupList=[];const centerGroupList=[];const rightGroupList=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn,(column,index,items,path,parentColumn)=>{const isColGroup=hasChildrenList(column);// 
if(parentColumn&&parentColumn.fixed){column.fixed=parentColumn.fixed;}if(parentColumn&&(column.fixed||'')!==(parentColumn.fixed||'')){errLog('vxe.error.groupFixed');}if(isColGroup){column.visible=!!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(column.children,subColumn=>hasChildrenList(subColumn)?false:subColumn.visible);}else if(column.visible){if(column.fixed==='left'){leftList.push(column);}else if(column.fixed==='right'){rightList.push(column);}else{centerList.push(column);}}});collectColumn.forEach(column=>{if(column.visible){if(column.fixed==='left'){leftGroupList.push(column);}else if(column.fixed==='right'){rightGroupList.push(column);}else{centerGroupList.push(column);}}});reactData.tableGroupColumn=leftGroupList.concat(centerGroupList).concat(rightGroupList);}else{// 
tableFullColumn.forEach(column=>{if(column.visible){if(column.fixed==='left'){leftList.push(column);}else if(column.fixed==='right'){rightList.push(column);}else{centerList.push(column);}}});}const visibleColumn=leftList.concat(centerList).concat(rightList);internalData.visibleColumn=visibleColumn;updateColumnOffsetLeft();const sXLoad=updateScrollXStatus();reactData.hasFixedColumn=leftList.length>0||rightList.length>0;Object.assign(columnStore,{leftList,centerList,rightList});if(sXLoad){// if (showOverflow) {
//   if (!rowOpts.height) {
//     const errColumn = internalData.tableFullColumn.find(column => column.showOverflow === false)
//     if (errColumn) {
//       errLog('vxe.error.errProp', [`column[field="${errColumn.field}"].show-overflow=false`, 'show-overflow=true'])
//     }
//   }
// }
// if (props.showHeader && !props.showHeaderOverflow) {
//   warnLog('vxe.error.reqProp', ['show-header-overflow'])
// }
// if (props.showFooter && !props.showFooterOverflow) {
//   warnLog('vxe.error.reqProp', ['show-footer-overflow'])
// }
if(props.spanMethod){warnLog('vxe.error.scrollErrProp',['span-method']);}if(props.footerSpanMethod){warnLog('vxe.error.scrollErrProp',['footer-span-method']);}if(isReset){const{visibleSize}=handleVirtualXVisible();scrollXStore.startIndex=0;scrollXStore.endIndex=visibleSize;scrollXStore.visibleSize=visibleSize;scrollXStore.visibleStartIndex=0;scrollXStore.visibleEndIndex=visibleSize;}}// /
// 
if(visibleColumn.length!==internalData.visibleColumn.length||!internalData.visibleColumn.every((column,index)=>column===visibleColumn[index])){$xeTable.clearMergeCells();$xeTable.clearMergeFooterItems();}visibleColumn.forEach((column,index)=>{const colid=column.id;const colRest=fullColumnIdData[colid];if(colRest){colRest._index=index;}});handleTableColumn();handleUpdateAggValues();if(isReset){updateColumnOffsetLeft();return $xeTable.updateFooter().then(()=>{return $xeTable.recalculate();}).then(()=>{$xeTable.updateCellAreas();return $xeTable.recalculate();});}return $xeTable.updateFooter();};const initColumnHierarchy=()=>{const{collectColumn}=internalData;const fullColIdData={};const fullColFieldData={};let sortIndex=1;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn,(column,index,items,path,parentColumn)=>{const{id:colid,field}=column;const parentId=parentColumn?parentColumn.id:null;const rest={$index:-1,_index:-1,column,colid,index,items,parent:parentColumn||null,width:0,oLeft:0};column.parentId=parentId;column.defaultParentId=parentId;column.sortNumber=sortIndex;column.renderSortNumber=sortIndex;sortIndex++;if(field){if(fullColFieldData[field]){errLog('vxe.error.colRepet',['field',field]);}fullColFieldData[field]=rest;}fullColIdData[colid]=rest;});internalData.fullColumnIdData=fullColIdData;internalData.fullColumnFieldData=fullColFieldData;};const handleInitColumn=collectColumn=>{const expandOpts=computeExpandOpts.value;internalData.collectColumn=collectColumn;const tableFullColumn=getColumnList(collectColumn);internalData.tableFullColumn=tableFullColumn;reactData.isColLoading=true;initColumnHierarchy();return Promise.resolve(restoreCustomStorage()).then(()=>{const{scrollXLoad,scrollYLoad,expandColumn}=reactData;cacheColumnMap();parseColumns(true).then(()=>{if(reactData.scrollXLoad){loadScrollXData();}});$xeTable.clearMergeCells();$xeTable.clearMergeFooterItems();$xeTable.handleTableData(true);$xeTable.handleAggregateSummaryData();if((scrollXLoad||scrollYLoad)&&expandColumn&&expandOpts.mode!=='fixed'){warnLog('vxe.error.scrollErrProp',['column.type=expand']);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{if($xeToolbar){$xeToolbar.syncUpdate({collectColumn:internalData.collectColumn,$table:$xeTable});}if($xeTable.handleUpdateCustomColumn){$xeTable.handleUpdateCustomColumn();}const columnOpts=computeColumnOpts.value;if(props.showCustomHeader&&reactData.isGroup&&(columnOpts.resizable||props.resizable)){warnLog('vxe.error.notConflictProp',['show-custom-header & colgroup','column-config.resizable=false']);}reactData.isColLoading=false;return handleLazyRecalculate(false,true,true);});});};const updateScrollXStatus=fullColumn=>{const virtualXOpts=computeVirtualXOpts.value;const allCols=fullColumn||internalData.tableFullColumn;// gt0
const scrollXLoad=!!virtualXOpts.enabled&&virtualXOpts.gt>-1&&(virtualXOpts.gt===0||virtualXOpts.gt<allCols.length);reactData.scrollXLoad=scrollXLoad;return scrollXLoad;};const updateScrollYStatus=fullData=>{const{treeConfig}=props;const $xeGanttView=internalData.xeGanttView;const virtualYOpts=computeVirtualYOpts.value;const treeOpts=computeTreeOpts.value;const{transform}=treeOpts;const allList=fullData||internalData.tableFullData;// gt0
const scrollYLoad=(transform||!treeConfig)&&!!virtualYOpts.enabled&&virtualYOpts.gt>-1&&(virtualYOpts.gt===0||virtualYOpts.gt<allList.length);reactData.scrollYLoad=scrollYLoad;if($xeGanttView&&$xeGanttView.handleUpdateSYStatus){$xeGanttView.handleUpdateSYStatus(scrollYLoad);}return scrollYLoad;};/**
         * 
         * @param rows
         * @param expanded
         * @returns
         */const handleBaseTreeExpand=(rows,expanded)=>{const{treeNodeColumn}=reactData;const{fullAllDataRowIdData,tableFullTreeData,treeExpandedMaps,treeExpandLazyLoadedMaps}=internalData;const treeOpts=computeTreeOpts.value;const{reserve,lazy,accordion,toggleMethod}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const hasChildField=treeOpts.hasChild||treeOpts.hasChildField;const result=[];const columnIndex=$xeTable.getColumnIndex(treeNodeColumn);const $columnIndex=$xeTable.getVMColumnIndex(treeNodeColumn);const{handleGetRowId}=createHandleGetRowId($xeTable);let validRows=toggleMethod?rows.filter(row=>toggleMethod({$table:$xeTable,expanded,column:treeNodeColumn,columnIndex,$columnIndex,row})):rows;if(accordion){validRows=validRows.length?[validRows[validRows.length-1]]:[];// 
const matchObj=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData,item=>item===validRows[0],{children:childrenField});if(matchObj){matchObj.items.forEach(item=>{const rowid=handleGetRowId(item);if(treeExpandedMaps[rowid]){delete treeExpandedMaps[rowid];}});}}if(expanded){validRows.forEach(row=>{const rowid=handleGetRowId(row);if(!treeExpandedMaps[rowid]){const rowRest=fullAllDataRowIdData[rowid];if(rowRest){const isLoad=lazy&&row[hasChildField]&&!rowRest.treeLoaded&&!treeExpandLazyLoadedMaps[rowid];// 
if(isLoad){result.push(handleAsyncTreeExpandChilds(row));}else{if(row[childrenField]&&row[childrenField].length){treeExpandedMaps[rowid]=row;}}}}});}else{validRows.forEach(item=>{const rowid=handleGetRowId(item);if(treeExpandedMaps[rowid]){delete treeExpandedMaps[rowid];}});}if(reserve){validRows.forEach(row=>handleTreeExpandReserve(row,expanded));}reactData.treeExpandedFlag++;return Promise.all(result).then(()=>{updateTreeLineStyle();return $xeTable.recalculate();});};/**
         * 
         * @param rows
         * @param expanded
         * @returns
         */const handleVirtualTreeExpand=(rows,expanded)=>{const{lastScrollLeft,lastScrollTop}=internalData;return handleBaseTreeExpand(rows,expanded).then(()=>{handleVirtualTreeToList();$xeTable.handleTableData();reactData.treeExpandedFlag++;updateAfterDataIndex();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}).then(()=>{return handleRecalculateStyle(true,true,true);}).then(()=>{restoreScrollLocation($xeTable,lastScrollLeft,lastScrollTop);updateTreeLineStyle();setTimeout(()=>{$xeTable.updateCellAreas();},30);});};/**
         * 
         * @param rows
         * @param expanded
         * @returns
         */const handleRowGroupBaseExpand=(rows,expanded)=>{const{fullAllDataRowIdData,tableFullGroupData,rowGroupExpandedMaps}=internalData;const aggregateOpts=computeAggregateOpts.value;const{mapChildrenField,accordion}=aggregateOpts;const{handleGetRowId}=createHandleGetRowId($xeTable);let validRows=rows;if(mapChildrenField){if(accordion){validRows=validRows.length?[validRows[validRows.length-1]]:[];// 
const matchObj=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullGroupData,item=>getRowid($xeTable,item)===getRowid($xeTable,validRows[0]),{children:mapChildrenField});if(matchObj){matchObj.items.forEach(item=>{const rowid=handleGetRowId(item);if(rowGroupExpandedMaps[rowid]){delete rowGroupExpandedMaps[rowid];}});}}if(expanded){validRows.forEach(row=>{const rowid=handleGetRowId(row);if(!rowGroupExpandedMaps[rowid]){const rowRest=fullAllDataRowIdData[rowid];if(rowRest){if(row[mapChildrenField]&&row[mapChildrenField].length){rowGroupExpandedMaps[rowid]=row;}}}});}else{validRows.forEach(item=>{const rowid=handleGetRowId(item);if(rowGroupExpandedMaps[rowid]){delete rowGroupExpandedMaps[rowid];}});}}reactData.rowGroupExpandedFlag++;return $xeTable.recalculate();};/**
         * 
         * @param rows
         * @param expanded
         * @returns
         */const handleRowGroupVirtualExpand=(rows,expanded)=>{return handleRowGroupBaseExpand(rows,expanded).then(()=>{handleVirtualTreeToList();$xeTable.handleTableData();reactData.rowGroupExpandedFlag++;updateAfterDataIndex();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}).then(()=>{return handleLazyRecalculate(true,true,true);}).then(()=>{setTimeout(()=>{$xeTable.updateCellAreas();},30);});};/**
         * 
         */const handleDefaultRowGroupExpand=()=>{const{isRowGroupStatus}=reactData;if(isRowGroupStatus){const aggregateOpts=computeAggregateOpts.value;const{expandAll,expandGroupFields}=aggregateOpts;if(expandAll){$xeTable.setAllRowGroupExpand(true);}else if(expandGroupFields&&expandGroupFields.length){$xeTable.setRowGroupExpandByField(expandGroupFields,true);}}};const handleCheckAllEvent=(evnt,value)=>{handleCheckedAllCheckboxRow(value);if(evnt){dispatchEvent('checkbox-all',{records:()=>$xeTable.getCheckboxRecords(),reserves:()=>$xeTable.getCheckboxReserveRecords(),indeterminates:()=>$xeTable.getCheckboxIndeterminateRecords(),checked:value},evnt);}};/**
         *  Y 
         */const loadScrollYData=()=>{const{isAllOverflow,isScrollYBig}=reactData;const{mergeBodyList,scrollYStore}=internalData;const{preloadSize,startIndex,endIndex,offsetSize}=scrollYStore;const autoOffsetYSize=isAllOverflow?offsetSize:offsetSize+1;const{toVisibleIndex,visibleSize}=handleVirtualYVisible();const offsetItem={startIndex:Math.max(0,isScrollYBig?toVisibleIndex-1:toVisibleIndex-1-offsetSize-preloadSize),endIndex:isScrollYBig?toVisibleIndex+visibleSize:toVisibleIndex+visibleSize+autoOffsetYSize+preloadSize};scrollYStore.visibleStartIndex=toVisibleIndex-1;scrollYStore.visibleEndIndex=toVisibleIndex+visibleSize+1;calculateMergerOffsetIndex(mergeBodyList,offsetItem,'row');const{startIndex:offsetStartIndex,endIndex:offsetEndIndex}=offsetItem;if(toVisibleIndex<=startIndex||toVisibleIndex>=endIndex-visibleSize-1){if(startIndex!==offsetStartIndex||endIndex!==offsetEndIndex){scrollYStore.startIndex=offsetStartIndex;scrollYStore.endIndex=offsetEndIndex;$xeTable.updateScrollYData();}}};const createGetRowCacheProp=prop=>{return function(row){const{fullAllDataRowIdData}=internalData;if(row){const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){return rowRest[prop];}}return-1;};};const createGetColumnCacheProp=prop=>{return function(column){const{fullColumnIdData}=internalData;if(column){const colRest=fullColumnIdData[column.id];if(colRest){return colRest[prop];}}return-1;};};const lazyScrollXData=()=>{const{lxTimeout,lxRunTime,scrollXStore}=internalData;const{visibleSize}=scrollXStore;const fpsTime=visibleSize>26?26:visibleSize>16?14:6;if(lxTimeout){clearTimeout(lxTimeout);}if(!lxRunTime||lxRunTime+fpsTime<Date.now()){internalData.lxRunTime=Date.now();loadScrollXData();}internalData.lxTimeout=setTimeout(()=>{internalData.lxTimeout=undefined;internalData.lxRunTime=undefined;loadScrollXData();},fpsTime);};const lazyScrollYData=()=>{const{lyTimeout,lyRunTime,scrollYStore}=internalData;const{visibleSize}=scrollYStore;const fpsTime=visibleSize>30?32:visibleSize>20?18:8;if(lyTimeout){clearTimeout(lyTimeout);}if(!lyRunTime||lyRunTime+fpsTime<Date.now()){internalData.lyRunTime=Date.now();loadScrollYData();}internalData.lyTimeout=setTimeout(()=>{internalData.lyTimeout=undefined;internalData.lyRunTime=undefined;loadScrollYData();},fpsTime);};const checkLastSyncScroll=(isRollX,isRollY)=>{const{lcsTimeout}=internalData;reactData.lazScrollLoading=true;if(lcsTimeout){clearTimeout(lcsTimeout);}internalData.lcsTimeout=setTimeout(()=>{const{scrollXLoad,scrollYLoad,isAllOverflow}=reactData;internalData.lcsRunTime=Date.now();internalData.lcsTimeout=undefined;internalData.intoRunScroll=false;internalData.inVirtualScroll=false;internalData.inWheelScroll=false;internalData.inHeaderScroll=false;internalData.inBodyScroll=false;internalData.inFooterScroll=false;reactData.lazScrollLoading=false;internalData.scrollRenderType='';if(!isAllOverflow){calcCellHeight();updateRowOffsetTop();}if(isRollX&&scrollXLoad){$xeTable.updateScrollXData();}if(isRollY&&scrollYLoad){$xeTable.updateScrollYData().then(()=>{if(!isAllOverflow){calcCellHeight();updateRowOffsetTop();}$xeTable.updateScrollYSpace();});}updateRowExpandStyle();$xeTable.updateCellAreas();},200);};const getWheelSpeed=lastScrollTime=>{let multiple=1;const currTime=Date.now();if(lastScrollTime+25>currTime){multiple=1.18;}else if(lastScrollTime+30>currTime){multiple=1.15;}else if(lastScrollTime+40>currTime){multiple=1.12;}else if(lastScrollTime+55>currTime){multiple=1.09;}else if(lastScrollTime+75>currTime){multiple=1.06;}else if(lastScrollTime+100>currTime){multiple=1.03;}return multiple;};const wheelScrollLeftTo=(scrollLeft,cb)=>{requestAnimationFrame(()=>{cb(scrollLeft);});};const wheelScrollTopTo=(diffNum,cb)=>{const duration=Math.abs(diffNum);const startTime=performance.now();let countTop=0;const step=timestamp=>{let progress=(timestamp-startTime)/duration;if(progress<0){progress=0;}else if(progress>1){progress=1;}const easedProgress=Math.pow(progress,2);const offsetTop=Math.floor(diffNum*easedProgress)-countTop;countTop+=offsetTop;cb(offsetTop);if(progress<1){requestAnimationFrame(step);}};requestAnimationFrame(step);};const syncGanttScrollTop=scrollTop=>{const $xeGanttView=internalData.xeGanttView;if($xeGanttView){const ganttInternalData=$xeGanttView.internalData;const{elemStore:ganttElemStore}=ganttInternalData;const ganttBodyScrollElem=getRefElem(ganttElemStore['main-body-scroll']);if(ganttBodyScrollElem){ganttBodyScrollElem.scrollTop=scrollTop;}}};const dispatchEvent=(type,params,evnt)=>{emit(type,createEvent(evnt,{$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt},params));};const handleScrollToRowColumn=(fieldOrColumn,row)=>{const{fullColumnIdData}=internalData;const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column&&fullColumnIdData[column.id]){return colToVisible($xeTable,column,row);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};const handleUpdateResize=()=>{const el=refElem.value;if(el&&el.clientWidth&&el.clientHeight){$xeTable.recalculate();}};const handleUpdateColResize=(evnt,params)=>{$xeTable.analyColumnWidth();$xeTable.recalculate().then(()=>{$xeTable.saveCustomStore('update:width');$xeTable.updateCellAreas();$xeTable.dispatchEvent('column-resizable-change',params,evnt);//  resizable-change
$xeTable.dispatchEvent('resizable-change',params,evnt);setTimeout(()=>$xeTable.recalculate(true),300);});};const handleUpdateRowResize=(evnt,params)=>{reactData.resizeHeightFlag++;$xeTable.recalculate().then(()=>{$xeTable.updateCellAreas();$xeTable.dispatchEvent('row-resizable-change',params,evnt);setTimeout(()=>$xeTable.recalculate(true),300);});};const updateColumnOffsetLeft=()=>{const{visibleColumn,fullColumnIdData}=internalData;let offsetLeft=0;for(let cIndex=0,rLen=visibleColumn.length;cIndex<rLen;cIndex++){const column=visibleColumn[cIndex];const colid=column.id;const colRest=fullColumnIdData[colid];if(colRest){colRest.oLeft=offsetLeft;}offsetLeft+=column.renderWidth;}};const updateRowOffsetTop=()=>{const{expandColumn}=reactData;const{afterFullData,fullAllDataRowIdData,rowExpandedMaps}=internalData;const expandOpts=computeExpandOpts.value;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const{handleGetRowId}=createHandleGetRowId($xeTable);let offsetTop=0;for(let rIndex=0,rLen=afterFullData.length;rIndex<rLen;rIndex++){const row=afterFullData[rIndex];const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid]||{};rowRest.oTop=offsetTop;offsetTop+=rowRest.resizeHeight||cellOpts.height||rowOpts.height||rowRest.height||defaultRowHeight;// 
if(expandColumn&&rowExpandedMaps[rowid]){offsetTop+=rowRest.expandHeight||expandOpts.height||0;}}};/**
         * 
         */const updateRowExpandStyle=()=>{const{expandColumn,scrollYLoad,scrollYTop,isScrollYBig}=reactData;const expandOpts=computeExpandOpts.value;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const{mode}=expandOpts;if(expandColumn&&mode==='fixed'){const{elemStore,fullAllDataRowIdData}=internalData;const rowExpandEl=refRowExpandElem.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);if(rowExpandEl&&bodyScrollElem){let isUpdateHeight=false;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(rowExpandEl.children,reEl=>{const expandEl=reEl;const rowid=expandEl.getAttribute('rowid')||'';const rowRest=fullAllDataRowIdData[rowid];if(rowRest){const expandHeight=expandEl.offsetHeight+1;const trEl=bodyScrollElem.querySelector(`.vxe-body--row[rowid="${rowid}"]`);let offsetTop=0;if(scrollYLoad){if(isScrollYBig&&trEl){offsetTop=trEl.offsetTop+trEl.offsetHeight;}else{offsetTop=rowRest.oTop+(rowRest.resizeHeight||cellOpts.height||rowOpts.height||rowRest.height||defaultRowHeight);}}else{if(trEl){offsetTop=trEl.offsetTop+trEl.offsetHeight;}}if(isScrollYBig){offsetTop+=scrollYTop;}expandEl.style.top=toCssUnit(offsetTop);if(!isUpdateHeight){if(rowRest.expandHeight!==expandHeight){isUpdateHeight=true;}}rowRest.expandHeight=expandHeight;}});if(isUpdateHeight){reactData.rowExpandHeightFlag++;(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{updateRowOffsetTop();});}}}};/**
         * 
         */const updateTreeLineStyle=()=>{const{treeConfig}=props;if(!treeConfig){return;}const{tableData}=reactData;const{fullAllDataRowIdData,treeExpandedMaps}=internalData;const cellOpts=computeCellOpts.value;const rowOpts=computeRowOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const treeOpts=computeTreeOpts.value;const{transform,mapChildrenField}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const{handleGetRowId}=createHandleGetRowId($xeTable);const expParentList=[];const handleNodeRow=(row,rIndex,rows)=>{const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid]||{};const childList=row[transform?mapChildrenField:childrenField];const prevRow=rows[rIndex-1]||null;const nextRow=rows[rIndex+1]||null;if(childList&&childList.length&&treeExpandedMaps[rowid]){expParentList.push({row,prevRow,nextRow});childList.forEach((childRow,crIndex)=>{const childRowid=handleGetRowId(childRow);if(treeExpandedMaps[childRowid]){handleNodeRow(childRow,crIndex,childList);}});}else{if(nextRow){const nextRowid=handleGetRowId(nextRow);const nextRowRest=fullAllDataRowIdData[nextRowid]||{};const currCellHeight=getCellRestHeight(rowRest,cellOpts,rowOpts,defaultRowHeight);const nextCellHeight=getCellRestHeight(nextRowRest,cellOpts,rowOpts,defaultRowHeight);rowRest.oHeight=currCellHeight;rowRest.lineHeight=Math.floor(currCellHeight/2+nextCellHeight/2);}else{rowRest.oHeight=0;rowRest.lineHeight=0;}}};tableData.forEach((row,rIndex)=>{handleNodeRow(row,rIndex,tableData);});external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().lastArrayEach(expParentList,({row,nextRow})=>{const rowid=handleGetRowId(row);const childList=row[transform?mapChildrenField:childrenField];const rowRest=fullAllDataRowIdData[rowid];if(rowRest){const currCellHeight=getCellRestHeight(rowRest,cellOpts,rowOpts,defaultRowHeight);let countOffsetHeight=currCellHeight;let countLineHeight=0;childList.forEach(childRow=>{const childRowid=handleGetRowId(childRow);const childRowRest=fullAllDataRowIdData[childRowid]||{};const childList=childRow[transform?mapChildrenField:childrenField];if(treeExpandedMaps[childRowid]&&childList&&childList.length){countOffsetHeight+=childRowRest.oHeight||0;countLineHeight+=childRowRest.oHeight||0;}else{const cellHeight=getCellRestHeight(childRowRest,cellOpts,rowOpts,defaultRowHeight);childRowRest.oHeight=cellHeight;childRowRest.lineHeight=cellHeight;countOffsetHeight+=cellHeight;countLineHeight+=cellHeight;}});if(nextRow){const nextRowid=handleGetRowId(nextRow);const nextRowRest=fullAllDataRowIdData[nextRowid]||{};const currCellHeight=getCellRestHeight(rowRest,cellOpts,rowOpts,defaultRowHeight);const nextCellHeight=getCellRestHeight(nextRowRest,cellOpts,rowOpts,defaultRowHeight);countOffsetHeight+=currCellHeight;countLineHeight+=Math.floor(currCellHeight/2+nextCellHeight/2);}rowRest.lineHeight=countLineHeight;rowRest.oHeight=countOffsetHeight;}});};const handleRowExpandScroll=()=>{const{elemStore}=internalData;const rowExpandEl=refRowExpandElem.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);if(rowExpandEl&&bodyScrollElem){rowExpandEl.scrollTop=bodyScrollElem.scrollTop;}};tableMethods={dispatchEvent,getEl(){return refElem.value;},/**
             * 
             */clearAll(){return clearTableAllStatus($xeTable);},/**
             *  data 
             * 
             * 
             */syncData(){errLog('vxe.error.delFunc',['syncData','getData']);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{reactData.tableData=[];emit('update:data',internalData.tableFullData);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();});},/**
             * 
             * ...
             */updateData(){const{scrollXLoad,scrollYLoad}=reactData;return $xeTable.handleTableData(true).then(()=>{$xeTable.updateFooter();if(scrollXLoad||scrollYLoad){if(scrollXLoad){$xeTable.updateScrollXSpace();}if(scrollYLoad){$xeTable.updateScrollYSpace();}return $xeTable.refreshScroll();}}).then(()=>{$xeTable.updateCellAreas();return handleLazyRecalculate(true,true,true);}).then(()=>{// 
setTimeout(()=>handleLazyRecalculate(false,true,true),50);});},/**
             * 
             * @param {Array} datas 
             */loadData(datas){const{initStatus}=internalData;return loadTableData(datas,false).then(()=>{internalData.inited=true;internalData.initStatus=true;if(!initStatus){handleLoadDefaults();}return handleLazyRecalculate(false,true,true);});},/**
             * 
             * @param {Array} datas 
             */reloadData(datas){return $xeTable.clearAll().then(()=>{internalData.inited=true;internalData.initStatus=true;return loadTableData(datas,true);}).then(()=>{handleLoadDefaults();return handleLazyRecalculate(false,true,true);});},/**
             * 
             */setRow(rows,record){if(rows&&record){let rest=rows;if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rest=[rows];}const rowkey=getRowkey($xeTable);rest.forEach(row=>{const rowid=getRowid($xeTable,row);const newRecord=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(Object.assign({},record),true);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(newRecord,rowkey,rowid);Object.assign(row,newRecord);});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             * 
             * @param {Row} row 
             * @param {Object} record 
             * @param {String} field 
             */reloadRow(row,record,field){const{keepSource}=props;const{tableData}=reactData;const{sourceDataRowIdData}=internalData;if(keepSource){if($xeTable.isAggregateRecord(row)){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}const oRow=sourceDataRowIdData[getRowid($xeTable,row)];if(oRow&&row){if(field){const newValue=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(record||row,field),true);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,field,newValue);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(oRow,field,newValue);}else{const rowkey=getRowkey($xeTable);const rowid=getRowid($xeTable,row);const newRecord=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(Object.assign({},record),true);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(newRecord,rowkey,rowid);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().destructuring(oRow,Object.assign(row,newRecord));}}reactData.tableData=tableData.slice(0);}else{errLog('vxe.error.reqProp',['keep-source']);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},getParams(){return props.params;},/**
             * 
             */loadTreeChildren(row,childRecords){const{keepSource}=props;const{tableSourceData,fullDataRowIdData,fullAllDataRowIdData,sourceDataRowIdData}=internalData;const treeOpts=computeTreeOpts.value;const{transform,mapChildrenField}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const parentRest=fullAllDataRowIdData[getRowid($xeTable,row)];const parentLevel=parentRest?parentRest.level:0;return tableMethods.createData(childRecords).then(rows=>{if(keepSource){const rowid=getRowid($xeTable,row);const matchObj=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableSourceData,item=>rowid===getRowid($xeTable,item),{children:childrenField});if(matchObj){matchObj.item[childrenField]=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(rows,true);}rows.forEach(childRow=>{const rowid=getRowid($xeTable,childRow);sourceDataRowIdData[rowid]=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(childRow,true);});}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(rows,(childRow,index,items,path,parentItem,nodes)=>{const rowid=getRowid($xeTable,childRow);const parentRow=parentItem||parentRest.row;const rest={row:childRow,rowid,seq:-1,index,_index:-1,$index:-1,treeIndex:-1,_tIndex:-1,items,parent:parentRow,level:parentLevel+nodes.length,height:0,resizeHeight:0,oTop:0,expandHeight:0};fullDataRowIdData[rowid]=rest;fullAllDataRowIdData[rowid]=rest;},{children:childrenField});row[childrenField]=rows;if(transform){row[mapChildrenField]=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(rows,false);}updateAfterDataIndex();return rows;});},/**
             * 
             * 
             * @param {ColumnInfo} columns 
             */loadColumn(columns){const{lastScrollLeft,lastScrollTop}=internalData;const collectColumn=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(columns,column=>(0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(cell.createColumn($xeTable,column)));return handleInitColumn(collectColumn).then(()=>{let targetScrollLeft=lastScrollLeft;let targetScrollTop=lastScrollTop;const virtualXOpts=computeVirtualXOpts.value;const virtualYOpts=computeVirtualYOpts.value;// 
if(virtualXOpts.scrollToLeftOnChange){targetScrollLeft=0;}if(virtualYOpts.scrollToTopOnChange){targetScrollTop=0;}restoreScrollLocation($xeTable,targetScrollLeft,targetScrollTop);});},/**
             * 
             * 
             * @param {ColumnInfo} columns 
             */reloadColumn(columns){return tableMethods.clearAll().then(()=>{return tableMethods.loadColumn(columns);});},/**
             *  tr  row 
             * @param {Element} tr 
             */getRowNode(tr){if(tr){const{fullAllDataRowIdData}=internalData;const rowid=tr.getAttribute('rowid');if(rowid){const rowRest=fullAllDataRowIdData[rowid];if(rowRest){return{rowid:rowRest.rowid,item:rowRest.row,index:rowRest.index,items:rowRest.items,parent:rowRest.parent};}}}return null;},/**
             *  th/td  column 
             * @param {Element} cell 
             */getColumnNode(cell){if(cell){const{fullColumnIdData}=internalData;const colid=cell.getAttribute('colid');if(colid){const colRest=fullColumnIdData[colid];if(colRest){return{colid:colRest.colid,item:colRest.column,index:colRest.index,items:colRest.items,parent:colRest.parent};}}}return null;},/**
             *  row 
             * @param {Row} row 
             */getRowSeq:createGetRowCacheProp('seq'),/**
             *  row  data 
             * @param {Row} row 
             */getRowIndex:createGetRowCacheProp('index'),/**
             *  row 
             * @param {Row} row 
             */getVTRowIndex:createGetRowCacheProp('_index'),/**
             *  row 
             * @param {Row} row 
             */getVMRowIndex:createGetRowCacheProp('$index'),/**
             *  column  columns 
             * @param {ColumnInfo} column 
             */getColumnIndex:createGetColumnCacheProp('index'),/**
             *  column 
             * @param {ColumnInfo} column 
             */getVTColumnIndex:createGetColumnCacheProp('_index'),/**
             *  column 
             * @param {ColumnInfo} column 
             */getVMColumnIndex:createGetColumnCacheProp('$index'),/**
             *  data 
             * 
             * @param {Array} records 
             */createData(records){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(tablePrivateMethods.defineField(records));});},/**
             *  Row|Rows 
             * 
             * @param {Array/Object} records 
             */createRow(records){const isArr=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records);if(!isArr){records=[records||{}];}return tableMethods.createData(records).then(rows=>isArr?rows:rows[0]);},/**
             * 
             * 
             *  row 
             *  rows 
             *  field 
             */revertData(rows,field){const{keepSource,treeConfig}=props;const{fullAllDataRowIdData,fullDataRowIdData,tableSourceData,sourceDataRowIdData,tableFullData,afterFullData,removeRowMaps}=internalData;const treeOpts=computeTreeOpts.value;const{transform}=treeOpts;const{handleGetRowId}=createHandleGetRowId($xeTable);if(!keepSource){errLog('vxe.error.reqProp',['keep-source']);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}let targetRows=rows;if(rows){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){targetRows=[rows];}}else{targetRows=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArray($xeTable.getUpdateRecords());}let reDelFlag=false;if(targetRows.length){targetRows.forEach(item=>{const rowid=handleGetRowId(item);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){const row=rowRest.row;if(!$xeTable.isInsertByRow(row)){const oRow=sourceDataRowIdData[rowid];if(oRow&&row){if(field){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,field,external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(oRow,field),true));}else{external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().destructuring(row,external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(oRow,true));}if(!fullDataRowIdData[rowid]&&$xeTable.isRemoveByRow(row)){if(removeRowMaps[rowid]){delete removeRowMaps[rowid];}tableFullData.unshift(row);afterFullData.unshift(row);reDelFlag=true;}}}}});}if(rows){if(reDelFlag){reactData.removeRowFlag++;$xeTable.updateFooter();$xeTable.cacheRowMap(false);$xeTable.handleTableData(treeConfig&&transform);if(!(treeConfig&&transform)){$xeTable.updateAfterDataIndex();}$xeTable.checkSelectionStatus();if(reactData.scrollYLoad){$xeTable.updateScrollYSpace();}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{$xeTable.updateCellAreas();return handleLazyRecalculate(false,true,true);});}return $xeTable.reloadData(tableSourceData);},/**
             * 
             * 
             *  row 
             *  rows 
             *  field 
             * @param {Array/Row} rows 
             * @param {String} field 
             */clearData(rows,field){const{tableFullData,visibleColumn}=internalData;if(!arguments.length){rows=tableFullData;}else if(rows&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}if(field){rows.forEach(row=>external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,field,null));}else{rows.forEach(row=>{visibleColumn.forEach(column=>{if(column.field){setCellValue(row,column,null);}});});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},getCellElement(row,fieldOrColumn){const{elemStore}=internalData;const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(!column){return null;}const rowid=getRowid($xeTable,row);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);let bodyElem;if(column){if(column.fixed){if(column.fixed==='left'){if(leftScrollElem){bodyElem=leftScrollElem;}}else{if(rightScrollElem){bodyElem=rightScrollElem;}}}if(!bodyElem){bodyElem=bodyScrollElem;}if(bodyElem){return bodyElem.querySelector(`.vxe-body--row[rowid="${rowid}"] .${column.id}`);}}return null;},getCellLabel(row,fieldOrColumn){const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(!column){return null;}const{formatter}=column;const cellValue=getCellValue(row,column);let cellLabel=cellValue;if(formatter){let formatData;const{fullAllDataRowIdData}=internalData;const rowid=getRowid($xeTable,row);const colid=column.id;const rowRest=fullAllDataRowIdData[rowid];if(rowRest){formatData=rowRest.formatData;if(!formatData){formatData=fullAllDataRowIdData[rowid].formatData={};}if(rowRest&&formatData[colid]){if(formatData[colid].value===cellValue){return formatData[colid].label;}}}const formatParams={cellValue,row,rowIndex:$xeTable.getRowIndex(row),column,columnIndex:$xeTable.getColumnIndex(column)};if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(formatter)){const gFormatOpts=table_formats.get(formatter);const tcFormatMethod=gFormatOpts?gFormatOpts.tableCellFormatMethod||gFormatOpts.cellFormatMethod:null;cellLabel=tcFormatMethod?tcFormatMethod(formatParams):'';}else if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(formatter)){const gFormatOpts=table_formats.get(formatter[0]);const tcFormatMethod=gFormatOpts?gFormatOpts.tableCellFormatMethod||gFormatOpts.cellFormatMethod:null;cellLabel=tcFormatMethod?tcFormatMethod(formatParams,...formatter.slice(1)):'';}else{cellLabel=formatter(formatParams);}if(formatData){formatData[colid]={value:cellValue,label:cellLabel};}}return cellLabel;},getFooterCellLabel(row,fieldOrColumn){const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(!column){return null;}const{footerFormatter}=column;const _columnIndex=$xeTable.getVTColumnIndex(column);let itemValue='';// 
if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(row)){itemValue=row[_columnIndex];}else{itemValue=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,column.field);}let cellLabel=itemValue;if(footerFormatter){let formatData;const{footerTableData}=reactData;const{footerFullDataRowData}=internalData;const colid=column.id;const $rowIndex=footerTableData.indexOf(row);let rowRest=null;if($rowIndex>-1){rowRest=footerFullDataRowData[$rowIndex];if(!rowRest){rowRest=footerFullDataRowData[$rowIndex]={};}formatData=rowRest.formatData;if(!formatData){formatData=footerFullDataRowData[$rowIndex].formatData={};}if(rowRest&&formatData[colid]){if(formatData[colid].value===itemValue){return formatData[colid].label;}}}const footerFormatParams={cellValue:itemValue,itemValue,row,items:row,$rowIndex,column,_columnIndex,columnIndex:$xeTable.getColumnIndex(column)};if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(footerFormatter)){const gFormatOpts=table_formats.get(footerFormatter);const fcFormatMethod=gFormatOpts?gFormatOpts.tableFooterCellFormatMethod:null;cellLabel=fcFormatMethod?fcFormatMethod(footerFormatParams):'';}else if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(footerFormatter)){const gFormatOpts=table_formats.get(footerFormatter[0]);const fcFormatMethod=gFormatOpts?gFormatOpts.tableFooterCellFormatMethod:null;cellLabel=fcFormatMethod?fcFormatMethod(footerFormatParams,...footerFormatter.slice(1)):'';}else{cellLabel=footerFormatter(footerFormatParams);}if(formatData){formatData[colid]={value:itemValue,label:cellLabel};}}return cellLabel;},/**
             * 
             */isInsertByRow(row){const rowid=getRowid($xeTable,row);return!!reactData.insertRowFlag&&!!internalData.insertRowMaps[rowid];},isRemoveByRow(row){const rowid=getRowid($xeTable,row);return!!reactData.removeRowFlag&&!!internalData.removeRowMaps[rowid];},/**
             * 
             */removeInsertRow(){const{insertRowMaps}=internalData;return $xeTable.remove(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().values(insertRowMaps));},/**
             * 
             */isUpdateByRow(rowidOrRow,field){const{keepSource}=props;const{tableFullColumn,fullDataRowIdData,sourceDataRowIdData}=internalData;if(keepSource){const rowid=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowidOrRow)||external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(rowidOrRow)?rowidOrRow:getRowid($xeTable,rowidOrRow);const rowRest=fullDataRowIdData[rowid];// 
if(!rowRest){return false;}const row=rowRest.row;const oRow=sourceDataRowIdData[rowid];if(oRow){if(arguments.length>1){return!eqCellValue(oRow,row,field);}for(let index=0,len=tableFullColumn.length;index<len;index++){const property=tableFullColumn[index].field;if(property&&!eqCellValue(oRow,row,property)){return true;}}}}return false;},/**
             * 
             * @param {Number} columnIndex 
             */getColumns(columnIndex){const{visibleColumn}=internalData;return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(columnIndex)?visibleColumn.slice(0):visibleColumn[columnIndex];},/**
             * 
             */getColid(fieldOrColumn){const column=handleFieldOrColumn($xeTable,fieldOrColumn);return column?column.id:null;},/**
             * 
             * @param {String} colid 
             */getColumnById(colid){const{fullColumnIdData}=internalData;return colid&&fullColumnIdData[colid]?fullColumnIdData[colid].column:null;},/**
             * 
             * @param {String} field 
             */getColumnByField(field){const fullColumnFieldData=internalData.fullColumnFieldData;return field&&fullColumnFieldData[field]?fullColumnFieldData[field].column:null;},getParentColumn(fieldOrColumn){const{fullColumnIdData}=internalData;const column=handleFieldOrColumn($xeTable,fieldOrColumn);return column&&column.parentId&&fullColumnIdData[column.parentId]?fullColumnIdData[column.parentId].column:null;},/**
             * 
             * 
             */getTableColumn(){return{collectColumn:internalData.collectColumn.slice(0),fullColumn:internalData.tableFullColumn.slice(0),visibleColumn:internalData.visibleColumn.slice(0),tableColumn:reactData.tableColumn.slice(0)};},/**
             * 
             * @param fieldOrColumn
             * @param targetFieldOrColumn
             * @param options
             */moveColumnTo(fieldOrColumn,targetFieldOrColumn,options){const{fullColumnIdData,visibleColumn}=internalData;const{dragToChild,dragPos,isCrossDrag}=Object.assign({},options);const dragCol=handleFieldOrColumn($xeTable,fieldOrColumn);let prevDragCol=null;const colRest=dragCol?fullColumnIdData[dragCol.id]:null;let defPos='left';if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(targetFieldOrColumn)){if(colRest&&targetFieldOrColumn){let currList=colRest.items;let offsetIndex=colRest._index+targetFieldOrColumn;if(isCrossDrag){currList=visibleColumn;offsetIndex=colRest._index+targetFieldOrColumn;}if(offsetIndex>0&&offsetIndex<currList.length-1){prevDragCol=currList[offsetIndex];}if(targetFieldOrColumn>0){defPos='right';}}}else{prevDragCol=handleFieldOrColumn($xeTable,targetFieldOrColumn);const targetColRest=prevDragCol?fullColumnIdData[prevDragCol.id]:null;if(colRest&&targetColRest){if(targetColRest._index>colRest._index){defPos='right';}}}return $xeTable.handleColDragSwapEvent(null,true,dragCol,prevDragCol,dragPos||defPos,dragToChild===true);},/**
             * 
             * @param rowidOrRow
             * @param targetRowidOrRow
             * @param options
             */moveRowTo(rowidOrRow,targetRowidOrRow,options){const{treeConfig}=props;const{fullAllDataRowIdData,afterFullData}=internalData;const{dragToChild,dragPos,isCrossDrag}=Object.assign({},options);const treeOpts=computeTreeOpts.value;const dragRow=handleRowidOrRow($xeTable,rowidOrRow);let prevDragRow=null;let defPos='top';const rowRest=dragRow?fullAllDataRowIdData[getRowid($xeTable,dragRow)]:null;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(targetRowidOrRow)){if(rowRest&&targetRowidOrRow){let currList=afterFullData;let offsetIndex=rowRest._index+targetRowidOrRow;if(treeConfig){currList=rowRest.items;if(treeOpts.transform){offsetIndex=rowRest.treeIndex+targetRowidOrRow;if(isCrossDrag){currList=afterFullData;offsetIndex=rowRest._index+targetRowidOrRow;}}}if(offsetIndex>=0&&offsetIndex<=currList.length-1){prevDragRow=currList[offsetIndex];}if(targetRowidOrRow>0){defPos='bottom';}}}else{prevDragRow=handleRowidOrRow($xeTable,targetRowidOrRow);const targetRowRest=prevDragRow?fullAllDataRowIdData[getRowid($xeTable,prevDragRow)]:null;if(rowRest&&targetRowRest){if(targetRowRest._index>rowRest._index){defPos='bottom';}}}const rest=$xeTable.handleRowDragSwapEvent(null,true,dragRow,prevDragRow,dragPos||defPos,dragToChild===true);return rest;},/**
             * 
             */getFullColumns(){const{collectColumn}=internalData;return collectColumn.slice(0);},/**
             *  data 
             */getData(rowIndex){const tableSynchData=props.data||internalData.tableSynchData;return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(rowIndex)?tableSynchData.slice(0):tableSynchData[rowIndex];},/**
             * 
             */getCheckboxRecords(isFull){const{treeConfig}=props;const{updateCheckboxFlag}=reactData;const{tableFullData,afterFullData,tableFullTreeData,fullDataRowIdData,afterFullRowMaps,selectCheckboxMaps}=internalData;const treeOpts=computeTreeOpts.value;const checkboxOpts=computeCheckboxOpts.value;const{transform,mapChildrenField}=treeOpts;const{checkField}=checkboxOpts;const childrenField=treeOpts.children||treeOpts.childrenField;let rowList=[];if(updateCheckboxFlag){if(checkField){if(treeConfig){//  transform 
const currTableData=isFull?transform?tableFullTreeData:tableFullData:transform?tableFullTreeData:afterFullData;rowList=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().filterTree(currTableData,row=>external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField),{children:transform?mapChildrenField:childrenField});}else{const currTableData=isFull?tableFullData:afterFullData;rowList=currTableData.filter(row=>external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField));}}else{const currMaps=isFull||treeConfig&&!transform?fullDataRowIdData:afterFullRowMaps;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(selectCheckboxMaps,(row,rowid)=>{if(currMaps[rowid]){rowList.push(fullDataRowIdData[rowid].row);}});}}return rowList;},/**
             *  tree-config 
             */getTreeRowChildren(rowOrRowid){const{treeConfig}=props;const{fullAllDataRowIdData}=internalData;const treeOpts=computeTreeOpts.value;const{transform,mapChildrenField}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;if(rowOrRowid&&treeConfig){let rowid;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowOrRowid)){rowid=rowOrRowid;}else{rowid=getRowid($xeTable,rowOrRowid);}if(rowid){const rest=fullAllDataRowIdData[rowid];const row=rest?rest.row:null;if(row){return row[transform?mapChildrenField:childrenField]||[];}}}return[];},/**
             *  tree-config 
             */getTreeRowLevel(rowOrRowid){const{treeConfig}=props;const{fullAllDataRowIdData}=internalData;if(rowOrRowid&&treeConfig){let rowid;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowOrRowid)){rowid=rowOrRowid;}else{rowid=getRowid($xeTable,rowOrRowid);}if(rowid){const rest=fullAllDataRowIdData[rowid];if(rest){return rest.level;}}}return-1;},/**
             *  tree-config 
             */getTreeParentRow(rowOrRowid){const{treeConfig}=props;const{fullAllDataRowIdData}=internalData;if(rowOrRowid&&treeConfig){let rowid;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowOrRowid)){rowid=rowOrRowid;}else{rowid=getRowid($xeTable,rowOrRowid);}if(rowid){const rest=fullAllDataRowIdData[rowid];if(rest){return rest.parent;}}}return null;},getParentRow(rowOrRowid){warnLog('vxe.error.delFunc',['getParentRow','getTreeParentRow']);return $xeTable.getTreeParentRow(rowOrRowid);},/**
             * 
             * @param {String/Number} rowid 
             */getRowById(cellValue){const{fullAllDataRowIdData}=internalData;const rowid=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cellValue)?'':encodeURIComponent(cellValue||'');return fullAllDataRowIdData[rowid]?fullAllDataRowIdData[rowid].row:null;},/**
             * 
             * @param {Row} row 
             */getRowid(row){return getRowid($xeTable,row);},/**
             * 
             * 
             * 
             */getTableData(){const{tableData,footerTableData}=reactData;const{tableFullData,afterFullData,tableFullTreeData}=internalData;return{fullData:props.treeConfig?tableFullTreeData.slice(0):tableFullData.slice(0),visibleData:afterFullData.slice(0),tableData:tableData.slice(0),footerData:footerTableData.slice(0)};},/**
             *  tree-config 
             */getFullData(){const{treeConfig}=props;const{tableFullData,tableFullTreeData}=internalData;if(treeConfig){const treeOpts=computeTreeOpts.value;const{transform,mapChildrenField,rowField,parentField}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;if(transform){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray(tableFullTreeData,{children:mapChildrenField}),{key:rowField,parentKey:parentField,children:childrenField,mapChildren:mapChildrenField});}return tableFullTreeData.slice(0);}return tableFullData.slice(0);},/**
             * 
             */setColumnFixed(fieldOrColumn,fixed){let status=false;const cols=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn)?fieldOrColumn:[fieldOrColumn];const columnOpts=computeColumnOpts.value;const isMaxFixedColumn=computeIsMaxFixedColumn.value;for(let i=0;i<cols.length;i++){const item=cols[i];const column=handleFieldOrColumn($xeTable,item);const targetColumn=getRootColumn($xeTable,column);if(targetColumn&&targetColumn.fixed!==fixed){// 
if(!targetColumn.fixed&&isMaxFixedColumn){if(core_.VxeUI.modal){core_.VxeUI.modal.message({status:'error',content:table_getI18n('vxe.table.maxFixedCol',[columnOpts.maxFixedSize])});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([targetColumn],column=>{column.fixed=fixed;column.renderFixed=fixed;});tablePrivateMethods.saveCustomStore('update:fixed');if(!status){status=true;}}}if(status){return tableMethods.refreshColumn();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             */clearColumnFixed(fieldOrColumn){let status=false;const cols=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn)?fieldOrColumn:[fieldOrColumn];cols.forEach(item=>{const column=handleFieldOrColumn($xeTable,item);const targetColumn=getRootColumn($xeTable,column);if(targetColumn&&targetColumn.fixed){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([targetColumn],column=>{column.fixed=null;column.renderFixed=null;});tablePrivateMethods.saveCustomStore('update:fixed');if(!status){status=true;}}});if(status){return tableMethods.refreshColumn();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             */hideColumn(fieldOrColumn){let status=false;const cols=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn)?fieldOrColumn:[fieldOrColumn];cols.forEach(item=>{const column=handleFieldOrColumn($xeTable,item);if(column&&column.visible){column.visible=false;if(!status){status=true;}}});if(status){return tablePrivateMethods.handleCustom();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             */showColumn(fieldOrColumn){let status=false;const cols=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn)?fieldOrColumn:[fieldOrColumn];cols.forEach(item=>{const column=handleFieldOrColumn($xeTable,item);if(column&&!column.visible){column.visible=true;if(!status){status=true;}}});if(status){return tablePrivateMethods.handleCustom();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},setColumnWidth(fieldOrColumn,width){const{elemStore}=internalData;let status=false;const cols=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn)?fieldOrColumn:[fieldOrColumn];let cWidth=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(width);if(isScale(width)){const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const bodyWidth=bodyScrollElem?bodyScrollElem.clientWidth-1:0;cWidth=Math.floor(cWidth*bodyWidth);}if(cWidth){cols.forEach(item=>{const column=handleFieldOrColumn($xeTable,item);if(column){column.resizeWidth=cWidth;if(!status){status=true;}}});if(status){return $xeTable.refreshColumn().then(()=>{return{status};});}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{return{status};});},getColumnWidth(fieldOrColumn){const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column){return column.renderWidth;}return 0;},/**
             * 
             *  true 
             * 
             */resetColumn(options){warnLog('vxe.error.delFunc',['resetColumn','resetCustom']);return $xeTable.resetCustom(options);},/**
             * 
             * 
             *  true 
             */refreshColumn(initSort){if(initSort){handleUpdateColumn();}return parseColumns(true).then(()=>{return $xeTable.refreshScroll();}).then(()=>{return handleLazyRecalculate(false,true,true);});},setRowHeightConf(heightConf){const{fullAllDataRowIdData}=internalData;let status=false;if(heightConf){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(heightConf,(height,rowid)=>{const rowRest=fullAllDataRowIdData[rowid];if(rowRest){const rHeight=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(height);if(rHeight){rowRest.resizeHeight=rHeight;if(!status){status=true;}}}});if(status){internalData.isResizeCellHeight=true;reactData.resizeHeightFlag++;}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateRowOffsetTop();return{status};});},getRowHeightConf(isFull){const{fullAllDataRowIdData,afterFullData}=internalData;const{handleGetRowId}=createHandleGetRowId($xeTable);const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const rest={};afterFullData.forEach(row=>{const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){const resizeHeight=rowRest.resizeHeight;if(resizeHeight||isFull){const currCellHeight=resizeHeight||cellOpts.height||rowOpts.height||rowRest.height||defaultRowHeight;rest[rowid]=currCellHeight;}}});return rest;},recalcRowHeight(rowOrId){const{fullAllDataRowIdData}=internalData;const rows=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rowOrId)?rowOrId:[rowOrId];const el=refElem.value;if(el){const{handleGetRowId}=createHandleGetRowId($xeTable);el.setAttribute('data-calc-row','Y');rows.forEach(row=>{const rowid=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(row)||external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(row)?row:handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){rowRest.resizeHeight=calcCellAutoHeight(rowRest,el);}el.removeAttribute('data-calc-row');});reactData.calcCellHeightFlag++;}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},setRowHeight(rowOrId,height){const{fullAllDataRowIdData}=internalData;let status=false;const rows=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rowOrId)?rowOrId:[rowOrId];let rHeight=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(height);if(isScale(height)){const tableBody=refTableBody.value;const bodyElem=tableBody?tableBody.$el:null;const bodyHeight=bodyElem?bodyElem.clientHeight-1:0;rHeight=Math.floor(rHeight*bodyHeight);}if(rHeight){const{handleGetRowId}=createHandleGetRowId($xeTable);rows.forEach(row=>{const rowid=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(row)||external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(row)?row:handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){rowRest.resizeHeight=rHeight;if(!status){status=true;}}});if(status){internalData.isResizeCellHeight=true;reactData.resizeHeightFlag++;}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{return{status};});},getRowHeight(rowOrId){const{fullAllDataRowIdData}=internalData;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const rowid=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowOrId)||external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(rowOrId)?rowOrId:getRowid($xeTable,rowOrId);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){return rowRest.resizeHeight||cellOpts.height||rowOpts.height||rowRest.height||defaultRowHeight;}return 0;},/**
             * 
             */refreshScroll(){const{elemStore,lastScrollLeft,lastScrollTop}=internalData;const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;return new Promise(resolve=>{// 
if(lastScrollLeft||lastScrollTop){return restoreScrollLocation($xeTable,lastScrollLeft,lastScrollTop).then(()=>{// 
setTimeout(resolve,10);});}internalData.intoRunScroll=true;// 
setScrollTop(yHandleEl,lastScrollTop);setScrollTop(bodyScrollElem,lastScrollTop);setScrollTop(leftScrollElem,lastScrollTop);setScrollTop(rightScrollElem,lastScrollTop);setScrollLeft(xHandleEl,lastScrollLeft);setScrollLeft(bodyScrollElem,lastScrollLeft);setScrollLeft(headerScrollElem,lastScrollLeft);setScrollLeft(footerScrollElem,lastScrollLeft);// 
setTimeout(()=>{internalData.intoRunScroll=false;resolve();},10);});},/**
             * 
             * 
             */recalculate(reFull){const isForce=!!reFull;return handleLazyRecalculate(isForce,isForce,isForce);},openTooltip(target,content){const $commTip=refCommTooltip.value;if($commTip&&$commTip.open){return $commTip.open(target,content);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             *  tooltip
             */closeTooltip(){const{tooltipStore}=reactData;const $tooltip=refTooltip.value;const $commTip=refCommTooltip.value;if(tooltipStore.visible){Object.assign(tooltipStore,{row:null,column:null,content:null,visible:false,type:null,currOpts:{}});if($tooltip&&$tooltip.close){$tooltip.close();}}if($commTip&&$commTip.close){$commTip.close();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             */isAllCheckboxChecked(){return reactData.isAllSelected;},/**
             * 
             */isAllCheckboxIndeterminate(){return!reactData.isAllSelected&&reactData.isIndeterminate;},/**
             * 
             */getCheckboxIndeterminateRecords(isFull){const{treeConfig}=props;const{fullDataRowIdData,treeIndeterminateRowMaps}=internalData;if(treeConfig){const fullRest=[];const defRest=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(treeIndeterminateRowMaps,(item,rowid)=>{if(item){fullRest.push(item);if(fullDataRowIdData[rowid]){defRest.push(item);}}});if(isFull){return fullRest;}return defRest;}return[];},/**
             * 
             * @param {Array/Row} rows 
             * @param {Boolean} value 
             */setCheckboxRow(rows,checked){if(rows&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}return handleCheckedCheckboxRow(rows,checked,true);},setCheckboxRowKey(keys,checked){const{fullAllDataRowIdData}=internalData;if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(keys)){keys=[keys];}const rows=[];keys.forEach(rowid=>{const rowRest=fullAllDataRowIdData[rowid];if(rowRest){rows.push(rowRest.row);}});return handleCheckedCheckboxRow(rows,checked,true);},isCheckedByCheckboxRow(row){const{updateCheckboxFlag}=reactData;const{selectCheckboxMaps}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{checkField}=checkboxOpts;if(checkField){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField);}return!!updateCheckboxFlag&&!!selectCheckboxMaps[getRowid($xeTable,row)];},isCheckedByCheckboxRowKey(rowid){const{updateCheckboxFlag}=reactData;const{fullAllDataRowIdData,selectCheckboxMaps}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{checkField}=checkboxOpts;if(checkField){const rowRest=fullAllDataRowIdData[rowid];if(rowRest){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rowRest.row,checkField);}return false;}return!!updateCheckboxFlag&&!!selectCheckboxMaps[rowid];},isIndeterminateByCheckboxRow(row){const{treeIndeterminateRowMaps}=internalData;return!!treeIndeterminateRowMaps[getRowid($xeTable,row)]&&!$xeTable.isCheckedByCheckboxRow(row);},isIndeterminateByCheckboxRowKey(rowid){const{treeIndeterminateRowMaps}=internalData;return!!treeIndeterminateRowMaps[rowid]&&!$xeTable.isCheckedByCheckboxRowKey(rowid);},/**
             * 
             */toggleCheckboxRow(row){const{selectCheckboxMaps}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{checkField}=checkboxOpts;const checked=checkField?!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField):!selectCheckboxMaps[getRowid($xeTable,row)];tablePrivateMethods.handleBatchSelectRows([row],checked,true);tablePrivateMethods.checkSelectionStatus();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             * @param {Boolean} value 
             */setAllCheckboxRow(value){return handleCheckedAllCheckboxRow(value,true);},/**
             * 
             */getRadioReserveRecord(isFull){const{treeConfig}=props;const{fullDataRowIdData,radioReserveRow,afterFullData}=internalData;const radioOpts=computeRadioOpts.value;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;if(radioOpts.reserve&&radioReserveRow){const rowid=getRowid($xeTable,radioReserveRow);if(isFull){if(!fullDataRowIdData[rowid]){return radioReserveRow;}}else{const rowkey=getRowkey($xeTable);if(treeConfig){const matchObj=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(afterFullData,row=>rowid===external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,rowkey),{children:childrenField});if(matchObj){return radioReserveRow;}}else{if(!afterFullData.some(row=>rowid===external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,rowkey))){return radioReserveRow;}}}}return null;},clearRadioReserve(){internalData.radioReserveRow=null;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             */getCheckboxReserveRecords(isFull){const{treeConfig}=props;const{afterFullData,fullDataRowIdData,checkboxReserveRowMap}=internalData;const checkboxOpts=computeCheckboxOpts.value;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const reserveSelection=[];if(checkboxOpts.reserve){const{handleGetRowId}=createHandleGetRowId($xeTable);const afterFullIdMaps={};if(treeConfig){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterFullData,row=>{afterFullIdMaps[handleGetRowId(row)]=1;},{children:childrenField});}else{afterFullData.forEach(row=>{afterFullIdMaps[handleGetRowId(row)]=1;});}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(checkboxReserveRowMap,(oldRow,oldRowid)=>{if(oldRow){if(isFull){if(!fullDataRowIdData[oldRowid]){reserveSelection.push(oldRow);}}else{if(!afterFullIdMaps[oldRowid]){reserveSelection.push(oldRow);}}}});}return reserveSelection;},clearCheckboxReserve(){internalData.checkboxReserveRowMap={};return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             */toggleAllCheckboxRow(){handleCheckAllEvent(null,!reactData.isAllSelected);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             * 
             */clearCheckboxRow(){const{treeConfig}=props;const{tableFullData}=internalData;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const checkboxOpts=computeCheckboxOpts.value;const{checkField,reserve}=checkboxOpts;// indeterminateField 
const indeterminateField=checkboxOpts.indeterminateField||checkboxOpts.halfField;if(checkField){const handleClearChecked=item=>{if(treeConfig&&indeterminateField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item,indeterminateField,false);}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item,checkField,false);};if(treeConfig){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullData,handleClearChecked,{children:childrenField});}else{tableFullData.forEach(handleClearChecked);}}if(reserve){tableFullData.forEach(row=>handleCheckboxReserveRow(row,false));}reactData.isAllSelected=false;reactData.isIndeterminate=false;internalData.selectCheckboxMaps={};internalData.treeIndeterminateRowMaps={};reactData.updateCheckboxFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             * @param {Row} row 
             */setCurrentRow(row){const $xeGanttView=internalData.xeGanttView;const rowOpts=computeRowOpts.value;const el=refElem.value;tableMethods.clearCurrentRow();// tableMethods.clearCurrentColumn()
reactData.currentRow=row;if(rowOpts.isCurrent||props.highlightCurrentRow){if(el){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`[rowid="${getRowid($xeTable,row)}"]`),elem=>addClass(elem,'row--current'));}}if($xeGanttView&&$xeGanttView.handleUpdateCurrentRow){$xeGanttView.handleUpdateCurrentRow(row);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},isCheckedByRadioRow(row){const{selectRadioRow}=reactData;if(row&&selectRadioRow){return $xeTable.eqRow(selectRadioRow,row);}return false;},isCheckedByRadioRowKey(key){const{selectRadioRow}=reactData;if(selectRadioRow){return key===getRowid($xeTable,selectRadioRow);}return false;},/**
             * 
             * @param {Row} row 
             */setRadioRow(row){return handleCheckedRadioRow(row,true);},/**
             * 
             * @param key 
             */setRadioRowKey(rowid){const{fullAllDataRowIdData}=internalData;const rowRest=fullAllDataRowIdData[rowid];if(rowRest){return handleCheckedRadioRow(rowRest.row,true);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             */clearCurrentRow(){const $xeGanttView=internalData.xeGanttView;const el=refElem.value;reactData.currentRow=null;internalData.hoverRow=null;if(el){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll('.row--current'),elem=>removeClass(elem,'row--current'));}if($xeGanttView&&$xeGanttView.handleUpdateCurrentRow){$xeGanttView.handleUpdateCurrentRow();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             */clearRadioRow(){reactData.selectRadioRow=null;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             */getCurrentRecord(isFull){const{currentRow}=reactData;const{fullDataRowIdData,afterFullRowMaps}=internalData;const rowOpts=computeRowOpts.value;if(rowOpts.isCurrent||props.highlightCurrentRow){const rowid=getRowid($xeTable,currentRow);if(isFull){if(fullDataRowIdData[rowid]){return currentRow;}}else{if(afterFullRowMaps[rowid]){return currentRow;}}}return null;},/**
             * 
             */getRadioRecord(isFull){const{fullDataRowIdData,afterFullRowMaps}=internalData;const{selectRadioRow}=reactData;if(selectRadioRow){const rowid=getRowid($xeTable,selectRadioRow);if(isFull){if(fullDataRowIdData[rowid]){return selectRadioRow;}}else{if(afterFullRowMaps[rowid]){return selectRadioRow;}}}return null;},getCurrentColumn(){const columnOpts=computeColumnOpts.value;return columnOpts.isCurrent||props.highlightCurrentColumn?reactData.currentColumn:null;},/**
             * 
             */setCurrentColumn(fieldOrColumn){const{mouseConfig}=props;const mouseOpts=computeMouseOpts.value;const isMouseSelected=mouseConfig&&mouseOpts.selected;const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column){$xeTable.clearCurrentColumn();reactData.currentColumn=column;}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{// 
if(isMouseSelected){$xeTable.addCellSelectedClass();}});},/**
             * 
             */clearCurrentColumn(){reactData.currentColumn=null;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},setPendingRow(rows,status){const{handleGetRowId}=createHandleGetRowId($xeTable);const{pendingRowMaps}=internalData;if(rows&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}if(status){rows.forEach(row=>{const rowid=handleGetRowId(row);if(rowid&&!pendingRowMaps[rowid]){pendingRowMaps[rowid]=row;}});}else{rows.forEach(row=>{const rowid=handleGetRowId(row);if(rowid&&pendingRowMaps[rowid]){delete pendingRowMaps[rowid];}});}reactData.pendingRowFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},togglePendingRow(rows){const{handleGetRowId}=createHandleGetRowId($xeTable);const{pendingRowMaps}=internalData;if(rows&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}rows.forEach(row=>{const rowid=handleGetRowId(row);if(rowid){if(pendingRowMaps[rowid]){delete pendingRowMaps[rowid];}else{pendingRowMaps[rowid]=row;}}});reactData.pendingRowFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},hasPendingByRow(row){return tableMethods.isPendingByRow(row);},isPendingByRow(row){const{pendingRowMaps}=internalData;const rowid=getRowid($xeTable,row);return!!pendingRowMaps[rowid];},getPendingRecords(){const{fullAllDataRowIdData,pendingRowMaps}=internalData;const insertRecords=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(pendingRowMaps,(row,rowid)=>{if(fullAllDataRowIdData[rowid]){insertRecords.push(row);}});return insertRecords;},clearPendingRow(){internalData.pendingRowMaps={};reactData.pendingRowFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},sort(sortConfs,sortOrder){const sortOpts=computeSortOpts.value;const{multiple,remote,orders}=sortOpts;if(sortConfs){if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(sortConfs)){sortConfs=[{field:sortConfs,order:sortOrder}];}}if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortConfs)){sortConfs=[sortConfs];}if(sortConfs.length){if(!multiple){clearAllSort();}(multiple?sortConfs:[sortConfs[0]]).forEach((confs,index)=>{let{field,order}=confs;let column=field;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(field)){column=tableMethods.getColumnByField(field);}if(column&&column.sortable){if(orders&&orders.indexOf(order)===-1){order=getNextSortOrder(column);}if(column.order!==order){column.order=order;}column.sortTime=Date.now()+index;}});// 
if(!remote){tablePrivateMethods.handleTableData(true);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateRowOffsetTop();tableMethods.updateCellAreas();return updateStyle();});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},setSort(sortConfs,isUpdate){return handleSortEvent(null,sortConfs,isUpdate);},setSortByEvent(evnt,sortConfs){return handleSortEvent(evnt,sortConfs,true);},/**
             * 
             * 
             * @param {String} fieldOrColumn 
             */clearSort(fieldOrColumn){const sortOpts=computeSortOpts.value;if(fieldOrColumn){const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column){column.order=null;}}else{clearAllSort();}if(!sortOpts.remote){$xeTable.handleTableData(true);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateRowOffsetTop();return updateStyle();});},clearSortByEvent(evnt,fieldOrColumn){const{tableFullColumn}=internalData;const sortOpts=computeSortOpts.value;const{multiple}=sortOpts;const sortCols=[];let column=null;if(evnt){if(fieldOrColumn){column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column){column.order=null;}}else{tableFullColumn.forEach(column=>{if(column.order){column.order=null;sortCols.push(column);}});}if(!sortOpts.remote){$xeTable.handleTableData(true);}if(!multiple){column=sortCols[0];}if(column){$xeTable.handleColumnSortEvent(evnt,column);}if(multiple&&sortCols.length){const params={$table:$xeTable,$event:evnt,cols:sortCols,sortList:[]};dispatchEvent('clear-all-sort',params,evnt);}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateRowOffsetTop();return updateStyle();});},isSort(fieldOrColumn){if(fieldOrColumn){const column=handleFieldOrColumn($xeTable,fieldOrColumn);return column?column.sortable&&!!column.order:false;}return tableMethods.getSortColumns().length>0;},getSortColumns(){const sortOpts=computeSortOpts.value;const{multiple,chronological}=sortOpts;const sortList=[];const{tableFullColumn}=internalData;tableFullColumn.forEach(column=>{const{field,order}=column;if(column.sortable&&order){sortList.push({column,field,property:field,order:order,sortTime:column.sortTime});}});if(multiple&&chronological&&sortList.length>1){return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(sortList,'sortTime');}return sortList;},setFilterByEvent(evnt,fieldOrColumn,options){const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column&&column.filters){column.filters=toFilters(options||[],column.id);return $xeTable.handleColumnConfirmFilter(column,evnt);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             * @param {Event} evnt 
             */closeFilter(){const{filterStore}=reactData;const{column,visible}=filterStore;filterStore.isAllSelected=false;filterStore.isIndeterminate=false;filterStore.visible=false;if(visible){const field=column?column.field:null;dispatchEvent('filter-visible',{column,property:field,field,filterList:()=>$xeTable.getCheckedFilters(),visible:false},null);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             * @param {String} fieldOrColumn 
             */isActiveFilterByColumn(fieldOrColumn){const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column){return column.filters&&column.filters.some(option=>option.checked);}return $xeTable.getCheckedFilters().length>0;},isFilter(fieldOrColumn){return tableMethods.isActiveFilterByColumn(fieldOrColumn);},clearFilterByEvent(evnt,fieldOrColumn){const{filterStore}=reactData;const{tableFullColumn}=internalData;const filterOpts=computeFilterOpts.value;const{multiple}=filterOpts;const filterCols=[];let column=null;if(fieldOrColumn){column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column){$xeTable.handleClearFilter(column);}}else{tableFullColumn.forEach(column=>{if(column.filters){filterCols.push(column);$xeTable.handleClearFilter(column);}});}if(!fieldOrColumn||column!==filterStore.column){Object.assign(filterStore,{isAllSelected:false,isIndeterminate:false,style:null,options:[],column:null,multiple:false,visible:false});}if(!filterOpts.remote){$xeTable.updateData();}if(!multiple){column=filterCols[0];}if(column){const filterList=()=>$xeTable.getCheckedFilters();const values=[];const datas=[];column.filters.forEach(item=>{if(item.checked){values.push(item.value);datas.push(item.data);}});const params={$table:$xeTable,$event:evnt,column,field:column.field,property:column.field,values,datas,filters:filterList,filterList};$xeTable.dispatchEvent('filter-change',params,evnt);$xeTable.dispatchEvent('clear-filter',params,evnt);}if(multiple&&filterCols.length){const params={$table:$xeTable,$event:evnt,cols:filterCols,filterList:[]};dispatchEvent('clear-all-filter',params,evnt);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             * @param {Row} row 
             */isRowExpandLoaded(row){const{fullAllDataRowIdData}=internalData;const rowRest=fullAllDataRowIdData[getRowid($xeTable,row)];return rowRest&&!!rowRest.expandLoaded;},clearRowExpandLoaded(row){const{fullAllDataRowIdData,rowExpandLazyLoadedMaps}=internalData;const expandOpts=computeExpandOpts.value;const{lazy}=expandOpts;const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];if(lazy&&rowRest){rowRest.expandLoaded=false;delete rowExpandLazyLoadedMaps[rowid];}reactData.rowExpandedFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             * @param {Row} row 
             */reloadRowExpand(row){const{rowExpandLazyLoadedMaps}=internalData;const expandOpts=computeExpandOpts.value;const{lazy}=expandOpts;const rowid=getRowid($xeTable,row);if(lazy&&!rowExpandLazyLoadedMaps[rowid]){$xeTable.clearRowExpandLoaded(row).then(()=>handleAsyncRowExpand(row));}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},reloadExpandContent(row){warnLog('vxe.error.delFunc',['reloadExpandContent','reloadRowExpand']);// 
return $xeTable.reloadRowExpand(row);},/**
             * 
             */toggleRowExpand(row){return $xeTable.setRowExpand(row,!$xeTable.isRowExpandByRow(row));},/**
             * 
             * @param {Boolean} expanded 
             */setAllRowExpand(expanded){const treeOpts=computeTreeOpts.value;const{tableFullData,tableFullTreeData}=internalData;const childrenField=treeOpts.children||treeOpts.childrenField;let expandedRows=[];if(props.treeConfig){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullTreeData,row=>{expandedRows.push(row);},{children:childrenField});}else{expandedRows=tableFullData;}return tableMethods.setRowExpand(expandedRows,expanded);},/**
             * 
             * 
             * 
             * @param {Array/Row} rows 
             * @param {Boolean} expanded 
             */setRowExpand(rows,expanded){const{expandColumn}=reactData;let{fullAllDataRowIdData,rowExpandedMaps,rowExpandLazyLoadedMaps}=internalData;const{handleGetRowId}=createHandleGetRowId($xeTable);const expandOpts=computeExpandOpts.value;const{reserve,lazy,accordion,toggleMethod}=expandOpts;const lazyRests=[];const columnIndex=expandColumn?$xeTable.getColumnIndex(expandColumn):-1;const $columnIndex=expandColumn?$xeTable.getVMColumnIndex(expandColumn):-1;if(rows){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}if(accordion){// 
rowExpandedMaps={};internalData.rowExpandedMaps=rowExpandedMaps;rows=rows.slice(rows.length-1,rows.length);}const validRows=toggleMethod?rows.filter(row=>toggleMethod({$table:$xeTable,expanded,column:expandColumn,columnIndex,$columnIndex,row,rowIndex:$xeTable.getRowIndex(row),$rowIndex:$xeTable.getVMRowIndex(row)})):rows;if(expanded){validRows.forEach(row=>{const rowid=handleGetRowId(row);if(!rowExpandedMaps[rowid]){const rowRest=fullAllDataRowIdData[rowid];const isLoad=lazy&&!rowRest.expandLoaded&&!rowExpandLazyLoadedMaps[rowid];if(isLoad){lazyRests.push(handleAsyncRowExpand(row));}else{rowExpandedMaps[rowid]=row;}}});}else{validRows.forEach(item=>{const rowid=handleGetRowId(item);if(rowExpandedMaps[rowid]){delete rowExpandedMaps[rowid];}});}if(reserve){validRows.forEach(row=>handleRowExpandReserve(row,expanded));}}reactData.rowExpandedFlag++;return Promise.all(lazyRests).then(()=>(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).then(()=>handleLazyRecalculate(true,true,true)).then(()=>{updateRowOffsetTop();updateRowExpandStyle();handleRowExpandScroll();return $xeTable.updateCellAreas();});},/**
             * 
             * @param {Row} row 
             */isRowExpandByRow(row){const{rowExpandedFlag}=reactData;const{rowExpandedMaps}=internalData;const rowid=getRowid($xeTable,row);return!!rowExpandedFlag&&!!rowExpandedMaps[rowid];},isExpandByRow(row){// 
warnLog('vxe.error.delFunc',['isExpandByRow','isRowExpandByRow']);return tableMethods.isRowExpandByRow(row);},/**
             * 
             */clearRowExpand(){const{tableFullData,scrollYStore}=internalData;const expandOpts=computeExpandOpts.value;const{reserve}=expandOpts;const expList=$xeTable.getRowExpandRecords();internalData.rowExpandedMaps={};if(reserve){tableFullData.forEach(row=>handleRowExpandReserve(row,false));}reactData.rowExpandedFlag++;scrollYStore.startIndex=0;scrollYStore.endIndex=1;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{if(expList.length){return handleLazyRecalculate(true,true,true);}}).then(()=>{updateRowOffsetTop();updateRowExpandStyle();handleRowExpandScroll();return $xeTable.updateCellAreas();});},clearRowExpandReserve(){internalData.rowExpandedReserveRowMap={};return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},getRowExpandRecords(){const rest=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(internalData.rowExpandedMaps,item=>{if(item){rest.push(item);}});return rest;},setRowGroups(fieldOrColumns){const{aggregateConfig,rowGroupConfig}=props;const aggregateOpts=computeAggregateOpts.value;const{maxGroupSize}=aggregateOpts;if(!(aggregateConfig||rowGroupConfig)){errLog('vxe.error.reqProp',['aggregate-config']);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}const confList=fieldOrColumns?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumns)?fieldOrColumns:[fieldOrColumns]:[];if(maxGroupSize&&confList.length>maxGroupSize){if(core_.VxeUI.modal){core_.VxeUI.modal.message({status:'error',content:table_getI18n('vxe.table.maxGroupCol',[maxGroupSize])});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}if(confList.length){handleUpdateRowGroup(confList.map(fieldOrColumn=>{return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn)?fieldOrColumn:fieldOrColumn.field;}));return loadTableData(internalData.tableSynchData,true);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},getRowGroups(){const{aggregateConfig,rowGroupConfig}=props;const{fullColumnFieldData}=internalData;if(aggregateConfig||rowGroupConfig){const{rowGroupList}=reactData;return rowGroupList.map(({field})=>{const colRet=fullColumnFieldData[field];if(colRet){return colRet.column;}return{field};});}return[];},getRowGroupFields(){return $xeTable.getRowGroups().map(item=>item.field);},clearRowGroups(){const{aggregateConfig,rowGroupConfig}=props;if(!(aggregateConfig||rowGroupConfig)){errLog('vxe.error.reqProp',['aggregate-config']);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}handleUpdateRowGroup([]);return loadTableData(internalData.tableSynchData,true);},isRowGroupRecord(row){warnLog('vxe.error.delFunc',['isRowGroupRecord','isAggregateRecord']);return $xeTable.isAggregateRecord(row);},isRowGroupExpandByRow(row){warnLog('vxe.error.delFunc',['isRowGroupExpandByRow','isAggregateExpandByRow']);return $xeTable.isAggregateExpandByRow(row);},isAggregateRecord(row){const{isRowGroupStatus}=reactData;return isRowGroupStatus&&row.isAggregate;},getAggregateContentByRow(row){const{isRowGroupStatus}=reactData;return isRowGroupStatus&&row&&row.isAggregate?row.groupContent:'';},getAggregateRowChildren(row){const aggregateOpts=computeAggregateOpts.value;const{childrenField,mapChildrenField}=aggregateOpts;const{isRowGroupStatus}=reactData;return isRowGroupStatus&&row&&row.isAggregate&&childrenField&&mapChildrenField?row[mapChildrenField]||[]:[];},isAggregateExpandByRow(row){const{rowGroupExpandedFlag}=reactData;const{rowGroupExpandedMaps}=internalData;return!!rowGroupExpandedFlag&&!!rowGroupExpandedMaps[getRowid($xeTable,row)];},setRowGroupExpand(rows,expanded){if(rows){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}return handleRowGroupVirtualExpand(rows,expanded);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},setRowGroupExpandByField(groupFields,expanded){const{isRowGroupStatus}=reactData;const aggregateOpts=computeAggregateOpts.value;const{childrenField}=aggregateOpts;if(groupFields){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(groupFields)){groupFields=[groupFields];}if(isRowGroupStatus){const rows=[];const gfKeys={};groupFields.forEach(groupField=>{gfKeys[groupField]=true;});external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(internalData.afterGroupFullData,row=>{if(row.isAggregate&&gfKeys[row.groupField]){rows.push(row);}},{children:childrenField});if(rows.length){return handleRowGroupVirtualExpand(rows,expanded);}}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},setAllRowGroupExpand(expanded){const{tableFullGroupData}=internalData;const aggregateOpts=computeAggregateOpts.value;const{mapChildrenField}=aggregateOpts;const rgExpandedMaps={};if(expanded&&mapChildrenField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullGroupData,row=>{if(row[mapChildrenField]&&row[mapChildrenField].length){rgExpandedMaps[getRowid($xeTable,row)]=row;}},{children:mapChildrenField});}internalData.rowGroupExpandedMaps=rgExpandedMaps;handleVirtualTreeToList();$xeTable.handleTableData();updateAfterDataIndex();reactData.rowGroupExpandedFlag++;return handleLazyRecalculate(true,true,true);},clearRowGroupExpand(){internalData.rowGroupExpandedMaps={};handleVirtualTreeToList();$xeTable.handleTableData();updateAfterDataIndex();reactData.rowGroupExpandedFlag++;return handleLazyRecalculate(true,true,true);},getTreeExpandRecords(){const rest=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(internalData.treeExpandedMaps,item=>{if(item){rest.push(item);}});return rest;},/**
             * 
             * @param {Row} row 
             */isTreeExpandLoaded(row){const{fullAllDataRowIdData}=internalData;const rowRest=fullAllDataRowIdData[getRowid($xeTable,row)];return rowRest&&!!rowRest.treeLoaded;},clearTreeExpandLoaded(rows){const{fullAllDataRowIdData,treeExpandedMaps}=internalData;const treeOpts=computeTreeOpts.value;const{transform}=treeOpts;if(rows){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}rows.forEach(row=>{const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];if(rowRest){rowRest.treeLoaded=false;if(treeExpandedMaps[rowid]){delete treeExpandedMaps[rowid];}}});}else{external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(fullAllDataRowIdData,rowRest=>{rowRest.treeLoaded=false;});}internalData.treeExpandedMaps={};if(transform){handleVirtualTreeToList();$xeTable.handleTableData();}reactData.treeExpandedFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             * @param {Row} row 
             */reloadTreeExpand(row){const{treeExpandLazyLoadedMaps}=internalData;const treeOpts=computeTreeOpts.value;const hasChildField=treeOpts.hasChild||treeOpts.hasChildField;const{transform,lazy}=treeOpts;const rowid=getRowid($xeTable,row);if(lazy&&row[hasChildField]&&!treeExpandLazyLoadedMaps[rowid]){return $xeTable.clearTreeExpandLoaded(row).then(()=>{return handleAsyncTreeExpandChilds(row);}).then(()=>{if(transform){handleVirtualTreeToList();$xeTable.handleTableData();}reactData.treeExpandedFlag++;}).then(()=>{return $xeTable.recalculate();});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},reloadTreeChilds(row){warnLog('vxe.error.delFunc',['reloadTreeChilds','reloadTreeExpand']);// 
return $xeTable.reloadTreeExpand(row);},/**
             * /
             */toggleTreeExpand(row){return $xeTable.setTreeExpand(row,!$xeTable.isTreeExpandByRow(row));},/**
             * 
             * @param {Boolean} expanded 
             */setAllTreeExpand(expanded){const{tableFullData}=internalData;const treeOpts=computeTreeOpts.value;const{transform,lazy}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const expandeds=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullData,row=>{const rowChildren=row[childrenField];if(lazy||rowChildren&&rowChildren.length){expandeds.push(row);}},{children:childrenField});return $xeTable.setTreeExpand(expandeds,expanded).then(()=>{if(transform){handleVirtualTreeToList();reactData.treeExpandedFlag++;return $xeTable.recalculate();}});},/**
             * 
             * 
             * 
             * @param {Array/Row} rows 
             * @param {Boolean} expanded 
             */setTreeExpand(rows,expanded){const treeOpts=computeTreeOpts.value;const{transform}=treeOpts;if(rows){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)){rows=[rows];}if(rows.length){// 
if(transform){return handleVirtualTreeExpand(rows,expanded);}else{return handleBaseTreeExpand(rows,expanded);}}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             * @param {Row} row 
             */isTreeExpandByRow(row){const{treeExpandedFlag}=reactData;const{treeExpandedMaps}=internalData;return!!treeExpandedFlag&&!!treeExpandedMaps[getRowid($xeTable,row)];},/**
             * 
             */clearTreeExpand(){const{tableFullTreeData}=internalData;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const{transform,reserve}=treeOpts;const expList=$xeTable.getTreeExpandRecords();internalData.treeExpandedMaps={};if(reserve){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullTreeData,row=>handleTreeExpandReserve(row,false),{children:childrenField});}return $xeTable.handleTableData().then(()=>{if(transform){handleVirtualTreeToList();$xeTable.handleTableData();}reactData.treeExpandedFlag++;}).then(()=>{updateTreeLineStyle();if(expList.length){return $xeTable.recalculate();}});},clearTreeExpandReserve(){internalData.treeExpandedReserveRowMap={};return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             */getScroll(){return $xeTable.getScrollData();},/**
             * 
             */getScrollData(){const{scrollXLoad,scrollYLoad,scrollbarHeight,scrollbarWidth}=reactData;const{elemStore}=internalData;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const scrollTop=bodyScrollElem?bodyScrollElem.scrollTop:0;const scrollLeft=bodyScrollElem?bodyScrollElem.scrollLeft:0;const clientHeight=bodyScrollElem?bodyScrollElem.clientHeight:0;const clientWidth=bodyScrollElem?bodyScrollElem.clientWidth:0;const scrollHeight=bodyScrollElem?bodyScrollElem.scrollHeight:0;const scrollWidth=bodyScrollElem?bodyScrollElem.scrollWidth:0;const isTop=scrollTop<=0;const isBottom=scrollTop+clientHeight>=scrollHeight;const isLeft=scrollLeft<=0;const isRight=scrollLeft+clientWidth>=scrollWidth;return{virtualX:scrollXLoad,virtualY:scrollYLoad,isTop,isBottom,isLeft,isRight,scrollbarHeight,scrollbarWidth,scrollTop,scrollLeft,scrollHeight,scrollWidth,clientHeight,clientWidth};},/**
             * 
             */scrollTo(scrollLeft,scrollTop){const{elemStore}=internalData;const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;internalData.intoRunScroll=true;if(scrollLeft){if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)){scrollTop=scrollLeft.top;scrollLeft=scrollLeft.left;}}if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)){setScrollLeft(xHandleEl,scrollLeft);setScrollLeft(bodyScrollElem,scrollLeft);setScrollLeft(headerScrollElem,scrollLeft);setScrollLeft(footerScrollElem,scrollLeft);loadScrollXData();}if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollTop)){setScrollTop(yHandleEl,scrollTop);setScrollTop(bodyScrollElem,scrollTop);setScrollTop(leftScrollElem,scrollTop);setScrollTop(rightScrollElem,scrollTop);loadScrollYData();}if(reactData.scrollXLoad||reactData.scrollYLoad){return new Promise(resolve=>{setTimeout(()=>{(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{internalData.intoRunScroll=false;resolve();});},30);});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{internalData.intoRunScroll=false;});},/**
             * 
             * @param {Row} row 
             * @param {ColumnInfo} fieldOrColumn 
             */scrollToRow(row,fieldOrColumn){const{isAllOverflow,scrollYLoad,scrollXLoad}=reactData;const rest=[];if(row){if(props.treeConfig){rest.push($xeTable.scrollToTreeRow(row));}else{rest.push(rowToVisible($xeTable,row));}}if(fieldOrColumn){rest.push(handleScrollToRowColumn(fieldOrColumn,row));}return Promise.all(rest).then(()=>{if(row){if(!isAllOverflow&&(scrollYLoad||scrollXLoad)){calcCellHeight();calcCellWidth();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}});},/**
             * 
             */scrollToColumn(fieldOrColumn){const{fullColumnIdData}=internalData;const column=handleFieldOrColumn($xeTable,fieldOrColumn);if(column&&fullColumnIdData[column.id]){return colToVisible($xeTable,column);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             */clearScroll(){const{elemStore,scrollXStore,scrollYStore}=internalData;const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;internalData.intoRunScroll=true;setScrollLeft(xHandleEl,0);setScrollLeft(bodyScrollElem,0);setScrollLeft(headerScrollElem,0);setScrollLeft(footerScrollElem,0);setScrollTop(yHandleEl,0);setScrollTop(bodyScrollElem,0);setScrollTop(leftScrollElem,0);setScrollTop(rightScrollElem,0);scrollXStore.startIndex=0;scrollXStore.visibleStartIndex=0;scrollXStore.endIndex=scrollXStore.visibleSize;scrollXStore.visibleEndIndex=scrollXStore.visibleSize;scrollYStore.startIndex=0;scrollYStore.visibleStartIndex=0;scrollYStore.endIndex=scrollYStore.visibleSize;scrollYStore.visibleEndIndex=scrollYStore.visibleSize;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{internalData.lastScrollLeft=0;internalData.lastScrollTop=0;internalData.intoRunScroll=false;});},/**
             * 
             */updateFooter(){const{showFooter,footerData,footerMethod}=props;const{visibleColumn,afterFullData}=internalData;let footData=[];if(showFooter&&footerData&&footerData.length){footData=footerData.slice(0);}else if(showFooter&&footerMethod){footData=visibleColumn.length?footerMethod({columns:visibleColumn,data:afterFullData,$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt}):[];}reactData.footerTableData=footData;$xeTable.handleUpdateFooterMerge();$xeTable.dispatchEvent('footer-data-change',{visibleColumn:internalData.visibleColumn,footData},null);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             *  updateStatus({ row, column }, cellValue)
             *  v-model  change 
             * 
             */updateStatus(slotParams,cellValue){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{const{editRules}=props;if(slotParams&&editRules){return $xeTable.handleCellRuleUpdateStatus('change',slotParams,cellValue);}});},/**
             *  [{ row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }]
             */setMergeCells(merges){if(props.spanMethod){errLog('vxe.error.errConflicts',['merge-cells','span-method']);}handleBodyMerge(merges);$xeTable.handleUpdateBodyMerge();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{const{expandColumn}=reactData;const{mergeBodyList}=internalData;if(expandColumn&&mergeBodyList.length){warnLog('vxe.error.errConflicts',['type=expand','merge-cells | span-method']);}$xeTable.updateCellAreas();return updateStyle();});},/**
             *  [{row:Row|number, col:ColumnInfo|number}]
             */removeMergeCells(merges){if(props.spanMethod){errLog('vxe.error.errConflicts',['merge-cells','span-method']);}const rest=removeBodyMerges(merges);$xeTable.handleUpdateBodyMerge();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{$xeTable.updateCellAreas();updateStyle();return rest;});},/**
             * 
             */getMergeCells(){return internalData.mergeBodyList.slice(0);},/**
             * 
             */clearMergeCells(){internalData.mergeBodyList=[];internalData.mergeBodyMaps={};internalData.mergeBodyCellMaps={};reactData.mergeBodyFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{return updateStyle();});},setMergeHeaderCells(merges){handleHeaderMerge(merges);$xeTable.handleUpdateHeaderMerge();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{return updateStyle();});},/**
             *  [{row:Row|number, col:ColumnInfo|number}]
             */removeMergeHeaderCells(merges){const rest=removeHeaderMerges(merges);$xeTable.handleUpdateHeaderMerge();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateStyle();return rest;});},/**
             * 
             */getMergeHeaderCells(){return internalData.mergeHeaderList.slice(0);},/**
             * 
             */clearMergeHeaderCells(){internalData.mergeHeaderList=[];internalData.mergeHeaderMaps={};internalData.mergeHeaderCellMaps={};reactData.mergeHeadFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{return updateStyle();});},setMergeFooterCells(merges){if(props.footerSpanMethod){errLog('vxe.error.errConflicts',['merge-footer-cells | merge-footer-items','footer-span-method']);}handleFooterMerge(merges);$xeTable.handleUpdateFooterMerge();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{return updateStyle();});},setMergeFooterItems(merges){// errLog('vxe.error.delFunc', ['setMergeFooterItems', 'setMergeFooterCells'])
return $xeTable.setMergeFooterCells(merges);},removeMergeFooterCells(merges){if(props.footerSpanMethod){errLog('vxe.error.errConflicts',['merge-footer-cells | merge-footer-items','footer-span-method']);}const rest=removeFooterMerges(merges);$xeTable.handleUpdateFooterMerge();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateStyle();return rest;});},removeMergeFooterItems(merges){// errLog('vxe.error.delFunc', ['removeMergeFooterItems', 'removeMergeFooterCells'])
return $xeTable.removeMergeFooterCells(merges);},/**
             * 
             */getMergeFooterCells(){return internalData.mergeFooterList.slice(0);},getMergeFooterItems(){// errLog('vxe.error.delFunc', ['getMergeFooterItems', 'getMergeFooterCells'])
return $xeTable.getMergeFooterCells();},/**
             * 
             */clearMergeFooterCells(){internalData.mergeFooterList=[];internalData.mergeFooterMaps={};internalData.mergeFooterCellMaps={};reactData.mergeFootFlag++;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{return updateStyle();});},clearMergeFooterItems(){// errLog('vxe.error.delFunc', ['clearMergeFooterItems', 'clearMergeFooterCells'])
return $xeTable.clearMergeFooterCells();},updateCellAreas(){const{mouseConfig}=props;const mouseOpts=computeMouseOpts.value;if(mouseConfig&&mouseOpts.area&&$xeTable.handleRecalculateCellAreaEvent){return $xeTable.handleRecalculateCellAreaEvent();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},getCustomStoreData(){const{id}=props;const customOpts=computeCustomOpts.value;const{isRowGroupStatus,rowGroupList}=reactData;const{fullColumnFieldData,collectColumn}=internalData;const{storage,checkMethod,storeOptions}=customOpts;const isAllCustom=storage===true;const storageOpts=Object.assign({},isAllCustom?{}:storage||{},storeOptions);const isCustomResizable=hangleStorageDefaultValue(storageOpts.resizable,isAllCustom);const isCustomVisible=hangleStorageDefaultValue(storageOpts.visible,isAllCustom);const isCustomFixed=hangleStorageDefaultValue(storageOpts.fixed,isAllCustom);const isCustomSort=hangleStorageDefaultValue(storageOpts.sort,isAllCustom);const isCustomAggGroup=hangleStorageDefaultValue(storageOpts.aggGroup,isAllCustom);const isCustomAggFunc=hangleStorageDefaultValue(storageOpts.aggFunc,isAllCustom);const resizableData={};const sortData=[];const visibleData={};const fixedData={};const aggGroupData={};const aggFuncData={};const storeData={resizableData:undefined,sortData:undefined,visibleData:undefined,fixedData:undefined,aggGroupData:undefined,aggFuncData:undefined};if(!id){if(storage){errLog('vxe.error.reqProp',['id']);}return storeData;}let hasResizable=0;let hasSort=0;let hasFixed=0;let hasVisible=0;let hasAggFunc=0;const sortMaps={};external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn,(column,index,items,path,parentColumn)=>{const colKey=column.getKey();if(!colKey){errLog('vxe.error.reqProp',[`${column.getTitle()||column.type||''} -> column.field=?`]);return;}if(parentColumn){if(isCustomSort){const pColKey=parentColumn.getKey();const psObj=sortMaps[pColKey];hasSort=1;if(psObj){const sObj={k:colKey};sortMaps[colKey]=sObj;if(!psObj.c){psObj.c=[];}psObj.c.push(sObj);}}}else{if(isCustomSort){hasSort=1;const sObj={k:colKey};sortMaps[colKey]=sObj;sortData.push(sObj);}// 
if(isCustomFixed&&(column.fixed||'')!==(column.defaultFixed||'')){hasFixed=1;fixedData[colKey]=column.fixed;}}if(isCustomResizable&&column.resizeWidth){hasResizable=1;resizableData[colKey]=column.renderWidth;}if(isCustomVisible&&(!checkMethod||checkMethod({$table:$xeTable,column}))){if(!column.visible&&column.defaultVisible){hasVisible=1;visibleData[colKey]=false;}else if(column.visible&&!column.defaultVisible){hasVisible=1;visibleData[colKey]=true;}}if(isCustomAggFunc&&(column.aggFunc||'')!==(column.defaultAggFunc||'')){hasAggFunc=1;aggFuncData[colKey]=column.aggFunc;}});if(hasResizable){storeData.resizableData=resizableData;}if(hasSort){storeData.sortData=sortData;}if(hasFixed){storeData.fixedData=fixedData;}if(hasVisible){storeData.visibleData=visibleData;}if(isCustomAggGroup&&isRowGroupStatus){rowGroupList.forEach(aggConf=>{const colRest=fullColumnFieldData[aggConf.field];if(colRest){aggGroupData[colRest.column.getKey()]=true;}});storeData.aggGroupData=aggGroupData;}if(hasAggFunc){storeData.aggFuncData=aggFuncData;}return storeData;},focus(){internalData.isActivated=true;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},blur(){internalData.isActivated=false;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             *  connectToolbar 
             * @deprecated
             */connect($toolbar){return $xeTable.connectToolbar($toolbar);},/**
             * 
             * @param $toolbar
             */connectToolbar($toolbar){if($toolbar){$xeToolbar=$toolbar;$xeToolbar.syncUpdate({collectColumn:internalData.collectColumn,$table:$xeTable});}else{errLog('vxe.error.barUnableLink');}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}};/**
         * 
         */const handleGlobalMousedownEvent=evnt=>{const{editStore,ctxMenuStore,customStore}=reactData;const{mouseConfig,editRules}=props;const el=refElem.value;const editOpts=computeEditOpts.value;const validOpts=computeValidOpts.value;const areaOpts=computeAreaOpts.value;const{actived}=editStore;const $validTooltip=refValidTooltip.value;const tableFilter=refTableFilter.value;const tableCustom=refTableCustom.value;const tableMenu=refTableMenu.value;// 
if(tableFilter){if(getEventTargetNode(evnt,el,'vxe-cell--filter').flag){// 
}else if(getEventTargetNode(evnt,tableFilter.getRefMaps().refElem.value).flag){// 
}else{if(!getEventTargetNode(evnt,document.body,'vxe-table--ignore-clear').flag){tablePrivateMethods.preventEvent(evnt,'event.clearFilter',internalData._currFilterParams,tableMethods.closeFilter);}}}// 
if(tableCustom){if(customStore.btnEl===evnt.target||getEventTargetNode(evnt,document.body,'vxe-toolbar-custom-target').flag){// 
}else if(getEventTargetNode(evnt,tableCustom.getRefMaps().refElem.value).flag){// 
}else{if(!getEventTargetNode(evnt,document.body,'vxe-table--ignore-clear').flag){if(customStore.visible&&$xeTable.closeCustom){tablePrivateMethods.preventEvent(evnt,'event.clearCustom',{},()=>{$xeTable.closeCustom();$xeTable.dispatchEvent('custom',{type:'close'},evnt);});}}}}// 
if(actived.row){if(!(editOpts.autoClear===false)){// 
const cell=actived.args.cell;if(!cell||!getEventTargetNode(evnt,cell).flag){if($validTooltip&&getEventTargetNode(evnt,$validTooltip.$el).flag){// 
}else if(!internalData._lastCallTime||internalData._lastCallTime+50<Date.now()){// 
if(!getEventTargetNode(evnt,document.body,'vxe-table--ignore-clear').flag){// 
tablePrivateMethods.preventEvent(evnt,'event.clearEdit',actived.args,()=>{let isClear;if(editOpts.mode==='row'){const rowTargetNode=getEventTargetNode(evnt,el,'vxe-body--row');const rowNodeRest=rowTargetNode.flag?tableMethods.getRowNode(rowTargetNode.targetElem):null;// row 
isClear=rowNodeRest?!$xeTable.eqRow(rowNodeRest.item,actived.args.row):false;}else{// cell 
isClear=!getEventTargetNode(evnt,el,'col--edit').flag;}// 
if(!isClear){isClear=getEventTargetNode(evnt,el,'vxe-header--row').flag;}// 
if(!isClear){isClear=getEventTargetNode(evnt,el,'vxe-footer--row').flag;}// 
if(!isClear&&props.height&&!reactData.overflowY){const bodyWrapperElem=evnt.target;if(hasClass(bodyWrapperElem,'vxe-table--body-wrapper')){isClear=evnt.offsetY<bodyWrapperElem.clientHeight;}}if(isClear||// 
!getEventTargetNode(evnt,el).flag){setTimeout(()=>{$xeTable.handleClearEdit(evnt).then(()=>{// 
if(!internalData.isActivated&&editRules&&validOpts.autoClear){reactData.validErrorMaps={};}});});}});}}}}}else if(mouseConfig){if(!getEventTargetNode(evnt,el).flag&&!($xeGGWrapper&&getEventTargetNode(evnt,$xeGGWrapper.getRefMaps().refElem.value).flag)&&!(tableMenu&&getEventTargetNode(evnt,tableMenu.getRefMaps().refElem.value).flag)&&!($xeToolbar&&getEventTargetNode(evnt,$xeToolbar.getRefMaps().refElem.value).flag)){if($xeTable.clearSelected){$xeTable.clearSelected();}if(areaOpts.autoClear){if($xeTable.getCellAreas){const cellAreas=$xeTable.getCellAreas();if(cellAreas&&cellAreas.length&&!getEventTargetNode(evnt,document.body,'vxe-table--ignore-areas-clear').flag){tablePrivateMethods.preventEvent(evnt,'event.clearAreas',{},()=>{$xeTable.clearCellAreas();$xeTable.clearCopyCellArea();dispatchEvent('clear-cell-area-selection',{cellAreas},evnt);});}}}}}// 
if($xeTable.closeMenu){if(ctxMenuStore.visible&&tableMenu&&!getEventTargetNode(evnt,tableMenu.getRefMaps().refElem.value).flag){$xeTable.closeMenu();}}const isActivated=getEventTargetNode(evnt,$xeGGWrapper?$xeGGWrapper.getRefMaps().refElem.value:el).flag;// 
if(!isActivated&&editRules&&validOpts.autoClear){reactData.validErrorMaps={};}// 
internalData.isActivated=isActivated;};/**
         * 
         */const handleGlobalBlurEvent=()=>{tableMethods.closeFilter();if($xeTable.closeMenu){$xeTable.closeMenu();}};/**
         * 
         */const handleGlobalMousewheelEvent=()=>{tableMethods.closeTooltip();if($xeTable.closeMenu){$xeTable.closeMenu();}};/**
         * 
         */const keydownEvent=evnt=>{const{mouseConfig,keyboardConfig}=props;const{filterStore,ctxMenuStore,editStore}=reactData;const mouseOpts=computeMouseOpts.value;const keyboardOpts=computeKeyboardOpts.value;const{actived}=editStore;const isEsc=table_globalEvents.hasKey(evnt,table_GLOBAL_EVENT_KEYS.ESCAPE);if(isEsc){tablePrivateMethods.preventEvent(evnt,'event.keydown',null,()=>{dispatchEvent('keydown-start',{},evnt);if(keyboardConfig&&mouseConfig&&mouseOpts.area&&$xeTable.handleKeyboardCellAreaEvent){$xeTable.handleKeyboardCellAreaEvent(evnt);}else if(actived.row||filterStore.visible||ctxMenuStore.visible){evnt.stopPropagation();//  Esc 
if($xeTable.closeMenu){$xeTable.closeMenu();}tableMethods.closeFilter();if(keyboardConfig&&keyboardOpts.isEsc){// 
if(actived.row){const params=actived.args;$xeTable.handleClearEdit(evnt);// 
if(mouseOpts.selected){(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>$xeTable.handleSelected(params,evnt));}}}}dispatchEvent('keydown',{},evnt);dispatchEvent('keydown-end',{},evnt);});}};/**
         * 
         */const handleGlobalKeydownEvent=evnt=>{// 
if(internalData.isActivated){$xeTable.preventEvent(evnt,'event.keydown',null,()=>{const{mouseConfig,keyboardConfig,treeConfig,editConfig,highlightCurrentRow,highlightCurrentColumn}=props;const{ctxMenuStore,editStore,currentRow}=reactData;const{afterFullData}=internalData;const isContentMenu=computeIsContentMenu.value;const bodyMenu=computeBodyMenu.value;const keyboardOpts=computeKeyboardOpts.value;const mouseOpts=computeMouseOpts.value;const editOpts=computeEditOpts.value;const treeOpts=computeTreeOpts.value;const menuList=computeMenuList.value;const rowOpts=computeRowOpts.value;const columnOpts=computeColumnOpts.value;const{selected,actived}=editStore;const childrenField=treeOpts.children||treeOpts.childrenField;const keyCode=evnt.keyCode;const isEsc=table_globalEvents.hasKey(evnt,table_GLOBAL_EVENT_KEYS.ESCAPE);const hasBackspaceKey=table_globalEvents.hasKey(evnt,table_GLOBAL_EVENT_KEYS.BACKSPACE);const isTab=table_globalEvents.hasKey(evnt,table_GLOBAL_EVENT_KEYS.TAB);const isEnter=table_globalEvents.hasKey(evnt,table_GLOBAL_EVENT_KEYS.ENTER);const isSpacebar=table_globalEvents.hasKey(evnt,table_GLOBAL_EVENT_KEYS.SPACEBAR);const isLeftArrow=table_globalEvents.hasKey(evnt,table_GLOBAL_EVENT_KEYS.ARROW_LEFT);const isUpArrow=table_globalEvents.hasKey(evnt,table_GLOBAL_EVENT_KEYS.ARROW_UP);const isRightArrow=table_globalEvents.hasKey(evnt,table_GLOBAL_EVENT_KEYS.ARROW_RIGHT);const isDwArrow=table_globalEvents.hasKey(evnt,table_GLOBAL_EVENT_KEYS.ARROW_DOWN);const hasDeleteKey=table_globalEvents.hasKey(evnt,table_GLOBAL_EVENT_KEYS.DELETE);const isF2=table_globalEvents.hasKey(evnt,table_GLOBAL_EVENT_KEYS.F2);const isContextMenu=table_globalEvents.hasKey(evnt,table_GLOBAL_EVENT_KEYS.CONTEXT_MENU);const isControlKey=hasControlKey(evnt);const hasShiftKey=evnt.shiftKey;const isAltKey=evnt.altKey;const operArrow=isLeftArrow||isUpArrow||isRightArrow||isDwArrow;const operCtxMenu=isContentMenu&&ctxMenuStore.visible&&(isEnter||isSpacebar||operArrow);const isEditStatus=isEnableConf(editConfig)&&actived.column&&actived.row;const beforeEditMethod=editOpts.beforeEditMethod||editOpts.activeMethod;if(operCtxMenu){// ; 
evnt.preventDefault();if(ctxMenuStore.showChild&&hasChildrenList(ctxMenuStore.selected)){$xeTable.moveCtxMenu(evnt,ctxMenuStore,'selectChild',isLeftArrow,false,ctxMenuStore.selected.children);}else{$xeTable.moveCtxMenu(evnt,ctxMenuStore,'selected',isRightArrow,true,menuList);}}else if(keyboardConfig&&mouseConfig&&mouseOpts.area&&$xeTable.handleKeyboardCellAreaEvent){$xeTable.handleKeyboardCellAreaEvent(evnt);}else if(isEsc){//  Esc 
if($xeTable.closeMenu){$xeTable.closeMenu();}$xeTable.closeFilter();if(keyboardConfig&&keyboardOpts.isEsc){// 
if(actived.row){const params=actived.args;$xeTable.handleClearEdit(evnt);// 
if(mouseOpts.selected){(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>$xeTable.handleSelected(params,evnt));}}}}else if(isSpacebar&&keyboardConfig&&keyboardOpts.isChecked&&selected.row&&selected.column&&(selected.column.type==='checkbox'||selected.column.type==='radio')){// 
evnt.preventDefault();if(selected.column.type==='checkbox'){tablePrivateMethods.handleToggleCheckRowEvent(evnt,selected.args);}else{tablePrivateMethods.triggerRadioRowEvent(evnt,selected.args);}}else if(isF2&&isEnableConf(editConfig)){if(!isEditStatus){//  F2 
if(selected.row&&selected.column){evnt.preventDefault();$xeTable.handleEdit(selected.args,evnt);}}}else if(isContextMenu){// 
internalData._keyCtx=selected.row&&selected.column&&bodyMenu.length;clearTimeout(internalData.keyCtxTimeout);internalData.keyCtxTimeout=setTimeout(()=>{internalData._keyCtx=false;},1000);}else if(isEnter&&!isAltKey&&keyboardConfig&&keyboardOpts.isEnter&&(selected.row||actived.row||treeConfig&&(rowOpts.isCurrent||highlightCurrentRow)&&currentRow)){const{isLastEnterAppendRow,beforeEnterMethod,enterMethod}=keyboardOpts;// 
if(isControlKey){// 
if(actived.row){const params=actived.args;$xeTable.handleClearEdit(evnt);// 
if(mouseOpts.selected){(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{$xeTable.handleSelected(params,evnt);});}}}else{// /
if(selected.row||actived.row){const activeParams=selected.row?selected.args:actived.args;if(hasShiftKey){if(keyboardOpts.enterToTab){$xeTable.moveTabSelected(activeParams,hasShiftKey,evnt);}else{$xeTable.moveEnterSelected(activeParams,isLeftArrow,true,isRightArrow,false,evnt);}}else{if(keyboardOpts.enterToTab){$xeTable.moveTabSelected(activeParams,hasShiftKey,evnt);}else{const activeRow=selected.row||actived.row;const activeColumn=selected.column||actived.column;const _rowIndex=$xeTable.getVTRowIndex(activeRow);const etrParams={row:activeRow,rowIndex:$xeTable.getRowIndex(activeRow),$rowIndex:$xeTable.getVMRowIndex(activeRow),_rowIndex,column:activeColumn,columnIndex:$xeTable.getColumnIndex(activeColumn),$columnIndex:$xeTable.getVMColumnIndex(activeColumn),_columnIndex:$xeTable.getVTColumnIndex(activeColumn),$table:$xeTable};if(!beforeEnterMethod||beforeEnterMethod(etrParams)!==false){// 
if(isLastEnterAppendRow){if(_rowIndex>=afterFullData.length-1){$xeTable.insertAt({},-1).then(({row:newRow})=>{$xeTable.scrollToRow(newRow,activeColumn);$xeTable.handleSelected({...activeParams,row:newRow},evnt);});$xeTable.dispatchEvent('enter-append-row',etrParams,evnt);return;}}$xeTable.moveEnterSelected(activeParams,isLeftArrow,false,isRightArrow,true,evnt);if(enterMethod){enterMethod(etrParams);}}}}}else if(treeConfig&&(rowOpts.isCurrent||highlightCurrentRow)&&currentRow){// 
const childrens=currentRow[childrenField];if(childrens&&childrens.length){evnt.preventDefault();const targetRow=childrens[0];const params={$table:$xeTable,row:targetRow,rowIndex:$xeTable.getRowIndex(targetRow),$rowIndex:$xeTable.getVMRowIndex(targetRow)};$xeTable.setTreeExpand(currentRow,true).then(()=>$xeTable.scrollToRow(targetRow)).then(()=>$xeTable.triggerCurrentRowEvent(evnt,params));}}}}else if(operArrow&&keyboardConfig&&keyboardOpts.isArrow){if(!isEditStatus){// 
if(mouseOpts.selected&&selected.row&&selected.column){$xeTable.moveArrowSelected(selected.args,isLeftArrow,isUpArrow,isRightArrow,isDwArrow,evnt);}else{// 
if((isUpArrow||isDwArrow)&&(rowOpts.isCurrent||highlightCurrentRow)){$xeTable.moveCurrentRow(isUpArrow,isDwArrow,evnt);}// 
if((isLeftArrow||isRightArrow)&&(columnOpts.isCurrent||highlightCurrentColumn)){$xeTable.moveCurrentColumn(isLeftArrow,isRightArrow,evnt);}}}}else if(isTab&&keyboardConfig&&keyboardOpts.isTab){//  Tab 
if(selected.row||selected.column){$xeTable.moveTabSelected(selected.args,hasShiftKey,evnt);}else if(actived.row||actived.column){$xeTable.moveTabSelected(actived.args,hasShiftKey,evnt);}}else if(keyboardConfig&&keyboardOpts.isDel&&hasDeleteKey&&isEnableConf(editConfig)&&(selected.row||selected.column)){// 
if(!isEditStatus){const{delMethod}=keyboardOpts;const params={row:selected.row,rowIndex:tableMethods.getRowIndex(selected.row),column:selected.column,columnIndex:tableMethods.getColumnIndex(selected.column),$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt};// 
if(!beforeEditMethod||beforeEditMethod(params)){if(delMethod){delMethod(params);}else{setCellValue(selected.row,selected.column,null);}//  del 
tableMethods.updateFooter();dispatchEvent('cell-delete-value',params,evnt);}}}else if(hasBackspaceKey&&keyboardConfig&&keyboardOpts.isBack&&isEnableConf(editConfig)&&(selected.row||selected.column)){if(!isEditStatus){const{backMethod}=keyboardOpts;// 
if(keyboardOpts.isDel&&isEnableConf(editConfig)&&(selected.row||selected.column)){const params={row:selected.row,rowIndex:$xeTable.getRowIndex(selected.row),column:selected.column,columnIndex:$xeTable.getColumnIndex(selected.column),$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt};// 
if(!beforeEditMethod||beforeEditMethod(params)){if(backMethod){backMethod(params);}else{setCellValue(selected.row,selected.column,null);$xeTable.handleEdit(selected.args,evnt);}dispatchEvent('cell-backspace-value',params,evnt);}}}}else if(hasBackspaceKey&&keyboardConfig&&treeConfig&&keyboardOpts.isBack&&(rowOpts.isCurrent||highlightCurrentRow)&&currentRow){// 
const{parent:parentRow}=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(internalData.afterTreeFullData,item=>item===currentRow,{children:childrenField});if(parentRow){evnt.preventDefault();const params={row:parentRow,rowIndex:$xeTable.getRowIndex(parentRow),$rowIndex:$xeTable.getVMRowIndex(parentRow),$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt};$xeTable.setTreeExpand(parentRow,false).then(()=>$xeTable.scrollToRow(parentRow)).then(()=>$xeTable.triggerCurrentRowEvent(evnt,params));}}else if(keyboardConfig&&isEnableConf(editConfig)&&keyboardOpts.isEdit&&!isControlKey&&(isSpacebar||keyCode>=48&&keyCode<=57||keyCode>=65&&keyCode<=90||keyCode>=96&&keyCode<=111||keyCode>=186&&keyCode<=192||keyCode>=219&&keyCode<=222)){const{editMode,editMethod}=keyboardOpts;// 
// if (isSpacebar) {
//   evnt.preventDefault()
// }
// 
if(selected.column&&selected.row&&isEnableConf(selected.column.editRender)){const beforeEditMethod=editOpts.beforeEditMethod||editOpts.activeMethod;const params={row:selected.row,rowIndex:$xeTable.getRowIndex(selected.row),column:selected.column,columnIndex:$xeTable.getColumnIndex(selected.column),$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt};if(!beforeEditMethod||beforeEditMethod({...selected.args,$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt})){if(editMethod){editMethod(params);}else{// 
if(editMode!=='insert'){setCellValue(selected.row,selected.column,null);}$xeTable.handleEdit(selected.args,evnt);}}}}dispatchEvent('keydown',{},evnt);});}};const handleGlobalPasteEvent=evnt=>{const{keyboardConfig,mouseConfig}=props;const{editStore,filterStore}=reactData;const{isActivated}=internalData;const mouseOpts=computeMouseOpts.value;const keyboardOpts=computeKeyboardOpts.value;const{actived}=editStore;if(isActivated&&!filterStore.visible){if(!(actived.row||actived.column)){if(keyboardConfig&&keyboardOpts.isClip&&mouseConfig&&mouseOpts.area&&$xeTable.handlePasteCellAreaEvent){$xeTable.handlePasteCellAreaEvent(evnt);}}dispatchEvent('paste',{},evnt);}};const handleGlobalCopyEvent=evnt=>{const{keyboardConfig,mouseConfig}=props;const{editStore,filterStore}=reactData;const{isActivated}=internalData;const mouseOpts=computeMouseOpts.value;const keyboardOpts=computeKeyboardOpts.value;const{actived}=editStore;if(isActivated&&!filterStore.visible){if(!(actived.row||actived.column)){if(keyboardConfig&&keyboardOpts.isClip&&mouseConfig&&mouseOpts.area&&$xeTable.handleCopyCellAreaEvent){$xeTable.handleCopyCellAreaEvent(evnt);}}dispatchEvent('copy',{},evnt);}};const handleGlobalCutEvent=evnt=>{const{keyboardConfig,mouseConfig}=props;const{editStore,filterStore}=reactData;const{isActivated}=internalData;const mouseOpts=computeMouseOpts.value;const keyboardOpts=computeKeyboardOpts.value;const{actived}=editStore;if(isActivated&&!filterStore.visible){if(!(actived.row||actived.column)){if(keyboardConfig&&keyboardOpts.isClip&&mouseConfig&&mouseOpts.area&&$xeTable.handleCutCellAreaEvent){$xeTable.handleCutCellAreaEvent(evnt);}}dispatchEvent('cut',{},evnt);}};const handleGlobalResizeEvent=()=>{if($xeTable.closeMenu){$xeTable.closeMenu();}const el=refElem.value;if(!el||!el.clientWidth){return;}handleResizeEvent();$xeTable.updateCellAreas();};const handleTargetEnterEvent=isClear=>{const $tooltip=refTooltip.value;clearTimeout(internalData.tooltipTimeout);if(isClear){tableMethods.closeTooltip();}else{if($tooltip&&$tooltip.setActived){$tooltip.setActived(true);}}};const clearCrossTableDragStatus=()=>{crossTableDragRowObj=null;crossTableDragRowInfo.row=null;};const clearDragStatus=()=>{const{dragRow,dragCol}=reactData;if(dragRow||dragCol){clearColDropOrigin();clearRowDropOrigin();hideDropTip();clearCrossTableDragStatus();reactData.dragRow=null;reactData.dragCol=null;}};const clearRowDropOrigin=()=>{const el=refElem.value;if(el){const clss='row--drag-origin';external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`.${clss}`),elem=>{elem.draggable=false;removeClass(elem,clss);});}};const updateRowDropOrigin=row=>{const el=refElem.value;if(el){const clss='row--drag-origin';const rowid=getRowid($xeTable,row);external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`[rowid="${rowid}"]`),elem=>{addClass(elem,clss);});}};const updateRowDropTipContent=tdEl=>{const{dragConfig}=props;const{dragRow}=reactData;const rowDragOpts=computeRowDragOpts.value;const{tooltipMethod}=rowDragOpts;const rTooltipMethod=tooltipMethod||(dragConfig?dragConfig.rowTooltipMethod:null);let tipContent='';if(rTooltipMethod){const rtParams={$table:$xeTable,row:dragRow};tipContent=`${rTooltipMethod(rtParams)||''}`;}else{tipContent=table_getI18n('vxe.table.dragTip',[tdEl.textContent||'']);}reactData.dragTipText=tipContent;};const updateColDropOrigin=column=>{const el=refElem.value;if(el){const colQuerys=[];external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column],item=>{colQuerys.push(`[colid="${item.id}"]`);});const clss='col--drag-origin';external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(colQuerys.join(',')),elem=>{addClass(elem,clss);});}};const clearColDropOrigin=()=>{const el=refElem.value;if(el){const clss='col--drag-origin';external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`.${clss}`),elem=>{elem.draggable=false;removeClass(elem,clss);});}};const updateColDropTipContent=tdEl=>{const{dragCol}=reactData;const columnDragOpts=computeColumnDragOpts.value;const{tooltipMethod}=columnDragOpts;let tipContent='';if(tooltipMethod){const dtParams={$table:$xeTable,column:dragCol};tipContent=`${tooltipMethod(dtParams)||''}`;}else{tipContent=table_getI18n('vxe.table.dragTip',[tdEl.textContent||'']);}reactData.dragTipText=tipContent;};const showDropTip=(evnt,trEl,thEl,showLine,dragPos)=>{let wrapperEl=refElem.value;if($xeGantt&&trEl){const{refGanttContainerElem}=$xeGantt.getRefMaps();const ganttContainerElem=refGanttContainerElem.value;if(ganttContainerElem){wrapperEl=ganttContainerElem;}}if(!wrapperEl){return;}const{overflowX,scrollbarWidth,overflowY,scrollbarHeight}=reactData;const{prevDragToChild}=internalData;const wrapperRect=wrapperEl.getBoundingClientRect();const osbWidth=overflowY?scrollbarWidth:0;const osbHeight=overflowX?scrollbarHeight:0;const tableWrapperWidth=wrapperEl.clientWidth;const tableWrapperHeight=wrapperEl.clientHeight;if(trEl){const rdLineEl=refDragRowLineElem.value;if(rdLineEl){if(showLine){const scrollbarYToLeft=computeScrollbarYToLeft.value;const trRect=trEl.getBoundingClientRect();let trHeight=trEl.clientHeight;const offsetTop=Math.max(1,trRect.y-wrapperRect.y);if(offsetTop+trHeight>tableWrapperHeight-osbHeight){trHeight=tableWrapperHeight-offsetTop-osbHeight;}rdLineEl.style.display='block';rdLineEl.style.left=`${scrollbarYToLeft?osbWidth:0}px`;rdLineEl.style.top=`${offsetTop}px`;rdLineEl.style.height=`${trHeight}px`;rdLineEl.style.width=`${tableWrapperWidth-osbWidth}px`;rdLineEl.setAttribute('drag-pos',dragPos);rdLineEl.setAttribute('drag-to-child',prevDragToChild?'y':'n');}else{rdLineEl.style.display='';}}}else if(thEl){const cdLineEl=refDragColLineElem.value;if(cdLineEl){if(showLine){const scrollbarXToTop=computeScrollbarXToTop.value;const leftContainerElem=refLeftContainer.value;const leftContainerWidth=leftContainerElem?leftContainerElem.clientWidth:0;const rightContainerElem=refRightContainer.value;const rightContainerWidth=rightContainerElem?rightContainerElem.clientWidth:0;const thRect=thEl.getBoundingClientRect();let thWidth=thEl.clientWidth;const offsetTop=Math.max(0,thRect.y-wrapperRect.y);const startX=leftContainerWidth;let offsetLeft=thRect.x-wrapperRect.x;if(offsetLeft<startX){thWidth-=startX-offsetLeft;offsetLeft=startX;}const endX=tableWrapperWidth-rightContainerWidth-(rightContainerWidth?0:osbWidth);if(offsetLeft+thWidth>endX){thWidth=endX-offsetLeft;}cdLineEl.style.display='block';cdLineEl.style.top=`${offsetTop}px`;cdLineEl.style.left=`${offsetLeft}px`;cdLineEl.style.width=`${thWidth}px`;if(prevDragToChild){cdLineEl.style.height=`${thRect.height}px`;}else{cdLineEl.style.height=`${tableWrapperHeight-offsetTop-(scrollbarXToTop?0:osbHeight)}px`;}cdLineEl.setAttribute('drag-pos',dragPos);cdLineEl.setAttribute('drag-to-child',prevDragToChild?'y':'n');}else{cdLineEl.style.display='';}}}const rdTipEl=refDragTipElem.value;if(rdTipEl){rdTipEl.style.display='block';rdTipEl.style.top=`${Math.min(wrapperEl.clientHeight-wrapperEl.scrollTop-rdTipEl.clientHeight,evnt.clientY-wrapperRect.y)}px`;rdTipEl.style.left=`${Math.min(wrapperEl.clientWidth-wrapperEl.scrollLeft-rdTipEl.clientWidth-16,evnt.clientX-wrapperRect.x)}px`;rdTipEl.setAttribute('drag-status',showLine?prevDragToChild?'sub':'normal':'disabled');}};const hideDropTip=()=>{const rdTipEl=refDragTipElem.value;const rdLineEl=refDragRowLineElem.value;const cdLineEl=refDragColLineElem.value;if(rdTipEl){rdTipEl.style.display='';}if(rdLineEl){rdLineEl.style.display='';}if(cdLineEl){cdLineEl.style.display='';}};const clearRowDragData=()=>{let wrapperEl=refElem.value;const dtClss=['.vxe-body--row'];if($xeGantt){const{refGanttContainerElem}=$xeGantt.getRefMaps();const ganttContainerElem=refGanttContainerElem.value;if(ganttContainerElem){wrapperEl=ganttContainerElem;}dtClss.push('.vxe-gantt-view--body-row','.vxe-gantt-view--chart-row');}hideDropTip();clearRowDropOrigin();clearRowAnimate(wrapperEl,dtClss);internalData.prevDragToChild=false;reactData.dragRow=null;reactData.dragCol=null;};const clearColDragData=()=>{const el=refElem.value;hideDropTip();clearColDropOrigin();clearColAnimate(el,['.vxe-table--column']);internalData.prevDragToChild=false;reactData.dragRow=null;reactData.dragCol=null;};/**
         *  tooltip
         * @param {Event} evnt 
         * @param {Row} row 
         */const handleTooltip=(evnt,tipOpts,type,tdEl,overflowElem,tipElem,params)=>{const tipOverEl=overflowElem||tdEl;if(!tipOverEl){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}params.cell=tdEl;const{tooltipStore}=reactData;const{column,row}=params;const{showAll,contentMethod}=tipOpts;const customContent=contentMethod?contentMethod(params):null;const useCustom=contentMethod&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(customContent);const content=useCustom?customContent:external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toString(column.type==='html'?tipOverEl.innerText:tipOverEl.textContent).trim();const isOver=tipOverEl.scrollWidth>tipOverEl.clientWidth;if(content&&(showAll||useCustom||isOver)){const tipContent=formatText(content);Object.assign(tooltipStore,{row,column,visible:true,content:tipContent,type,currOpts:tipOpts});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{const $tooltip=refTooltip.value;if($tooltip&&$tooltip.open){$tooltip.open(isOver?tipOverEl:tipElem,tipContent);}});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();};const callSlot=(slotFunc,params)=>{if(slotFunc){if($xeGGWrapper){return $xeGGWrapper.callSlot(slotFunc,params);}// if (XEUtils.isString(slotFunc)) {
//   slotFunc = slots[slotFunc] || null
// }
if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)){return getSlotVNs(slotFunc(params));}}return[];};/**
         * 
         */tablePrivateMethods={getSetupOptions(){return table_getConfig();},updateAfterDataIndex,callSlot,/**
             * 
             */getParentElem(){const el=refElem.value;if($xeGGWrapper){const gridEl=$xeGGWrapper.getRefMaps().refElem.value;return gridEl?gridEl.parentNode:null;}return el?el.parentNode:null;},/**
             * 
             */getParentHeight(){const{height}=props;const el=refElem.value;if(el){const parentElem=el.parentNode;let parentPaddingSize=0;let parentWrapperHeight=0;if(parentElem){if($xeGantt&&hasClass(parentElem,'vxe-gantt--table-wrapper')){parentWrapperHeight=$xeGantt.getParentHeight();}else if($xeGrid&&hasClass(parentElem,'vxe-grid--table-wrapper')){parentWrapperHeight=$xeGrid.getParentHeight();}else{parentWrapperHeight=parentElem.clientHeight;parentPaddingSize=height==='100%'||height==='auto'?getPaddingTopBottomSize(parentElem):0;}}return Math.floor(parentWrapperHeight-parentPaddingSize);}return 0;},/**
             * 
             * 
             * 
             */getExcludeHeight(){return $xeGGWrapper?$xeGGWrapper.getExcludeHeight():0;},/**
             * 
             * @param {Row} records 
             */defineField(records){const{treeConfig}=props;const expandOpts=computeExpandOpts.value;const treeOpts=computeTreeOpts.value;const radioOpts=computeRadioOpts.value;const checkboxOpts=computeCheckboxOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const rowkey=getRowkey($xeTable);if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records)){records=[records];}return records.map(record=>{internalData.tableFullColumn.forEach(column=>{const{field,editRender}=column;if(field&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().has(record,field)&&!record[field]){let cellValue=null;if(editRender){const{defaultValue}=editRender;if(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(defaultValue)){cellValue=defaultValue({column});}else if(!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(defaultValue)){cellValue=defaultValue;}}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(record,field,cellValue);}});const otherFields=[radioOpts.labelField,checkboxOpts.checkField,checkboxOpts.labelField,expandOpts.labelField];otherFields.forEach(key=>{if(key&&eqEmptyValue(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(record,key))){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(record,key,null);}});if(treeConfig&&treeOpts.lazy&&external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(record[childrenField])){record[childrenField]=null;}// 
if(eqEmptyValue(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(record,rowkey))){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(record,rowkey,getRowUniqueId());}return record;});},handleTableData(force){const{scrollYLoad}=reactData;const{scrollYStore,fullDataRowIdData}=internalData;const $xeGanttView=internalData.xeGanttView;let fullList=internalData.afterFullData;// 
if(force){// 
updateAfterFullData();// 
fullList=handleVirtualTreeToList();}const tableData=scrollYLoad?fullList.slice(scrollYStore.startIndex,scrollYStore.endIndex):fullList.slice(0);const visibleDataRowIdMaps={};tableData.forEach((row,$index)=>{const rowid=getRowid($xeTable,row);const rest=fullDataRowIdData[rowid];if(rest){rest.$index=$index;}visibleDataRowIdMaps[rowid]=row;});reactData.tableData=tableData;internalData.visibleDataRowIdData=visibleDataRowIdMaps;if($xeGanttView&&$xeGanttView.updateViewData){$xeGanttView.updateViewData();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             *  Map
             */cacheRowMap(isReset){const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{currKeyField,fullAllDataRowIdData,tableFullData,tableFullTreeData,tableFullGroupData,treeExpandedMaps,rowExpandedMaps,selectCheckboxMaps}=internalData;const fullAllDataRowIdMaps=isReset?{}:{...fullAllDataRowIdData};// 
const fullDataRowIdMaps={};const idMaps={};const{handleUpdateRowId}=createHandleUpdateRowId($xeTable);const handleRowCache=(row,index,items,currIndex,parentRow,rowid,level,seq)=>{let rowRest=fullAllDataRowIdMaps[rowid];if(idMaps[rowid]){errLog('vxe.error.repeatKey',[currKeyField,rowid]);}if(!rowRest){rowRest={row,rowid,seq,index:-1,_index:-1,$index:-1,treeIndex:index,_tIndex:-1,items,parent:parentRow,level,height:0,resizeHeight:0,oTop:0,expandHeight:0};fullDataRowIdMaps[rowid]=rowRest;fullAllDataRowIdMaps[rowid]=rowRest;}rowRest.treeLoaded=false;rowRest.expandLoaded=false;rowRest.row=row;rowRest.items=items;rowRest.parent=parentRow;rowRest.level=level;rowRest.index=currIndex;rowRest.treeIndex=index;// 
if(selectCheckboxMaps[rowid]){selectCheckboxMaps[rowid]=row;}if(rowExpandedMaps[rowid]){rowExpandedMaps[rowid]=row;}idMaps[rowid]=true;fullDataRowIdMaps[rowid]=rowRest;fullAllDataRowIdMaps[rowid]=rowRest;};if(treeConfig){const treeOpts=computeTreeOpts.value;const{lazy}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const hasChildField=treeOpts.hasChild||treeOpts.hasChildField;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullTreeData,(row,index,items,path,parentRow,nodes)=>{const rowid=handleUpdateRowId(row);if(treeConfig&&lazy){if(row[hasChildField]&&row[childrenField]===undefined){row[childrenField]=null;}if(treeExpandedMaps[rowid]){if(!row[childrenField]||!row[childrenField].length){delete treeExpandedMaps[rowid];}}}handleRowCache(row,index,items,parentRow?-1:index,parentRow,rowid,nodes.length-1,toTreePathSeq(path));},{children:childrenField});}else if(isRowGroupStatus){const aggregateOpts=computeAggregateOpts.value;const{mapChildrenField}=aggregateOpts;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullGroupData,(row,index,items,path,parentRow,nodes)=>{const rowid=handleUpdateRowId(row);handleRowCache(row,index,items,parentRow?-1:index,parentRow,rowid,nodes.length-1,toTreePathSeq(path));},{children:mapChildrenField});}else{tableFullData.forEach((row,index,items)=>{handleRowCache(row,index,items,index,null,handleUpdateRowId(row),0,index+1);});}internalData.fullDataRowIdData=fullDataRowIdMaps;internalData.fullAllDataRowIdData=fullAllDataRowIdMaps;reactData.treeExpandedFlag++;},cacheSourceMap(fullData){const{treeConfig}=props;const treeOpts=computeTreeOpts.value;const sourceData=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(fullData,true);const{handleUpdateRowId}=createHandleUpdateRowId($xeTable);const sourceRowIdData={};const handleSourceRow=row=>{const rowid=handleUpdateRowId(row);sourceRowIdData[rowid]=row;};// 
if(treeConfig){const childrenField=treeOpts.children||treeOpts.childrenField;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(sourceData,handleSourceRow,{children:treeOpts.transform?treeOpts.mapChildrenField:childrenField});}else{sourceData.forEach(handleSourceRow);}internalData.sourceDataRowIdData=sourceRowIdData;internalData.tableSourceData=sourceData;},/**
             * 
             */analyColumnWidth(){const{tableFullColumn}=internalData;const columnOpts=computeColumnOpts.value;const{width:defaultWidth,minWidth:defaultMinWidth}=columnOpts;const resizeList=[];const pxList=[];const pxMinList=[];const autoMinList=[];const scaleList=[];const scaleMinList=[];const autoList=[];const remainList=[];tableFullColumn.forEach(column=>{if(defaultWidth&&!column.width){column.width=defaultWidth;}if(defaultMinWidth&&!column.minWidth){column.minWidth=defaultMinWidth;}if(column.visible){if(column.resizeWidth){resizeList.push(column);}else if(column.width==='auto'){autoList.push(column);}else if(isPx(column.width)){pxList.push(column);}else if(isScale(column.width)){scaleList.push(column);}else if(isPx(column.minWidth)){pxMinList.push(column);}else if(column.minWidth==='auto'){autoMinList.push(column);}else if(isScale(column.minWidth)){scaleMinList.push(column);}else{remainList.push(column);}}});Object.assign(reactData.columnStore,{resizeList,pxList,pxMinList,autoMinList,scaleList,scaleMinList,autoList,remainList});},handleColResizeMousedownEvent(evnt,fixedType,params){evnt.stopPropagation();evnt.preventDefault();const{column}=params;const{columnStore,overflowX,scrollbarHeight}=reactData;const{visibleColumn}=internalData;const{leftList,rightList}=columnStore;const resizableOpts=computeResizableOpts.value;const osbHeight=overflowX?scrollbarHeight:0;const tableEl=refElem.value;const leftContainerElem=refLeftContainer.value;const rightContainerElem=refRightContainer.value;const resizeBarElem=refColResizeBar.value;if(!resizeBarElem){return;}const isLeftFixed=fixedType==='left';const isRightFixed=fixedType==='right';const resizeTipElem=resizeBarElem.firstElementChild;const scrollbarXToTop=computeScrollbarXToTop.value;const{clientX:dragClientX}=evnt;const dragBtnElem=evnt.target;let cell=dragBtnElem.parentElement;let resizeColumn=column;const isDragGroupCol=column.children&&column.children.length;if(isDragGroupCol){resizeColumn=getLastChildColumn(column);if(isDragGroupCol){const trEl=cell?cell.parentElement:null;const theadEl=trEl?trEl.parentElement:null;cell=theadEl?theadEl.querySelector(`.vxe-header--column[colid="${resizeColumn.id}"]`):null;}}if(!cell){return;}const cellParams=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(params,{cell,$table:$xeTable});let dragLeft=0;const tableRect=tableEl.getBoundingClientRect();const rightContainerRect=rightContainerElem?rightContainerElem.getBoundingClientRect():null;const cellRect=cell.getBoundingClientRect();const dragBtnRect=dragBtnElem.getBoundingClientRect();const dragBtnWidth=dragBtnElem.clientWidth;const dragBtnOffsetWidth=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(dragBtnWidth/2);const dragPosLeft=dragBtnRect.x-tableRect.x+dragBtnOffsetWidth;const minInterval=getColReMinWidth(cellParams)-dragBtnOffsetWidth;// 
const dragMinLeft=isRightFixed?0:cellRect.x-tableRect.x+dragBtnWidth+minInterval;const dragMaxLeft=cellRect.x-tableRect.x+cell.clientWidth-minInterval;let fixedLeftRemainWidth=0;let fixedRightRemainWidth=0;if(isLeftFixed||isRightFixed){let isMach=false;const fixedColumn=isLeftFixed?leftList:rightList;for(let i=0;i<fixedColumn.length;i++){const item=fixedColumn[i];if(isMach){fixedLeftRemainWidth+=item.renderWidth;}else{isMach=item.id===resizeColumn.id;if(!isMach){fixedRightRemainWidth+=item.renderWidth;}}}}// 
const updateEvent=evnt=>{evnt.stopPropagation();evnt.preventDefault();const tableHeight=tableEl.clientHeight;const offsetX=evnt.clientX-dragClientX;let left=dragPosLeft+offsetX;if(isLeftFixed){if(rightContainerRect){left=Math.min(left,rightContainerRect.x-tableRect.x-fixedLeftRemainWidth-minInterval);}}else if(isRightFixed){if(leftContainerElem){left=Math.max(left,leftContainerElem.clientWidth+fixedRightRemainWidth+minInterval);}left=Math.min(left,dragMaxLeft);}dragLeft=Math.max(left,dragMinLeft);const resizeBarLeft=Math.max(1,dragLeft);resizeBarElem.style.left=`${resizeBarLeft}px`;resizeBarElem.style.top=`${scrollbarXToTop?osbHeight:0}px`;resizeBarElem.style.height=`${scrollbarXToTop?tableHeight-osbHeight:tableHeight}px`;if(resizableOpts.showDragTip&&resizeTipElem){resizeTipElem.textContent=table_getI18n('vxe.table.resizeColTip',[Math.floor(resizeColumn.renderWidth+(isRightFixed?dragPosLeft-dragLeft:dragLeft-dragPosLeft))]);const tableWrapperWidth=tableEl.clientWidth;const resizeBarWidth=resizeBarElem.clientWidth;const resizeTipWidth=resizeTipElem.clientWidth;const resizeTipHeight=resizeTipElem.clientHeight;let resizeTipLeft=-resizeTipWidth;if(resizeBarLeft<resizeTipWidth+resizeBarWidth){resizeTipLeft=0;}else if(resizeBarLeft>tableWrapperWidth){resizeTipLeft+=tableWrapperWidth-resizeBarLeft;}resizeTipElem.style.left=`${resizeTipLeft}px`;resizeTipElem.style.top=`${Math.min(tableHeight-resizeTipHeight,Math.max(0,evnt.clientY-tableRect.y-resizeTipHeight/2))}px`;}reactData.isDragResize=true;};reactData.isDragResize=true;addClass(tableEl,'col-drag--resize');resizeBarElem.style.display='block';document.onmousemove=updateEvent;document.onmouseup=function(evnt){document.onmousemove=null;document.onmouseup=null;resizeBarElem.style.display='none';internalData._lastResizeTime=Date.now();setTimeout(()=>{reactData.isDragResize=false;},50);const resizeWidth=resizeColumn.renderWidth+(isRightFixed?dragPosLeft-dragLeft:dragLeft-dragPosLeft);const resizeParams={...params,resizeWidth,resizeColumn};if(resizableOpts.dragMode==='fixed'){visibleColumn.forEach(item=>{if(item.id!==resizeColumn.id){if(!item.resizeWidth){item.resizeWidth=item.renderWidth;}}});}if($xeTable.handleColResizeCellAreaEvent){$xeTable.handleColResizeCellAreaEvent(evnt,resizeParams);}else{resizeColumn.resizeWidth=resizeWidth;handleUpdateColResize(evnt,resizeParams);}removeClass(tableEl,'col-drag--resize');};updateEvent(evnt);if($xeTable.closeMenu){$xeTable.closeMenu();}},handleColResizeDblclickEvent(evnt,params){const resizableOpts=computeResizableOpts.value;const{isDblclickAutoWidth}=resizableOpts;const el=refElem.value;if(isDblclickAutoWidth&&el){evnt.stopPropagation();evnt.preventDefault();const{fullColumnIdData}=internalData;const{column}=params;let resizeColumn=column;if(column.children&&column.children.length){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(column.children,childColumn=>{resizeColumn=childColumn;});}const colid=resizeColumn.id;const colRest=fullColumnIdData[colid];const dragBtnElem=evnt.target;const cell=dragBtnElem.parentNode;const cellParams=Object.assign(params,{cell,$table:$xeTable});const colMinWidth=getColReMinWidth(cellParams);el.setAttribute('data-calc-col','Y');let resizeWidth=calcColumnAutoWidth(resizeColumn,el);el.removeAttribute('data-calc-col');if(colRest){resizeWidth=Math.max(resizeWidth,colRest.width);}resizeWidth=Math.max(colMinWidth,resizeWidth);const resizeParams={...params,resizeWidth,resizeColumn};reactData.isDragResize=false;internalData._lastResizeTime=Date.now();if($xeTable.handleColResizeDblclickCellAreaEvent){$xeTable.handleColResizeDblclickCellAreaEvent(evnt,resizeParams);}else{resizeColumn.resizeWidth=resizeWidth;handleUpdateColResize(evnt,resizeParams);}}},handleRowResizeMousedownEvent(evnt,params){evnt.stopPropagation();evnt.preventDefault();const{row}=params;const{showOverflow}=props;const{overflowX,scrollbarWidth,overflowY,scrollbarHeight}=reactData;const{elemStore,fullAllDataRowIdData}=internalData;const osbWidth=overflowY?scrollbarWidth:0;const osbHeight=overflowX?scrollbarHeight:0;const scrollbarYToLeft=computeScrollbarYToLeft.value;const resizableOpts=computeResizableOpts.value;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;let tableEl=refElem.value;if($xeGantt){const{refGanttContainerElem}=$xeGantt.getRefMaps();const ganttContainerElem=refGanttContainerElem.value;if(ganttContainerElem){tableEl=ganttContainerElem;}}const resizeBarElem=refRowResizeBar.value;if(!resizeBarElem){return;}const{clientY:dragClientY}=evnt;const resizeTipElem=resizeBarElem.firstElementChild;const dragBtnElem=evnt.currentTarget;const tdEl=dragBtnElem.parentNode;const trEl=tdEl.parentNode;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);if(!bodyScrollElem){return;}const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];if(!rowRest){return;}const defaultRowHeight=computeDefaultRowHeight.value;let currCellHeight=rowRest.resizeHeight||cellOpts.height||rowOpts.height||rowRest.height||defaultRowHeight;if(!showOverflow){currCellHeight=tdEl.clientHeight;}const tableRect=tableEl.getBoundingClientRect();const trRect=trEl.getBoundingClientRect();const targetOffsetY=dragClientY-trRect.y-trEl.clientHeight;let resizeHeight=currCellHeight;const cellEl=tdEl.querySelector('.vxe-cell');let cellMinHeight=0;if(cellEl){const cellStyle=getComputedStyle(cellEl);cellMinHeight=Math.max(1,Math.ceil(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellStyle.paddingTop)+external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellStyle.paddingBottom)));}const minTop=trRect.y-tableRect.y+cellMinHeight;// 
const updateEvent=evnt=>{evnt.stopPropagation();evnt.preventDefault();const rtWidth=tableEl.clientWidth-osbWidth;const tableHeight=tableEl.clientHeight-osbHeight;let dragTop=evnt.clientY-tableRect.y-targetOffsetY;if(dragTop<minTop){dragTop=minTop;}else{resizeHeight=Math.max(cellMinHeight,currCellHeight+evnt.clientY-dragClientY);}resizeBarElem.style.left=`${scrollbarYToLeft?osbWidth:0}px`;resizeBarElem.style.top=`${dragTop}px`;resizeBarElem.style.width=`${rtWidth}px`;if(resizableOpts.showDragTip&&resizeTipElem){resizeTipElem.textContent=table_getI18n('vxe.table.resizeRowTip',[resizeHeight]);const resizeTipWidth=resizeTipElem.clientWidth;const resizeTipHeight=resizeTipElem.clientHeight;let resizeBarLeft=Math.max(2,evnt.clientX-tableRect.x);let resizeBarTop=0;if(resizeBarLeft+resizeTipWidth>=rtWidth-2){resizeBarLeft=rtWidth-resizeTipWidth-2;}if(dragTop+resizeTipHeight>=tableHeight){resizeBarTop=tableHeight-(dragTop+resizeTipHeight);}resizeTipElem.style.left=`${resizeBarLeft}px`;resizeTipElem.style.top=`${resizeBarTop}px`;}reactData.isDragResize=true;};reactData.isDragResize=true;addClass(tableEl,'row-drag--resize');resizeBarElem.style.display='block';document.onmousemove=updateEvent;document.onmouseup=function(evnt){document.onmousemove=null;document.onmouseup=null;resizeBarElem.style.display='none';internalData._lastResizeTime=Date.now();setTimeout(()=>{reactData.isDragResize=false;},50);if(resizeHeight!==currCellHeight){const resizeParams={...params,resizeHeight,resizeRow:row};internalData.isResizeCellHeight=true;if($xeTable.handleRowResizeCellAreaEvent){$xeTable.handleRowResizeCellAreaEvent(evnt,resizeParams);}else{rowRest.resizeHeight=resizeHeight;handleUpdateRowResize(evnt,resizeParams);updateRowOffsetTop();}}removeClass(tableEl,'row-drag--resize');};updateEvent(evnt);},handleRowResizeDblclickEvent(evnt,params){const resizableOpts=computeResizableOpts.value;const{isDblclickAutoHeight}=resizableOpts;const el=refElem.value;if(isDblclickAutoHeight&&el){evnt.stopPropagation();evnt.preventDefault();const{editStore}=reactData;const{fullAllDataRowIdData}=internalData;const{actived}=editStore;const{row}=params;const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];if(!rowRest){return;}const handleRsHeight=()=>{el.setAttribute('data-calc-row','Y');const resizeHeight=calcCellAutoHeight(rowRest,el);el.removeAttribute('data-calc-row');const resizeParams={...params,resizeHeight,resizeRow:row};reactData.isDragResize=false;internalData._lastResizeTime=Date.now();if($xeTable.handleRowResizeDblclickCellAreaEvent){$xeTable.handleRowResizeDblclickCellAreaEvent(evnt,resizeParams);}else{rowRest.resizeHeight=resizeHeight;handleUpdateRowResize(evnt,resizeParams);}};if(actived.row||actived.column){$xeTable.clearEdit().then(handleRsHeight);}else{handleRsHeight();}}},saveCustomStore(type){const{customConfig}=props;const tableId=computeTableId.value;const customOpts=computeCustomOpts.value;const{updateStore,storage,storeOptions}=customOpts;const isAllCustom=storage===true;const storageOpts=Object.assign({},isAllCustom?{}:storage||{},storeOptions);const isCustomResizable=hangleStorageDefaultValue(storageOpts.resizable,isAllCustom);const isCustomVisible=hangleStorageDefaultValue(storageOpts.visible,isAllCustom);const isCustomFixed=hangleStorageDefaultValue(storageOpts.fixed,isAllCustom);const isCustomSort=hangleStorageDefaultValue(storageOpts.sort,isAllCustom);const isCustomAggGroup=hangleStorageDefaultValue(storageOpts.aggGroup,isAllCustom);const isCustomAggFunc=hangleStorageDefaultValue(storageOpts.aggFunc,isAllCustom);if(type!=='reset'){// fix
reactData.isCustomStatus=true;}if(storage&&(customConfig?isEnableConf(customOpts):customOpts.enabled)&&(isCustomResizable||isCustomVisible||isCustomFixed||isCustomSort||isCustomAggGroup||isCustomAggFunc)){if(!tableId){errLog('vxe.error.reqProp',['id']);return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}const storeData=type==='reset'?{resizableData:{},sortData:[],visibleData:{},fixedData:{},aggGroupData:{},aggFuncData:{}}:tableMethods.getCustomStoreData();if(updateStore){return updateStore({$table:$xeTable,id:tableId,type,storeData});}else{setCustomStorageMap(tableId,type==='reset'?null:storeData);}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},handleCustom(){const{mouseConfig}=props;if(mouseConfig){if($xeTable.clearSelected){$xeTable.clearSelected();}if($xeTable.clearCellAreas){$xeTable.clearCellAreas();$xeTable.clearCopyCellArea();}}tablePrivateMethods.analyColumnWidth();return tableMethods.refreshColumn(true);},handleUpdateDataQueue(){reactData.upDataFlag++;},handleRefreshColumnQueue(){reactData.reColumnFlag++;},handleFilterOptions(column){if(column){const{filterStore}=reactData;const{filterRender,filters}=column;const filterOptions=filters||[];const compConf=isEnableConf(filterRender)?table_renderer.get(filterRender.name):null;const frMethod=column.filterRecoverMethod||(compConf?compConf.tableFilterRecoverMethod||compConf.filterRecoverMethod:null);filterStore.column=column;// 
filterOptions.forEach(option=>{const{_checked,checked}=option;option._checked=checked;if(!checked&&_checked!==checked){if(frMethod){frMethod({option,column,$table:$xeTable});}}});$xeTable.checkFilterOptions();}},preventEvent(evnt,type,args,next,end){let evntList=table_interceptor.get(type);// 
if(!evntList.length&&type==='event.clearEdit'){evntList=table_interceptor.get('event.clearActived');if(evntList.length){warnLog('vxe.error.delEvent',['event.clearActived','event.clearEdit']);}}// 
let rest=null;let isStop=false;for(let i=0;i<evntList.length;i++){const func=evntList[i];const fnRest=func(Object.assign({$table:$xeTable,$grid:$xeGrid,gantt:$xeGantt,$event:evnt},args));if(fnRest===false){isStop=true;break;}else if(fnRest&&fnRest.status===false){rest=fnRest.result;isStop=true;break;}}if(!isStop){if(next){rest=next();}}if(end){end();}return rest;},updateCheckboxStatus(){const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{afterTreeFullData,afterGroupFullData,selectCheckboxMaps,treeIndeterminateRowMaps}=internalData;const aggregateOpts=computeAggregateOpts.value;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const checkboxOpts=computeCheckboxOpts.value;const{checkField,indeterminateField,checkStrictly,checkMethod}=checkboxOpts;if(checkStrictly){return;}if(isRowGroupStatus||treeConfig){const{handleGetRowId}=createHandleGetRowId($xeTable);const childRowMaps={};const childRowList=[];if(isRowGroupStatus){// 
const mapChildrenField=aggregateOpts.mapChildrenField;if(mapChildrenField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterGroupFullData,row=>{const rowid=handleGetRowId(row);const childList=row[mapChildrenField];if(childList&&childList.length&&!childRowMaps[rowid]){childRowMaps[rowid]=1;childRowList.unshift([row,rowid,childList]);}},{children:mapChildrenField});}}else if(treeConfig){// 
const{transform,mapChildrenField}=treeOpts;external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeFullData,row=>{const rowid=handleGetRowId(row);const childList=row[transform?mapChildrenField:childrenField];if(childList&&childList.length&&!childRowMaps[rowid]){childRowMaps[rowid]=1;childRowList.unshift([row,rowid,childList]);}else{if(indeterminateField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,indeterminateField,false);}}},{children:transform?mapChildrenField:childrenField});}childRowList.forEach(vals=>{const row=vals[0];const rowid=vals[1];const childList=vals[2];let sLen=0;// 
let hLen=0;// 
let vLen=0;// 
const cLen=childList.length;// 
childList.forEach(checkMethod?item=>{const childRowid=handleGetRowId(item);const isSelect=checkField?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item,checkField):selectCheckboxMaps[childRowid];if(checkMethod({$table:$xeTable,row:item})){if(isSelect){sLen++;}else if(treeIndeterminateRowMaps[childRowid]){hLen++;}vLen++;}else{if(isSelect){sLen++;}else if(treeIndeterminateRowMaps[childRowid]){hLen++;}}}:item=>{const childRowid=handleGetRowId(item);const isSelect=checkField?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item,checkField):selectCheckboxMaps[childRowid];if(isSelect){sLen++;}else if(treeIndeterminateRowMaps[childRowid]){hLen++;}vLen++;});let isSelected=false;if(cLen>0){if(vLen>0){isSelected=(sLen>0||hLen>0)&&sLen>=vLen;}else{// 
if(sLen>0&&sLen>=vLen){isSelected=true;}else if(selectCheckboxMaps[rowid]){isSelected=true;}else{isSelected=false;}}}else{// 
isSelected=selectCheckboxMaps[rowid];}const halfSelect=!isSelected&&(sLen>0||hLen>0);if(checkField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,checkField,isSelected);}if(indeterminateField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,indeterminateField,halfSelect);}if(isSelected){if(!checkField){selectCheckboxMaps[rowid]=row;}if(treeIndeterminateRowMaps[rowid]){delete treeIndeterminateRowMaps[rowid];}}else{if(!checkField){if(selectCheckboxMaps[rowid]){delete selectCheckboxMaps[rowid];}}if(halfSelect){treeIndeterminateRowMaps[rowid]=row;}else{if(treeIndeterminateRowMaps[rowid]){delete treeIndeterminateRowMaps[rowid];}}}});}reactData.updateCheckboxFlag++;},updateAllCheckboxStatus(){const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{afterFullData,afterTreeFullData,afterGroupFullData,checkboxReserveRowMap,selectCheckboxMaps,treeIndeterminateRowMaps}=internalData;const aggregateOpts=computeAggregateOpts.value;const{mapChildrenField}=aggregateOpts;const checkboxOpts=computeCheckboxOpts.value;const{checkField,checkMethod,showReserveStatus}=checkboxOpts;const{handleGetRowId}=createHandleGetRowId($xeTable);let sLen=0;// 
let dsLen=0;// 
let hLen=0;// 
let dhLen=0;// 
let vLen=0;// 
const rootList=treeConfig?afterTreeFullData:isRowGroupStatus?afterGroupFullData:afterFullData;rootList.forEach(checkMethod?row=>{const childRowid=handleGetRowId(row);const selected=checkField?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField):selectCheckboxMaps[childRowid];if(isRowGroupStatus&&$xeTable.isAggregateRecord(row)){const childList=row[mapChildrenField||''];if(selected){vLen++;sLen++;}else if(treeIndeterminateRowMaps[childRowid]){vLen++;hLen++;}else if(childList&&childList.length&&childList.some(item=>checkMethod({$table:$xeTable,row:item}))){vLen++;}}else if(checkMethod({$table:$xeTable,row})){if(selected){sLen++;}else if(treeIndeterminateRowMaps[childRowid]){hLen++;}vLen++;}else{if(selected){dsLen++;}else if(treeIndeterminateRowMaps[childRowid]){dhLen++;}}}:row=>{const childRowid=handleGetRowId(row);const selected=checkField?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField):selectCheckboxMaps[childRowid];if(selected){sLen++;}else if(treeIndeterminateRowMaps[childRowid]){hLen++;}vLen++;});const isSelected=rootList.length>0?vLen>0?sLen>=vLen:sLen>=rootList.length:false;let halfSelect=!isSelected&&(sLen>0||hLen>0||dsLen>0||dhLen>0);// 
if(!isSelected&&!halfSelect&&showReserveStatus){halfSelect=!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEmpty(checkboxReserveRowMap);}reactData.isAllSelected=isSelected;reactData.isIndeterminate=halfSelect;},checkSelectionStatus(){$xeTable.updateCheckboxStatus();$xeTable.updateAllCheckboxStatus();},/**
             * 
             * 
             */handleBatchSelectRows(rows,checked,isForce){const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{selectCheckboxMaps}=internalData;const aggregateOpts=computeAggregateOpts.value;const treeOpts=computeTreeOpts.value;const{transform,mapChildrenField}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const checkboxOpts=computeCheckboxOpts.value;const{checkField,checkStrictly,checkMethod}=checkboxOpts;const{handleGetRowId}=createHandleGetRowId($xeTable);// indeterminateField 
const indeterminateField=checkboxOpts.indeterminateField||checkboxOpts.halfField;if(checkField){// 
if((treeConfig||isRowGroupStatus)&&!checkStrictly){// 
external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(rows,row=>{if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,checkField,checked);if(indeterminateField){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,indeterminateField,false);}handleCheckboxReserveRow(row,checked);}},{children:transform?mapChildrenField:childrenField});reactData.updateCheckboxFlag++;return;}// 
rows.forEach(row=>{if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row,checkField,checked);handleCheckboxReserveRow(row,checked);}});reactData.updateCheckboxFlag++;return;}// 
if(!checkStrictly){if(isRowGroupStatus){// 
external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(rows,row=>{const rowid=handleGetRowId(row);if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){if(checked){selectCheckboxMaps[rowid]=row;}else{if(selectCheckboxMaps[rowid]){delete selectCheckboxMaps[rowid];}}handleCheckboxReserveRow(row,checked);}},{children:aggregateOpts.mapChildrenField});reactData.updateCheckboxFlag++;return;}else if(treeConfig){// 
external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(rows,row=>{const rowid=handleGetRowId(row);if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){if(checked){selectCheckboxMaps[rowid]=row;}else{if(selectCheckboxMaps[rowid]){delete selectCheckboxMaps[rowid];}}handleCheckboxReserveRow(row,checked);}},{children:transform?mapChildrenField:childrenField});reactData.updateCheckboxFlag++;return;}}// 
rows.forEach(row=>{const rowid=handleGetRowId(row);if(isForce||!checkMethod||checkMethod({$table:$xeTable,row})){if(checked){if(!selectCheckboxMaps[rowid]){selectCheckboxMaps[rowid]=row;}}else{if(selectCheckboxMaps[rowid]){delete selectCheckboxMaps[rowid];}}handleCheckboxReserveRow(row,checked);reactData.updateCheckboxFlag++;}});},/**
             * 
             * @deprecated
             */handleSelectRow({row},checked,isForce){$xeTable.handleBatchSelectRows([row],checked,isForce);},/**
             * 
             */handleUpdateBodyMerge(){const{mergeBodyList}=internalData;internalData.mergeBodyCellMaps=buildMergeData(mergeBodyList);reactData.mergeBodyFlag++;},handleUpdateHeaderMerge(){const{mergeHeaderList}=internalData;internalData.mergeHeaderCellMaps=buildMergeData(mergeHeaderList);reactData.mergeHeadFlag++;},handleUpdateFooterMerge(){const{mergeFooterList}=internalData;internalData.mergeFooterCellMaps=buildMergeData(mergeFooterList);reactData.mergeFootFlag++;},handleAggregateSummaryData(){return updateGroupData();},triggerHeaderTitleEvent(evnt,iconParams,params){const tipContent=iconParams.content||iconParams.message;if(tipContent){const{tooltipStore}=reactData;const{column}=params;const content=getFuncText(tipContent);handleTargetEnterEvent(true);tooltipStore.row=null;tooltipStore.column=column;tooltipStore.visible=true;tooltipStore.currOpts=iconParams;(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{const $tooltip=refTooltip.value;if($tooltip&&$tooltip.open){$tooltip.open(evnt.currentTarget,content);}});}},/**
             *  tooltip 
             */triggerHeaderTooltipEvent(evnt,params){const{tooltipStore}=reactData;const headerTooltipOpts=computeHeaderTooltipOpts.value;const{column}=params;handleTargetEnterEvent(true);const titleElem=evnt.currentTarget;if(!titleElem){return;}const cWrapperEl=titleElem.parentElement;if(!cWrapperEl){return;}const cellEl=cWrapperEl.parentElement;if(!cellEl){return;}const thEl=cellEl.parentElement;if(!thEl){return;}if(tooltipStore.column!==column||!tooltipStore.visible){const ctEl=thEl.querySelector('.vxe-cell--title');handleTooltip(evnt,headerTooltipOpts,'header',thEl,(hasClass(thEl,'col--ellipsis')?ctEl:cWrapperEl)||cWrapperEl,ctEl||cellEl,params);}},/**
             *  tooltip 
             */triggerBodyTooltipEvent(evnt,params){const{editConfig}=props;const{editStore}=reactData;const{tooltipStore}=reactData;const tooltipOpts=computeTooltipOpts.value;const editOpts=computeEditOpts.value;const{actived}=editStore;const{row,column}=params;const tdEl=evnt.currentTarget;handleTargetEnterEvent(tooltipStore.column!==column||tooltipStore.row!==row);// 
if(column.editRender&&isEnableConf(editConfig)){// 
if(editOpts.mode==='row'&&actived.row===row){return;}// 
if(actived.row===row&&actived.column===column){return;}}if(tooltipStore.column!==column||tooltipStore.row!==row||!tooltipStore.visible){const ctEl=tdEl.querySelector('.vxe-cell--wrapper');let ovEl=null;let tipEl=tdEl.querySelector(column.type==='html'?'.vxe-cell--html':'.vxe-cell--label');if(column.treeNode){ovEl=tdEl.querySelector('.vxe-tree-cell');}if(!tipEl){tipEl=ctEl;}handleTooltip(evnt,tooltipOpts,'body',tdEl,ovEl||ctEl,tipEl,params);}},/**
             *  tooltip 
             */triggerFooterTooltipEvent(evnt,params){const{column}=params;const{tooltipStore}=reactData;const footerTooltipOpts=computeFooterTooltipOpts.value;const tdEl=evnt.currentTarget;handleTargetEnterEvent(tooltipStore.column!==column||!!tooltipStore.row);if(tooltipStore.column!==column||!tooltipStore.visible){const ctEl=tdEl.querySelector('.vxe-cell--wrapper');let ovEl=null;let tipEl=tdEl.querySelector(column.type==='html'?'.vxe-cell--html':'.vxe-cell--label');if(column.type==='html'){ovEl=tdEl.querySelector('.vxe-cell--html');}if(!tipEl){tipEl=ctEl;}handleTooltip(evnt,footerTooltipOpts,'footer',tdEl,ovEl||ctEl,tipEl,params);}},handleTargetLeaveEvent(){const tooltipOpts=computeTooltipOpts.value;let $tooltip=refTooltip.value;if($tooltip&&$tooltip.setActived){$tooltip.setActived(false);}if(tooltipOpts.enterable){internalData.tooltipTimeout=setTimeout(()=>{$tooltip=refTooltip.value;if($tooltip&&$tooltip.isActived&&!$tooltip.isActived()){$xeTable.closeTooltip();}},tooltipOpts.leaveDelay);}else{$xeTable.closeTooltip();}},triggerHeaderCellClickEvent(evnt,params){const{_lastResizeTime}=internalData;const sortOpts=computeSortOpts.value;const columnOpts=computeColumnOpts.value;const currentColumnOpts=computeCurrentColumnOpts.value;const{column}=params;const cell=evnt.currentTarget;const triggerResizable=_lastResizeTime&&_lastResizeTime>Date.now()-300;const triggerSort=getEventTargetNode(evnt,cell,'vxe-cell--sort').flag;const triggerFilter=getEventTargetNode(evnt,cell,'vxe-cell--filter').flag;if(sortOpts.trigger==='cell'&&!(triggerResizable||triggerSort||triggerFilter)){$xeTable.triggerSortEvent(evnt,column,getNextSortOrder(column));}dispatchEvent('header-cell-click',Object.assign({triggerResizable,triggerSort,triggerFilter,cell},params),evnt);if((columnOpts.isCurrent||props.highlightCurrentColumn)&&(!currentColumnOpts.trigger||['header','default'].includes(currentColumnOpts.trigger))){$xeTable.triggerCurrentColumnEvent(evnt,params);}},triggerHeaderCellDblclickEvent(evnt,params){dispatchEvent('header-cell-dblclick',Object.assign({cell:evnt.currentTarget},params),evnt);},/**
             * 
             * 
             * 
             */triggerCellClickEvent(evnt,params){const{treeConfig,highlightCurrentRow,highlightCurrentColumn,editConfig,aggregateConfig,rowGroupConfig}=props;const{editStore,isDragResize,expandColumn,checkboxColumn,radioColumn}=reactData;if(isDragResize){return;}const expandOpts=computeExpandOpts.value;const editOpts=computeEditOpts.value;const treeOpts=computeTreeOpts.value;const radioOpts=computeRadioOpts.value;const checkboxOpts=computeCheckboxOpts.value;const keyboardOpts=computeKeyboardOpts.value;const aggregateOpts=computeAggregateOpts.value;const rowOpts=computeRowOpts.value;const columnOpts=computeColumnOpts.value;const currentColumnOpts=computeCurrentColumnOpts.value;const{actived,focused}=editStore;const{row,column}=params;const{type,treeNode,rowGroupNode}=column;const isRadioType=type==='radio';const isCheckboxType=type==='checkbox';const isExpandType=type==='expand';const cell=evnt.currentTarget;const triggerRadio=isRadioType&&getEventTargetNode(evnt,cell,'vxe-cell--radio').flag;const triggerCheckbox=isCheckboxType&&getEventTargetNode(evnt,cell,'vxe-cell--checkbox').flag;const triggerTreeNode=treeNode&&getEventTargetNode(evnt,cell,'vxe-cell--tree-btn').flag;const triggerExpandNode=isExpandType&&getEventTargetNode(evnt,cell,'vxe-table--expanded').flag;const triggerRowGroupNode=isExpandType&&getEventTargetNode(evnt,cell,'vxe-row-group--node-btn').flag;params=Object.assign({cell,triggerRadio,triggerCheckbox,triggerTreeNode,triggerExpandNode},params);if(!triggerCheckbox&&!triggerRadio){// 
if(!triggerExpandNode&&(expandColumn&&expandOpts.trigger==='row'||isExpandType&&expandOpts.trigger==='cell')){$xeTable.triggerRowExpandEvent(evnt,params);}// 
if(treeConfig&&(treeOpts.trigger==='row'||treeNode&&treeOpts.trigger==='cell')){$xeTable.triggerTreeExpandEvent(evnt,params);}// 
if((aggregateConfig||rowGroupConfig)&&(aggregateOpts.trigger==='row'||rowGroupNode&&aggregateOpts.trigger==='cell')){$xeTable.triggerRowGroupExpandEvent(evnt,params);}}// 
if(!triggerTreeNode){if(!triggerExpandNode&&!triggerRowGroupNode){// 
if(rowOpts.isCurrent||highlightCurrentRow){if(!triggerCheckbox&&!triggerRadio){$xeTable.triggerCurrentRowEvent(evnt,params);}}// 
if((columnOpts.isCurrent||highlightCurrentColumn)&&(!currentColumnOpts.trigger||['cell','default'].includes(currentColumnOpts.trigger))){if(!triggerCheckbox&&!triggerRadio){$xeTable.triggerCurrentColumnEvent(evnt,params);}}// 
if(!triggerRadio&&(radioColumn&&radioOpts.trigger==='row'||isRadioType&&radioOpts.trigger==='cell')){$xeTable.triggerRadioRowEvent(evnt,params);}// 
if(!triggerCheckbox&&(checkboxColumn&&checkboxOpts.trigger==='row'||isCheckboxType&&checkboxOpts.trigger==='cell')){$xeTable.handleToggleCheckRowEvent(evnt,params);}}// 
if(isEnableConf(editConfig)){// 
if(keyboardOpts.arrowCursorLock&&evnt&&editOpts.mode==='cell'&&evnt.target&&/^input|textarea$/i.test(evnt.target.tagName)){focused.column=column;focused.row=row;}if(editOpts.trigger==='manual'){if(actived.args&&actived.row===row&&column!==actived.column){handleChangeCell(evnt,params);}}else if(!actived.args||row!==actived.row||column!==actived.column){if(editOpts.trigger==='click'){handleChangeCell(evnt,params);}else if(editOpts.trigger==='dblclick'){if(editOpts.mode==='row'&&actived.row===row){handleChangeCell(evnt,params);}}}}}// 
if(isEnableConf(editConfig)&&editOpts.trigger==='dblclick'){if(actived.row&&actived.column){if(editOpts.mode==='row'){if(!$xeTable.eqRow(actived.row,row)){$xeTable.handleClearEdit(evnt);}}else if(editOpts.mode==='cell'){if(!$xeTable.eqRow(actived.row,row)||actived.column.id!==column.id){$xeTable.handleClearEdit(evnt);}}}}dispatchEvent('cell-click',params,evnt);},/**
             * 
             * 
             */triggerCellDblclickEvent(evnt,params){const{editConfig}=props;const{editStore,isDragResize}=reactData;if(isDragResize){return;}const editOpts=computeEditOpts.value;const{actived}=editStore;const cell=evnt.currentTarget;params=Object.assign({cell},params);if(isEnableConf(editConfig)&&editOpts.trigger==='dblclick'){if(!actived.args||evnt.currentTarget!==actived.args.cell){if(editOpts.mode==='row'){checkValidate('blur').catch(e=>e).then(()=>{$xeTable.handleEdit(params,evnt).then(()=>checkValidate('change')).catch(e=>e);});}else if(editOpts.mode==='cell'){$xeTable.handleEdit(params,evnt).then(()=>checkValidate('change')).catch(e=>e);}}}dispatchEvent('cell-dblclick',params,evnt);},handleToggleCheckRowEvent(evnt,params){const{selectCheckboxMaps}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{checkField,trigger}=checkboxOpts;const{row}=params;if(trigger==='manual'){return;}let checked=false;if(checkField){checked=!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row,checkField);}else{checked=!selectCheckboxMaps[getRowid($xeTable,row)];}if(evnt){$xeTable.triggerCheckRowEvent(evnt,params,checked);}else{$xeTable.handleBatchSelectRows([row],checked);$xeTable.checkSelectionStatus();}},triggerCheckRowEvent(evnt,params,checked){const{treeConfig}=props;const{row}=params;const{isRowGroupStatus}=reactData;const{afterFullData}=internalData;const checkboxOpts=computeCheckboxOpts.value;const{checkMethod,trigger}=checkboxOpts;if(trigger==='manual'){return;}evnt.stopPropagation();if(checkboxOpts.isShiftKey&&evnt.shiftKey&&!(treeConfig||isRowGroupStatus)){const checkboxRecords=$xeTable.getCheckboxRecords();if(checkboxRecords.length){const firstRow=checkboxRecords[0];const _rowIndex=$xeTable.getVTRowIndex(row);const _firstRowIndex=$xeTable.getVTRowIndex(firstRow);if(_rowIndex!==_firstRowIndex){$xeTable.setAllCheckboxRow(false);const rangeRows=_rowIndex<_firstRowIndex?afterFullData.slice(_rowIndex,_firstRowIndex+1):afterFullData.slice(_firstRowIndex,_rowIndex+1);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{handleCheckedCheckboxRow(rangeRows,true,false);});dispatchEvent('checkbox-range-select',Object.assign({rangeRecords:rangeRows},params),evnt);return;}}}if(isRowGroupStatus||!checkMethod||checkMethod({$table:$xeTable,row})){$xeTable.handleBatchSelectRows([row],checked);$xeTable.checkSelectionStatus();dispatchEvent('checkbox-change',Object.assign({records:()=>$xeTable.getCheckboxRecords(),reserves:()=>$xeTable.getCheckboxReserveRecords(),indeterminates:()=>$xeTable.getCheckboxIndeterminateRecords(),checked},params),evnt);}},/**
             * 
             */triggerCheckAllEvent(evnt,value){const checkboxOpts=computeCheckboxOpts.value;const{trigger}=checkboxOpts;if(trigger==='manual'){return;}if(evnt){evnt.stopPropagation();}handleCheckAllEvent(evnt,value);},/**
             * 
             */triggerRadioRowEvent(evnt,params){const{selectRadioRow:oldValue}=reactData;const{row}=params;const radioOpts=computeRadioOpts.value;const{trigger,checkMethod}=radioOpts;if(trigger==='manual'){return;}evnt.stopPropagation();if(!checkMethod||checkMethod({$table:$xeTable,row})){let newValue=row;let isChange=oldValue!==newValue;if(isChange){handleCheckedRadioRow(newValue);}else if(!radioOpts.strict){isChange=oldValue===newValue;if(isChange){newValue=null;$xeTable.clearRadioRow();}}if(isChange){dispatchEvent('radio-change',{oldValue,newValue,...params},evnt);}}},triggerCurrentColumnEvent(evnt,params){const{currentColumn:oldValue}=reactData;const columnOpts=computeColumnOpts.value;const currentColumnOpts=computeCurrentColumnOpts.value;const beforeRowMethod=currentColumnOpts.beforeSelectMethod||columnOpts.currentMethod;const{column:newValue}=params;const{trigger}=currentColumnOpts;if(trigger==='manual'){return;}const isChange=oldValue!==newValue;if(!beforeRowMethod||beforeRowMethod({column:newValue,$table:$xeTable})){$xeTable.setCurrentColumn(newValue);if(isChange){dispatchEvent('current-column-change',{oldValue,newValue,...params},evnt);}}else{dispatchEvent('current-column-disabled',params,evnt);}},triggerCurrentRowEvent(evnt,params){const{currentRow:oldValue}=reactData;const rowOpts=computeRowOpts.value;const currentRowOpts=computeCurrentRowOpts.value;const beforeRowMethod=currentRowOpts.beforeSelectMethod||rowOpts.currentMethod;const{row:newValue}=params;const{trigger}=currentRowOpts;if(trigger==='manual'){return;}const isChange=oldValue!==newValue;if(!beforeRowMethod||beforeRowMethod({row:newValue,$table:$xeTable})){$xeTable.setCurrentRow(newValue);if(isChange){dispatchEvent('current-row-change',{oldValue,newValue,...params},evnt);// 
dispatchEvent('current-change',{oldValue,newValue,...params},evnt);}}else{dispatchEvent('current-row-disabled',params,evnt);}},/**
             * 
             */triggerRowExpandEvent(evnt,params){const{expandColumn}=reactData;const{rowExpandLazyLoadedMaps}=internalData;const expandOpts=computeExpandOpts.value;const{row}=params;const{lazy,trigger}=expandOpts;if(trigger==='manual'){return;}evnt.stopPropagation();const rowid=getRowid($xeTable,row);if(!lazy||!rowExpandLazyLoadedMaps[rowid]){const expanded=!$xeTable.isRowExpandByRow(row);const columnIndex=expandColumn?$xeTable.getColumnIndex(expandColumn):-1;const $columnIndex=expandColumn?$xeTable.getVMColumnIndex(expandColumn):-1;$xeTable.setRowExpand(row,expanded);dispatchEvent('toggle-row-expand',{expanded,column:expandColumn,columnIndex,$columnIndex,row,rowIndex:$xeTable.getRowIndex(row),$rowIndex:$xeTable.getVMRowIndex(row)},evnt);}},/**
             * 
             */triggerRowGroupExpandEvent(evnt,params){const{rowGroupExpandedMaps}=internalData;const aggregateOpts=computeAggregateOpts.value;const{row,column}=params;const{trigger}=aggregateOpts;if(trigger==='manual'){return;}evnt.stopPropagation();const rowid=getRowid($xeTable,row);const expanded=!rowGroupExpandedMaps[rowid];const columnIndex=$xeTable.getColumnIndex(column);const $columnIndex=$xeTable.getVMColumnIndex(column);$xeTable.setRowGroupExpand(row,expanded);dispatchEvent('toggle-row-group-expand',{expanded,column,columnIndex,$columnIndex,row},evnt);},/**
             * 
             */triggerTreeExpandEvent(evnt,params){const{treeExpandLazyLoadedMaps,treeEATime}=internalData;const treeOpts=computeTreeOpts.value;const{row,column}=params;const{lazy,trigger,accordion}=treeOpts;if(trigger==='manual'){return;}evnt.stopPropagation();const rowid=getRowid($xeTable,row);if(!lazy||!treeExpandLazyLoadedMaps[rowid]){const expanded=!$xeTable.isTreeExpandByRow(row);const columnIndex=$xeTable.getColumnIndex(column);const $columnIndex=$xeTable.getVMColumnIndex(column);if(treeEATime){clearTimeout(treeEATime);}$xeTable.setTreeExpand(row,expanded).then(()=>{if(accordion){internalData.treeEATime=setTimeout(()=>{internalData.treeEATime=undefined;$xeTable.scrollToRow(row);},30);}});dispatchEvent('toggle-tree-expand',{expanded,column,columnIndex,$columnIndex,row},evnt);}},handleColumnSortEvent(evnt,column){const{mouseConfig}=props;const mouseOpts=computeMouseOpts.value;const{field,sortable,order}=column;if(sortable){const params={$table:$xeTable,$event:evnt,column,field,property:field,order,sortList:tableMethods.getSortColumns(),sortTime:column.sortTime};if(mouseConfig&&mouseOpts.area&&$xeTable.handleSortEvent){$xeTable.handleSortEvent(evnt,params);}if(!order){dispatchEvent('clear-sort',params,evnt);}dispatchEvent('sort-change',params,evnt);}},/**
             * 
             */triggerSortEvent(evnt,column,order){const sortOpts=computeSortOpts.value;const{multiple,allowClear}=sortOpts;const{field,sortable}=column;if(sortable){if(!order||column.order===order){if(allowClear){$xeTable.clearSort(multiple?column:null);}}else{$xeTable.sort({field,order});}$xeTable.handleColumnSortEvent(evnt,column);}},handleCellRuleUpdateStatus(type,cellParams,cellValue){const{validStore}=reactData;const{row,column}=cellParams;if($xeTable.hasCellRules){if($xeTable.hasCellRules(type,row,column)){const cell=$xeTable.getCellElement(row,column);if(cell){const customVal=!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(cellValue);return $xeTable.validCellRules(type,row,column,cellValue).then(()=>{if(customVal&&validStore.visible){setCellValue(row,column,cellValue);}$xeTable.clearValidate(row,column);}).catch(({rule})=>{if(customVal){setCellValue(row,column,cellValue);}$xeTable.showValidTooltip({rule,row,column,cell});});}}}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();},/**
             * 
             */triggerHeaderCellMousedownEvent(evnt,params){const{mouseConfig}=props;const mouseOpts=computeMouseOpts.value;const columnOpts=computeColumnOpts.value;const columnDragOpts=computeColumnDragOpts.value;const{trigger,isCrossDrag,isPeerDrag,disabledMethod}=columnDragOpts;const cell=evnt.currentTarget;const triggerInput=cell&&cell.tagName&&cell.tagName.toLowerCase()==='input';const triggerCheckbox=getEventTargetNode(evnt,cell,'vxe-cell--checkbox').flag;const triggerSort=getEventTargetNode(evnt,cell,'vxe-cell--sort').flag;const triggerFilter=getEventTargetNode(evnt,cell,'vxe-cell--filter').flag;let triggerDrag=false;const isColDragCell=columnOpts.drag&&trigger==='cell';if(!(triggerInput||triggerCheckbox||triggerSort||triggerFilter)){const{column}=params;if(isColDragCell&&!column.fixed&&(isCrossDrag||isPeerDrag||!column.parentId)&&!(disabledMethod&&disabledMethod(params))){triggerDrag=true;$xeTable.handleHeaderCellDragMousedownEvent(evnt,params);}}if(!triggerDrag&&mouseConfig&&mouseOpts.area&&$xeTable.handleHeaderCellAreaMouseDnEvent){$xeTable.handleHeaderCellAreaMouseDnEvent(evnt,Object.assign({cell,triggerSort,triggerFilter},params));}$xeTable.focus();if($xeTable.closeMenu){$xeTable.closeMenu();}},/**
             * 
             */triggerCellMousedownEvent(evnt,params){const{column}=params;const{type,treeNode}=column;const isRadioType=type==='radio';const isCheckboxType=type==='checkbox';const isExpandType=type==='expand';const rowOpts=computeRowOpts.value;const rowDragOpts=computeRowDragOpts.value;const{trigger,isCrossDrag,isPeerDrag,disabledMethod}=rowDragOpts;const cell=evnt.currentTarget;params.cell=cell;const triggerInput=cell&&cell.tagName&&cell.tagName.toLowerCase()==='input';const triggerRadio=isRadioType&&getEventTargetNode(evnt,cell,'vxe-cell--radio').flag;const triggerCheckbox=isCheckboxType&&getEventTargetNode(evnt,cell,'vxe-cell--checkbox').flag;const triggerTreeNode=treeNode&&getEventTargetNode(evnt,cell,'vxe-cell--tree-btn').flag;const triggerExpandNode=isExpandType&&getEventTargetNode(evnt,cell,'vxe-table--expanded').flag;let isColDragCell=false;if(rowOpts.drag){isColDragCell=trigger==='row'||column.dragSort&&trigger==='cell';}let triggerDrag=false;if(!(triggerInput||triggerRadio||triggerCheckbox||triggerTreeNode||triggerExpandNode)){if(isColDragCell&&(isCrossDrag||isPeerDrag||!params.level)&&!(disabledMethod&&disabledMethod(params))){triggerDrag=true;$xeTable.handleCellDragMousedownEvent(evnt,params);}}if(!triggerDrag&&$xeTable.handleCellMousedownEvent){$xeTable.handleCellMousedownEvent(evnt,params);}$xeTable.focus();$xeTable.closeFilter();if($xeTable.closeMenu){$xeTable.closeMenu();}},triggerCellMouseupEvent(){clearDragStatus();},/**
             * 
             */handleRowDragDragstartEvent(evnt){if(evnt.dataTransfer){evnt.dataTransfer.setDragImage(getTpImg(),0,0);}},handleRowDragSwapEvent(evnt,isSyncRow,dragRow,prevDragRow,prevDragPos,prevDragToChild){const{treeConfig,dragConfig}=props;const rowDragOpts=computeRowDragOpts.value;const{afterFullData,tableFullData,fullAllDataRowIdData}=internalData;const $xeGanttView=internalData.xeGanttView;const{animation,isPeerDrag,isCrossDrag,isSelfToChildDrag,dragEndMethod,dragToChildMethod}=rowDragOpts;const treeOpts=computeTreeOpts.value;const cellOpts=computeCellOpts.value;const rowOpts=computeRowOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const{transform,rowField,mapChildrenField,parentField}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;const dEndMethod=dragEndMethod||(dragConfig?dragConfig.dragEndMethod:null);const dragOffsetIndex=prevDragPos==='bottom'?1:0;const el=refElem.value;const errRest={status:false};if(!(el&&prevDragRow&&dragRow)){return Promise.resolve(errRest);}// 
if(prevDragRow!==dragRow){const dragParams={oldRow:dragRow,newRow:prevDragRow,dragRow,dragPos:prevDragPos,dragToChild:!!prevDragToChild,offsetIndex:dragOffsetIndex};const isDragToChildFlag=isSelfToChildDrag&&dragToChildMethod?dragToChildMethod(dragParams):prevDragToChild;return Promise.resolve(dEndMethod?dEndMethod(dragParams):true).then(status=>{if(!status){clearRowDragData();clearCrossTableDragStatus();return errRest;}const dragRowid=getRowid($xeTable,dragRow);const dragRowRest=fullAllDataRowIdData[dragRowid]||{};const _dragRowIndex=dragRowRest._index;let dragRowHeight=0;let dragOffsetTop=-1;if(animation){dragRowHeight=getCellRestHeight(dragRowRest,cellOpts,rowOpts,defaultRowHeight);const oldTrEl=el.querySelector(`.vxe-body--row[rowid="${dragRowid}"]`);if(oldTrEl){dragOffsetTop=oldTrEl.offsetTop;}}let oafIndex=-1;let nafIndex=-1;// 
if(treeConfig){if(transform){// 
const oldRest=dragRowRest;const newRowid=getRowid($xeTable,prevDragRow);const newRest=fullAllDataRowIdData[newRowid];if(oldRest&&newRest){const{level:oldLevel}=oldRest;const{level:newLevel}=newRest;const oldAllMaps={};external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([dragRow],item=>{oldAllMaps[getRowid($xeTable,item)]=item;},{children:mapChildrenField});let isSelfToChildStatus=false;if(oldLevel&&newLevel){// 
if(isPeerDrag&&!isCrossDrag){if(oldRest.row[parentField]!==newRest.row[parentField]){// 
return errRest;}}else{if(!isCrossDrag){return errRest;}if(oldAllMaps[newRowid]){isSelfToChildStatus=true;if(!(isCrossDrag&&isSelfToChildDrag)){if(core_.VxeUI.modal){core_.VxeUI.modal.message({status:'error',content:table_getI18n('vxe.error.treeDragChild')});}return errRest;}}}}else if(oldLevel){// 
if(!isCrossDrag){return errRest;}}else if(newLevel){// 
if(!isCrossDrag){return errRest;}if(oldAllMaps[newRowid]){isSelfToChildStatus=true;if(!(isCrossDrag&&isSelfToChildDrag)){if(core_.VxeUI.modal){core_.VxeUI.modal.message({status:'error',content:table_getI18n('vxe.error.treeDragChild')});}return errRest;}}}else{// 
}const fullList=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray(internalData.afterTreeFullData,{key:rowField,parentKey:parentField,children:mapChildrenField});// 
const otfIndex=$xeTable.findRowIndexOf(fullList,dragRow);fullList.splice(otfIndex,1);// 
const ptfIndex=$xeTable.findRowIndexOf(fullList,prevDragRow);const ntfIndex=ptfIndex+dragOffsetIndex;fullList.splice(ntfIndex,0,dragRow);// 
if(isSelfToChildStatus&&isCrossDrag&&isSelfToChildDrag){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(dragRow[childrenField],childRow=>{childRow[parentField]=dragRow[parentField];});}dragRow[parentField]=isDragToChildFlag?prevDragRow[rowField]:prevDragRow[parentField];internalData.tableFullTreeData=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(fullList,{key:rowField,parentKey:parentField,children:childrenField,mapChildren:mapChildrenField});}}}else{// 
oafIndex=$xeTable.findRowIndexOf(afterFullData,dragRow);const otfIndex=$xeTable.findRowIndexOf(tableFullData,dragRow);afterFullData.splice(oafIndex,1);tableFullData.splice(otfIndex,1);// 
const pafIndex=$xeTable.findRowIndexOf(afterFullData,prevDragRow);const ptfIndex=$xeTable.findRowIndexOf(tableFullData,prevDragRow);nafIndex=pafIndex+dragOffsetIndex;const ntfIndex=ptfIndex+dragOffsetIndex;afterFullData.splice(nafIndex,0,dragRow);tableFullData.splice(ntfIndex,0,dragRow);}clearRowDragData();clearCrossTableDragStatus();$xeTable.handleTableData(treeConfig&&transform);$xeTable.cacheRowMap(false);updateScrollYStatus();if(!(treeConfig&&transform)){$xeTable.updateAfterDataIndex();}$xeTable.checkSelectionStatus();if(reactData.scrollYLoad){$xeTable.updateScrollYSpace();}if(evnt){dispatchEvent('row-dragend',{oldRow:dragRow,newRow:prevDragRow,dragRow,dragPos:prevDragPos,dragToChild:isDragToChildFlag,offsetIndex:dragOffsetIndex,_index:{newIndex:nafIndex,oldIndex:oafIndex}},evnt);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{if(animation){const{tableData}=reactData;const dragRowRest=fullAllDataRowIdData[dragRowid];const _newRowIndex=dragRowRest._index;const firstRow=tableData[0];const firstRowRest=fullAllDataRowIdData[getRowid($xeTable,firstRow)];let wrapperEl=el;if($xeGantt&&$xeGanttView){const{refGanttContainerElem}=$xeGantt.getRefMaps();const ganttContainerElem=refGanttContainerElem.value;if(ganttContainerElem){wrapperEl=ganttContainerElem;}}if(firstRowRest){const _firstRowIndex=firstRowRest._index;const _lastRowIndex=_firstRowIndex+tableData.length;let rsIndex=-1;let reIndex=-1;let offsetRate=1;if(_dragRowIndex<_firstRowIndex){// 
rsIndex=0;reIndex=_newRowIndex-_firstRowIndex;}else if(_dragRowIndex>_lastRowIndex){// 
const $newRowIndex=dragRowRest.$index;rsIndex=$newRowIndex+1;reIndex=tableData.length;offsetRate=-1;}else{if(_newRowIndex>_dragRowIndex){// 
rsIndex=_dragRowIndex-_firstRowIndex;reIndex=rsIndex+_newRowIndex-_dragRowIndex;}else{// 
rsIndex=_newRowIndex-_firstRowIndex;reIndex=rsIndex+_dragRowIndex-_newRowIndex+1;offsetRate=-1;}}const dragRangeList=tableData.slice(rsIndex,reIndex);if(dragRangeList.length){const dtClss=[];dragRangeList.forEach(row=>{const rowid=getRowid($xeTable,row);dtClss.push(`.vxe-body--row[rowid="${rowid}"]`);if($xeGantt){dtClss.push(`.vxe-gantt-view--body-row[rowid="${rowid}"]`,`.vxe-gantt-view--chart-row[rowid="${rowid}"]`);}});const dtTrList=wrapperEl.querySelectorAll(dtClss.join(','));moveRowAnimateToTb(dtTrList,offsetRate*dragRowHeight);}}const drClss=[`.vxe-body--row[rowid="${dragRowid}"]`];if($xeGantt){drClss.push(`.vxe-gantt-view--body-row[rowid="${dragRowid}"]`,`.vxe-gantt-view--chart-row[rowid="${dragRowid}"]`);}const newDtTrList=wrapperEl.querySelectorAll(drClss.join(','));const newTrEl=newDtTrList[0];if(dragOffsetTop>-1&&newTrEl){moveRowAnimateToTb(newDtTrList,dragOffsetTop-newTrEl.offsetTop);}}updateRowOffsetTop();updateRowExpandStyle();$xeTable.updateCellAreas();$xeTable.recalculate();}).then(()=>{return{status:true};});}).catch(()=>{return errRest;});}return Promise.resolve(errRest);},handleCrossTableRowDragCancelEvent(){clearRowDragData();clearCrossTableDragStatus();},/**
             * 
             */handleCrossTableRowDragFinishEvent(evnt){const{tableData}=reactData;const{fullAllDataRowIdData}=internalData;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const rowDragOpts=computeRowDragOpts.value;const{animation,isCrossTableDrag}=rowDragOpts;const treeOpts=computeTreeOpts.value;const{mapChildrenField}=treeOpts;const el=refElem.value;if(isCrossTableDrag&&crossTableDragRowObj&&crossTableDragRowInfo){const{row:dragRow}=crossTableDragRowInfo;if(dragRow){const dragRowid=getRowid($xeTable,dragRow);const dragRowRest=fullAllDataRowIdData[dragRowid];let dragRowHeight=0;let rsIndex=-1;if(dragRowRest){if(animation){dragRowHeight=getCellRestHeight(dragRowRest,cellOpts,rowOpts,defaultRowHeight);}rsIndex=dragRowRest.$index;}const dragRangeList=rsIndex>-1&&rsIndex<tableData.length-1?tableData.slice(rsIndex+1):[];const dragList=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray([dragRow],{updated:true,children:mapChildrenField});$xeTable.remove(dragList).then(()=>{if(animation&&dragRowHeight&&dragRangeList.length){const $xeGanttView=internalData.xeGanttView;let wrapperEl=el;if($xeGantt&&$xeGanttView){const{refGanttContainerElem}=$xeGantt.getRefMaps();const ganttContainerElem=refGanttContainerElem.value;if(ganttContainerElem){wrapperEl=ganttContainerElem;}}const dtClss=[];dragRangeList.forEach(row=>{const rowid=getRowid($xeTable,row);dtClss.push(`.vxe-body--row[rowid="${rowid}"]`);if($xeGantt){dtClss.push(`.vxe-gantt-view--body-row[rowid="${rowid}"]`,`.vxe-gantt-view--chart-row[rowid="${rowid}"]`);}});const dtTrList=wrapperEl.querySelectorAll(dtClss.join(','));moveRowAnimateToTb(dtTrList,dragRowHeight);}});dispatchEvent('row-remove-dragend',{row:dragRow},evnt);clearRowDragData();clearCrossTableDragStatus();}}},/**
             * 
             */handleCrossTableRowDragoverEmptyEvent(evnt){const{tableData}=reactData;const rowDragOpts=computeRowDragOpts.value;const{isCrossTableDrag}=rowDragOpts;if(isCrossTableDrag&&crossTableDragRowObj&&!tableData.length){const{$oldTable,$newTable}=crossTableDragRowObj;if($oldTable){const oldTableReactData=$oldTable.reactData;if($oldTable.xID!==$xeTable.xID){if($newTable&&$newTable.xID!==$xeTable.xID){$newTable.hideCrossTableRowDropClearStatus();}evnt.preventDefault();$oldTable.hideCrossTableRowDropClearStatus();crossTableDragRowObj.$newTable=$xeTable;internalData.prevDragRow=null;reactData.dragTipText=oldTableReactData.dragTipText;showDropTip(evnt,evnt.currentTarget,null,true,'');}}}},/**
             * 
             */handleCrossTableRowDragInsertEvent(evnt){const{treeConfig}=props;const{prevDragRow,prevDragPos,prevDragToChild}=internalData;const rowDragOpts=computeRowDragOpts.value;const{animation,isSelfToChildDrag,isCrossTableDrag,dragEndMethod,dragToChildMethod}=rowDragOpts;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const treeOpts=computeTreeOpts.value;const{parentField,mapChildrenField}=treeOpts;const childrenField=treeOpts.children||treeOpts.childrenField;// 
if(isCrossTableDrag&&crossTableDragRowObj&&crossTableDragRowInfo){const{row:oldRow}=crossTableDragRowInfo;const{$oldTable}=crossTableDragRowObj;const el=refElem.value;if($oldTable&&oldRow){const dragRow=oldRow;let dragOffsetIndex=-1;if(prevDragRow){dragOffsetIndex=prevDragPos==='bottom'?1:0;}const dragParams={oldRow:dragRow,newRow:prevDragRow,dragRow,dragPos:prevDragPos,dragToChild:!!prevDragToChild,offsetIndex:dragOffsetIndex};const isDragToChildFlag=isSelfToChildDrag&&dragToChildMethod?dragToChildMethod(dragParams):prevDragToChild;const errRest={status:false};Promise.resolve(dragEndMethod?dragEndMethod(dragParams):true).then(status=>{if(!status){if($oldTable){if($oldTable.xID!==$xeTable.xID){$oldTable.handleCrossTableRowDragCancelEvent(evnt);}}clearRowDragData();clearCrossTableDragStatus();return errRest;}let insertRest=Promise.resolve();if(treeConfig){const dragList=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toTreeArray([dragRow],{updated:true,children:mapChildrenField});$oldTable.handleCrossTableRowDragFinishEvent(evnt);if(prevDragRow){dragRow[parentField]=prevDragRow[parentField];}else{dragRow[parentField]=null;}dragList.forEach(row=>{row[childrenField]=undefined;row[mapChildrenField]=undefined;});if(prevDragRow){if(prevDragPos==='bottom'){insertRest=$xeTable.insertNextAt(dragList,prevDragRow);}else{insertRest=$xeTable.insertAt(dragList,prevDragRow);}}else{insertRest=$xeTable.insert(dragList);}}else{$oldTable.handleCrossTableRowDragFinishEvent(evnt);if(prevDragRow){if(prevDragPos==='bottom'){insertRest=$xeTable.insertNextAt(dragRow,prevDragRow);}else{insertRest=$xeTable.insertAt(dragRow,prevDragRow);}}else{insertRest=$xeTable.insert(dragRow);}}dispatchEvent('row-insert-dragend',{oldRow,newRow:prevDragRow,dragRow,dragPos:prevDragPos,dragToChild:isDragToChildFlag,offsetIndex:dragOffsetIndex},evnt);clearRowDragData();insertRest.then(()=>{const{tableData}=reactData;const{fullAllDataRowIdData}=internalData;const oldRowid=getRowid($xeTable,dragRow);const oldRowRest=fullAllDataRowIdData[oldRowid];let dragRowHeight=0;let rsIndex=-1;if(oldRowRest){if(animation){dragRowHeight=getCellRestHeight(oldRowRest,cellOpts,rowOpts,defaultRowHeight);}rsIndex=oldRowRest.$index;}const dragRangeList=rsIndex>-1?tableData.slice(rsIndex):[];if(animation&&dragRowHeight&&dragRangeList.length){const $xeGanttView=internalData.xeGanttView;let wrapperEl=el;if($xeGantt&&$xeGanttView){const{refGanttContainerElem}=$xeGantt.getRefMaps();const ganttContainerElem=refGanttContainerElem.value;if(ganttContainerElem){wrapperEl=ganttContainerElem;}}const dtClss=[];dragRangeList.forEach(row=>{const rowid=getRowid($xeTable,row);dtClss.push(`.vxe-body--row[rowid="${rowid}"]`);if($xeGantt){dtClss.push(`.vxe-gantt-view--body-row[rowid="${rowid}"]`,`.vxe-gantt-view--chart-row[rowid="${rowid}"]`);}});const dtTrList=wrapperEl.querySelectorAll(dtClss.join(','));moveRowAnimateToTb(dtTrList,-dragRowHeight);}});});}}},hideCrossTableRowDropClearStatus(){hideDropTip();},handleRowDragDragendEvent(evnt){const{treeConfig}=props;const{fullAllDataRowIdData,prevDragToChild}=internalData;const{dragRow}=reactData;const treeOpts=computeTreeOpts.value;const{lazy}=treeOpts;const hasChildField=treeOpts.hasChild||treeOpts.hasChildField;const{prevDragRow,prevDragPos}=internalData;const rowDragOpts=computeRowDragOpts.value;const{isCrossTableDrag}=rowDragOpts;// 
if(isCrossTableDrag&&crossTableDragRowObj){const{$newTable}=crossTableDragRowObj;if($newTable&&$newTable.xID!==$xeTable.xID){$newTable.handleCrossTableRowDragInsertEvent(evnt);return;}}if(treeConfig&&lazy&&prevDragToChild){// 
const newRowid=getRowid($xeTable,prevDragRow);const rowRest=fullAllDataRowIdData[newRowid];if(prevDragRow[hasChildField]){if(rowRest&&rowRest.treeLoaded){$xeTable.handleRowDragSwapEvent(evnt,true,dragRow,prevDragRow,prevDragPos,prevDragToChild);}}else{$xeTable.handleRowDragSwapEvent(evnt,true,dragRow,prevDragRow,prevDragPos,prevDragToChild);}}else{$xeTable.handleRowDragSwapEvent(evnt,true,dragRow,prevDragRow,prevDragPos,prevDragToChild);}},handleRowDragDragoverEvent(evnt){const{treeConfig}=props;const{fullAllDataRowIdData}=internalData;const{dragRow}=reactData;const treeOpts=computeTreeOpts.value;const{lazy,transform,parentField}=treeOpts;const hasChildField=treeOpts.hasChild||treeOpts.hasChildField;const rowDragOpts=computeRowDragOpts.value;const{isPeerDrag,isCrossDrag,isToChildDrag,isCrossTableDrag}=rowDragOpts;if(!dragRow&&!(isCrossTableDrag&&(!treeConfig||isCrossDrag)&&crossTableDragRowObj)){evnt.preventDefault();return;}const isControlKey=hasControlKey(evnt);const trEl=evnt.currentTarget;const rowid=trEl.getAttribute('rowid')||'';const rest=fullAllDataRowIdData[rowid];if(rest){evnt.preventDefault();const row=rest.row;const rowid=getRowid($xeTable,row);const rowRest=fullAllDataRowIdData[rowid];const offsetY=evnt.clientY-trEl.getBoundingClientRect().y;const dragPos=offsetY<trEl.clientHeight/2?'top':'bottom';internalData.prevDragToChild=!!(treeConfig&&transform&&isCrossDrag&&isToChildDrag&&isControlKey);internalData.prevDragRow=row;internalData.prevDragPos=dragPos;// 
if(isCrossTableDrag&&(!treeConfig||isCrossDrag)&&crossTableDragRowObj){const{$oldTable,$newTable}=crossTableDragRowObj;if($oldTable){const oldTableReactData=$oldTable.reactData;if($oldTable.xID===$xeTable.xID){if($newTable){$newTable.hideCrossTableRowDropClearStatus();}reactData.isCrossDragRow=false;oldTableReactData.isCrossDragRow=false;crossTableDragRowObj.$newTable=null;}else{if($newTable&&$newTable.xID!==$xeTable.xID){$newTable.hideCrossTableRowDropClearStatus();}$oldTable.hideCrossTableRowDropClearStatus();oldTableReactData.isCrossDragRow=true;reactData.dragTipText=oldTableReactData.dragTipText;crossTableDragRowObj.$newTable=$xeTable;showDropTip(evnt,trEl,null,true,dragPos);return;}}}if($xeTable.eqRow(dragRow,row)||isControlKey&&treeConfig&&lazy&&row[hasChildField]&&rowRest&&!rowRest.treeLoaded||!isCrossDrag&&treeConfig&&transform&&(isPeerDrag?dragRow[parentField]!==row[parentField]:rest.level)){showDropTip(evnt,trEl,null,false,dragPos);return;}showDropTip(evnt,trEl,null,true,dragPos);dispatchEvent('row-dragover',{oldRow:dragRow,targetRow:row,dragPos},evnt);}},handleCellDragMousedownEvent(evnt,params){evnt.stopPropagation();const{dragConfig}=props;const rowDragOpts=computeRowDragOpts.value;const{isCrossTableDrag,trigger,dragStartMethod}=rowDragOpts;const{row}=params;const dragEl=evnt.currentTarget;const tdEl=trigger==='cell'||trigger==='row'?dragEl:dragEl.parentElement?.parentElement;const trEl=tdEl.parentElement;const dStartMethod=dragStartMethod||(dragConfig?dragConfig.dragStartMethod:null);clearRowDropOrigin();if(dStartMethod&&!dStartMethod(params)){trEl.draggable=false;reactData.dragRow=null;reactData.dragCol=null;clearCrossTableDragStatus();hideDropTip();return;}if(isCrossTableDrag){crossTableDragRowInfo.row=row;crossTableDragRowObj={$oldTable:$xeTable,$newTable:null};}reactData.dragRow=row;reactData.isCrossDragRow=false;reactData.dragCol=null;trEl.draggable=true;updateRowDropOrigin(row);updateRowDropTipContent(tdEl);dispatchEvent('row-dragstart',params,evnt);},handleCellDragMouseupEvent(){clearDragStatus();},/**
             * 
             */handleHeaderCellDragDragstartEvent(evnt){if(evnt.dataTransfer){evnt.dataTransfer.setDragImage(getTpImg(),0,0);}},handleColDragSwapColumn(){handleUpdateColumn();return parseColumns(false).then(()=>{$xeTable.updateCellAreas();$xeTable.saveCustomStore('update:sort');});},handleColDragSwapEvent(evnt,isSyncColumn,dragCol,prevDragCol,prevDragPos,prevDragToChild){const{mouseConfig}=props;const columnDragOpts=computeColumnDragOpts.value;const{animation,isPeerDrag,isCrossDrag,isSelfToChildDrag,isToChildDrag,dragEndMethod,dragToChildMethod}=columnDragOpts;const{collectColumn,fullColumnIdData}=internalData;const el=refElem.value;const dragOffsetIndex=prevDragPos==='right'?1:0;const errRest={status:false};if(!(el&&prevDragCol&&dragCol)){return Promise.resolve(errRest);}// 
if(prevDragCol!==dragCol){const dragColumn=dragCol;const newColumn=prevDragCol;const dragParams={oldColumn:dragColumn,newColumn,dragColumn,dragPos:prevDragPos,dragToChild:!!prevDragToChild,offsetIndex:dragOffsetIndex};const isDragToChildFlag=isSelfToChildDrag&&dragToChildMethod?dragToChildMethod(dragParams):prevDragToChild;return Promise.resolve(dragEndMethod?dragEndMethod(dragParams):true).then(status=>{if(!status){clearColDragData();clearCrossTableDragStatus();return errRest;}let dragTargetColumn=null;const dragAllTargetCols=[];let dragColWidth=0;if(animation){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([dragColumn],column=>{if(!dragTargetColumn&&(!column.children||!column.children.length)){dragTargetColumn=column;dragColWidth+=column.renderWidth;}dragAllTargetCols.push(column);});}if(!dragTargetColumn){dragTargetColumn=dragColumn;}const dragColRest=fullColumnIdData[dragTargetColumn.id]||{};const _dragColIndex=dragColRest._index;let dragOffsetLeft=-1;if(animation){const oldTrEl=el.querySelector(`.vxe-table--column[colid="${dragTargetColumn.id}"]`);if(oldTrEl){dragOffsetLeft=oldTrEl.offsetLeft;}}let oafIndex=-1;let nafIndex=-1;const oldAllMaps={};external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([dragColumn],column=>{oldAllMaps[column.id]=column;});let isSelfToChildStatus=false;if(dragColumn.parentId&&newColumn.parentId){// 
if(isPeerDrag&&!isCrossDrag){if(dragColumn.parentId!==newColumn.parentId){// 
return errRest;}}else{if(!isCrossDrag){return errRest;}if(oldAllMaps[newColumn.id]){isSelfToChildStatus=true;if(!(isCrossDrag&&isSelfToChildDrag)){if(core_.VxeUI.modal){core_.VxeUI.modal.message({status:'error',content:table_getI18n('vxe.error.treeDragChild')});}return errRest;}}}}else if(dragColumn.parentId){// 
if(!isCrossDrag){return errRest;}}else if(newColumn.parentId){// 
if(!isCrossDrag){return errRest;}if(oldAllMaps[newColumn.id]){isSelfToChildStatus=true;if(!(isCrossDrag&&isSelfToChildDrag)){if(core_.VxeUI.modal){core_.VxeUI.modal.message({status:'error',content:table_getI18n('vxe.error.treeDragChild')});}return errRest;}}}else{// 
}const oldewMatchRest=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(collectColumn,item=>item.id===dragColumn.id);// 
if(isSelfToChildStatus&&isCrossDrag&&isSelfToChildDrag){if(oldewMatchRest){const{items:oCols,index:oIndex}=oldewMatchRest;const childList=dragColumn.children||[];childList.forEach(column=>{column.parentId=dragColumn.parentId;});oCols.splice(oIndex,1,...childList);dragColumn.children=[];}}else{if(oldewMatchRest){const{items:oCols,index:oIndex,parent:oParent}=oldewMatchRest;oCols.splice(oIndex,1);if(!oParent){oafIndex=oIndex;}}}const newMatchRest=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(collectColumn,item=>item.id===newColumn.id);if(newMatchRest){const{items:nCols,index:nIndex,parent:nParent}=newMatchRest;// 
if(isCrossDrag&&isToChildDrag&&isDragToChildFlag){dragColumn.parentId=newColumn.id;newColumn.children=(newColumn.children||[]).concat([dragColumn]);}else{dragColumn.parentId=newColumn.parentId;nCols.splice(nIndex+dragOffsetIndex,0,dragColumn);}if(!nParent){nafIndex=nIndex;}}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn,(column,index,items,path,parentColumn)=>{if(!parentColumn){const sortIndex=index+1;column.renderSortNumber=sortIndex;}});if(mouseConfig){if($xeTable.clearSelected){$xeTable.clearSelected();}if($xeTable.clearCellAreas){$xeTable.clearCellAreas();$xeTable.clearCopyCellArea();}}clearColDragData();clearCrossTableDragStatus();if(evnt){dispatchEvent('column-dragend',{oldColumn:dragColumn,newColumn,dragColumn,dragPos:prevDragPos,dragToChild:isDragToChildFlag,offsetIndex:dragOffsetIndex,_index:{newIndex:nafIndex,oldIndex:oafIndex}},evnt);}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{if(isSyncColumn){return $xeTable.handleColDragSwapColumn();}}).then(()=>{if(animation){const{tableColumn}=reactData;const{visibleColumn,fullColumnIdData}=internalData;let dragNewColumn=null;const dragNewColMaps={};external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([dragColumn],column=>{if(!dragNewColumn&&(!column.children||!column.children.length)){dragNewColumn=column;}dragNewColMaps[column.id]=column;});if(!dragNewColumn){dragNewColumn=dragColumn;}if(dragColWidth&&dragAllTargetCols.length){const _newColIndex=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(visibleColumn,column=>!!dragNewColumn&&column.id===dragNewColumn.id);const firstCol=tableColumn[0];const firstColRest=fullColumnIdData[firstCol.id];if(firstColRest){const _firstColIndex=firstColRest._index;const _lastColIndex=_firstColIndex+tableColumn.length;let csIndex=-1;let ceIndex=-1;let offsetRate=1;if(_dragColIndex<_firstColIndex){// 
csIndex=0;ceIndex=_newColIndex-_firstColIndex;}else if(_dragColIndex>_lastColIndex){// 
const $newRowIndex=dragColRest.$index;csIndex=$newRowIndex+1;ceIndex=tableColumn.length;offsetRate=-1;}else{if(_newColIndex>_dragColIndex){// 
csIndex=_dragColIndex-_firstColIndex;ceIndex=csIndex+_newColIndex-_dragColIndex;}else{// 
csIndex=_newColIndex-_firstColIndex+1;ceIndex=csIndex+_dragColIndex-_newColIndex;offsetRate=-1;}}const dragRangeList=[];const dragRangeMaps={};for(let i=csIndex;i<ceIndex;i++){const column=tableColumn[i];if(!dragRangeMaps[column.id]&&!dragNewColMaps[column.id]){dragRangeMaps[column.id]=column;dragRangeList.push(column);}}external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([newColumn],column=>{if(!dragRangeMaps[column.id]){dragRangeMaps[column.id]=column;dragRangeList.push(column);}});if(dragRangeList.length){const dtTrList=el.querySelectorAll(dragRangeList.map(column=>`.vxe-table--column[colid="${column.id}"]`).join(','));moveColAnimateToLr(dtTrList,offsetRate*dragColWidth);}}const newTrList=el.querySelectorAll(dragAllTargetCols.map(column=>`.vxe-table--column[colid="${column.id}"]`).join(','));const newTdEl=newTrList[0];if(dragOffsetLeft>-1&&newTdEl){moveColAnimateToLr(newTrList,dragOffsetLeft-newTdEl.offsetLeft);}}}updateColumnOffsetLeft();loadScrollXData();$xeTable.updateCellAreas();return{status:true};});}).catch(()=>{return errRest;});}return Promise.resolve(errRest);},handleHeaderCellDragDragendEvent(evnt){const{dragCol}=reactData;const{prevDragCol,prevDragPos,prevDragToChild}=internalData;$xeTable.handleColDragSwapEvent(evnt,true,dragCol,prevDragCol,prevDragPos,prevDragToChild);},handleHeaderCellDragDragoverEvent(evnt){const{dragCol}=reactData;const columnDragOpts=computeColumnDragOpts.value;const{isToChildDrag,isPeerDrag,isCrossDrag}=columnDragOpts;if(!dragCol){evnt.preventDefault();return;}const isControlKey=hasControlKey(evnt);const thEl=evnt.currentTarget;const colid=thEl.getAttribute('colid');const column=$xeTable.getColumnById(colid);if(column){evnt.preventDefault();const{clientX}=evnt;const offsetX=clientX-thEl.getBoundingClientRect().x;const dragPos=offsetX<thEl.clientWidth/2?'left':'right';internalData.prevDragToChild=!!(isCrossDrag&&isToChildDrag&&isControlKey);internalData.prevDragCol=column;internalData.prevDragPos=dragPos;if(column.fixed||dragCol&&dragCol.id===column.id||!isCrossDrag&&(isPeerDrag?dragCol.parentId!==column.parentId:column.parentId)){showDropTip(evnt,null,thEl,false,dragPos);return;}showDropTip(evnt,null,thEl,true,dragPos);dispatchEvent('column-dragover',{oldColumn:dragCol,targetColumn:column,dragPos},evnt);// 
const el=refElem.value;if(!el){return;}const xHandleEl=refScrollXHandleElem.value;const tableBody=refTableBody.value;const tableBodyElem=tableBody?tableBody.$el:null;const scrollTargetEl=xHandleEl||tableBodyElem;if(scrollTargetEl){const wrapperRect=el.getBoundingClientRect();const tableWrapperWidth=el.clientWidth;const leftContainerElem=refLeftContainer.value;const leftContainerWidth=leftContainerElem?leftContainerElem.clientWidth:0;const rightContainerElem=refRightContainer.value;const rightContainerWidth=rightContainerElem?rightContainerElem.clientWidth:0;const srartX=wrapperRect.x+leftContainerWidth;const endX=wrapperRect.x+tableWrapperWidth-rightContainerWidth;const distSize=28;const startDistSize=clientX-srartX;const endDistSize=endX-clientX;if(startDistSize>0&&startDistSize<=distSize){const scrollRatio=Math.floor(tableWrapperWidth/(startDistSize>distSize/2?240:120));scrollTargetEl.scrollLeft-=scrollRatio*(distSize-startDistSize);}else if(endDistSize>0&&endDistSize<=distSize){const scrollRatio=Math.floor(tableWrapperWidth/(endDistSize>distSize/2?240:120));scrollTargetEl.scrollLeft+=scrollRatio*(distSize-endDistSize);}}}},handleHeaderCellDragMousedownEvent(evnt,params){evnt.stopPropagation();const columnDragOpts=computeColumnDragOpts.value;const{trigger,dragStartMethod}=columnDragOpts;const{column}=params;const dragEl=evnt.currentTarget;const thEl=trigger==='cell'?dragEl:dragEl.parentElement?.parentElement;clearColDropOrigin();if(dragStartMethod&&!dragStartMethod(params)){thEl.draggable=false;reactData.dragRow=null;reactData.dragCol=null;clearCrossTableDragStatus();hideDropTip();return;}reactData.dragCol=column;reactData.dragRow=null;thEl.draggable=true;clearCrossTableDragStatus();updateColDropOrigin(column);updateColDropTipContent(thEl);dispatchEvent('column-dragstart',params,evnt);},handleHeaderCellDragMouseupEvent(){clearColDropOrigin();hideDropTip();clearCrossTableDragStatus();reactData.dragRow=null;reactData.dragCol=null;},handleScrollEvent(evnt,isRollY,isRollX,scrollTop,scrollLeft,params){const{highlightHoverRow}=props;const{lastScrollLeft,lastScrollTop}=internalData;const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;if(!xHandleEl||!yHandleEl){return;}const rowOpts=computeRowOpts.value;const validTip=refValidTooltip.value;const tooltip=refTooltip.value;const bodyHeight=yHandleEl.clientHeight;const bodyWidth=xHandleEl.clientWidth;const scrollHeight=yHandleEl.scrollHeight;const scrollWidth=xHandleEl.scrollWidth;let isTop=false;let isBottom=false;let isLeft=false;let isRight=false;let direction='';let isTopBoundary=false;let isBottomBoundary=false;let isLeftBoundary=false;let isRightBoundary=false;if(isRollX){const xThreshold=computeScrollXThreshold.value;isLeft=scrollLeft<=0;if(!isLeft){isRight=scrollLeft+bodyWidth>=scrollWidth;}if(scrollLeft>lastScrollLeft){direction='right';if(scrollLeft+bodyWidth>=scrollWidth-xThreshold){isRightBoundary=true;}}else{direction='left';if(scrollLeft<=xThreshold){isLeftBoundary=true;}}$xeTable.checkScrolling();internalData.lastScrollLeft=scrollLeft;}if(isRollY){const yThreshold=computeScrollYThreshold.value;isTop=scrollTop<=1;if(!isTop){isBottom=scrollTop+bodyHeight>=scrollHeight-1;}if(scrollTop>lastScrollTop){direction='bottom';if(scrollTop+bodyHeight>=scrollHeight-yThreshold){isBottomBoundary=true;}}else{direction='top';if(scrollTop<=yThreshold){isTopBoundary=true;}}internalData.lastScrollTop=scrollTop;}reactData.lastScrollTime=Date.now();const evntParams={scrollTop,scrollLeft,bodyHeight,bodyWidth,scrollHeight,scrollWidth,isX:isRollX,isY:isRollY,isTop,isBottom,isLeft,isRight,direction,...params};updateRowExpandStyle();checkLastSyncScroll(isRollX,isRollY);if(isRollX){$xeTable.closeFilter();}if(rowOpts.isHover||highlightHoverRow){$xeTable.clearHoverRow();}if(validTip&&validTip.reactData.visible){validTip.close();}if(tooltip&&tooltip.reactData.visible){tooltip.close();}if(isBottomBoundary||isTopBoundary||isRightBoundary||isLeftBoundary){dispatchEvent('scroll-boundary',evntParams,evnt);}dispatchEvent('scroll',evntParams,evnt);},/**
             *  X 
             */triggerScrollXEvent(){const virtualXOpts=computeVirtualXOpts.value;if(virtualXOpts.immediate){loadScrollXData();}else{lazyScrollXData();}},/**
             *  Y 
             */triggerScrollYEvent(){const virtualYOpts=computeVirtualYOpts.value;if(virtualYOpts.immediate){loadScrollYData();}else{lazyScrollYData();}},triggerBodyScrollEvent(evnt,fixedType){const{scrollYLoad,scrollXLoad}=reactData;const{elemStore,intoRunScroll,lastScrollTop,lastScrollLeft,inWheelScroll,inVirtualScroll,inHeaderScroll,inBodyScroll,scrollRenderType,inFooterScroll}=internalData;if(inWheelScroll||inVirtualScroll||inHeaderScroll||inFooterScroll){return;}const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);const rowExpandEl=refRowExpandElem.value;if(intoRunScroll){return;}if(!bodyScrollElem){return;}if(!xHandleEl){return;}if(!yHandleEl){return;}if(inBodyScroll){if(scrollRenderType!==fixedType){return;}}let scrollTop=yHandleEl.scrollTop;let scrollLeft=xHandleEl.scrollLeft;if(leftScrollElem&&fixedType==='left'){scrollTop=leftScrollElem.scrollTop;}else if(rightScrollElem&&fixedType==='right'){scrollTop=rightScrollElem.scrollTop;}else{scrollTop=bodyScrollElem.scrollTop;scrollLeft=bodyScrollElem.scrollLeft;}const isRollX=scrollLeft!==lastScrollLeft;const isRollY=scrollTop!==lastScrollTop;internalData.inBodyScroll=true;internalData.scrollRenderType=fixedType;if(isRollY){if(fixedType==='left'){setScrollTop(bodyScrollElem,scrollTop);setScrollTop(rightScrollElem,scrollTop);}else if(fixedType==='right'){setScrollTop(bodyScrollElem,scrollTop);setScrollTop(leftScrollElem,scrollTop);}else{setScrollTop(leftScrollElem,scrollTop);setScrollTop(rightScrollElem,scrollTop);}setScrollTop(yHandleEl,scrollTop);setScrollTop(rowExpandEl,scrollTop);syncGanttScrollTop(scrollTop);if(scrollYLoad){$xeTable.triggerScrollYEvent(evnt);}}if(isRollX){setScrollLeft(xHandleEl,scrollLeft);setScrollLeft(headerScrollElem,scrollLeft);setScrollLeft(footerScrollElem,scrollLeft);if(scrollXLoad){$xeTable.triggerScrollXEvent(evnt);}}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,scrollTop,scrollLeft,{type:'body',fixed:fixedType});},triggerHeaderScrollEvent(evnt,fixedType){const{scrollXLoad}=reactData;const{elemStore,intoRunScroll,inWheelScroll,inVirtualScroll,inBodyScroll,inFooterScroll}=internalData;if(inWheelScroll||inVirtualScroll||inBodyScroll||inFooterScroll){return;}const yHandleEl=refScrollYHandleElem.value;const xHandleEl=refScrollXHandleElem.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);if(intoRunScroll){return;}if(!headerScrollElem){return;}if(!xHandleEl){return;}if(!yHandleEl){return;}const scrollTop=yHandleEl.scrollTop;const scrollLeft=headerScrollElem.scrollLeft;const isRollX=true;const isRollY=false;internalData.inHeaderScroll=true;setScrollLeft(xHandleEl,scrollLeft);setScrollLeft(footerScrollElem,scrollLeft);setScrollLeft(bodyScrollElem,scrollLeft);if(scrollXLoad){$xeTable.triggerScrollXEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,scrollTop,scrollLeft,{type:'header',fixed:fixedType});},triggerFooterScrollEvent(evnt,fixedType){const{scrollXLoad}=reactData;const{elemStore,intoRunScroll,inWheelScroll,inVirtualScroll,inHeaderScroll,inBodyScroll}=internalData;if(inWheelScroll||inVirtualScroll||inHeaderScroll||inBodyScroll){return;}const yHandleEl=refScrollYHandleElem.value;const xHandleEl=refScrollXHandleElem.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);if(intoRunScroll){return;}if(!footerScrollElem){return;}if(!xHandleEl){return;}if(!yHandleEl){return;}const scrollTop=yHandleEl.scrollTop;const scrollLeft=footerScrollElem.scrollLeft;const isRollX=true;const isRollY=false;internalData.inFooterScroll=true;setScrollLeft(xHandleEl,scrollLeft);setScrollLeft(headerScrollElem,scrollLeft);setScrollLeft(bodyScrollElem,scrollLeft);if(scrollXLoad){$xeTable.triggerScrollXEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,scrollTop,scrollLeft,{type:'footer',fixed:fixedType});},triggerBodyWheelEvent(evnt){const{target,deltaY,deltaX,shiftKey}=evnt;if(target&&/^textarea$/i.test(target.tagName)){return;}// 
if(!deltaY&&!deltaX){return;}const{highlightHoverRow}=tableProps;const{scrollXLoad,scrollYLoad,expandColumn}=reactData;const leftFixedWidth=computeLeftFixedWidth.value;const rightFixedWidth=computeRightFixedWidth.value;const{elemStore,lastScrollTop,lastScrollLeft}=internalData;const rowOpts=computeRowOpts.value;const scrollbarXOpts=computeScrollbarXOpts.value;const scrollbarYOpts=computeScrollbarYOpts.value;const xHandleEl=refScrollXHandleElem.value;const yHandleEl=refScrollYHandleElem.value;const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);const rowExpandEl=refRowExpandElem.value;if(!bodyScrollElem){return;}const wheelSpeed=getWheelSpeed(reactData.lastScrollTime);const deltaTop=shiftKey?0:deltaY*wheelSpeed;const deltaLeft=(shiftKey?deltaX||deltaY:deltaX)*wheelSpeed;const currScrollTop=bodyScrollElem.scrollTop;const currScrollLeft=bodyScrollElem.scrollLeft;const scrollTop=currScrollTop+deltaTop;const scrollLeft=currScrollLeft+deltaLeft;const isRollX=scrollLeft!==lastScrollLeft;const isRollY=scrollTop!==lastScrollTop;if(isRollX){// 
if(scrollbarXOpts.visible==='hidden'){evnt.preventDefault();return;}}if(isRollY){// 
if(scrollbarYOpts.visible==='hidden'){evnt.preventDefault();return;}const isTopWheel=deltaTop<0;// 
if(isTopWheel?currScrollTop<=0:currScrollTop>=bodyScrollElem.scrollHeight-bodyScrollElem.clientHeight){return;}}// 
if($xeParentTable){if(isRollY){if(checkTargetElement(evnt.target,[leftScrollElem,bodyScrollElem,rightScrollElem],evnt.currentTarget)){evnt.stopPropagation();return;}}if(isRollX){if(checkTargetElement(evnt.target,[headerScrollElem,bodyScrollElem,footerScrollElem],evnt.currentTarget)){evnt.stopPropagation();return;}}}if(!(leftFixedWidth||rightFixedWidth||expandColumn)){return;}if(rowOpts.isHover||highlightHoverRow){$xeTable.clearHoverRow();}// 
if(isRollX){evnt.preventDefault();internalData.inWheelScroll=true;if(browseObj.firefox||browseObj.safari){const currLeftNum=scrollLeft;setScrollLeft(xHandleEl,currLeftNum);setScrollLeft(bodyScrollElem,currLeftNum);setScrollLeft(headerScrollElem,currLeftNum);setScrollLeft(footerScrollElem,currLeftNum);if(scrollXLoad){$xeTable.triggerScrollXEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,bodyScrollElem.scrollTop,currLeftNum,{type:'table',fixed:''});}else{wheelScrollLeftTo(scrollLeft,offsetLeft=>{internalData.inWheelScroll=true;const currLeftNum=offsetLeft;setScrollLeft(xHandleEl,currLeftNum);setScrollLeft(bodyScrollElem,currLeftNum);setScrollLeft(headerScrollElem,currLeftNum);setScrollLeft(footerScrollElem,currLeftNum);if(scrollXLoad){$xeTable.triggerScrollXEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,bodyScrollElem.scrollTop,currLeftNum,{type:'table',fixed:''});});}}if(isRollY){evnt.preventDefault();internalData.inWheelScroll=true;if(browseObj.firefox||browseObj.safari){const currTopNum=scrollTop;setScrollTop(yHandleEl,currTopNum);setScrollTop(bodyScrollElem,currTopNum);setScrollTop(leftScrollElem,currTopNum);setScrollTop(rightScrollElem,currTopNum);setScrollTop(rowExpandEl,currTopNum);syncGanttScrollTop(currTopNum);if(scrollYLoad){$xeTable.triggerScrollYEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,currTopNum,bodyScrollElem.scrollLeft,{type:'table',fixed:''});}else{wheelScrollTopTo(scrollTop-currScrollTop,offsetTop=>{internalData.inWheelScroll=true;const currTopNum=bodyScrollElem.scrollTop+offsetTop;setScrollTop(yHandleEl,currTopNum);setScrollTop(bodyScrollElem,currTopNum);setScrollTop(leftScrollElem,currTopNum);setScrollTop(rightScrollElem,currTopNum);setScrollTop(rowExpandEl,currTopNum);syncGanttScrollTop(currTopNum);if(scrollYLoad){$xeTable.triggerScrollYEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,currTopNum,bodyScrollElem.scrollLeft,{type:'table',fixed:''});});}}},triggerVirtualScrollXEvent(evnt){const{scrollXLoad}=reactData;const{elemStore,inWheelScroll,lastScrollTop,inHeaderScroll,inBodyScroll,inFooterScroll}=internalData;if(inHeaderScroll||inBodyScroll||inFooterScroll){return;}if(inWheelScroll){return;}const headerScrollElem=getRefElem(elemStore['main-header-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const footerScrollElem=getRefElem(elemStore['main-footer-scroll']);const yHandleEl=refScrollYHandleElem.value;const wrapperEl=evnt.currentTarget;const{scrollLeft}=wrapperEl;const yBodyEl=yHandleEl||bodyScrollElem;let scrollTop=0;if(yBodyEl){scrollTop=yBodyEl.scrollTop;}const isRollX=true;const isRollY=scrollTop!==lastScrollTop;internalData.inVirtualScroll=true;setScrollLeft(bodyScrollElem,scrollLeft);setScrollLeft(headerScrollElem,scrollLeft);setScrollLeft(footerScrollElem,scrollLeft);if(scrollXLoad){$xeTable.triggerScrollXEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,scrollTop,scrollLeft,{type:'table',fixed:''});},triggerVirtualScrollYEvent(evnt){const{scrollYLoad}=reactData;const{elemStore,inWheelScroll,lastScrollLeft,inHeaderScroll,inBodyScroll,inFooterScroll}=internalData;if(inHeaderScroll||inBodyScroll||inFooterScroll){return;}if(inWheelScroll){return;}const leftScrollElem=getRefElem(elemStore['left-body-scroll']);const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const rightScrollElem=getRefElem(elemStore['right-body-scroll']);const rowExpandEl=refRowExpandElem.value;const xHandleEl=refScrollXHandleElem.value;const wrapperEl=evnt.currentTarget;const{scrollTop}=wrapperEl;const xBodyEl=xHandleEl||bodyScrollElem;let scrollLeft=0;if(xBodyEl){scrollLeft=xBodyEl.scrollLeft;}const isRollX=scrollLeft!==lastScrollLeft;const isRollY=true;internalData.inVirtualScroll=true;setScrollTop(bodyScrollElem,scrollTop);setScrollTop(leftScrollElem,scrollTop);setScrollTop(rightScrollElem,scrollTop);setScrollTop(rowExpandEl,scrollTop);syncGanttScrollTop(scrollTop);if(scrollYLoad){$xeTable.triggerScrollYEvent(evnt);}$xeTable.handleScrollEvent(evnt,isRollY,isRollX,scrollTop,scrollLeft,{type:'table',fixed:''});},/**
             * 
             * 
             * @param {Row} row 
             */scrollToTreeRow(row){const{treeConfig}=props;const{isRowGroupStatus}=reactData;const{tableFullData}=internalData;const rests=[];if(treeConfig||isRowGroupStatus){const aggregateOpts=computeAggregateOpts.value;const treeOpts=computeTreeOpts.value;const childrenField=treeOpts.children||treeOpts.childrenField;const matchObj=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullData,item=>$xeTable.eqRow(item,row),{children:isRowGroupStatus?aggregateOpts.mapChildrenField:childrenField});if(matchObj){const nodes=matchObj.nodes;nodes.forEach((row,index)=>{if(index<nodes.length-1&&!$xeTable.isTreeExpandByRow(row)){rests.push($xeTable.setTreeExpand(row,true));}});}}return Promise.all(rests).then(()=>rowToVisible($xeTable,row));},updateScrollYStatus,//  X 
updateScrollXSpace(){const{scrollXLoad,overflowX,scrollXWidth}=reactData;const{visibleColumn,scrollXStore,elemStore,fullColumnIdData}=internalData;const $xeGanttView=internalData.xeGanttView;const mouseOpts=computeMouseOpts.value;const tableBody=refTableBody.value;const tableBodyElem=tableBody?tableBody.$el:null;if(tableBodyElem){const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const bodyTableElem=getRefElem(elemStore['main-body-table']);const headerTableElem=getRefElem(elemStore['main-header-table']);const footerTableElem=getRefElem(elemStore['main-footer-table']);let xSpaceLeft=0;const firstColumn=visibleColumn[scrollXStore.startIndex];if(firstColumn){const colRest=fullColumnIdData[firstColumn.id]||{};xSpaceLeft=colRest.oLeft;}let clientWidth=0;if(bodyScrollElem){clientWidth=bodyScrollElem.clientWidth;}// 
let isScrollXBig=false;let ySpaceWidth=scrollXWidth;if(scrollXWidth>maxXWidth){// 
if(bodyScrollElem&&bodyTableElem&&bodyScrollElem.scrollLeft+clientWidth>=maxXWidth){xSpaceLeft=maxXWidth-bodyTableElem.clientWidth;}else{xSpaceLeft=(maxXWidth-clientWidth)*(xSpaceLeft/(scrollXWidth-clientWidth));}ySpaceWidth=maxXWidth;isScrollXBig=true;}if(!(scrollXLoad&&overflowX)){xSpaceLeft=0;}if(table_getConfig().scrollMarginStyle){// 
if(headerTableElem){headerTableElem.style.marginLeft=headerTableElem.getAttribute('xvm')?`${xSpaceLeft}px`:'';}if(bodyTableElem){bodyTableElem.style.marginLeft=`${xSpaceLeft}px`;}if(footerTableElem){footerTableElem.style.marginLeft=footerTableElem.getAttribute('xvm')?`${xSpaceLeft}px`:'';}}else{if(headerTableElem){headerTableElem.style.transform=headerTableElem.getAttribute('xvm')?`translate(${xSpaceLeft}px, 0px)`:'';}if(bodyTableElem){bodyTableElem.style.transform=`translate(${xSpaceLeft}px, ${reactData.scrollYTop||0}px)`;}if(footerTableElem){footerTableElem.style.transform=footerTableElem.getAttribute('xvm')?`translate(${xSpaceLeft}px, 0px)`:'';}}const containerList=['main'];containerList.forEach(name=>{const layoutList=['header','body','footer'];layoutList.forEach(layout=>{const xSpaceElem=getRefElem(elemStore[`${name}-${layout}-xSpace`]);if(xSpaceElem){xSpaceElem.style.width=scrollXLoad?`${ySpaceWidth}px`:'';}});});reactData.scrollXLeft=xSpaceLeft;reactData.scrollXWidth=ySpaceWidth;reactData.isScrollXBig=isScrollXBig;const scrollXSpaceEl=refScrollXSpaceElem.value;if(scrollXSpaceEl){scrollXSpaceEl.style.width=`${ySpaceWidth}px`;}calcScrollbar();if(isScrollXBig&&mouseOpts.area){errLog('vxe.error.notProp',['mouse-config.area']);}if($xeGanttView&&$xeGanttView.handleUpdateSXSpace){$xeGanttView.handleUpdateSXSpace();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateStyle();});}},//  Y 
updateScrollYSpace(){const{isAllOverflow,overflowY,scrollYLoad,scrollYHeight,expandColumn}=reactData;const{scrollYStore,elemStore,isResizeCellHeight,afterFullData,fullAllDataRowIdData,rowExpandedMaps}=internalData;const $xeGanttView=internalData.xeGanttView;const{startIndex}=scrollYStore;const mouseOpts=computeMouseOpts.value;const expandOpts=computeExpandOpts.value;const rowOpts=computeRowOpts.value;const cellOpts=computeCellOpts.value;const defaultRowHeight=computeDefaultRowHeight.value;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const bodyTableElem=getRefElem(elemStore['main-body-table']);const leftBodyTableElem=getRefElem(elemStore['left-body-table']);const rightbodyTableElem=getRefElem(elemStore['right-body-table']);const containerList=['main','left','right'];let ySpaceTop=0;let sYHeight=scrollYHeight;let isScrollYBig=false;if(scrollYLoad){const isCustomCellHeight=isResizeCellHeight||cellOpts.height||rowOpts.height;if(!isCustomCellHeight&&!expandColumn&&isAllOverflow){sYHeight=afterFullData.length*defaultRowHeight;if(sYHeight>maxYHeight){isScrollYBig=true;}ySpaceTop=Math.max(0,startIndex*defaultRowHeight);}else{const firstRow=afterFullData[startIndex];if(firstRow){let rowid=getRowid($xeTable,firstRow);let rowRest=fullAllDataRowIdData[rowid]||{};ySpaceTop=rowRest.oTop||0;const lastRow=afterFullData[afterFullData.length-1];rowid=getRowid($xeTable,lastRow);rowRest=fullAllDataRowIdData[rowid]||{};// 
if(rowRest.oTop){sYHeight=(rowRest.oTop||0)+(rowRest.resizeHeight||cellOpts.height||rowOpts.height||rowRest.height||defaultRowHeight);// 
if(expandColumn&&rowExpandedMaps[rowid]){sYHeight+=rowRest.expandHeight||expandOpts.height||0;}}if(sYHeight>maxYHeight){isScrollYBig=true;}}else{sYHeight=bodyTableElem?bodyTableElem.clientHeight:0;}}}else{if(bodyTableElem){sYHeight=bodyTableElem.clientHeight;}}let clientHeight=0;if(bodyScrollElem){clientHeight=bodyScrollElem.clientHeight;}// 
let ySpaceHeight=sYHeight;let scrollYTop=ySpaceTop;if(isScrollYBig){// 
if(bodyScrollElem&&bodyTableElem&&bodyScrollElem.scrollTop+clientHeight>=maxYHeight){scrollYTop=maxYHeight-bodyTableElem.clientHeight;}else{scrollYTop=(maxYHeight-clientHeight)*(ySpaceTop/(scrollYHeight-clientHeight));}ySpaceHeight=maxYHeight;}if(!(scrollYLoad&&overflowY)){scrollYTop=0;}if(table_getConfig().scrollMarginStyle){if(leftBodyTableElem){leftBodyTableElem.style.marginTop=`${scrollYTop}px`;}if(bodyTableElem){bodyTableElem.style.marginTop=`${scrollYTop}px`;}if(rightbodyTableElem){rightbodyTableElem.style.marginTop=`${scrollYTop}px`;}}else{if(leftBodyTableElem){leftBodyTableElem.style.transform=`translate(0px, ${scrollYTop}px)`;}if(bodyTableElem){bodyTableElem.style.transform=`translate(${reactData.scrollXLeft||0}px, ${scrollYTop}px)`;}if(rightbodyTableElem){rightbodyTableElem.style.transform=`translate(0px, ${scrollYTop}px)`;}}containerList.forEach(name=>{const layoutList=['header','body','footer'];layoutList.forEach(layout=>{const ySpaceElem=getRefElem(elemStore[`${name}-${layout}-ySpace`]);if(ySpaceElem){ySpaceElem.style.height=ySpaceHeight?`${ySpaceHeight}px`:'';}});});const scrollYSpaceEl=refScrollYSpaceElem.value;if(scrollYSpaceEl){scrollYSpaceEl.style.height=ySpaceHeight?`${ySpaceHeight}px`:'';}const rowExpandYSpaceEl=refRowExpandYSpaceElem.value;if(rowExpandYSpaceEl){rowExpandYSpaceEl.style.height=ySpaceHeight?`${ySpaceHeight}px`:'';}reactData.scrollYTop=scrollYTop;reactData.scrollYHeight=ySpaceHeight;reactData.isScrollYBig=isScrollYBig;calcScrollbar();if(isScrollYBig&&mouseOpts.area){errLog('vxe.error.notProp',['mouse-config.area']);}if($xeGanttView&&$xeGanttView.handleUpdateSYSpace){$xeGanttView.handleUpdateSYSpace();}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{updateStyle();});},updateScrollXData(){const{isAllOverflow}=reactData;handleTableColumn();$xeTable.updateScrollXSpace();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{handleTableColumn();$xeTable.updateScrollXSpace();if(!isAllOverflow){$xeTable.updateScrollYSpace();}});},updateScrollYData(){$xeTable.handleTableData();$xeTable.updateScrollYSpace();return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(()=>{$xeTable.handleTableData();$xeTable.updateScrollYSpace();});},/**
             * 
             */checkScrolling(){const{elemStore}=internalData;const bodyScrollElem=getRefElem(elemStore['main-body-scroll']);const leftContainerElem=refLeftContainer.value;const rightContainerElem=refRightContainer.value;const xHandleEl=refScrollXHandleElem.value;const bodtTargetEl=xHandleEl||bodyScrollElem;if(bodtTargetEl){if(leftContainerElem){if(bodtTargetEl.scrollLeft>0){addClass(leftContainerElem,'scrolling--middle');}else{removeClass(leftContainerElem,'scrolling--middle');}}if(rightContainerElem){if(bodtTargetEl.clientWidth<bodtTargetEl.scrollWidth-Math.ceil(bodtTargetEl.scrollLeft)){addClass(rightContainerElem,'scrolling--middle');}else{removeClass(rightContainerElem,'scrolling--middle');}}}},handleUpdateAggData(){return loadTableData(internalData.tableSynchData,true);},updateZindex(){if(props.zIndex){internalData.tZindex=props.zIndex;}else if(internalData.tZindex<getLastZIndex()){internalData.tZindex=nextZIndex();}},handleCheckedCheckboxRow,/**
             *  hover 
             */triggerHoverEvent(evnt,{row}){tablePrivateMethods.setHoverRow(row);},setHoverRow(row){const $xeGanttView=internalData.xeGanttView;const rowid=getRowid($xeTable,row);const el=refElem.value;tablePrivateMethods.clearHoverRow();if(el){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`.vxe-body--row[rowid="${rowid}"]`),elem=>addClass(elem,'row--hover'));}internalData.hoverRow=row;if($xeGanttView&&$xeGanttView.handleUpdateHoverRow){$xeGanttView.handleUpdateHoverRow(row);}},clearHoverRow(){const $xeGanttView=internalData.xeGanttView;const el=refElem.value;if(el){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll('.vxe-body--row.row--hover'),elem=>removeClass(elem,'row--hover'));}internalData.hoverRow=null;if($xeGanttView&&$xeGanttView.handleUpdateHoverRow){$xeGanttView.handleUpdateHoverRow();}},/**
             *  getCellElement 
             * @deprecated
             */getCell(row,column){return tableMethods.getCellElement(row,column);},findRowIndexOf(list,row){return row?external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(list,item=>$xeTable.eqRow(item,row)):-1;},eqRow(row1,row2){if(row1&&row2){if(row1===row2){return true;}return getRowid($xeTable,row1)===getRowid($xeTable,row2);}return false;},handleConnectGanttView($ganttView){if($ganttView&&$ganttView.connectUpdate){$ganttView.connectUpdate({$table:$xeTable});internalData.xeGanttView=$ganttView;}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();}};// 
// 'openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print'.split(',').forEach(name => {
//   ($xeTable as any)[name] = function () {
//     errLog('vxe.error.reqModule', ['Export'])
//   }
// })
// 'clearValidate,fullValidate,validate'.split(',').forEach(name => {
//   ($xeTable as any)[name] = function () {
//     errLog('vxe.error.reqModule', ['Validator'])
//   }
// })
Object.assign($xeTable,tableMethods,tablePrivateMethods);/**
         * 
         * 
         * 
         * @param {String} fixedType 
         */const renderViewFixed=fixedType=>{const{showHeader,showFooter}=props;const{tableData,tableColumn,tableGroupColumn,columnStore,footerTableData}=reactData;const scrollbarOpts=computeScrollbarOpts.value;const scrollbarXOpts=computeScrollbarXOpts.value;const scrollbarYOpts=computeScrollbarYOpts.value;const{overscrollBehavior:overscrollXBehavior}=scrollbarXOpts;const{overscrollBehavior:overscrollYBehavior}=scrollbarYOpts;const isFixedLeft=fixedType==='left';const fixedColumn=isFixedLeft?columnStore.leftList:columnStore.rightList;const osXBehavior=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(overscrollXBehavior)?scrollbarOpts.overscrollBehavior:overscrollXBehavior;const osYBehavior=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(overscrollYBehavior)?scrollbarOpts.overscrollBehavior:overscrollYBehavior;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:isFixedLeft?refLeftContainer:refRightContainer,class:[`vxe-table--fixed-${fixedType}-wrapper`,`sx--${scrollbarXOpts.visible}`,`sy--${scrollbarYOpts.visible}`,{[`x-ob--${osXBehavior}`]:osXBehavior,[`y-ob--${osYBehavior}`]:osYBehavior}]},[showHeader?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(header,{ref:isFixedLeft?refTableLeftHeader:refTableRightHeader,fixedType,tableData,tableColumn,tableGroupColumn,fixedColumn}):table_renderEmptyElement($xeTable),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(body,{ref:isFixedLeft?refTableLeftBody:refTableRightBody,fixedType,tableData,tableColumn,fixedColumn}),showFooter?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(footer,{ref:isFixedLeft?refTableLeftFooter:refTableRightFooter,footerTableData,tableColumn,fixedColumn,fixedType}):table_renderEmptyElement($xeTable)]);};const renderEmptyBody=()=>{const emptyOpts=computeEmptyOpts.value;const emptySlot=slots.empty;const emptyParams={$table:$xeTable,$grid:$xeGrid,gantt:$xeGantt};if(emptySlot){return emptySlot(emptyParams);}else{const compConf=emptyOpts.name?table_renderer.get(emptyOpts.name):null;const rtEmptyView=compConf?compConf.renderTableEmpty||compConf.renderTableEmptyView||compConf.renderEmpty:null;if(rtEmptyView){return getSlotVNs(rtEmptyView(emptyOpts,emptyParams));}}return getFuncText(props.emptyText)||table_getI18n('vxe.table.emptyText');};const renderDragTipContents=()=>{const{dragConfig}=props;const{dragRow,dragCol,dragTipText}=reactData;const columnDragOpts=computeColumnDragOpts.value;const rowDragOpts=computeRowDragOpts.value;const rowDragSlots=rowDragOpts.slots||{};const rTipSlot=rowDragSlots.tip||(dragConfig&&dragConfig.slots?dragConfig.slots.rowTip:null);const columnDragSlots=columnDragOpts.slots||{};const cTipSlot=columnDragSlots.tip;const dRow=dragRow||(rowDragOpts.isCrossTableDrag?crossTableDragRowInfo.row:null);if(dRow&&rTipSlot){return callSlot(rTipSlot,{row:dRow});}if(dragCol&&cTipSlot){return callSlot(cTipSlot,{column:dragCol});}return[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span',dragTipText)];};const renderDragTip=()=>{const{dragRow,dragCol}=reactData;const rowOpts=computeRowOpts.value;const columnOpts=computeColumnOpts.value;const rowDragOpts=computeRowDragOpts.value;const columnDragOpts=computeColumnDragOpts.value;const dRow=dragRow||(rowDragOpts.isCrossTableDrag?crossTableDragRowInfo.row:null);if(rowOpts.drag||columnOpts.drag){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--drag-wrapper'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refDragRowLineElem,class:['vxe-table--drag-row-line',{'is--guides':rowDragOpts.showGuidesStatus}]}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refDragColLineElem,class:['vxe-table--drag-col-line',{'is--guides':columnDragOpts.showGuidesStatus}]}),dRow&&rowDragOpts.showDragTip||dragCol&&columnDragOpts.showDragTip?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refDragTipElem,class:'vxe-table--drag-sort-tip'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--drag-sort-tip-wrapper'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--drag-sort-tip-status'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span',{class:['vxe-table--drag-sort-tip-normal-status',dRow?table_getIcon().TABLE_DRAG_STATUS_ROW:table_getIcon().TABLE_DRAG_STATUS_COLUMN]}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span',{class:['vxe-table--drag-sort-tip-sub-status',table_getIcon().TABLE_DRAG_STATUS_SUB_ROW]}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span',{class:['vxe-table--drag-sort-tip-disabled-status',table_getIcon().TABLE_DRAG_DISABLED]})]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--drag-sort-tip-content'},renderDragTipContents())])]):table_renderEmptyElement($xeTable)]);}return table_renderEmptyElement($xeTable);};const renderRowExpandedVNs=()=>{const{treeConfig}=props;const{expandColumn,isRowGroupStatus}=reactData;const tableRowExpandedList=computeTableRowExpandedList.value;const expandOpts=computeExpandOpts.value;const{mode}=expandOpts;if(mode!=='fixed'){return table_renderEmptyElement($xeTable);}const expandVNs=[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'repY',ref:refRowExpandYSpaceElem})];if(expandColumn){const{handleGetRowId}=createHandleGetRowId($xeTable);tableRowExpandedList.forEach(row=>{const expandOpts=computeExpandOpts.value;const{height:expandHeight,padding,indent}=expandOpts;const{fullAllDataRowIdData,fullColumnIdData}=internalData;const treeOpts=computeTreeOpts.value;const{transform,seqMode}=treeOpts;const cellStyle={};const rowid=handleGetRowId(row);const rowRest=fullAllDataRowIdData[rowid];const colid=expandColumn.id;const colRest=fullColumnIdData[colid]||{};let rowLevel=0;let seq=-1;let _rowIndex=-1;let rowIndex=-1;let $rowIndex=-1;if(rowRest){rowIndex=rowRest.index;$rowIndex=rowRest.$index;_rowIndex=rowRest._index;rowLevel=rowRest.level;seq=rowRest.seq;if(isRowGroupStatus||treeConfig&&transform&&seqMode==='increasing'){seq=rowRest._index+1;}else if(treeConfig&&seqMode==='fixed'){seq=rowRest._tIndex+1;}}if(expandHeight){cellStyle.height=`${expandHeight}px`;}if(isRowGroupStatus||treeConfig){cellStyle.paddingLeft=`${rowLevel*(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(indent)?indent:treeOpts.indent)+30}px`;}let columnIndex=-1;let $columnIndex=-1;let _columnIndex=-1;if(colRest){columnIndex=colRest.index;$columnIndex=colRest.$index;_columnIndex=colRest._index;}const expandParams={$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt,seq,column:expandColumn,columnIndex,$columnIndex,_columnIndex,fixed:'',source:'table',type:'body',level:rowLevel,rowid,row,rowIndex,$rowIndex,_rowIndex,isHidden:false,isEdit:false,visibleData:[],data:[],items:[]};expandVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:rowid,class:['vxe-body--row-expanded-cell',{'is--padding':padding,'is--ellipsis':expandHeight}],rowid,style:cellStyle},expandColumn.renderData(expandParams)));});}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refRowExpandElem,class:'vxe-table--row-expanded-wrapper'},expandVNs);};const renderScrollX=()=>{return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'vsx',ref:refScrollXVirtualElem,class:'vxe-table--scroll-x-virtual'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollXLeftCornerElem,class:'vxe-table--scroll-x-left-corner'}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollXWrapperElem,class:'vxe-table--scroll-x-wrapper'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollXHandleElem,class:'vxe-table--scroll-x-handle',onScroll:$xeTable.triggerVirtualScrollXEvent},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollXSpaceElem,class:'vxe-table--scroll-x-space'})]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--scroll-x-handle-appearance'})]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollXRightCornerElem,class:'vxe-table--scroll-x-right-corner'})]);};const renderScrollY=()=>{return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollYVirtualElem,class:'vxe-table--scroll-y-virtual'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollYTopCornerElem,class:'vxe-table--scroll-y-top-corner'}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollYWrapperElem,class:'vxe-table--scroll-y-wrapper'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollYHandleElem,class:'vxe-table--scroll-y-handle',onScroll:$xeTable.triggerVirtualScrollYEvent},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollYSpaceElem,class:'vxe-table--scroll-y-space'})]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--scroll-y-handle-appearance'})]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refScrollYBottomCornerElem,class:'vxe-table--scroll-y-bottom-corner'})]);};const renderViewport=()=>{const{showHeader,showFooter}=props;const{overflowX,tableData,tableColumn,tableGroupColumn,footerTableData,columnStore}=reactData;const scrollbarOpts=computeScrollbarOpts.value;const scrollbarXOpts=computeScrollbarXOpts.value;const scrollbarYOpts=computeScrollbarYOpts.value;const{overscrollBehavior:overscrollXBehavior}=scrollbarXOpts;const{overscrollBehavior:overscrollYBehavior}=scrollbarYOpts;const{leftList,rightList}=columnStore;const osXBehavior=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(overscrollXBehavior)?scrollbarOpts.overscrollBehavior:overscrollXBehavior;const osYBehavior=external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(overscrollYBehavior)?scrollbarOpts.overscrollBehavior:overscrollYBehavior;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refTableViewportElem,class:['vxe-table--viewport-wrapper',{[`x-ob--${osXBehavior}`]:osXBehavior,[`y-ob--${osYBehavior}`]:osYBehavior}]},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:['vxe-table--main-wrapper',`sx--${scrollbarXOpts.visible}`,`sy--${scrollbarYOpts.visible}`]},[/**
                     * 
                     */showHeader?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(header,{ref:refTableHeader,tableData,tableColumn,tableGroupColumn}):table_renderEmptyElement($xeTable),/**
                     * 
                     */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(body,{ref:refTableBody,tableData,tableColumn}),/**
                     * 
                     */showFooter?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(footer,{ref:refTableFooter,footerTableData,tableColumn}):table_renderEmptyElement($xeTable)]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--fixed-wrapper'},[leftList&&leftList.length&&overflowX?renderViewFixed('left'):table_renderEmptyElement($xeTable),rightList&&rightList.length&&overflowX?renderViewFixed('right'):table_renderEmptyElement($xeTable)]),renderRowExpandedVNs()]);};const renderBody=()=>{const scrollbarYToLeft=computeScrollbarYToLeft.value;return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--layout-wrapper'},scrollbarYToLeft?[renderScrollY(),renderViewport()]:[renderViewport(),renderScrollY()]);};const renderVN=()=>{const{loading,stripe,showHeader,height,treeConfig,mouseConfig,showFooter,highlightCell,highlightHoverRow,highlightHoverColumn,editConfig,editRules}=props;const{isGroup,overflowX,overflowY,scrollXLoad,scrollYLoad,tableData,initStore,isRowGroupStatus,columnStore,filterStore,customStore,tooltipStore}=reactData;const{teleportToWrapperElem,popupToWrapperElem}=internalData;const{leftList,rightList}=columnStore;const loadingSlot=slots.loading;const tipSlots={header:slots.headerTooltip||slots['header-tooltip'],body:slots.tooltip,footer:slots.footerTooltip||slots['footer-tooltip']};const currTooltipSlot=tooltipStore.visible&&tooltipStore.type?tipSlots[tooltipStore.type]:null;const rowDragOpts=computeRowDragOpts.value;const tableTipConfig=computeTableTipConfig.value;const validTipConfig=computeValidTipConfig.value;const validOpts=computeValidOpts.value;const checkboxOpts=computeCheckboxOpts.value;const treeOpts=computeTreeOpts.value;const rowOpts=computeRowOpts.value;const columnOpts=computeColumnOpts.value;const vSize=computeSize.value;const tableBorder=computeTableBorder.value;const mouseOpts=computeMouseOpts.value;const areaOpts=computeAreaOpts.value;const loadingOpts=computeLoadingOpts.value;const isContentMenu=computeIsContentMenu.value;const currLoading=reactData.isColLoading||reactData.isRowLoading||loading;const resizableOpts=computeResizableOpts.value;const isArea=mouseConfig&&mouseOpts.area;const columnDragOpts=computeColumnDragOpts.value;const scrollbarXToTop=computeScrollbarXToTop.value;const scrollbarYToLeft=computeScrollbarYToLeft.value;const{isCrossTableDrag}=rowDragOpts;const tbOns={onKeydown:keydownEvent};if(isCrossTableDrag&&!tableData.length){tbOns.onDragover=$xeTable.handleCrossTableRowDragoverEmptyEvent;}return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refElem,class:['vxe-table','vxe-table--render-default',`tid_${xID}`,`border--${tableBorder}`,`sx-pos--${scrollbarXToTop?'top':'bottom'}`,`sy-pos--${scrollbarYToLeft?'left':'right'}`,{[`size--${vSize}`]:vSize,[`valid-msg--${validOpts.msgMode}`]:!!editRules,'vxe-editable':!!editConfig,'old-cell-valid':editRules&&table_getConfig().cellVaildMode==='obsolete','cell--highlight':highlightCell,'cell--selected':mouseConfig&&mouseOpts.selected,'cell--area':isArea,'header-cell--area':isArea&&areaOpts.selectCellByHeader,'body-cell--area':isArea&&areaOpts.selectCellByBody,'row--highlight':rowOpts.isHover||highlightHoverRow,'column--highlight':columnOpts.isHover||highlightHoverColumn,'checkbox--range':checkboxOpts.range,'col--drag-cell':columnOpts.drag&&columnDragOpts.trigger==='cell','is--header':showHeader,'is--footer':showFooter,'is--group':isGroup,'is-row-group':isRowGroupStatus,'is--tree-line':treeConfig&&(treeOpts.showLine||treeOpts.line),'is--fixed-left':leftList.length,'is--fixed-right':rightList.length,'is--animat':!!props.animat,'is--round':props.round,'is--stripe':!treeConfig&&stripe,'is--loading':currLoading,'is--empty':!currLoading&&!tableData.length,'is--scroll-y':overflowY,'is--scroll-x':overflowX,'is--virtual-x':scrollXLoad,'is--virtual-y':scrollYLoad}],spellcheck:false,...tbOns},[/**
                 * 
                 */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table-slots'},slots.default?slots.default({}):[]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refVarElem,class:'vxe-table-vars'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table-var-default'}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table-var-medium'}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table-var-small'}),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table-var-mini'})]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'tw',class:'vxe-table--render-wrapper'},scrollbarXToTop?[renderScrollX(),renderBody()]:[renderBody(),renderScrollX()]),/**
                 * 
                 */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'tn',ref:refEmptyPlaceholder,class:'vxe-table--empty-place-wrapper'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--empty-placeholder'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--empty-content'},renderEmptyBody())])]),/**
                 * 
                 */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'tl',class:'vxe-table--border-line'}),/**
                 * 
                 */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'tcl',ref:refColResizeBar,class:'vxe-table--resizable-col-bar'},resizableOpts.showDragTip?[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--resizable-number-tip'})]:[]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'ttw'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport,{to:teleportToWrapperElem,disabled:!($xeGantt&&teleportToWrapperElem)},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refTeleportWrapper},[/**
                             * 
                             */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'trl',ref:refRowResizeBar,class:'vxe-table--resizable-row-bar'},resizableOpts.showDragTip?[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:'vxe-table--resizable-number-tip'})]:[]),/**
                             * 
                             */initStore.custom?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(panel,{key:'cs',ref:refTableCustom,customStore}):table_renderEmptyElement($xeTable),/**
                             * 
                             */VxeUILoadingComponent?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUILoadingComponent,{key:'lg',class:'vxe-table--loading',modelValue:currLoading,icon:loadingOpts.icon,text:loadingOpts.text},loadingSlot?{default:()=>callSlot(loadingSlot,{$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt,loading:currLoading})}:{}):loadingSlot?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{class:['vxe-loading--custom-wrapper',{'is--visible':currLoading}]},callSlot(loadingSlot,{$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt,loading:currLoading})):table_renderEmptyElement($xeTable),/**
                             * 
                             */renderDragTip()])])]),(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:'tpw'},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport,{to:popupToWrapperElem,disabled:!($xeGGWrapper&&popupToWrapperElem)},[(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{ref:refPopupWrapperElem},[/**
                             * 
                             */initStore.filter?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(filter_panel,{key:'tf',ref:refTableFilter,filterStore}):table_renderEmptyElement($xeTable),/**
                             * 
                             */isContentMenu?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(menu_panel,{key:'tm',ref:refTableMenu}):table_renderEmptyElement($xeTable)])])]),/**
                 * 
                 */initStore.import&&props.importConfig?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(import_panel,{key:'it',defaultOptions:reactData.importParams,storeData:reactData.importStore}):table_renderEmptyElement($xeTable),/**
                 * 
                 */initStore.export&&(props.exportConfig||props.printConfig)?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(export_panel,{key:'et',defaultOptions:reactData.exportParams,storeData:reactData.exportStore}):table_renderEmptyElement($xeTable),/**
                 * 
                 */VxeUITooltipComponent?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{},[/**
                         * 
                         */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUITooltipComponent,{key:'ctp',ref:refCommTooltip,isArrow:false,enterable:false}),/**
                          * 
                          */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUITooltipComponent,{key:'btp',ref:refTooltip,theme:tableTipConfig.theme,enterable:tableTipConfig.enterable,enterDelay:tableTipConfig.enterDelay,leaveDelay:tableTipConfig.leaveDelay,useHTML:tableTipConfig.useHTML,width:tableTipConfig.width,height:tableTipConfig.height,minWidth:tableTipConfig.minWidth,minHeight:tableTipConfig.minHeight,maxWidth:tableTipConfig.maxWidth,maxHeight:tableTipConfig.maxHeight},currTooltipSlot?{content:()=>{const{type,row,column,content:tooltipContent}=tooltipStore;if(currTooltipSlot){if(column&&type==='header'){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:type},currTooltipSlot({column,tooltipContent,$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt}));}if(row&&column&&type==='body'){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:type},currTooltipSlot({row,column,tooltipContent,$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt}));}if(row&&column&&type==='footer'){return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div',{key:type},currTooltipSlot({row,column,tooltipContent,$table:$xeTable,$grid:$xeGrid,$gantt:$xeGantt}));}}return table_renderEmptyElement($xeTable);}}:{}),/**
                          * 
                          */props.editRules&&validOpts.showMessage&&(validOpts.message==='default'?!height:validOpts.message==='tooltip')?(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUITooltipComponent,{key:'vtp',ref:refValidTooltip,class:[{'old-cell-valid':editRules&&table_getConfig().cellVaildMode==='obsolete'},'vxe-table--valid-error'],theme:validTipConfig.theme,enterable:validTipConfig.enterable,enterDelay:validTipConfig.enterDelay,leaveDelay:validTipConfig.leaveDelay}):table_renderEmptyElement($xeTable)]):table_renderEmptyElement($xeTable)]);};const dataFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.data?props.data.length:-1,()=>{dataFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.data,()=>{dataFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(dataFlag,()=>{const{initStatus}=internalData;const value=props.data||[];if(value&&value.length>=20000){warnLog('vxe.error.errLargeData',['loadData(data), reloadData(data)']);}loadTableData(value,true).then(()=>{const{scrollXLoad,scrollYLoad,expandColumn}=reactData;const expandOpts=computeExpandOpts.value;internalData.inited=true;internalData.initStatus=true;if(!initStatus){handleLoadDefaults();}// const checkboxOpts = computeCheckboxOpts.value
// const checkboxColumn = internalData.tableFullColumn.find(column => column.type === 'checkbox')
// if (checkboxColumn && internalData.tableFullData.length > 300 && !checkboxOpts.checkField) {
//   warnLog('vxe.error.checkProp', ['checkbox-config.checkField'])
// }
if((scrollXLoad||scrollYLoad)&&expandColumn&&expandOpts.mode!=='fixed'){warnLog('vxe.error.scrollErrProp',['column.type=expand']);}return tableMethods.recalculate();});});const staticColumnFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.staticColumns.length,()=>{staticColumnFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.staticColumns,()=>{staticColumnFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(staticColumnFlag,()=>{(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>handleInitColumn(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(reactData.staticColumns)));});const tableColumnFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.tableColumn.length,()=>{tableColumnFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.tableColumn,()=>{tableColumnFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(tableColumnFlag,()=>{tablePrivateMethods.analyColumnWidth();});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.upDataFlag,()=>{(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{tableMethods.updateData();});});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.reColumnFlag,()=>{(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{tableMethods.refreshColumn();});});const reLayoutFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeSize,()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.showHeader,()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.showFooter,()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.overflowX,()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>reactData.overflowY,()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.height,()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.maxHeight,()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeScrollbarXToTop,()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeScrollbarYToLeft,()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>core_.VxeUI.getLanguage(),()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>{const scrollbarXOpts=computeScrollbarXOpts.value;return scrollbarXOpts.visible;},()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>{const scrollbarYOpts=computeScrollbarYOpts.value;return scrollbarYOpts.visible;},()=>{reLayoutFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(reLayoutFlag,()=>{$xeTable.recalculate(true);});const footFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.footerData?props.footerData.length:-1,()=>{footFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.footerData,()=>{footFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(footFlag,()=>{internalData.footerFullDataRowData={};$xeTable.updateFooter();});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.syncResize,value=>{if(value){handleUpdateResize();(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{handleUpdateResize();setTimeout(()=>handleUpdateResize());});}});const mergeCellFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.mergeCells?props.mergeCells.length:-1,()=>{mergeCellFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.mergeCells,()=>{mergeCellFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(mergeCellFlag,()=>{handleUpdateMergeBodyCells(props.mergeCells||[]);});const mergeHeaderItemFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.mergeHeaderCells?props.mergeHeaderCells.length:-1,()=>{mergeHeaderItemFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.mergeHeaderCells,()=>{mergeHeaderItemFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(mergeHeaderItemFlag,()=>{handleUpdateMergeHeaderCells(props.mergeHeaderCells||[]);});const mergeFooteCellFlag=(0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.mergeFooterCells?props.mergeFooterCells.length:-1,()=>{mergeFooteCellFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.mergeFooterCells,()=>{mergeFooteCellFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.mergeFooterItems?props.mergeFooterItems.length:-1,()=>{mergeFooteCellFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>props.mergeFooterItems,()=>{mergeFooteCellFlag.value++;});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(mergeFooteCellFlag,()=>{const mFooterCells=props.mergeFooterCells||props.mergeFooterItems;handleUpdateMergeFooterCells(mFooterCells||[]);});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeRowGroupFields,val=>{handleUpdateRowGroup(val);});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeRowField,()=>{const{inited,tableFullData}=internalData;// 
if(inited){handleKeyField();reactData.tableData=[];(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{$xeTable.reloadData(tableFullData);});}});if($xeTabs){(0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(()=>$xeTabs?$xeTabs.reactData.resizeFlag:null,()=>{handleGlobalResizeEvent();});}handleKeyField();table_hooks.forEach(options=>{const{setupTable}=options;if(setupTable){const hookRest=setupTable($xeTable);if(hookRest&&external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(hookRest)){Object.assign($xeTable,hookRest);}}});tablePrivateMethods.preventEvent(null,'created',{$table:$xeTable});let resizeObserver;(0,external_commonjs_vue_commonjs2_vue_root_Vue_.onActivated)(()=>{tableMethods.recalculate().then(()=>tableMethods.refreshScroll());tablePrivateMethods.preventEvent(null,'activated',{$table:$xeTable});});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.onDeactivated)(()=>{const{filterStore}=reactData;if(filterStore.visible){$xeTable.clearFilter();}$xeTable.closeTooltip();internalData.isActivated=false;tablePrivateMethods.preventEvent(null,'deactivated',{$table:$xeTable});});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(()=>{const columnOpts=computeColumnOpts.value;const rowOpts=computeRowOpts.value;const customOpts=computeCustomOpts.value;const aggregateOpts=computeAggregateOpts.value;const virtualYOpts=computeVirtualYOpts.value;const{groupFields}=aggregateOpts;if($xeGantt){const{refClassifyWrapperElem}=$xeGantt.getRefMaps();const classifyWrapperEl=refClassifyWrapperElem.value;if(classifyWrapperEl){internalData.teleportToWrapperElem=classifyWrapperEl;}}if($xeGGWrapper){const{refPopupContainerElem}=$xeGGWrapper.getRefMaps();const popupContainerEl=refPopupContainerElem.value;if(popupContainerEl){internalData.popupToWrapperElem=popupContainerEl;}}if(columnOpts.drag||rowOpts.drag||customOpts.allowSort){initTpImg();}handleUpdateRowGroup(groupFields);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{const{exportConfig,importConfig,treeConfig,highlightCurrentRow,highlightCurrentColumn}=props;const{scrollXStore,scrollYStore}=internalData;const editOpts=computeEditOpts.value;const treeOpts=computeTreeOpts.value;const radioOpts=computeRadioOpts.value;const checkboxOpts=computeCheckboxOpts.value;const expandOpts=computeExpandOpts.value;const rowOpts=computeRowOpts.value;const customOpts=computeCustomOpts.value;const mouseOpts=computeMouseOpts.value;const exportOpts=computeExportOpts.value;const importOpts=computeImportOpts.value;const currentRowOpts=computeCurrentRowOpts.value;const currentColumnOpts=computeCurrentColumnOpts.value;const keyboardOpts=computeKeyboardOpts.value;const aggregateOpts=computeAggregateOpts.value;const rowDragOpts=computeRowDragOpts.value;if(props.rowId){warnLog('vxe.error.delProp',['row-id','row-config.keyField']);}if(props.rowKey){warnLog('vxe.error.delProp',['row-key','row-config.useKey']);}if(props.columnKey){warnLog('vxe.error.delProp',['column-id','column-config.useKey']);}if(!(props.rowId||rowOpts.keyField)&&(checkboxOpts.reserve||checkboxOpts.checkRowKeys||radioOpts.reserve||radioOpts.checkRowKey||expandOpts.expandRowKeys||treeOpts.expandRowKeys)){warnLog('vxe.error.reqProp',['row-config.keyField']);}if(props.editConfig&&(editOpts.showStatus||editOpts.showUpdateStatus||editOpts.showInsertStatus)&&!props.keepSource){warnLog('vxe.error.reqProp',['keep-source']);}// if (treeConfig && (treeOpts.showLine || treeOpts.line) && !showOverflow) {
//   warnLog('vxe.error.reqProp', ['show-overflow'])
// }
if(treeConfig&&!treeOpts.transform&&props.stripe){warnLog('vxe.error.noTree',['stripe']);}if(props.showFooter&&!(props.footerMethod||props.footerData)){warnLog('vxe.error.reqProp',['footer-data | footer-method']);}if(rowOpts.height){warnLog('vxe.error.delProp',['row-config.height','cell-config.height']);}if(props.highlightCurrentRow){warnLog('vxe.error.delProp',['highlight-current-row','row-config.isCurrent']);}if(props.highlightHoverRow){warnLog('vxe.error.delProp',['highlight-hover-row','row-config.isHover']);}if(props.highlightCurrentColumn){warnLog('vxe.error.delProp',['highlight-current-column','column-config.isCurrent']);}if(props.highlightHoverColumn){warnLog('vxe.error.delProp',['highlight-hover-column','column-config.isHover']);}if(props.resizable){warnLog('vxe.error.delProp',['resizable','column-config.resizable']);}// if (props.virtualXConfig && props.scrollX) {
//   warnLog('vxe.error.notSupportProp', ['virtual-x-config', 'scroll-x', 'scroll-x=null'])
// }
// if (props.virtualYConfig && props.scrollY) {
//   warnLog('vxe.error.notSupportProp', ['virtual-y-config', 'scroll-y', 'scroll-y=null'])
// }
if(props.aggregateConfig&&props.rowGroupConfig){warnLog('vxe.error.notSupportProp',['aggregate-config','row-group-config','row-group-config=null']);}// if (props.scrollY) {
//   warnLog('vxe.error.delProp', ['scroll-y', 'virtual-y-config'])
// }
// if (props.scrollX) {
//   warnLog('vxe.error.delProp', ['scroll-x', 'virtual-x-config'])
// }
// 
if(importConfig&&importOpts.types&&!importOpts.importMethod&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includeArrays(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps),importOpts.types)){warnLog('vxe.error.errProp',[`export-config.types=${importOpts.types.join(',')}`,importOpts.types.filter(type=>external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps),type)).join(',')||external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(importOpts._typeMaps).join(',')]);}if(exportConfig&&exportOpts.types&&!exportOpts.exportMethod&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includeArrays(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps),exportOpts.types)){warnLog('vxe.error.errProp',[`export-config.types=${exportOpts.types.join(',')}`,exportOpts.types.filter(type=>external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps),type)).join(',')||external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(exportOpts._typeMaps).join(',')]);}if(!props.id){if((props.customConfig?isEnableConf(customOpts):customOpts.enabled)&&customOpts.storage){errLog('vxe.error.reqProp',['id']);}}if(props.treeConfig&&checkboxOpts.range){errLog('vxe.error.noTree',['checkbox-config.range']);}if(rowOpts.height&&!props.showOverflow){warnLog('vxe.error.notProp',['table.show-overflow']);}if(!$xeTable.triggerCellAreaModnEvent){if(props.areaConfig){warnLog('vxe.error.notProp',['area-config']);}if(props.clipConfig){warnLog('vxe.error.notProp',['clip-config']);}if(props.fnrConfig){warnLog('vxe.error.notProp',['fnr-config']);}if(mouseOpts.area){errLog('vxe.error.notProp',['mouse-config.area']);return;}}if(!$xeTable.handlePivotTableAggregateData){if(customOpts.allowGroup){errLog('vxe.error.notProp',['custom-config.allowGroup']);return;}if(customOpts.allowValues){errLog('vxe.error.notProp',['custom-config.allowValues']);return;}}if(treeConfig&&rowOpts.drag&&!treeOpts.transform){errLog('vxe.error.notSupportProp',['row-config.drag','tree-config.transform=false','tree-config.transform=true']);}if(treeConfig&&rowDragOpts.isCrossTableDrag&&!rowDragOpts.isCrossDrag){errLog('vxe.error.reqSupportProp',['tree-config & row-drag-config.isCrossTableDrag','row-drag-config.isCrossDrag']);}if(props.dragConfig){warnLog('vxe.error.delProp',['drag-config','row-drag-config']);}if(props.rowGroupConfig){warnLog('vxe.error.delProp',['row-group-config','aggregate-config']);}if(aggregateOpts.countFields){warnLog('vxe.error.delProp',['row-group-config.countFields','column.agg-func']);}if(aggregateOpts.aggregateMethod){warnLog('vxe.error.delProp',['row-group-config.aggregateMethod','aggregate-config.calcValuesMethod']);}if(aggregateOpts.countMethod){warnLog('vxe.error.delProp',['aggregate-config.countMethod','aggregate-config.calcValuesMethod']);}if(props.treeConfig&&treeOpts.children){warnLog('vxe.error.delProp',['tree-config.children','tree-config.childrenField']);}if(props.treeConfig&&treeOpts.line){warnLog('vxe.error.delProp',['tree-config.line','tree-config.showLine']);}if(mouseOpts.area&&mouseOpts.selected){warnLog('vxe.error.errConflicts',['mouse-config.area','mouse-config.selected']);}if(mouseOpts.area&&props.treeConfig&&!treeOpts.transform){errLog('vxe.error.noTree',['mouse-config.area']);}if(props.editConfig&&editOpts.activeMethod){warnLog('vxe.error.delProp',['edit-config.activeMethod','edit-config.beforeEditMethod']);}if(props.treeConfig&&checkboxOpts.isShiftKey){errLog('vxe.error.errConflicts',['tree-config','checkbox-config.isShiftKey']);}if(checkboxOpts.halfField){warnLog('vxe.error.delProp',['checkbox-config.halfField','checkbox-config.indeterminateField']);}if(treeConfig){external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(['rowField','parentField','childrenField','hasChildField','mapChildrenField'],key=>{const val=treeOpts[key];if(val&&val.indexOf('.')>-1){errLog('vxe.error.errProp',[`${key}=${val}`,`${key}=${val.split('.')[0]}`]);}});}if(rowOpts.currentMethod){warnLog('vxe.error.delProp',['row-config.currentMethod','current-row-config.beforeSelectMethod']);}if(columnOpts.currentMethod){warnLog('vxe.error.delProp',['row-config.currentMethod','current-column-config.beforeSelectMethod']);}if((rowOpts.isCurrent||highlightCurrentRow)&&props.keyboardConfig&&keyboardOpts.isArrow&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(currentRowOpts.isFollowSelected)){warnLog('vxe.error.notConflictProp',['row-config.isCurrent','current-row-config.isFollowSelected']);}if((columnOpts.isCurrent||highlightCurrentColumn)&&props.keyboardConfig&&keyboardOpts.isArrow&&!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(currentColumnOpts.isFollowSelected)){warnLog('vxe.error.notConflictProp',['column-config.isCurrent','current-column-config.isFollowSelected']);}// 
// if (props.spanMethod) {
//   if (virtualXOpts.enabled) {
//     warnLog('vxe.error.notConflictProp', ['span-method', 'virtual-x-config.enabled=false'])
//   }
//   if (virtualYOpts.enabled) {
//     warnLog('vxe.error.notConflictProp', ['span-method', 'virtual-y-config.enabled=false'])
//   }
// }
// if (props.footerSpanMethod) {
//   if (virtualXOpts.enabled) {
//     warnLog('vxe.error.notConflictProp', ['footer-span-method', 'virtual-x-config.enabled=false'])
//   }
// }
// 
// if (props.editConfig && !$xeTable.insert) {
//   errLog('vxe.error.reqModule', ['Edit'])
// }
// if (props.editRules && !$xeTable.validate) {
//   errLog('vxe.error.reqModule', ['Validator'])
// }
// if ((checkboxOpts.range || props.keyboardConfig || props.mouseConfig) && !$xeTable.handleCellMousedownEvent) {
//   errLog('vxe.error.reqModule', ['Keyboard'])
// }
// if ((props.printConfig || props.importConfig || props.exportConfig) && !$xeTable.exportData) {
//   errLog('vxe.error.reqModule', ['Export'])
// }
Object.assign(scrollYStore,{startIndex:0,endIndex:0,visibleSize:0});Object.assign(scrollXStore,{startIndex:0,endIndex:0,visibleSize:0});initData();if(props.autoResize){const el=refElem.value;const parentEl=tablePrivateMethods.getParentElem();resizeObserver=table_globalResize.create(()=>{if(props.autoResize){handleResizeEvent();}});if(el){resizeObserver.observe(el);}if(parentEl){resizeObserver.observe(parentEl);}}});if(virtualYOpts.mode!=='scroll'){const tableViewportEl=refTableViewportElem.value;if(tableViewportEl){tableViewportEl.addEventListener('wheel',$xeTable.triggerBodyWheelEvent,{passive:false});}}table_globalEvents.on($xeTable,'paste',handleGlobalPasteEvent);table_globalEvents.on($xeTable,'copy',handleGlobalCopyEvent);table_globalEvents.on($xeTable,'cut',handleGlobalCutEvent);table_globalEvents.on($xeTable,'mousedown',handleGlobalMousedownEvent);table_globalEvents.on($xeTable,'blur',handleGlobalBlurEvent);table_globalEvents.on($xeTable,'mousewheel',handleGlobalMousewheelEvent);table_globalEvents.on($xeTable,'keydown',handleGlobalKeydownEvent);table_globalEvents.on($xeTable,'resize',handleGlobalResizeEvent);table_globalEvents.on($xeTable,'contextmenu',$xeTable.handleGlobalContextmenuEvent);$xeTable.preventEvent(null,'mounted',{$table:$xeTable});});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(()=>{const tableViewportEl=refTableViewportElem.value;if(tableViewportEl){tableViewportEl.removeEventListener('wheel',$xeTable.triggerBodyWheelEvent);}internalData.cvCacheMaps={};internalData.prevDragRow=null;internalData.prevDragCol=null;if(resizeObserver){resizeObserver.disconnect();}tableMethods.closeFilter();if($xeTable.closeMenu){$xeTable.closeMenu();}table_globalEvents.off($xeTable,'paste');table_globalEvents.off($xeTable,'copy');table_globalEvents.off($xeTable,'cut');table_globalEvents.off($xeTable,'mousedown');table_globalEvents.off($xeTable,'blur');table_globalEvents.off($xeTable,'mousewheel');table_globalEvents.off($xeTable,'keydown');table_globalEvents.off($xeTable,'resize');table_globalEvents.off($xeTable,'contextmenu');tablePrivateMethods.preventEvent(null,'beforeUnmount',{$table:$xeTable});});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(()=>{tablePrivateMethods.preventEvent(null,'unmounted',{$table:$xeTable});external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData,createInternalData());});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(()=>{if(props.loading){if(!VxeUILoadingComponent&&!slots.loading){errLog('vxe.error.errProp',['loading=true','loading=false | <template #loading>...</template>']);errLog('vxe.error.reqComp',['vxe-loading']);}}if(props.showOverflow===true||props.showOverflow==='tooltip'||props.showHeaderOverflow===true||props.showHeaderOverflow==='tooltip'||props.showFooterOverflow===true||props.showFooterOverflow==='tooltip'||props.tooltipConfig||props.editRules){if(!VxeUITooltipComponent){if(props.showOverflow===true){errLog('vxe.error.errProp',['show-overflow=true','show-overflow=title']);}if(props.showOverflow==='tooltip'){errLog('vxe.error.errProp',['show-overflow=tooltip','show-overflow=title']);}if(props.showHeaderOverflow===true){errLog('vxe.error.errProp',['show-header-overflow=true','show-header-overflow=title']);}if(props.showHeaderOverflow==='tooltip'){errLog('vxe.error.errProp',['show-header-overflow=tooltip','show-header-overflow=title']);}if(props.showFooterOverflow===true){errLog('vxe.error.errProp',['show-footer-overflow=true','show-footer-overflow=title']);}if(props.showFooterOverflow==='tooltip'){errLog('vxe.error.errProp',['show-footer-overflow=tooltip','show-footer-overflow=title']);}errLog('vxe.error.reqComp',['vxe-tooltip']);}}});(0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeColgroup',null);(0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeTable',$xeTable);$xeTable.renderVN=renderVN;return $xeTable;},render(){return this.renderVN();}}));
;// ./packages/toolbar/src/toolbar.ts










const {
  getConfig: toolbar_getConfig,
  getIcon: toolbar_getIcon,
  getI18n: toolbar_getI18n,
  renderer: toolbar_renderer,
  commands: toolbar_commands,
  createEvent: toolbar_createEvent,
  useFns: toolbar_useFns
} = core_.VxeUI;
function toolbar_createInternalData() {
  return {
    connectTable: null
  };
}
/* harmony default export */ var toolbar = (defineVxeComponent({
  name: 'VxeToolbar',
  props: {
    loading: Boolean,
    refresh: [Boolean, Object],
    refreshOptions: Object,
    import: [Boolean, Object],
    importOptions: Object,
    export: [Boolean, Object],
    exportOptions: Object,
    print: [Boolean, Object],
    printOptions: Object,
    zoom: [Boolean, Object],
    zoomOptions: Object,
    custom: [Boolean, Object],
    customOptions: Object,
    buttons: {
      type: Array,
      default: () => toolbar_getConfig().toolbar.buttons
    },
    tools: {
      type: Array,
      default: () => toolbar_getConfig().toolbar.tools
    },
    perfect: {
      type: Boolean,
      default: () => toolbar_getConfig().toolbar.perfect
    },
    size: {
      type: String,
      default: () => toolbar_getConfig().toolbar.size || toolbar_getConfig().size
    },
    className: [String, Function]
  },
  emits: ['button-click', 'tool-click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    // 
    const VxeUIButtonComponent = core_.VxeUI.getComponent('VxeButton');
    const $xeGrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeGrid', null);
    const $xeGantt = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeGantt', null);
    const $xeGGWrapper = $xeGrid || $xeGantt;
    const {
      computeSize
    } = toolbar_useFns.useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isRefresh: false,
      connectFlag: 0,
      columns: []
    });
    const internalData = toolbar_createInternalData();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeToolbar = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let toolbarMethods = {};
    const computeRefreshOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.refresh, true), props.refreshOptions, props.refresh);
    });
    const computeImportOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.import, true), props.importOptions, props.import);
    });
    const computeExportOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.export, true), props.exportOptions, props.export);
    });
    const computePrintOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.print, true), props.printOptions, props.print);
    });
    const computeZoomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.zoom, true), props.zoomOptions, props.zoom);
    });
    const computeCustomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(toolbar_getConfig().toolbar.custom, true), props.customOptions, props.custom);
    });
    const computeTableCustomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if (reactData.connectFlag || $table) {
        if ($table) {
          const {
            computeCustomOpts
          } = $table.getComputeMaps();
          return computeCustomOpts.value;
        }
      }
      return {
        trigger: ''
      };
    });
    const computeTrigger = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const tableCustomOpts = computeTableCustomOpts.value;
      return tableCustomOpts.trigger;
    });
    const checkTable = () => {
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if ($table) {
        return true;
      }
      errLog('vxe.error.barUnableLink');
    };
    const handleClickSettingEvent = ({
      $event
    }) => {
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if ($table) {
        if ($table.triggerCustomEvent) {
          $table.triggerCustomEvent($event);
        }
      }
    };
    const handleMouseenterSettingEvent = ({
      $event
    }) => {
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if ($table) {
        $table.customOpenEvent($event);
      }
    };
    const handleMouseleaveSettingEvent = ({
      $event
    }) => {
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      if ($table) {
        const {
          customStore
        } = $table.reactData;
        customStore.activeBtn = false;
        setTimeout(() => {
          if (!customStore.activeBtn && !customStore.activeWrapper) {
            $table.customCloseEvent($event);
          }
        }, 350);
      }
    };
    const refreshEvent = ({
      $event
    }) => {
      const {
        isRefresh
      } = reactData;
      const refreshOpts = computeRefreshOpts.value;
      if (!isRefresh) {
        const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
        if (queryMethod) {
          reactData.isRefresh = true;
          try {
            Promise.resolve(queryMethod({})).catch(e => e).then(() => {
              reactData.isRefresh = false;
            });
          } catch (e) {
            reactData.isRefresh = false;
          }
        } else if ($xeGGWrapper) {
          reactData.isRefresh = true;
          $xeGGWrapper.triggerToolbarCommitEvent({
            code: refreshOpts.code || 'reload'
          }, $event).catch(() => {}).then(() => {
            reactData.isRefresh = false;
          });
        }
      }
    };
    const zoomEvent = ({
      $event
    }) => {
      if ($xeGGWrapper) {
        $xeGGWrapper.triggerZoomEvent($event);
      } else {
        warnLog('vxe.error.notProp', ['[toolbar] zoom']);
      }
    };
    const importEvent = () => {
      if (checkTable()) {
        const {
          connectTable
        } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.importData();
        }
      }
    };
    const openImportEvent = () => {
      if (checkTable()) {
        const {
          connectTable
        } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openImport();
        }
      }
    };
    const exportEvent = () => {
      if (checkTable()) {
        const {
          connectTable
        } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.exportData();
        }
      }
    };
    const openExportEvent = () => {
      if (checkTable()) {
        const {
          connectTable
        } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openExport();
        }
      }
    };
    const printEvent = () => {
      if (checkTable()) {
        const {
          connectTable
        } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.print();
        }
      }
    };
    const openPrintEvent = () => {
      if (checkTable()) {
        const {
          connectTable
        } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openPrint();
        }
      }
    };
    const handleDefaultCodeEvent = (eventParams, item, cb) => {
      switch (item.code) {
        case 'print':
          printEvent();
          break;
        case 'open_print':
          openPrintEvent();
          break;
        case 'custom':
          handleClickSettingEvent(eventParams);
          break;
        case 'export':
          exportEvent();
          break;
        case 'open_export':
          openExportEvent();
          break;
        case 'import':
          importEvent();
          break;
        case 'open_import':
          openImportEvent();
          break;
        case 'zoom':
          zoomEvent(eventParams);
          break;
        case 'refresh':
          refreshEvent(eventParams);
          break;
        default:
          cb();
          break;
      }
    };
    const btnEvent = (eventParams, item) => {
      const {
        $event
      } = eventParams;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      const {
        code
      } = item;
      if (code) {
        handleDefaultCodeEvent(eventParams, item, () => {
          if ($xeGGWrapper) {
            $xeGGWrapper.triggerToolbarBtnEvent(item, $event);
          } else {
            const gCommandOpts = toolbar_commands.get(code);
            const params = {
              code,
              button: item,
              $table: $table,
              $grid: $xeGrid,
              $gantt: $xeGantt,
              $event
            };
            if (gCommandOpts) {
              const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
              if (tCommandMethod) {
                tCommandMethod(params);
              } else {
                errLog('vxe.error.notCommands', [`[toolbar] ${code}`]);
              }
            }
            $xeToolbar.dispatchEvent('button-click', params, $event);
          }
        });
      }
    };
    const tolEvent = (eventParams, item) => {
      const {
        $event
      } = eventParams;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      const {
        code
      } = item;
      if (code) {
        handleDefaultCodeEvent(eventParams, item, () => {
          if ($xeGGWrapper) {
            $xeGGWrapper.triggerToolbarTolEvent(item, $event);
          } else {
            const gCommandOpts = toolbar_commands.get(code);
            const params = {
              code,
              button: null,
              tool: item,
              $table: $table,
              $grid: $xeGrid,
              $gantt: $xeGantt,
              $event
            };
            if (gCommandOpts) {
              const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
              if (tCommandMethod) {
                tCommandMethod(params);
              } else {
                errLog('vxe.error.notCommands', [`[toolbar] ${code}`]);
              }
            }
            $xeToolbar.dispatchEvent('tool-click', params, $event);
          }
        });
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, toolbar_createEvent(evnt, {
        $toolbar: $xeToolbar
      }, params));
    };
    toolbarMethods = {
      dispatchEvent,
      syncUpdate(params) {
        internalData.connectTable = params.$table;
        reactData.columns = params.collectColumn;
        reactData.connectFlag++;
      }
    };
    Object.assign($xeToolbar, toolbarMethods);
    const renderDropdowns = (item, isBtn) => {
      const {
        dropdowns
      } = item;
      const downVNs = [];
      if (dropdowns) {
        return dropdowns.map((child, index) => {
          if (child.visible === false) {
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
          }
          return VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
            key: index,
            ...Object.assign({}, child, {
              content: child.content || child.name,
              options: undefined
            }),
            onClick: eventParams => isBtn ? btnEvent(eventParams, child) : tolEvent(eventParams, child)
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
        });
      }
      return downVNs;
    };
    /**
     * 
     */
    const renderLeftBtns = () => {
      const {
        buttons
      } = props;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      const buttonPrefixSlot = slots.buttonPrefix || slots['button-prefix'];
      const buttonSuffixSlot = slots.buttonSuffix || slots['button-suffix'];
      const btnVNs = [];
      if (buttonPrefixSlot) {
        btnVNs.push(...getSlotVNs(buttonPrefixSlot({
          buttons: buttons || [],
          $grid: $xeGrid,
          $gantt: $xeGantt,
          $table: $table
        })));
      }
      if (buttons) {
        buttons.forEach((item, index) => {
          const {
            dropdowns,
            buttonRender
          } = item;
          if (item.visible !== false) {
            const compConf = buttonRender ? toolbar_renderer.get(buttonRender.name) : null;
            if (buttonRender && compConf && compConf.renderToolbarButton) {
              const toolbarButtonClassName = compConf.toolbarButtonClassName;
              const params = {
                $grid: $xeGrid,
                $gantt: $xeGantt,
                $table: $table,
                button: item
              };
              btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
                key: `br${item.code || index}`,
                class: ['vxe-button--item', toolbarButtonClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(toolbarButtonClassName) ? toolbarButtonClassName(params) : toolbarButtonClassName : '']
              }, getSlotVNs(compConf.renderToolbarButton(buttonRender, params))));
            } else {
              if (VxeUIButtonComponent) {
                btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
                  key: `bd${item.code || index}`,
                  ...Object.assign({}, item, {
                    content: item.content || item.name,
                    options: undefined
                  }),
                  onClick: eventParams => btnEvent(eventParams, item)
                }, dropdowns && dropdowns.length ? {
                  dropdowns: () => renderDropdowns(item, true)
                } : {}));
              }
            }
          }
        });
      }
      if (buttonSuffixSlot) {
        btnVNs.push(...getSlotVNs(buttonSuffixSlot({
          buttons: buttons || [],
          $grid: $xeGrid,
          $gantt: $xeGantt,
          $table: $table
        })));
      }
      return btnVNs;
    };
    /**
     * 
     */
    const renderRightTools = () => {
      const {
        tools
      } = props;
      const {
        connectTable
      } = internalData;
      const $table = connectTable;
      const toolPrefixSlot = slots.toolPrefix || slots['tool-prefix'];
      const toolSuffixSlot = slots.toolSuffix || slots['tool-suffix'];
      const btnVNs = [];
      if (toolPrefixSlot) {
        btnVNs.push(...getSlotVNs(toolPrefixSlot({
          tools: tools || [],
          $grid: $xeGrid,
          $gantt: $xeGantt,
          $table: $table
        })));
      }
      if (tools) {
        tools.forEach((item, tIndex) => {
          const {
            dropdowns,
            toolRender
          } = item;
          if (item.visible !== false) {
            const rdName = toolRender ? toolRender.name : null;
            const compConf = toolRender ? toolbar_renderer.get(rdName) : null;
            if (toolRender && compConf && compConf.renderToolbarTool) {
              const toolbarToolClassName = compConf.toolbarToolClassName;
              const params = {
                $grid: $xeGrid,
                $gantt: $xeGantt,
                $table: $table,
                tool: item
              };
              btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
                key: rdName,
                class: ['vxe-tool--item', toolbarToolClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(toolbarToolClassName) ? toolbarToolClassName(params) : toolbarToolClassName : '']
              }, getSlotVNs(compConf.renderToolbarTool(toolRender, params))));
            } else {
              if (VxeUIButtonComponent) {
                btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
                  key: tIndex,
                  ...Object.assign({}, item, {
                    content: item.content || item.name,
                    options: undefined
                  }),
                  onClick: eventParams => tolEvent(eventParams, item)
                }, dropdowns && dropdowns.length ? {
                  dropdowns: () => renderDropdowns(item, false)
                } : {}));
              }
            }
          }
        });
      }
      if (toolSuffixSlot) {
        btnVNs.push(...getSlotVNs(toolSuffixSlot({
          tools: tools || [],
          $grid: $xeGrid,
          $gantt: $xeGantt,
          $table: $table
        })));
      }
      return btnVNs;
    };
    const renderToolImport = () => {
      const importOpts = computeImportOpts.value;
      return VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        key: 'import',
        circle: true,
        icon: importOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_IMPORT,
        title: toolbar_getI18n('vxe.toolbar.import'),
        onClick: openImportEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderToolExport = () => {
      const exportOpts = computeExportOpts.value;
      return VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        key: 'export',
        circle: true,
        icon: exportOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_EXPORT,
        title: toolbar_getI18n('vxe.toolbar.export'),
        onClick: openExportEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderToolPrint = () => {
      const printOpts = computePrintOpts.value;
      return VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        key: 'print',
        circle: true,
        icon: printOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_PRINT,
        title: toolbar_getI18n('vxe.toolbar.print'),
        onClick: openPrintEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderToolRefresh = () => {
      const refreshOpts = computeRefreshOpts.value;
      return VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        key: 'refresh',
        circle: true,
        icon: reactData.isRefresh ? refreshOpts.iconLoading || toolbar_getIcon().TOOLBAR_TOOLS_REFRESH_LOADING : refreshOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_REFRESH,
        title: toolbar_getI18n('vxe.toolbar.refresh'),
        onClick: refreshEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderToolZoom = () => {
      const zoomOpts = computeZoomOpts.value;
      return $xeGGWrapper && VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        key: 'zoom',
        circle: true,
        icon: $xeGGWrapper.isMaximized() ? zoomOpts.iconOut || toolbar_getIcon().TOOLBAR_TOOLS_MINIMIZE : zoomOpts.iconIn || toolbar_getIcon().TOOLBAR_TOOLS_FULLSCREEN,
        title: toolbar_getI18n(`vxe.toolbar.zoom${$xeGGWrapper.isMaximized() ? 'Out' : 'In'}`),
        onClick: zoomEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderToolCustom = () => {
      const customOpts = computeCustomOpts.value;
      const btnTrigger = computeTrigger.value;
      const customBtnOns = {};
      if (btnTrigger === 'manual') {
        // 
      } else if (btnTrigger === 'hover') {
        // hover 
        customBtnOns.onMouseenter = handleMouseenterSettingEvent;
        customBtnOns.onMouseleave = handleMouseleaveSettingEvent;
      } else {
        // 
        customBtnOns.onClick = handleClickSettingEvent;
      }
      return VxeUIButtonComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIButtonComponent, {
        key: 'custom',
        circle: true,
        icon: customOpts.icon || toolbar_getIcon().TOOLBAR_TOOLS_CUSTOM,
        title: toolbar_getI18n('vxe.toolbar.custom'),
        className: 'vxe-toolbar-custom-target',
        ...customBtnOns
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderVN = () => {
      const {
        perfect,
        loading,
        refresh,
        zoom,
        custom,
        className
      } = props;
      const {
        connectTable
      } = internalData;
      const vSize = computeSize.value;
      const toolsSlot = slots.tools;
      const buttonsSlot = slots.buttons;
      const $table = connectTable;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-toolbar', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $toolbar: $xeToolbar
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--perfect': perfect,
          'is--loading': loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-buttons--wrapper'
      }, buttonsSlot ? buttonsSlot({
        $grid: $xeGrid,
        $gantt: $xeGantt,
        $table: $table
      }) : renderLeftBtns()), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tools--wrapper'
      }, toolsSlot ? toolsSlot({
        $grid: $xeGrid,
        $gantt: $xeGantt,
        $table: $table
      }) : renderRightTools()), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tools--operate'
      }, [props.import ? renderToolImport() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), props.export ? renderToolExport() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), props.print ? renderToolPrint() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), refresh ? renderToolRefresh() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), zoom && $xeGGWrapper ? renderToolZoom() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), custom ? renderToolCustom() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]);
    };
    $xeToolbar.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      const refreshOpts = computeRefreshOpts.value;
      const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
      if (props.refresh && !$xeGGWrapper && !queryMethod) {
        warnLog('vxe.error.notFunc', ['[toolbar] queryMethod']);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isPlainObject(props.custom)) {
        warnLog('vxe.error.delProp', ['[toolbar] custom={...}', 'custom=boolean & custom-options={...}']);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isPlainObject(props.print)) {
        warnLog('vxe.error.delProp', ['[toolbar] print={...}', 'print=boolean & print-options={...}']);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isPlainObject(props.export)) {
        warnLog('vxe.error.delProp', ['[toolbar] export={...}', 'export=boolean & export-options={...}']);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isPlainObject(props.import)) {
        warnLog('vxe.error.delProp', ['[toolbar] import={...}', 'import=boolean & import-options={...}']);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isPlainObject(props.refresh)) {
        warnLog('vxe.error.delProp', ['[toolbar] refresh={...}', 'refresh=boolean & refresh-options={...}']);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isPlainObject(props.refresh)) {
        warnLog('vxe.error.delProp', ['[toolbar] zoom={...}', 'zoom=boolean & zoom-options={...}']);
      }
      const customOpts = computeCustomOpts.value;
      if (customOpts.isFooter) {
        warnLog('vxe.error.delProp', ['[toolbar] toolbar.custom.isFooter', 'table.custom-config.showFooter']);
      }
      if (customOpts.showFooter) {
        warnLog('vxe.error.delProp', ['[toolbar] toolbar.custom.showFooter', 'table.custom-config.showFooter']);
      }
      if (customOpts.immediate) {
        warnLog('vxe.error.delProp', ['[toolbar] toolbar.custom.immediate', 'table.custom-config.immediate']);
      }
      if (customOpts.trigger) {
        warnLog('vxe.error.delProp', ['[toolbar] toolbar.custom.trigger', 'table.custom-config.trigger']);
      }
      if (props.refresh || props.import || props.export || props.print || props.zoom) {
        if (!VxeUIButtonComponent) {
          errLog('vxe.error.reqComp', ['vxe-button']);
        }
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData, toolbar_createInternalData());
    });
    return $xeToolbar;
  },
  render() {
    return this.renderVN();
  }
}));
;// ./packages/grid/src/grid.ts



















const {
  getConfig: grid_getConfig,
  getI18n: grid_getI18n,
  commands: grid_commands,
  hooks: grid_hooks,
  useFns: grid_useFns,
  createEvent: grid_createEvent,
  globalEvents: grid_globalEvents,
  GLOBAL_EVENT_KEYS: grid_GLOBAL_EVENT_KEYS,
  renderEmptyElement: grid_renderEmptyElement
} = core_.VxeUI;
const tableComponentPropKeys = Object.keys(tableProps);
const tableComponentMethodKeys = ['clearAll', 'syncData', 'updateData', 'loadData', 'reloadData', 'reloadRow', 'loadColumn', 'reloadColumn', 'getRowNode', 'getColumnNode', 'getRowIndex', 'getVTRowIndex', 'getVMRowIndex', 'getColumnIndex', 'getVTColumnIndex', 'getVMColumnIndex', 'setRow', 'createData', 'createRow', 'revertData', 'clearData', 'isRemoveByRow', 'isInsertByRow', 'isUpdateByRow', 'getColumns', 'getColumnById', 'getColumnByField', 'getTableColumn', 'getFullColumns', 'getData', 'getCheckboxRecords', 'getParentRow', 'getTreeRowChildren', 'getTreeRowLevel', 'getTreeParentRow', 'getRowSeq', 'getRowById', 'getRowid', 'getTableData', 'getFullData', 'setColumnFixed', 'clearColumnFixed', 'setColumnWidth', 'getColumnWidth', 'recalcRowHeight', 'setRowHeightConf', 'getRowHeightConf', 'setRowHeight', 'getRowHeight', 'hideColumn', 'showColumn', 'resetColumn', 'refreshColumn', 'refreshScroll', 'recalculate', 'closeTooltip', 'isAllCheckboxChecked', 'isAllCheckboxIndeterminate', 'getCheckboxIndeterminateRecords', 'setCheckboxRow', 'setCheckboxRowKey', 'isCheckedByCheckboxRow', 'isCheckedByCheckboxRowKey', 'isIndeterminateByCheckboxRow', 'isIndeterminateByCheckboxRowKey', 'toggleCheckboxRow', 'setAllCheckboxRow', 'getRadioReserveRecord', 'clearRadioReserve', 'getCheckboxReserveRecords', 'clearCheckboxReserve', 'toggleAllCheckboxRow', 'clearCheckboxRow', 'setCurrentRow', 'isCheckedByRadioRow', 'isCheckedByRadioRowKey', 'setRadioRow', 'setRadioRowKey', 'clearCurrentRow', 'clearRadioRow', 'getCurrentRecord', 'getRadioRecord', 'getCurrentColumn', 'setCurrentColumn', 'clearCurrentColumn', 'setPendingRow', 'togglePendingRow', 'hasPendingByRow', 'isPendingByRow', 'getPendingRecords', 'clearPendingRow', 'setFilterByEvent', 'sort', 'setSort', 'setSortByEvent', 'clearSort', 'clearSortByEvent', 'isSort', 'getSortColumns', 'closeFilter', 'isFilter', 'clearFilterByEvent', 'isActiveFilterByColumn', 'isRowExpandLoaded', 'clearRowExpandLoaded', 'reloadRowExpand', 'reloadRowExpand', 'toggleRowExpand', 'setAllRowExpand', 'setRowExpand', 'isExpandByRow', 'isRowExpandByRow', 'clearRowExpand', 'clearRowExpandReserve', 'getRowExpandRecords', 'getTreeExpandRecords', 'isTreeExpandLoaded', 'clearTreeExpandLoaded', 'reloadTreeExpand', 'reloadTreeChilds', 'toggleTreeExpand', 'setAllTreeExpand', 'setTreeExpand', 'isTreeExpandByRow', 'clearTreeExpand', 'clearTreeExpandReserve', 'getScroll', 'getScrollData', 'scrollTo', 'scrollToRow', 'scrollToColumn', 'clearScroll', 'updateFooter', 'updateStatus', 'setMergeCells', 'removeInsertRow', 'removeMergeCells', 'getMergeCells', 'setMergeHeaderCells', 'removeMergeHeaderCells', 'getMergeHeaderCells', 'clearMergeHeaderCells', 'clearMergeCells', 'setMergeFooterItems', 'removeMergeFooterItems', 'getMergeFooterItems', 'clearMergeFooterItems', 'getCustomStoreData', 'setRowGroupExpand', 'setRowGroupExpandByField', 'setAllRowGroupExpand', 'clearRowGroupExpand', 'isRowGroupExpandByRow', 'isRowGroupRecord', 'isAggregateRecord', 'isAggregateExpandByRow', 'getAggregateContentByRow', 'getAggregateRowChildren', 'setRowGroups', 'clearRowGroups', 'openTooltip', 'moveColumnTo', 'moveRowTo', 'getCellLabel', 'getCellElement', 'focus', 'blur', 'connect', 'connectToolbar'];
function grid_createInternalData() {
  return {};
}
/* harmony default export */ var grid = (defineVxeComponent({
  name: 'VxeGrid',
  props: gridProps,
  emits: gridEmits,
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    // 
    const VxeUIFormComponent = core_.VxeUI.getComponent('VxeForm');
    const VxeUIPagerComponent = core_.VxeUI.getComponent('VxePager');
    const defaultLayouts = [['Form'], ['Toolbar', 'Top', 'Table', 'Bottom', 'Pager']];
    const {
      computeSize
    } = grid_useFns.useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      tableLoading: false,
      proxyInited: false,
      isZMax: false,
      tableData: [],
      filterData: [],
      formData: {},
      sortData: [],
      tZindex: 0,
      tablePage: {
        total: 0,
        pageSize: grid_getConfig().pager?.pageSize || 10,
        currentPage: 1
      }
    });
    const internalData = grid_createInternalData();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refToolbar = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPager = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPopupContainerElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFormWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refToolbarWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTopWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBottomWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPagerWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const extendTableMethods = methodKeys => {
      const funcs = {};
      methodKeys.forEach(name => {
        funcs[name] = (...args) => {
          const $xeTable = refTable.value;
          if ($xeTable && $xeTable[name]) {
            return $xeTable[name](...args);
          }
        };
      });
      return funcs;
    };
    const gridExtendTableMethods = extendTableMethods(tableComponentMethodKeys);
    tableComponentMethodKeys.forEach(name => {
      gridExtendTableMethods[name] = (...args) => {
        const $xeTable = refTable.value;
        if ($xeTable && $xeTable[name]) {
          return $xeTable && $xeTable[name](...args);
        }
      };
    });
    const computeProxyOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(grid_getConfig().grid.proxyConfig, true), props.proxyConfig);
    });
    const computeIsRespMsg = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const proxyOpts = computeProxyOpts.value;
      return !!(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(proxyOpts.message) ? proxyOpts.message : proxyOpts.showResponseMsg);
    });
    const computeIsActiveMsg = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const proxyOpts = computeProxyOpts.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(proxyOpts.showActionMsg) ? proxyOpts.showActionMsg : !!proxyOpts.showActiveMsg;
    });
    const computePagerOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, grid_getConfig().grid.pagerConfig, props.pagerConfig);
    });
    const computeFormOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, grid_getConfig().grid.formConfig, props.formConfig);
    });
    const computeToolbarOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, grid_getConfig().grid.toolbarConfig, props.toolbarConfig);
    });
    const computeZoomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, grid_getConfig().grid.zoomConfig, props.zoomConfig);
    });
    const computeStyles = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        height,
        maxHeight
      } = props;
      const {
        isZMax,
        tZindex
      } = reactData;
      const stys = {};
      if (isZMax) {
        stys.zIndex = tZindex;
      } else {
        if (height) {
          stys.height = height === 'auto' || height === '100%' ? '100%' : toCssUnit(height);
        }
        if (maxHeight) {
          stys.maxHeight = maxHeight === 'auto' || maxHeight === '100%' ? '100%' : toCssUnit(maxHeight);
        }
      }
      return stys;
    });
    const computeTableExtendProps = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const rest = {};
      tableComponentPropKeys.forEach(key => {
        rest[key] = props[key];
      });
      return rest;
    });
    const computeTableProps = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        seqConfig,
        pagerConfig,
        editConfig,
        proxyConfig
      } = props;
      const {
        isZMax,
        tablePage
      } = reactData;
      const tableExtendProps = computeTableExtendProps.value;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const isLoading = computeIsLoading.value;
      const tProps = Object.assign({}, tableExtendProps);
      if (isZMax) {
        if (tableExtendProps.maxHeight) {
          tProps.maxHeight = '100%';
        } else {
          tProps.height = '100%';
        }
      }
      if (proxyConfig && isEnableConf(proxyOpts)) {
        tProps.loading = isLoading;
        if (pagerConfig && proxyOpts.seq && isEnableConf(pagerOpts)) {
          tProps.seqConfig = Object.assign({}, seqConfig, {
            startIndex: (tablePage.currentPage - 1) * tablePage.pageSize
          });
        }
      }
      if (editConfig) {
        tProps.editConfig = Object.assign({}, editConfig);
      }
      return tProps;
    });
    const computeCurrLayoutConf = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        layouts
      } = props;
      let confs = [];
      if (layouts && layouts.length) {
        confs = layouts;
      } else {
        confs = grid_getConfig().grid.layouts || defaultLayouts;
      }
      let headKeys = [];
      let bodyKeys = [];
      let footKeys = [];
      if (confs.length) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(confs[0])) {
          headKeys = confs[0];
          bodyKeys = confs[1] || [];
          footKeys = confs[2] || [];
        } else {
          bodyKeys = confs;
        }
      }
      return {
        headKeys,
        bodyKeys,
        footKeys
      };
    });
    const computeCustomCurrentPageFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const pagerOpts = computePagerOpts.value;
      return pagerOpts.currentPage;
    });
    const computeCustomPageSizeFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const pagerOpts = computePagerOpts.value;
      return pagerOpts.pageSize;
    });
    const computeCustomTotalFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const pagerOpts = computePagerOpts.value;
      return pagerOpts.total;
    });
    const computePageCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        tablePage
      } = reactData;
      return Math.max(Math.ceil(tablePage.total / tablePage.pageSize), 1);
    });
    const computeIsLoading = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        loading,
        proxyConfig
      } = props;
      const {
        tableLoading
      } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const {
        showLoading
      } = proxyOpts;
      return loading || tableLoading && showLoading && proxyConfig && isEnableConf(proxyOpts);
    });
    const refMaps = {
      refElem,
      refTable,
      refForm,
      refToolbar,
      refPager,
      refPopupContainerElem
    };
    const computeMaps = {
      computeProxyOpts,
      computePagerOpts,
      computeFormOpts,
      computeToolbarOpts,
      computeZoomOpts
    };
    const $xeGrid = {
      xID,
      props: props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const initToolbar = () => {
      const toolbarOpts = computeToolbarOpts.value;
      if (props.toolbarConfig && isEnableConf(toolbarOpts)) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const $xeTable = refTable.value;
          const $xeToolbar = refToolbar.value;
          if ($xeTable && $xeToolbar) {
            $xeTable.connectToolbar($xeToolbar);
          }
        });
      }
    };
    const getFormData = () => {
      const {
        proxyConfig
      } = props;
      const {
        formData
      } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      return proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data;
    };
    const initPages = propKey => {
      const {
        tablePage
      } = reactData;
      const {
        pagerConfig
      } = props;
      const pagerOpts = computePagerOpts.value;
      if (pagerConfig && isEnableConf(pagerOpts)) {
        if (propKey) {
          if (pagerOpts[propKey]) {
            tablePage[propKey] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(pagerOpts[propKey]);
          }
        } else {
          const {
            currentPage,
            pageSize,
            total
          } = pagerOpts;
          if (currentPage) {
            tablePage.currentPage = currentPage;
          }
          if (pageSize) {
            tablePage.pageSize = pageSize;
          }
          if (total) {
            tablePage.total = total;
          }
        }
      }
    };
    const triggerPendingEvent = code => {
      const isActiveMsg = computeIsActiveMsg.value;
      const $xeTable = refTable.value;
      const selectRecords = $xeTable ? $xeTable.getCheckboxRecords() : [];
      if (selectRecords.length) {
        if ($xeTable) {
          $xeTable.togglePendingRow(selectRecords);
        }
        $xeGrid.clearCheckboxRow();
      } else {
        if (isActiveMsg) {
          if (core_.VxeUI.modal) {
            core_.VxeUI.modal.message({
              id: code,
              content: grid_getI18n('vxe.grid.selectOneRecord'),
              status: 'warning'
            });
          }
        }
      }
    };
    const getRespMsg = (rest, defaultMsg) => {
      const proxyOpts = computeProxyOpts.value;
      const resConfigs = proxyOpts.response || proxyOpts.props || {};
      const messageProp = resConfigs.message;
      const $xeTable = refTable.value;
      let msg;
      if (rest && messageProp) {
        msg = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(messageProp) ? messageProp({
          data: rest,
          $table: $xeTable,
          $grid: $xeGrid,
          $gantt: null
        }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, messageProp);
      }
      return msg || grid_getI18n(defaultMsg);
    };
    const handleDeleteRow = (code, alertKey, callback) => {
      const isActiveMsg = computeIsActiveMsg.value;
      const selectRecords = $xeGrid.getCheckboxRecords();
      if (isActiveMsg) {
        if (selectRecords.length) {
          if (core_.VxeUI.modal) {
            return core_.VxeUI.modal.confirm({
              id: `cfm_${code}`,
              content: grid_getI18n(alertKey),
              escClosable: true
            }).then(type => {
              if (type === 'confirm') {
                return callback();
              }
            });
          }
        } else {
          if (core_.VxeUI.modal) {
            core_.VxeUI.modal.message({
              id: `msg_${code}`,
              content: grid_getI18n('vxe.grid.selectOneRecord'),
              status: 'warning'
            });
          }
        }
      } else {
        if (selectRecords.length) {
          callback();
        }
      }
      return Promise.resolve();
    };
    const pageChangeEvent = params => {
      const {
        proxyConfig
      } = props;
      const {
        tablePage
      } = reactData;
      const {
        $event,
        currentPage,
        pageSize
      } = params;
      const proxyOpts = computeProxyOpts.value;
      tablePage.currentPage = currentPage;
      tablePage.pageSize = pageSize;
      $xeGrid.dispatchEvent('page-change', params, $event);
      if (proxyConfig && isEnableConf(proxyOpts)) {
        $xeGrid.commitProxy('query').then(rest => {
          $xeGrid.dispatchEvent('proxy-query', rest, $event);
        });
      }
    };
    const handleSortEvent = params => {
      const $xeTable = refTable.value;
      const {
        proxyConfig
      } = props;
      if (!$xeTable) {
        return;
      }
      const {
        computeSortOpts
      } = $xeTable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const sortOpts = computeSortOpts.value;
      // 
      if (sortOpts.remote) {
        reactData.sortData = params.sortList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          $xeGrid.commitProxy('query').then(rest => {
            $xeGrid.dispatchEvent('proxy-query', rest, params.$event);
          });
        }
      }
    };
    const sortChangeEvent = params => {
      handleSortEvent(params);
      $xeGrid.dispatchEvent('sort-change', params, params.$event);
    };
    const clearAllSortEvent = params => {
      handleSortEvent(params);
      $xeGrid.dispatchEvent('clear-all-sort', params, params.$event);
    };
    const handleFilterEvent = params => {
      const $xeTable = refTable.value;
      const {
        proxyConfig
      } = props;
      if (!$xeTable) {
        return;
      }
      const {
        computeFilterOpts
      } = $xeTable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const filterOpts = computeFilterOpts.value;
      // 
      if (filterOpts.remote) {
        reactData.filterData = params.filterList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          $xeGrid.commitProxy('query').then(rest => {
            $xeGrid.dispatchEvent('proxy-query', rest, params.$event);
          });
        }
      }
    };
    const filterChangeEvent = params => {
      handleFilterEvent(params);
      $xeGrid.dispatchEvent('filter-change', params, params.$event);
    };
    const clearAllFilterEvent = params => {
      handleFilterEvent(params);
      $xeGrid.dispatchEvent('clear-all-filter', params, params.$event);
    };
    const submitFormEvent = params => {
      const {
        proxyConfig
      } = props;
      const proxyOpts = computeProxyOpts.value;
      if (reactData.tableLoading) {
        return;
      }
      if (proxyConfig && isEnableConf(proxyOpts)) {
        $xeGrid.commitProxy('reload').then(rest => {
          $xeGrid.dispatchEvent('proxy-query', {
            ...rest,
            isReload: true
          }, params.$event);
        });
      }
      $xeGrid.dispatchEvent('form-submit', params, params.$event);
    };
    const resetFormEvent = params => {
      const $xeTable = refTable.value;
      const {
        proxyConfig
      } = props;
      const {
        $event
      } = params;
      const proxyOpts = computeProxyOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if ($xeTable) {
          $xeTable.clearScroll();
        }
        $xeGrid.commitProxy('reload').then(rest => {
          $xeGrid.dispatchEvent('proxy-query', {
            ...rest,
            isReload: true
          }, $event);
        });
      }
      $xeGrid.dispatchEvent('form-reset', params, $event);
    };
    const submitInvalidEvent = params => {
      $xeGrid.dispatchEvent('form-submit-invalid', params, params.$event);
    };
    const collapseEvent = params => {
      const {
        $event
      } = params;
      $xeGrid.dispatchEvent('form-toggle-collapse', params, $event);
      $xeGrid.dispatchEvent('form-collapse', params, $event);
    };
    const handleZoom = isMax => {
      const {
        isZMax
      } = reactData;
      if (isMax ? !isZMax : isZMax) {
        reactData.isZMax = !isZMax;
        if (reactData.tZindex < getLastZIndex()) {
          reactData.tZindex = nextZIndex();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => $xeGrid.recalculate(true)).then(() => {
        setTimeout(() => $xeGrid.recalculate(true), 15);
        return reactData.isZMax;
      });
    };
    const getFuncSlot = (optSlots, slotKey) => {
      const funcSlot = optSlots[slotKey];
      if (funcSlot) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(funcSlot)) {
          if (slots[funcSlot]) {
            return slots[funcSlot];
          } else {
            errLog('vxe.error.notSlot', [`[grid] ${funcSlot}`]);
          }
        } else {
          return funcSlot;
        }
      }
      return null;
    };
    const getConfigSlot = slotConfigs => {
      const slotConf = {};
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectMap(slotConfigs, (slotFunc, slotKey) => {
        if (slotFunc) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
            if (slots[slotFunc]) {
              slotConf[slotKey] = slots[slotFunc];
            } else {
              errLog('vxe.error.notSlot', [`[grid] ${slotFunc}`]);
            }
          } else {
            slotConf[slotKey] = slotFunc;
          }
        }
      });
      return slotConf;
    };
    /**
     * 
     */
    const renderForm = () => {
      const {
        formConfig,
        proxyConfig
      } = props;
      const {
        formData
      } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (formConfig && isEnableConf(formOpts) || slots.form) {
        let slotVNs = [];
        if (slots.form) {
          slotVNs = slots.form({
            $grid: $xeGrid,
            $gantt: null
          });
        } else {
          if (formOpts.items) {
            const formSlots = {};
            if (!formOpts.inited) {
              formOpts.inited = true;
              const beforeItem = proxyOpts.beforeItem;
              if (proxyOpts && beforeItem) {
                formOpts.items.forEach(item => {
                  beforeItem({
                    $grid: $xeGrid,
                    $gantt: null,
                    item
                  });
                });
              }
            }
            // 
            formOpts.items.forEach(item => {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(item.slots, func => {
                if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
                  if (slots[func]) {
                    formSlots[func] = slots[func];
                  }
                }
              });
            });
            if (VxeUIFormComponent) {
              slotVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIFormComponent, {
                ref: refForm,
                ...Object.assign({}, formOpts, {
                  data: proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data
                }),
                onSubmit: submitFormEvent,
                onReset: resetFormEvent,
                onSubmitInvalid: submitInvalidEvent,
                onCollapse: collapseEvent
              }, formSlots));
            }
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refFormWrapper,
          key: 'form',
          class: 'vxe-grid--form-wrapper'
        }, slotVNs);
      }
      return grid_renderEmptyElement($xeGrid);
    };
    /**
     * 
     */
    const renderToolbar = () => {
      const {
        toolbarConfig
      } = props;
      const toolbarOpts = computeToolbarOpts.value;
      const toolbarSlot = slots.toolbar;
      if (toolbarConfig && isEnableConf(toolbarOpts) || toolbarSlot) {
        let slotVNs = [];
        if (toolbarSlot) {
          slotVNs = toolbarSlot({
            $grid: $xeGrid,
            $gantt: null
          });
        } else {
          const toolbarOptSlots = toolbarOpts.slots;
          const toolbarSlots = {};
          if (toolbarOptSlots) {
            const buttonsSlot = getFuncSlot(toolbarOptSlots, 'buttons');
            const buttonPrefixSlot = getFuncSlot(toolbarOptSlots, 'buttonPrefix');
            const buttonSuffixSlot = getFuncSlot(toolbarOptSlots, 'buttonSuffix');
            const toolsSlot = getFuncSlot(toolbarOptSlots, 'tools');
            const toolPrefixSlot = getFuncSlot(toolbarOptSlots, 'toolPrefix');
            const toolSuffixSlot = getFuncSlot(toolbarOptSlots, 'toolSuffix');
            if (buttonsSlot) {
              toolbarSlots.buttons = buttonsSlot;
            }
            if (buttonPrefixSlot) {
              toolbarSlots.buttonPrefix = buttonPrefixSlot;
            }
            if (buttonSuffixSlot) {
              toolbarSlots.buttonSuffix = buttonSuffixSlot;
            }
            if (toolsSlot) {
              toolbarSlots.tools = toolsSlot;
            }
            if (toolPrefixSlot) {
              toolbarSlots.toolPrefix = toolPrefixSlot;
            }
            if (toolSuffixSlot) {
              toolbarSlots.toolSuffix = toolSuffixSlot;
            }
          }
          slotVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(toolbar, {
            ref: refToolbar,
            ...toolbarOpts,
            slots: undefined
          }, toolbarSlots));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refToolbarWrapper,
          key: 'toolbar',
          class: 'vxe-grid--toolbar-wrapper'
        }, slotVNs);
      }
      return grid_renderEmptyElement($xeGrid);
    };
    /**
     * 
     */
    const renderTop = () => {
      const topSlot = slots.top;
      if (topSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refTopWrapper,
          key: 'top',
          class: 'vxe-grid--top-wrapper'
        }, topSlot({
          $grid: $xeGrid,
          $gantt: null
        }));
      }
      return grid_renderEmptyElement($xeGrid);
    };
    const renderTableLeft = () => {
      const leftSlot = slots.left;
      if (leftSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-grid--left-wrapper'
        }, leftSlot({
          $grid: $xeGrid,
          $gantt: null
        }));
      }
      return grid_renderEmptyElement($xeGrid);
    };
    const renderTableRight = () => {
      const rightSlot = slots.right;
      if (rightSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-grid--right-wrapper'
        }, rightSlot({
          $grid: $xeGrid,
          $gantt: null
        }));
      }
      return grid_renderEmptyElement($xeGrid);
    };
    /**
     * 
     */
    const renderTable = () => {
      const {
        proxyConfig
      } = props;
      const tableProps = computeTableProps.value;
      const proxyOpts = computeProxyOpts.value;
      const tableOns = Object.assign({}, tableCompEvents);
      const emptySlot = slots.empty;
      const loadingSlot = slots.loading;
      const rowDragIconSlot = slots.rowDragIcon || slots['row-drag-icon'];
      const columnDragIconSlot = slots.columnDragIcon || slots['column-drag-icon'];
      const headerTooltipSlot = slots.headerTooltip || slots['header-tooltip'];
      const tooltipSlot = slots.tooltip;
      const footerTooltipSlot = slots.footerTooltip || slots['footer-tooltip'];
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (proxyOpts.sort) {
          tableOns.onSortChange = sortChangeEvent;
          tableOns.onClearAllSort = clearAllSortEvent;
        }
        if (proxyOpts.filter) {
          tableOns.onFilterChange = filterChangeEvent;
          tableOns.onClearAllFilter = clearAllFilterEvent;
        }
      }
      const slotObj = {};
      if (emptySlot) {
        slotObj.empty = emptySlot;
      }
      if (loadingSlot) {
        slotObj.loading = loadingSlot;
      }
      if (rowDragIconSlot) {
        slotObj.rowDragIcon = rowDragIconSlot;
      }
      if (columnDragIconSlot) {
        slotObj.columnDragIcon = columnDragIconSlot;
      }
      if (headerTooltipSlot) {
        slotObj.headerTooltip = headerTooltipSlot;
      }
      if (tooltipSlot) {
        slotObj.tooltip = tooltipSlot;
      }
      if (footerTooltipSlot) {
        slotObj.footerTooltip = footerTooltipSlot;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--table-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(table, {
        ref: refTable,
        ...tableProps,
        ...tableOns
      }, slotObj)]);
    };
    /**
     * 
     */
    const renderBottom = () => {
      if (slots.bottom) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refBottomWrapper,
          key: 'bottom',
          class: 'vxe-grid--bottom-wrapper'
        }, slots.bottom({
          $grid: $xeGrid,
          $gantt: null
        }));
      }
      return grid_renderEmptyElement($xeGrid);
    };
    /**
     * 
     */
    const renderPager = () => {
      const {
        proxyConfig,
        pagerConfig
      } = props;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const pagerSlot = slots.pager;
      if (pagerConfig && isEnableConf(pagerOpts) || slots.pager) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refPagerWrapper,
          key: 'pager',
          class: 'vxe-grid--pager-wrapper'
        }, pagerSlot ? pagerSlot({
          $grid: $xeGrid,
          $gantt: null
        }) : [VxeUIPagerComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIPagerComponent, {
          ref: refPager,
          ...pagerOpts,
          ...(proxyConfig && isEnableConf(proxyOpts) ? reactData.tablePage : {}),
          onPageChange: pageChangeEvent
        }, getConfigSlot(pagerOpts.slots)) : grid_renderEmptyElement($xeGrid)]);
      }
      return grid_renderEmptyElement($xeGrid);
    };
    const renderChildLayout = layoutKeys => {
      const childVNs = [];
      layoutKeys.forEach(key => {
        switch (key) {
          case 'Form':
            childVNs.push(renderForm());
            break;
          case 'Toolbar':
            childVNs.push(renderToolbar());
            break;
          case 'Top':
            childVNs.push(renderTop());
            break;
          case 'Table':
            childVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              key: 'table',
              class: 'vxe-grid--table-container'
            }, [renderTableLeft(), renderTable(), renderTableRight()]));
            break;
          case 'Bottom':
            childVNs.push(renderBottom());
            break;
          case 'Pager':
            childVNs.push(renderPager());
            break;
          default:
            errLog('vxe.error.notProp', [`[grid] layouts -> ${key}`]);
            break;
        }
      });
      return childVNs;
    };
    const renderLayout = () => {
      const currLayoutConf = computeCurrLayoutConf.value;
      const {
        headKeys,
        bodyKeys,
        footKeys
      } = currLayoutConf;
      const asideLeftSlot = slots.asideLeft || slots['aside-left'];
      const asideRightSlot = slots.asideRight || slots['aside-right'];
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--layout-header-wrapper'
      }, renderChildLayout(headKeys)), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--layout-body-wrapper'
      }, [asideLeftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--layout-aside-left-wrapper'
      }, asideLeftSlot({})) : grid_renderEmptyElement($xeGrid), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--layout-body-content-wrapper'
      }, renderChildLayout(bodyKeys)), asideRightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--layout-aside-right-wrapper'
      }, asideRightSlot({})) : grid_renderEmptyElement($xeGrid)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-grid--layout-footer-wrapper'
      }, renderChildLayout(footKeys)), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refPopupContainerElem
      })];
    };
    const tableCompEvents = {};
    tableEmits.forEach(name => {
      const type = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().camelCase(`on-${name}`);
      tableCompEvents[type] = (...args) => emit(name, ...args);
    });
    const getDefaultFormData = () => {
      const formOpts = computeFormOpts.value;
      if (formOpts.items) {
        const fData = {};
        formOpts.items.forEach(item => {
          const {
            field,
            itemRender
          } = item;
          if (field) {
            let itemValue = null;
            if (itemRender) {
              const {
                startField,
                endField,
                defaultValue
              } = itemRender;
              if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(defaultValue)) {
                itemValue = defaultValue({
                  item
                });
              } else if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(defaultValue)) {
                itemValue = defaultValue;
              }
              if (startField && endField) {
                external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(fData, startField, null);
                external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(fData, endField, null);
              }
            }
            fData[field] = itemValue;
          }
        });
        return fData;
      }
      return {};
    };
    const initProxy = () => {
      const {
        proxyConfig,
        formConfig
      } = props;
      const {
        proxyInited
      } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (formConfig && isEnableConf(formOpts) && proxyOpts.form && formOpts.items) {
          reactData.formData = getDefaultFormData();
        }
        if (!proxyInited) {
          reactData.proxyInited = true;
          if (proxyOpts.autoLoad !== false) {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => $xeGrid.commitProxy('initial')).then(rest => {
              dispatchEvent('proxy-query', {
                ...rest,
                isInited: true
              }, new Event('initial'));
            });
          }
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const zoomOpts = computeZoomOpts.value;
      const isEsc = grid_globalEvents.hasKey(evnt, grid_GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc && reactData.isZMax && zoomOpts.escRestore !== false) {
        $xeGrid.triggerZoomEvent(evnt);
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, grid_createEvent(evnt, {
        $grid: $xeGrid,
        $gantt: null
      }, params));
    };
    const gridMethods = {
      dispatchEvent,
      getEl() {
        return refElem.value;
      },
      /**
       *  code  button
       * @param {String/Object} code 
       */
      commitProxy(proxyTarget, ...args) {
        const {
          proxyConfig,
          toolbarConfig,
          pagerConfig,
          editRules,
          validConfig
        } = props;
        const {
          tablePage
        } = reactData;
        const isActiveMsg = computeIsActiveMsg.value;
        const isRespMsg = computeIsRespMsg.value;
        const proxyOpts = computeProxyOpts.value;
        const pagerOpts = computePagerOpts.value;
        const toolbarOpts = computeToolbarOpts.value;
        const {
          beforeQuery,
          afterQuery,
          beforeDelete,
          afterDelete,
          beforeSave,
          afterSave,
          ajax = {}
        } = proxyOpts;
        const resConfigs = proxyOpts.response || proxyOpts.props || {};
        const $xeTable = refTable.value;
        if (!$xeTable) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
        let formData = getFormData();
        let button = null;
        let code = null;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(proxyTarget)) {
          const {
            buttons
          } = toolbarOpts;
          const matchObj = toolbarConfig && isEnableConf(toolbarOpts) && buttons ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(buttons, item => item.code === proxyTarget, {
            children: 'dropdowns'
          }) : null;
          button = matchObj ? matchObj.item : null;
          code = proxyTarget;
        } else {
          button = proxyTarget;
          code = button.code;
        }
        const btnParams = button ? button.params : null;
        switch (code) {
          case 'insert':
            return $xeTable.insert({});
          case 'insert_edit':
            return $xeTable.insert({}).then(({
              row
            }) => $xeTable.setEditRow(row, true));
          // 
          case 'insert_actived':
            return $xeTable.insert({}).then(({
              row
            }) => $xeTable.setEditRow(row, true));
          // 
          case 'mark_cancel':
            triggerPendingEvent(code);
            break;
          case 'remove':
            return handleDeleteRow(code, 'vxe.grid.removeSelectRecord', () => $xeTable.removeCheckboxRow());
          case 'import':
            $xeTable.importData(btnParams);
            break;
          case 'open_import':
            $xeTable.openImport(btnParams);
            break;
          case 'export':
            $xeTable.exportData(btnParams);
            break;
          case 'open_export':
            $xeTable.openExport(btnParams);
            break;
          case 'reset_custom':
            return $xeTable.resetCustom(true);
          case 'initial':
          case 'reload':
          case 'query':
            {
              const ajaxMethods = ajax.query;
              const querySuccessMethods = ajax.querySuccess;
              const queryErrorMethods = ajax.queryError;
              if (ajaxMethods) {
                const isInited = code === 'initial';
                const isReload = code === 'reload';
                if (!isInited && reactData.tableLoading) {
                  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
                }
                let operPromise = null;
                let sortList = [];
                let filterList = [];
                let pageParams = {};
                if (pagerConfig) {
                  if (isInited || isReload) {
                    // 
                    tablePage.currentPage = 1;
                  }
                  if (isEnableConf(pagerOpts)) {
                    pageParams = {
                      ...tablePage
                    };
                  }
                }
                if (isInited) {
                  // 
                  if (proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form) {
                    formData = getDefaultFormData();
                    reactData.formData = formData;
                  }
                  if ($xeTable) {
                    const tableInternalData = $xeTable.internalData;
                    const {
                      tableFullColumn,
                      fullColumnFieldData
                    } = tableInternalData;
                    const {
                      computeSortOpts
                    } = $xeTable.getComputeMaps();
                    const sortOpts = computeSortOpts.value;
                    let defaultSort = sortOpts.defaultSort;
                    tableFullColumn.forEach(column => {
                      column.order = null;
                    });
                    // 
                    if (defaultSort) {
                      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(defaultSort)) {
                        defaultSort = [defaultSort];
                      }
                      sortList = defaultSort.map(item => {
                        const {
                          field,
                          order
                        } = item;
                        const colRest = fullColumnFieldData[field];
                        if (colRest) {
                          const column = colRest.column;
                          if (column) {
                            column.order = order;
                          }
                        }
                        return {
                          field,
                          property: field,
                          order
                        };
                      });
                    }
                    filterList = $xeTable.getCheckedFilters();
                  }
                } else {
                  if ($xeTable) {
                    if (isReload) {
                      operPromise = $xeTable.clearAll();
                    } else {
                      sortList = $xeTable.getSortColumns();
                      filterList = $xeTable.getCheckedFilters();
                    }
                  }
                }
                const commitParams = {
                  $table: $xeTable,
                  $grid: $xeGrid,
                  $gantt: null,
                  code,
                  button,
                  isInited,
                  isReload,
                  page: pageParams,
                  sort: sortList.length ? sortList[0] : {},
                  sorts: sortList,
                  filters: filterList,
                  form: formData,
                  options: ajaxMethods
                };
                reactData.sortData = sortList;
                reactData.filterData = filterList;
                reactData.tableLoading = true;
                return Promise.all([Promise.resolve((beforeQuery || ajaxMethods)(commitParams, ...args)), operPromise]).then(([rest]) => {
                  let tableData = [];
                  reactData.tableLoading = false;
                  if (rest) {
                    if (pagerConfig && isEnableConf(pagerOpts)) {
                      const totalProp = resConfigs.total;
                      const total = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(totalProp) ? totalProp({
                        data: rest,
                        $table: $xeTable,
                        $grid: $xeGrid,
                        $gantt: null
                      }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, totalProp || 'page.total')) || 0;
                      tablePage.total = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(total);
                      const resultProp = resConfigs.result;
                      tableData = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(resultProp) ? resultProp({
                        data: rest,
                        $table: $xeTable,
                        $grid: $xeGrid,
                        $gantt: null
                      }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, resultProp || 'result')) || [];
                      // 
                      const pageCount = Math.max(Math.ceil(total / tablePage.pageSize), 1);
                      if (tablePage.currentPage > pageCount) {
                        tablePage.currentPage = pageCount;
                      }
                    } else {
                      const listProp = resConfigs.list;
                      tableData = (listProp ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(listProp) ? listProp({
                        data: rest,
                        $table: $xeTable,
                        $grid: $xeGrid,
                        $gantt: null
                      }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, listProp) : rest) || [];
                    }
                  }
                  if ($xeTable) {
                    $xeTable.loadData(tableData);
                  } else {
                    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                      const $xeTable = refTable.value;
                      if ($xeTable) {
                        $xeTable.loadData(tableData);
                      }
                    });
                  }
                  if (afterQuery) {
                    afterQuery(commitParams, ...args);
                  }
                  if (querySuccessMethods) {
                    querySuccessMethods({
                      ...commitParams,
                      response: rest
                    });
                  }
                  return {
                    status: true
                  };
                }).catch(rest => {
                  reactData.tableLoading = false;
                  if (queryErrorMethods) {
                    queryErrorMethods({
                      ...commitParams,
                      response: rest
                    });
                  }
                  return {
                    status: false
                  };
                });
              } else {
                errLog('vxe.error.notFunc', ['[grid] proxy-config.ajax.query']);
              }
              break;
            }
          case 'delete':
            {
              const ajaxMethods = ajax.delete;
              const deleteSuccessMethods = ajax.deleteSuccess;
              const deleteErrorMethods = ajax.deleteError;
              if (ajaxMethods) {
                const selectRecords = $xeGrid.getCheckboxRecords();
                const removeRecords = selectRecords.filter(row => !$xeTable.isInsertByRow(row));
                const body = {
                  removeRecords
                };
                const commitParams = {
                  $table: $xeTable,
                  $grid: $xeGrid,
                  $gantt: null,
                  code,
                  button,
                  body,
                  form: formData,
                  options: ajaxMethods
                };
                if (selectRecords.length) {
                  return handleDeleteRow(code, 'vxe.grid.deleteSelectRecord', () => {
                    if (!removeRecords.length) {
                      return $xeTable.remove(selectRecords);
                    }
                    reactData.tableLoading = true;
                    return Promise.resolve((beforeDelete || ajaxMethods)(commitParams, ...args)).then(rest => {
                      reactData.tableLoading = false;
                      $xeTable.setPendingRow(removeRecords, false);
                      if (isRespMsg) {
                        if (core_.VxeUI.modal) {
                          core_.VxeUI.modal.message({
                            content: getRespMsg(rest, 'vxe.grid.delSuccess'),
                            status: 'success'
                          });
                        }
                      }
                      if (afterDelete) {
                        afterDelete(commitParams, ...args);
                      } else {
                        $xeGrid.commitProxy('query');
                      }
                      if (deleteSuccessMethods) {
                        deleteSuccessMethods({
                          ...commitParams,
                          response: rest
                        });
                      }
                      return {
                        status: true
                      };
                    }).catch(rest => {
                      reactData.tableLoading = false;
                      if (isRespMsg) {
                        if (core_.VxeUI.modal) {
                          core_.VxeUI.modal.message({
                            id: code,
                            content: getRespMsg(rest, 'vxe.grid.operError'),
                            status: 'error'
                          });
                        }
                      }
                      if (deleteErrorMethods) {
                        deleteErrorMethods({
                          ...commitParams,
                          response: rest
                        });
                      }
                      return {
                        status: false
                      };
                    });
                  });
                } else {
                  if (isActiveMsg) {
                    if (core_.VxeUI.modal) {
                      core_.VxeUI.modal.message({
                        id: code,
                        content: grid_getI18n('vxe.grid.selectOneRecord'),
                        status: 'warning'
                      });
                    }
                  }
                }
              } else {
                errLog('vxe.error.notFunc', ['[grid] proxy-config.ajax.delete']);
              }
              break;
            }
          case 'save':
            {
              const ajaxMethods = ajax.save;
              const saveSuccessMethods = ajax.saveSuccess;
              const saveErrorMethods = ajax.saveError;
              if (ajaxMethods) {
                const body = $xeTable.getRecordset();
                const {
                  insertRecords,
                  removeRecords,
                  updateRecords,
                  pendingRecords
                } = body;
                const commitParams = {
                  $table: $xeTable,
                  $grid: $xeGrid,
                  $gantt: null,
                  code,
                  button,
                  body,
                  form: formData,
                  options: ajaxMethods
                };
                // 
                if (insertRecords.length) {
                  body.pendingRecords = pendingRecords.filter(row => $xeTable.findRowIndexOf(insertRecords, row) === -1);
                }
                // 
                if (pendingRecords.length) {
                  body.insertRecords = insertRecords.filter(row => $xeTable.findRowIndexOf(pendingRecords, row) === -1);
                }
                let restPromise = Promise.resolve();
                if (editRules) {
                  // 
                  restPromise = $xeTable[validConfig && validConfig.msgMode === 'full' ? 'fullValidate' : 'validate'](body.insertRecords.concat(updateRecords));
                }
                return restPromise.then(errMap => {
                  if (errMap) {
                    // 
                    return;
                  }
                  if (body.insertRecords.length || removeRecords.length || updateRecords.length || body.pendingRecords.length) {
                    reactData.tableLoading = true;
                    return Promise.resolve((beforeSave || ajaxMethods)(commitParams, ...args)).then(rest => {
                      reactData.tableLoading = false;
                      $xeTable.clearPendingRow();
                      if (isRespMsg) {
                        if (core_.VxeUI.modal) {
                          core_.VxeUI.modal.message({
                            content: getRespMsg(rest, 'vxe.grid.saveSuccess'),
                            status: 'success'
                          });
                        }
                      }
                      if (afterSave) {
                        afterSave(commitParams, ...args);
                      } else {
                        $xeGrid.commitProxy('query');
                      }
                      if (saveSuccessMethods) {
                        saveSuccessMethods({
                          ...commitParams,
                          response: rest
                        });
                      }
                      return {
                        status: true
                      };
                    }).catch(rest => {
                      reactData.tableLoading = false;
                      if (isRespMsg) {
                        if (core_.VxeUI.modal) {
                          core_.VxeUI.modal.message({
                            id: code,
                            content: getRespMsg(rest, 'vxe.grid.operError'),
                            status: 'error'
                          });
                        }
                      }
                      if (saveErrorMethods) {
                        saveErrorMethods({
                          ...commitParams,
                          response: rest
                        });
                      }
                      return {
                        status: false
                      };
                    });
                  } else {
                    if (isActiveMsg) {
                      if (core_.VxeUI.modal) {
                        core_.VxeUI.modal.message({
                          id: code,
                          content: grid_getI18n('vxe.grid.dataUnchanged'),
                          status: 'info'
                        });
                      }
                    }
                  }
                });
              } else {
                errLog('vxe.error.notFunc', ['[grid] proxy-config.ajax.save']);
              }
              break;
            }
          default:
            {
              const gCommandOpts = grid_commands.get(code);
              if (gCommandOpts) {
                const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
                if (tCommandMethod) {
                  tCommandMethod({
                    code,
                    button,
                    $grid: $xeGrid,
                    $table: $xeTable,
                    $gantt: null
                  }, ...args);
                } else {
                  errLog('vxe.error.notCommands', [`[grid] ${code}`]);
                }
              }
            }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      getParams() {
        return props.params;
      },
      zoom() {
        if (reactData.isZMax) {
          return $xeGrid.revert();
        }
        return $xeGrid.maximize();
      },
      isMaximized() {
        return reactData.isZMax;
      },
      maximize() {
        return handleZoom(true);
      },
      revert() {
        return handleZoom();
      },
      getFormData,
      getFormItems(itemIndex) {
        const formOpts = computeFormOpts.value;
        const {
          formConfig
        } = props;
        const {
          items
        } = formOpts;
        const itemList = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(formConfig && isEnableConf(formOpts) && items ? items : [], item => {
          itemList.push(item);
        }, {
          children: 'children'
        });
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(itemIndex) ? itemList : itemList[itemIndex];
      },
      resetForm() {
        const $form = refForm.value;
        if ($form) {
          return $form.reset();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      validateForm() {
        const $form = refForm.value;
        if ($form) {
          return $form.validate();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      validateFormField(field) {
        const $form = refForm.value;
        if ($form) {
          return $form.validateField(field);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      clearFormValidate(field) {
        const $form = refForm.value;
        if ($form) {
          return $form.clearValidate(field);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      homePage() {
        const {
          tablePage
        } = reactData;
        tablePage.currentPage = 1;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      homePageByEvent(evnt) {
        const $pager = refPager.value;
        if ($pager) {
          $pager.homePageByEvent(evnt);
        }
      },
      endPage() {
        const {
          tablePage
        } = reactData;
        const pageCount = computePageCount.value;
        tablePage.currentPage = pageCount;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      endPageByEvent(evnt) {
        const $pager = refPager.value;
        if ($pager) {
          $pager.endPageByEvent(evnt);
        }
      },
      getCurrentPage() {
        const {
          tablePage
        } = reactData;
        return tablePage.currentPage;
      },
      setCurrentPage(currentPage) {
        const {
          tablePage
        } = reactData;
        const pageCount = computePageCount.value;
        tablePage.currentPage = Math.min(pageCount, Math.max(1, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(currentPage)));
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setCurrentPageByEvent(evnt, currentPage) {
        const $pager = refPager.value;
        if ($pager) {
          $pager.setCurrentPageByEvent(evnt, currentPage);
        }
      },
      getPageSize() {
        const {
          tablePage
        } = reactData;
        return tablePage.pageSize;
      },
      setPageSize(pageSize) {
        const {
          tablePage
        } = reactData;
        tablePage.pageSize = Math.max(1, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(pageSize));
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setPageSizeByEvent(evnt, pageSize) {
        const $pager = refPager.value;
        if ($pager) {
          $pager.setPageSizeByEvent(evnt, pageSize);
        }
      },
      getProxyInfo() {
        const $xeTable = refTable.value;
        if (props.proxyConfig) {
          const {
            sortData
          } = reactData;
          return {
            data: $xeTable ? $xeTable.getFullData() : [],
            filter: reactData.filterData,
            form: getFormData(),
            sort: sortData.length ? sortData[0] : {},
            sorts: sortData,
            pager: reactData.tablePage,
            pendingRecords: $xeTable ? $xeTable.getPendingRecords() : []
          };
        }
        return null;
      }
      // setProxyInfo (options) {
      //   if (props.proxyConfig && options) {
      //     const { pager, form } = options
      //     const proxyOpts = computeProxyOpts.value
      //     if (pager) {
      //       if (pager.currentPage) {
      //         reactData.tablePage.currentPage = Number(pager.currentPage)
      //       }
      //       if (pager.pageSize) {
      //         reactData.tablePage.pageSize = Number(pager.pageSize)
      //       }
      //     }
      //     if (proxyOpts.form && form) {
      //       Object.assign(reactData.formData, form)
      //     }
      //   }
      //   return nextTick()
      // }
    };
    const gridPrivateMethods = {
      extendTableMethods,
      callSlot(slotFunc, params) {
        if (slotFunc) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
            slotFunc = slots[slotFunc] || null;
          }
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
            return getSlotVNs(slotFunc(params));
          }
        }
        return [];
      },
      /**
       * 
       */
      getExcludeHeight() {
        const {
          height
        } = props;
        const {
          isZMax
        } = reactData;
        const el = refElem.value;
        if (el) {
          const formWrapper = refFormWrapper.value;
          const toolbarWrapper = refToolbarWrapper.value;
          const topWrapper = refTopWrapper.value;
          const bottomWrapper = refBottomWrapper.value;
          const pagerWrapper = refPagerWrapper.value;
          const parentEl = el.parentElement;
          let parentPaddingSize = 0;
          if (parentEl && (height === '100%' || height === 'auto')) {
            parentPaddingSize = isZMax ? 0 : getPaddingTopBottomSize(parentEl);
          }
          return parentPaddingSize + getPaddingTopBottomSize(el) + getOffsetHeight(formWrapper) + getOffsetHeight(toolbarWrapper) + getOffsetHeight(topWrapper) + getOffsetHeight(bottomWrapper) + getOffsetHeight(pagerWrapper);
        }
        return 0;
      },
      getParentHeight() {
        const el = refElem.value;
        if (el) {
          const parentEl = el.parentElement;
          return (reactData.isZMax ? getDomNode().visibleHeight : parentEl ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getComputedStyle(parentEl).height) : 0) - gridPrivateMethods.getExcludeHeight();
        }
        return 0;
      },
      triggerToolbarCommitEvent(params, evnt) {
        const {
          code
        } = params;
        return $xeGrid.commitProxy(params, evnt).then(rest => {
          if (code && rest && rest.status && ['query', 'reload', 'delete', 'save'].includes(code)) {
            $xeGrid.dispatchEvent(code === 'delete' || code === 'save' ? `proxy-${code}` : 'proxy-query', {
              ...rest,
              isReload: code === 'reload'
            }, evnt);
          }
        });
      },
      triggerToolbarBtnEvent(button, evnt) {
        $xeGrid.triggerToolbarCommitEvent(button, evnt);
        $xeGrid.dispatchEvent('toolbar-button-click', {
          code: button.code,
          button
        }, evnt);
      },
      triggerToolbarTolEvent(tool, evnt) {
        $xeGrid.triggerToolbarCommitEvent(tool, evnt);
        $xeGrid.dispatchEvent('toolbar-tool-click', {
          code: tool.code,
          tool
        }, evnt);
      },
      triggerZoomEvent(evnt) {
        $xeGrid.zoom();
        $xeGrid.dispatchEvent('zoom', {
          type: reactData.isZMax ? 'max' : 'revert'
        }, evnt);
      }
    };
    Object.assign($xeGrid, gridExtendTableMethods, gridMethods, gridPrivateMethods, {
      // 
      loadColumn(columns) {
        const $xeTable = refTable.value;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(columns, column => {
          if (column.slots) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(column.slots, func => {
              if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
                if (!slots[func]) {
                  errLog('vxe.error.notSlot', [`[grid] ${func}`]);
                }
              }
            });
          }
        });
        if ($xeTable) {
          return $xeTable.loadColumn(columns);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      reloadColumn(columns) {
        $xeGrid.clearAll();
        return $xeGrid.loadColumn(columns);
      }
    });
    const renderVN = () => {
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      const isLoading = computeIsLoading.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-grid', {
          [`size--${vSize}`]: vSize,
          'is--animat': !!props.animat,
          'is--round': props.round,
          'is--maximize': reactData.isZMax,
          'is--loading': isLoading
        }],
        style: styles
      }, renderLayout());
    };
    const columnFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.columns ? props.columns.length : -1, () => {
      columnFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.columns, () => {
      columnFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(columnFlag, () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => $xeGrid.loadColumn(props.columns || []));
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.toolbarConfig, () => {
      initToolbar();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeCustomCurrentPageFlag, () => {
      initPages('currentPage');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeCustomPageSizeFlag, () => {
      initPages('pageSize');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeCustomTotalFlag, () => {
      initPages('total');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.proxyConfig, () => {
      initProxy();
    });
    grid_hooks.forEach(options => {
      const {
        setupGrid
      } = options;
      if (setupGrid) {
        const hookRest = setupGrid($xeGrid);
        if (hookRest && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(hookRest)) {
          Object.assign($xeGrid, hookRest);
        }
      }
    });
    initPages();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          columns
        } = props;
        const proxyOpts = computeProxyOpts.value;
        if (props.formConfig) {
          if (!VxeUIFormComponent) {
            errLog('vxe.error.reqComp', ['vxe-form']);
          }
        }
        if (props.pagerConfig) {
          if (!VxeUIPagerComponent) {
            errLog('vxe.error.reqComp', ['vxe-pager']);
          }
        }
        // const { data, columns, proxyConfig } = props
        // const formOpts = computeFormOpts.value
        // if (isEnableConf(proxyConfig) && (data || (proxyOpts.form && formOpts.data))) {
        //   errLog('vxe.error.errConflicts', ['[grid] data', 'proxy-config'])
        // }
        if (proxyOpts.props) {
          warnLog('vxe.error.delProp', ['[grid] proxy-config.props', 'proxy-config.response']);
        }
        if (columns && columns.length) {
          $xeGrid.loadColumn(columns);
        }
        initToolbar();
        initProxy();
      });
      grid_globalEvents.on($xeGrid, 'keydown', handleGlobalKeydownEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      grid_globalEvents.off($xeGrid, 'keydown');
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData, grid_createInternalData());
    });
    $xeGrid.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeGrid', $xeGrid);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeGantt', null);
    return $xeGrid;
  },
  render() {
    return this.renderVN();
  }
}));
;// ./packages/grid/index.ts


const VxeGrid = Object.assign({}, grid, {
  install(app) {
    app.component(grid.name, grid);
  }
});
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(grid.name, grid);
}
core_.VxeUI.component(grid);
const Grid = VxeGrid;
/* harmony default export */ var packages_grid = ((/* unused pure expression or super */ null && (VxeGrid)));
;// ./packages/table/src/use/cell-view.ts


function useCellView(props) {
  const currColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const {
      renderParams
    } = props;
    return renderParams.column;
  });
  const currRow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const {
      renderParams
    } = props;
    return renderParams.row;
  });
  const cellOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const {
      renderOpts
    } = props;
    return renderOpts.props || {};
  });
  const cellModel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
    get() {
      const {
        renderParams
      } = props;
      const {
        row,
        column
      } = renderParams;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
    },
    set(value) {
      const {
        renderParams
      } = props;
      const {
        row,
        column
      } = renderParams;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, column.field, value);
    }
  });
  return {
    currColumn,
    currRow,
    cellModel,
    cellOptions
  };
}
;// ./packages/table/src/use/index.ts

;// ./packages/table/index.ts



const VxeTable = Object.assign({}, table, {
  install(app) {
    app.component(table.name, table);
  }
});
const tableHandle = {
  useCellView: useCellView
};
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(table.name, table);
}
core_.VxeUI.component(table);
core_.VxeUI.tableHandle = tableHandle;
const Table = VxeTable;
/* harmony default export */ var packages_table = ((/* unused pure expression or super */ null && (VxeTable)));
;// ./packages/toolbar/index.ts


const VxeToolbar = Object.assign({}, toolbar, {
  install(app) {
    app.component(toolbar.name, toolbar);
  }
});
if (core_.VxeUI.dynamicApp) {
  core_.VxeUI.dynamicApp.component(toolbar.name, toolbar);
}
core_.VxeUI.component(toolbar);
const Toolbar = VxeToolbar;
/* harmony default export */ var packages_toolbar = ((/* unused pure expression or super */ null && (VxeToolbar)));
;// ./packages/locale/lang/zh-CN.ts
/* harmony default export */ var zh_CN = ({
  vxe: {
    base: {
      pleaseInput: '',
      pleaseSelect: '',
      comma: '',
      fullStop: ''
    },
    loading: {
      text: '...'
    },
    error: {
      downErr: '',
      errLargeData: ' {0}',
      groupFixed: '',
      groupMouseRange: ' "{0}" ',
      groupTag: ' "{0}"  "{1}"',
      scrollErrProp: ' "{0}"',
      errConflicts: ' "{0}"  "{1}" ',
      modelConflicts: ' "{0}"  "{1}" ',
      notSupportProp: ' "{0}"  "{1}" "{2}"',
      reqSupportProp: ' "{0}"  "{1}"',
      notConflictProp: ' "{0}"  "{1}"',
      unableInsert: '',
      useErr: ' "{0}"  Table ',
      barUnableLink: '',
      expandContent: ' "content"',
      reqComp: ' "{0}"  https://vxeui.com/#/start/useGlobal',
      reqModule: ' "{0}" ',
      reqProp: ' "{0}" ',
      emptyProp: ' "{0}" ',
      errProp: ' "{0}" "{1}"',
      colRepet: 'column.{0}="{1}" ',
      notFunc: ' "{0}" ',
      errFunc: ' "{0}" ',
      notValidators: ' "{0}" ',
      notFormats: ' "{0}" ',
      notCommands: ' "{0}" ',
      notSlot: ' "{0}" ',
      noTree: ' "{0}"',
      noGroup: ' "{0}"',
      notProp: ' "{0}"',
      checkProp: ' "{0}" ',
      coverProp: '"{0}"  "{1}" ',
      uniField: ' "{0}" ',
      repeatKey: ' {0}="{1}"',
      repeatProp: ' {0}="{1}"',
      delFunc: ' "{0}"  "{1}"',
      delProp: ' "{0}"  "{1}"',
      delEvent: ' "{0}"  "{1}"',
      removeProp: ' "{0}" ',
      errFormat: ' "VXETable.formats"  "formatter={0}" ',
      notType: ' "{0}"',
      notExp: '/',
      impFields: '',
      treeNotImp: '',
      treeCrossDrag: '',
      treeDragChild: '',
      reqPlugin: ' "{1}" https://vxeui.com/other{0}/#/{1}/install',
      errMaxRow: ' {0} ',
      useNew: ' {0} {1}',
      errorVersion: ' {0} {1}'
    },
    table: {
      emptyText: '',
      allTitle: '/',
      seqTitle: '',
      actionTitle: '',
      confirmFilter: '',
      resetFilter: '',
      allFilter: '',
      sortAsc: '',
      sortDesc: '',
      filter: '',
      impSuccess: ' {0} ',
      expLoading: '',
      expSuccess: '',
      expError: '',
      expFilename: '_{0}',
      expOriginFilename: '__{0}',
      customTitle: '',
      customAll: '',
      customConfirm: '',
      customClose: '',
      customCancel: '',
      customRestore: '',
      maxFixedCol: ' {0} ',
      maxGroupCol: ' {0} ',
      dragTip: '{0}',
      resizeColTip: '{0} ',
      resizeRowTip: '{0} ',
      rowGroupContentTotal: '{0}{1}',
      menuLoading: '...'
    },
    grid: {
      selectOneRecord: '',
      deleteSelectRecord: '',
      removeSelectRecord: '',
      dataUnchanged: '',
      delSuccess: '',
      saveSuccess: '',
      operError: ''
    },
    select: {
      clear: '',
      allChecked: '',
      total: '{0} / {1}',
      search: '',
      loadingText: '',
      emptyText: '',
      maxSize: ' {0} ',
      overSizeErr: ' {0} ',
      searchEmpty: ''
    },
    tree: {
      searchEmpty: ''
    },
    treeSelect: {
      clearChecked: '',
      allChecked: '',
      allExpand: '',
      clearExpand: '',
      total: ' {0}',
      search: '',
      emptyText: ''
    },
    pager: {
      goto: '',
      gotoTitle: '',
      pagesize: '{0}/',
      total: ' {0} ',
      pageClassifier: '',
      homePage: '',
      homePageTitle: '',
      prevPage: '',
      prevPageTitle: '',
      nextPage: '',
      nextPageTitle: '',
      prevJump: '',
      prevJumpTitle: '',
      nextJump: '',
      nextJumpTitle: '',
      endPage: '',
      endPageTitle: ''
    },
    alert: {
      title: ''
    },
    button: {
      confirm: '',
      cancel: '',
      clear: ''
    },
    filter: {
      search: ''
    },
    custom: {
      cstmTitle: '',
      cstmRestore: '',
      cstmCancel: '',
      cstmConfirm: '',
      cstmConfirmRestore: '',
      cstmDragTarget: '{0}',
      setting: {
        colSort: '',
        sortHelpTip: '',
        colTitle: '',
        colResizable: '',
        colVisible: '',
        colFixed: '',
        colFixedMax: ' {0} ',
        fixedLeft: '',
        fixedUnset: '',
        fixedRight: ''
      }
    },
    import: {
      modes: {
        covering: '',
        insert: '',
        insertTop: '',
        insertBottom: ''
      },
      impTitle: '',
      impFile: '',
      impSelect: '',
      impType: '',
      impOpts: '',
      impMode: '',
      impConfirm: '',
      impCancel: ''
    },
    export: {
      types: {
        csv: 'CSV ()(*.csv)',
        html: '(*.html)',
        xml: 'XML (*.xml)',
        txt: '()(*.txt)',
        xls: 'Excel 97-2003 (*.xls)',
        xlsx: 'Excel (*.xlsx)',
        pdf: 'PDF (*.pdf)'
      },
      modes: {
        empty: '',
        current: '',
        selected: '',
        all: ''
      },
      printTitle: '',
      expTitle: '',
      expName: '',
      expNamePlaceholder: '',
      expSheetName: '',
      expSheetNamePlaceholder: '',
      expType: '',
      expMode: '',
      expCurrentColumn: '',
      expColumn: '',
      expOpts: '',
      expOptHeader: '',
      expHeaderTitle: '',
      expOptFooter: '',
      expFooterTitle: '',
      expOptColgroup: '',
      expOptTitle: '',
      expTitleTitle: '',
      expColgroupTitle: '',
      expOptMerge: '',
      expMergeTitle: '',
      expOptAllExpand: '',
      expAllExpandTitle: '',
      expOptUseStyle: '',
      expUseStyleTitle: '',
      expOptOriginal: '',
      expOriginalTitle: '',
      expPrint: '',
      expConfirm: '',
      expCancel: ''
    },
    modal: {
      errTitle: '',
      zoomMin: '',
      zoomIn: '',
      zoomOut: '',
      close: '',
      miniMaxSize: ' {0} ',
      footPropErr: 'show-footer  show-confirm-button | show-cancel-button | '
    },
    drawer: {
      close: ''
    },
    form: {
      folding: '',
      unfolding: ''
    },
    toolbar: {
      import: '',
      export: '',
      print: '',
      refresh: '',
      zoomIn: '',
      zoomOut: '',
      custom: '',
      customAll: '',
      customConfirm: '',
      customRestore: '',
      fixedLeft: '',
      fixedRight: '',
      cancelFixed: ''
    },
    datePicker: {
      yearTitle: '{0} '
    },
    dateRangePicker: {
      pleaseRange: ''
    },
    input: {
      date: {
        m1: '01 ',
        m2: '02 ',
        m3: '03 ',
        m4: '04 ',
        m5: '05 ',
        m6: '06 ',
        m7: '07 ',
        m8: '08 ',
        m9: '09 ',
        m10: '10 ',
        m11: '11 ',
        m12: '12 ',
        quarterLabel: '{0} ',
        monthLabel: '{0} ',
        dayLabel: '{0}  {1}',
        labelFormat: {
          date: 'yyyy-MM-dd',
          time: 'HH:mm:ss',
          datetime: 'yyyy-MM-dd HH:mm:ss',
          week: 'yyyy  WW ',
          month: 'yyyy-MM',
          quarter: 'yyyy  q ',
          year: 'yyyy'
        },
        weeks: {
          w: '',
          w0: '',
          w1: '',
          w2: '',
          w3: '',
          w4: '',
          w5: '',
          w6: ''
        },
        months: {
          m0: '',
          m1: '',
          m2: '',
          m3: '',
          m4: '',
          m5: '',
          m6: '',
          m7: '',
          m8: '',
          m9: '',
          m10: '',
          m11: ''
        },
        quarters: {
          q1: '',
          q2: '',
          q3: '',
          q4: ''
        }
      }
    },
    numberInput: {
      currencySymbol: ''
    },
    imagePreview: {
      popupTitle: '',
      operBtn: {
        zoomOut: '',
        zoomIn: '',
        pctFull: '',
        pct11: '',
        rotateLeft: '',
        rotateRight: '',
        print: '',
        download: ''
      }
    },
    upload: {
      fileBtnText: '',
      imgBtnText: '',
      dragPlaceholder: '',
      imgSizeHint: '{0}',
      imgCountHint: '{0}',
      fileTypeHint: ' {0} ',
      fileSizeHint: '{0}',
      fileCountHint: '{0}',
      uploadTypeErr: '',
      overCountErr: '{0}',
      overCountExtraErr: '{0}{1}',
      overSizeErr: '{0}',
      manualUpload: '',
      reUpload: '',
      uploadProgress: ' {0}%',
      uploadErr: '',
      uploadSuccess: '',
      moreBtnText: '{0}',
      viewItemTitle: '',
      morePopup: {
        readTitle: '',
        imageTitle: '',
        fileTitle: ''
      }
    },
    empty: {
      defText: ''
    },
    colorPicker: {
      clear: '',
      confirm: '',
      copySuccess: '{0}',
      hex: ''
    },
    formDesign: {
      formName: '',
      defFormTitle: '',
      widgetPropTab: '',
      widgetFormTab: '',
      error: {
        wdFormUni: '',
        wdSubUni: ''
      },
      styleSetting: {
        btn: '',
        title: '',
        layoutTitle: '',
        verticalLayout: '',
        horizontalLayout: '',
        styleTitle: '',
        boldTitle: '',
        fontBold: '',
        fontNormal: '',
        colonTitle: '',
        colonVisible: '',
        colonHidden: '',
        alignTitle: '',
        widthTitle: '',
        alignLeft: '',
        alignRight: '',
        unitPx: '',
        unitPct: ''
      },
      widget: {
        group: {
          base: '',
          layout: '',
          system: '',
          module: '',
          chart: '',
          advanced: ''
        },
        copyTitle: '_{0}',
        component: {
          input: '',
          textarea: '',
          select: '',
          row: '',
          title: '',
          text: '',
          subtable: '',
          VxeSwitch: '/',
          VxeInput: '',
          VxeNumberInput: '',
          VxeDatePicker: '',
          VxeTextarea: '',
          VxeSelect: '',
          VxeTreeSelect: '',
          VxeRadioGroup: '',
          VxeCheckboxGroup: '',
          VxeUploadFile: '',
          VxeUploadImage: '',
          VxeRate: '',
          VxeSlider: ''
        }
      },
      widgetProp: {
        name: '',
        placeholder: '',
        required: '',
        multiple: '',
        displaySetting: {
          name: '',
          pc: '',
          mobile: '',
          visible: '',
          hidden: ''
        },
        dataSource: {
          name: '',
          defValue: '{0}',
          addOption: '',
          batchEditOption: '',
          batchEditTip: 'ExcelWPS ',
          batchEditSubTip: 'ExcelWPS ',
          buildOption: ''
        },
        rowProp: {
          colSize: '',
          col2: '',
          col3: '',
          col4: '',
          col6: '',
          layout: ''
        },
        textProp: {
          name: '',
          alignTitle: '',
          alignLeft: '',
          alignCenter: '',
          alignRight: '',
          colorTitle: '',
          sizeTitle: '',
          boldTitle: '',
          fontNormal: '',
          fontBold: ''
        },
        subtableProp: {
          seqTitle: '',
          showSeq: '',
          showCheckbox: '',
          errSubDrag: '',
          colPlace: ''
        },
        uploadProp: {
          limitFileCount: '',
          limitFileSize: '',
          multiFile: '',
          limitImgCount: '',
          limitImgSize: '',
          multiImg: ''
        }
      }
    },
    listDesign: {
      fieldSettingTab: '',
      listSettingTab: '',
      searchTitle: '',
      listTitle: '',
      searchField: '',
      listField: '',
      activeBtn: {
        ActionButtonUpdate: '',
        ActionButtonDelete: ''
      },
      search: {
        addBtn: '',
        emptyText: '',
        editPopupTitle: ''
      },
      searchPopup: {
        colTitle: '',
        saveBtn: ''
      }
    },
    text: {
      copySuccess: '',
      copyError: ''
    },
    countdown: {
      formats: {
        yyyy: '',
        MM: '',
        dd: '',
        HH: '',
        mm: '',
        ss: ''
      }
    },
    gantt: {
      tFullFormat: {
        year: '{yy}',
        quarter: '{yy}{q}',
        month: '{yy}{M}',
        week: '{yy}{W}',
        day: '{yy}{M}{E}',
        date: '{yy}{M}{d}',
        hour: '{yy} {M}{d}{H}',
        minute: '{yy}{M}{d}{H}{m}'
      },
      tSimpleFormat: {
        year: '{yy}',
        quarter: '{q}',
        month: '{M}',
        week: '{W}',
        day: '{d}',
        date: '{d}',
        hour: '{H}',
        minute: '{m}'
      },
      dayss: {
        w0: '',
        w1: '',
        w2: '',
        w3: '',
        w4: '',
        w5: '',
        w6: ''
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: '',
          multiErr: '',
          selectErr: '',
          extendErr: '',
          pasteMultiErr: '',
          cpInvalidErr: '{0}'
        },
        fnr: {
          title: '',
          findLabel: '',
          replaceLabel: '',
          findTitle: '',
          replaceTitle: '',
          tabs: {
            find: '',
            replace: ''
          },
          filter: {
            re: '',
            whole: '',
            sensitive: ''
          },
          btns: {
            findNext: '',
            findAll: '',
            replace: '',
            replaceAll: '',
            cancel: ''
          },
          header: {
            seq: '#',
            cell: '',
            value: ''
          },
          body: {
            row: '{0}',
            col: '{0}'
          },
          empty: '()',
          reError: '',
          recordCount: ' {0} ',
          notCell: '',
          replaceSuccess: ' {0} '
        }
      },
      extendPivotTable: {
        aggregation: {
          grouping: '',
          values: '',
          groupPlaceholder: '',
          valuesPlaceholder: '',
          dragExistCol: '',
          sortHelpTip: ''
        },
        aggFuncs: {
          sum: '',
          count: '',
          avg: '',
          min: '',
          max: '',
          first: '',
          last: ''
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: '',
          fixedGroup: '',
          cancelFixed: '',
          fixedLeft: '',
          fixedRight: ''
        },
        cases: {
          equal: '',
          gt: '',
          lt: '',
          begin: '',
          endin: '',
          include: '',
          isSensitive: ''
        }
      },
      filterCombination: {
        menus: {
          sort: '',
          clearSort: '',
          sortAsc: '',
          sortDesc: '',
          fixedColumn: '',
          fixedGroup: '',
          cancelFixed: '',
          fixedLeft: '',
          fixedRight: '',
          clearFilter: '',
          textOption: '',
          numberOption: ''
        },
        popup: {
          title: '',
          currColumnTitle: '',
          and: '',
          or: '',
          describeHtml: ' ? <br/> * '
        },
        cases: {
          equal: '',
          unequal: '',
          gt: '',
          ge: '',
          lt: '',
          le: '',
          begin: '',
          notbegin: '',
          endin: '',
          notendin: '',
          include: '',
          exclude: '',
          between: '',
          custom: '',
          insensitive: '',
          isSensitive: ''
        },
        empty: '()',
        notData: ''
      }
    },
    pro: {
      area: {
        mergeErr: '',
        multiErr: '',
        extendErr: '',
        pasteMultiErr: ''
      },
      fnr: {
        title: '',
        findLabel: '',
        replaceLabel: '',
        findTitle: '',
        replaceTitle: '',
        tabs: {
          find: '',
          replace: ''
        },
        filter: {
          re: '',
          whole: '',
          sensitive: ''
        },
        btns: {
          findNext: '',
          findAll: '',
          replace: '',
          replaceAll: '',
          cancel: ''
        },
        header: {
          seq: '#',
          cell: '',
          value: ''
        },
        empty: '()',
        reError: '',
        recordCount: ' {0} ',
        notCell: '',
        replaceSuccess: ' {0} '
      }
    },
    renderer: {
      search: '',
      cases: {
        equal: '',
        unequal: '',
        gt: '',
        ge: '',
        lt: '',
        le: '',
        begin: '',
        notbegin: '',
        endin: '',
        notendin: '',
        include: '',
        exclude: '',
        between: '',
        custom: '',
        insensitive: '',
        isSensitive: ''
      },
      combination: {
        menus: {
          sort: '',
          clearSort: '',
          sortAsc: '',
          sortDesc: '',
          fixedColumn: '',
          fixedGroup: '',
          cancelFixed: '',
          fixedLeft: '',
          fixedRight: '',
          clearFilter: '',
          textOption: '',
          numberOption: ''
        },
        popup: {
          title: '',
          currColumnTitle: '',
          and: '',
          or: '',
          describeHtml: ' ? <br/> * '
        },
        empty: '()',
        notData: ''
      }
    }
  }
});
;// ./packages/components.ts









const components = [VxeColumn, VxeColgroup, VxeGrid, VxeTable, VxeToolbar];
// 
function install(app, options) {
  core_.VxeUI.setConfig(options);
  components.forEach(component => component.install(app));
}
// 
if (!core_.VxeUI.hasLanguage('zh-CN')) {
  const defaultLanguage = 'zh-CN';
  core_.VxeUI.setI18n(defaultLanguage, zh_CN);
  core_.VxeUI.setLanguage(defaultLanguage);
}
core_.VxeUI.setTheme('light');

// Components





;// ./index.ts


if (typeof window !== 'undefined' && window.Vue) {
  if (!window.VXETable) {
    window.VXETable = components_namespaceObject;
  }
}

/* harmony default export */ var index = (components_namespaceObject);
;// ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = (index);


/******/ 	return __webpack_exports__;
/******/ })()
;
});