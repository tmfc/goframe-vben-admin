/**
 * tdesign v1.17.3
 * (c) 2025 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Vue = require('vue');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var table_baseTableProps = require('./base-table-props.js');
var table_hooks_useTableHeader = require('./hooks/useTableHeader.js');
var table_hooks_useColumnResize = require('./hooks/useColumnResize.js');
var table_hooks_useFixed = require('./hooks/useFixed.js');
var table_hooks_usePagination = require('./hooks/usePagination.js');
require('@babel/runtime/helpers/toConsumableArray');
require('@babel/runtime/helpers/typeof');
require('../_chunks/dep-3c17082b.js');
var index = require('../_chunks/dep-e0d767af.js');
var configProvider_hooks_useConfig = require('../config-provider/hooks/useConfig.js');
var observe = require('../_chunks/dep-cbefdeb1.js');
var log = require('../_chunks/dep-0e38324c.js');
require('../_chunks/dep-62c55445.js');
var index$1 = require('../_chunks/dep-4de1c225.js');
var table_hooks_useAffix = require('./hooks/useAffix.js');
var loading_index = require('../loading/index.js');
var table_components_tbody = require('./components/tbody.js');
var table_hooks_useStyle = require('./hooks/useStyle.js');
var table_hooks_useClassName = require('./hooks/useClassName.js');
var affix_index = require('../affix/index.js');
var table_components_tr = require('./components/tr.js');
var table_components_thead = require('./components/thead.js');
var table_components_tfoot = require('./components/tfoot.js');
var table_utils_index = require('./utils/index.js');
var helper = require('../_chunks/dep-6d2dff6a.js');
var table_hooks_useRowHighlight = require('./hooks/useRowHighlight.js');
var table_hooks_useHoverKeyboardEvent = require('./hooks/useHoverKeyboardEvent.js');
var throttle = require('../_chunks/dep-465ce79d.js');
var pick = require('../_chunks/dep-d86e814d.js');
var isFunction = require('../_chunks/dep-97cde52e.js');
var get = require('../_chunks/dep-f5fd81dc.js');
require('./hooks/useMultiHeader.js');
require('./components/ellipsis.js');
require('../_chunks/dep-e9e443b3.js');
require('../_chunks/dep-3857e28e.js');
require('../_chunks/dep-42470626.js');
require('../_chunks/dep-11c0611a.js');
require('../_chunks/dep-56be0189.js');
require('../tooltip/index.js');
require('../tooltip/tooltip.js');
require('../tooltip/props.js');
require('../popup/props.js');
require('../popup/index.js');
require('../popup/popup.js');
require('@popperjs/core');
require('../_chunks/dep-4b3d4086.js');
require('../_chunks/dep-f36ac85d.js');
require('../_chunks/dep-6080cc7c.js');
require('../_chunks/dep-e3ec6bc0.js');
require('../_chunks/dep-a0ce0259.js');
require('../_chunks/dep-53514171.js');
require('../_chunks/dep-b970235a.js');
require('../_chunks/dep-cda66fb3.js');
require('../popup/container.js');
require('../_chunks/dep-bc0bad3f.js');
require('../_chunks/dep-b172ffb0.js');
require('../_chunks/dep-cedcef50.js');
require('../_chunks/dep-b237d743.js');
require('../_chunks/dep-9927af91.js');
require('../_chunks/dep-09350c0c.js');
require('../_chunks/dep-d5216d3b.js');
require('../_chunks/dep-f7736f6a.js');
require('../_chunks/dep-dee5853a.js');
require('../_chunks/dep-0ac6ae68.js');
require('../_chunks/dep-960712c7.js');
require('../_chunks/dep-e6017cc5.js');
require('../_chunks/dep-bfcf2d69.js');
require('../_chunks/dep-d0a18b94.js');
require('../_chunks/dep-4ba9517c.js');
require('../_chunks/dep-d3130f90.js');
require('../_chunks/dep-35a0e660.js');
require('../_chunks/dep-bb254cec.js');
require('../_chunks/dep-81f89596.js');
require('dayjs');
require('../_chunks/dep-dc91d44a.js');
require('../_chunks/dep-676e174d.js');
require('../_chunks/dep-fac560bb.js');
require('../_chunks/dep-d72e09dd.js');
require('../_chunks/dep-2a644c59.js');
require('../_chunks/dep-9f738d44.js');
require('../_chunks/dep-73b8ee37.js');
require('../_chunks/dep-b8a33a6b.js');
require('../_chunks/dep-abd1e140.js');
require('../_chunks/dep-f13b9823.js');
require('@babel/runtime/helpers/createClass');
require('@babel/runtime/helpers/classCallCheck');
require('../tooltip/utils/index.js');
require('../_chunks/dep-b750b13e.js');
require('../_chunks/dep-bdede950.js');
require('../_chunks/dep-061dfad4.js');
require('../_chunks/dep-47b09eba.js');
require('../_chunks/dep-6c08ebb5.js');
require('../_chunks/dep-aa9e4429.js');
require('../_chunks/dep-a6223cc7.js');
require('../_chunks/dep-0766d71c.js');
require('../_chunks/dep-636d3f02.js');
require('../_chunks/dep-6c6f0107.js');
require('../_chunks/dep-6493b25c.js');
require('../pagination/index.js');
require('../pagination/pagination.js');
require('@babel/runtime/helpers/objectWithoutProperties');
require('tdesign-icons-vue-next');
require('../_chunks/dep-b914353a.js');
require('../_chunks/dep-c0b34a05.js');
require('../input-number/index.js');
require('../input-number/input-number.js');
require('../button/index.js');
require('../button/button.js');
require('../button/props.js');
require('../_chunks/dep-f572b8fd.js');
require('../_chunks/dep-e1cde54e.js');
require('../_chunks/dep-8e410bd8.js');
require('../_chunks/dep-a03f99f0.js');
require('../loading/plugin.js');
require('../_chunks/dep-fa858b52.js');
require('../loading/icon/gradient.js');
require('../loading/props.js');
require('../_chunks/dep-4a3aa884.js');
require('../_chunks/dep-e62aa80a.js');
require('../_chunks/dep-7f429c3c.js');
require('../_chunks/dep-bdb30c10.js');
require('../_chunks/dep-6a7fa692.js');
require('../_chunks/dep-b9205c6b.js');
require('../_chunks/dep-6e45c2ab.js');
require('../input/index.js');
require('../input/input.js');
require('../input/props.js');
require('../_chunks/dep-490c9f6b.js');
require('../input/hooks/useInput.js');
require('../form/consts/index.js');
require('../input/hooks/useLengthLimit.js');
require('../input/hooks/useInputEventHandler.js');
require('../input/hooks/useInputWidth.js');
require('../input/input-group.js');
require('../input/input-group-props.js');
require('../input-number/props.js');
require('../input-number/hooks/useInputNumber.js');
require('../_chunks/dep-56548994.js');
require('../_chunks/dep-b9baa76e.js');
require('../select/index.js');
require('../select/select.js');
require('@babel/runtime/helpers/asyncToGenerator');
require('@babel/runtime/regenerator');
require('../common-components/fake-arrow.js');
require('../select-input/index.js');
require('../select-input/select-input.js');
require('../select-input/props.js');
require('../select-input/hooks/useMultiple.js');
require('../tag-input/index.js');
require('../tag-input/tag-input.js');
require('../tag-input/props.js');
require('../tag-input/hooks/useDragSorter.js');
require('../tag-input/hooks/useHover.js');
require('../tag-input/hooks/useTagScroll.js');
require('../tag-input/hooks/useTagList.js');
require('../tag/index.js');
require('../tag/tag.js');
require('tinycolor2');
require('../tag/props.js');
require('../tag/check-tag.js');
require('../tag/check-tag-props.js');
require('../_chunks/dep-679830b0.js');
require('../tag/check-tag-group.js');
require('../tag/check-tag-group-props.js');
require('../select-input/hooks/useOverlayInnerStyle.js');
require('../select-input/hooks/useSingle.js');
require('../_chunks/dep-5026a2be.js');
require('../select/components/select-panel.js');
require('../select/option.js');
require('../select/option-props.js');
require('../checkbox/index.js');
require('../checkbox/checkbox.js');
require('../checkbox/props.js');
require('../checkbox/consts/index.js');
require('../checkbox/hooks/useCheckboxLazyLoad.js');
require('../checkbox/hooks/useKeyboardEvent.js');
require('../checkbox/group.js');
require('../checkbox/checkbox-group-props.js');
require('../_chunks/dep-a57b35a8.js');
require('../_chunks/dep-818d4d83.js');
require('../select/utils/index.js');
require('../select/consts/index.js');
require('../select/option-group.js');
require('../select/option-group-props.js');
require('../select/props.js');
require('../select/hooks/usePanelVirtualScroll.js');
require('../select/hooks/useKeyboardControl.js');
require('../select/hooks/useSelectOptions.js');
require('../input-adornment/index.js');
require('../input-adornment/input-adornment.js');
require('../input-adornment/props.js');
require('../pagination/props.js');
require('../pagination/hooks/useMoreAction.js');
require('../pagination/hooks/usePaginationClasses.js');
require('../pagination/pagination-mini.js');
require('../pagination/pagination-mini-props.js');
require('./hooks/useRowspanAndColspan.js');
require('../affix/affix.js');
require('../affix/props.js');
require('./hooks/useLazyLoad.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);

function useElementLazyRender(labelRef, lazyLoad) {
  var ioObserver = Vue.ref();
  var showElement = Vue.ref(true);
  var handleLazyLoad = function handleLazyLoad() {
    if (!lazyLoad.value || !labelRef.value || ioObserver.value) return;
    showElement.value = false;
    var io = observe.observe(labelRef.value, null, function () {
      showElement.value = true;
    }, 10);
    ioObserver.value = io;
  };
  Vue.onMounted(handleLazyLoad);
  lazyLoad.value && Vue.watch([lazyLoad, labelRef], handleLazyLoad);
  Vue.onBeforeUnmount(function () {
    var _ioObserver$value, _ioObserver$value$uno;
    if (!lazyLoad.value) return;
    (_ioObserver$value = ioObserver.value) === null || _ioObserver$value === void 0 || (_ioObserver$value$uno = _ioObserver$value.unobserve) === null || _ioObserver$value$uno === void 0 || _ioObserver$value$uno.call(_ioObserver$value, labelRef.value);
  });
  return {
    showElement: showElement
  };
}

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !Vue.isVNode(s);
}
var BASE_TABLE_EVENTS = ["page-change", "cell-click", "scroll", "scrollX", "scrollY"];
var BASE_TABLE_ALL_EVENTS = table_components_tr.ROW_LISTENERS.map(function (t) {
  return "row-".concat(t);
}).concat(BASE_TABLE_EVENTS);
var _BaseTable = Vue.defineComponent({
  name: "TBaseTable",
  props: _objectSpread(_objectSpread({}, table_baseTableProps["default"]), {}, {
    renderExpandedRow: Function,
    onLeafColumnsChange: Function,
    thDraggable: Boolean
  }),
  emits: ["show-element-change", "update:activeRowKeys"],
  setup: function setup(props2, context) {
    var _toRefs = Vue.toRefs(props2),
      lazyLoad = _toRefs.lazyLoad;
    var renderTNode = index.useTNodeJSX();
    var tableRef = Vue.ref();
    var tableElmRef = Vue.ref();
    var tableBodyRef = Vue.ref();
    var bottomContentRef = Vue.ref();
    var tableFootHeight = Vue.ref(0);
    var _useClassName = table_hooks_useClassName["default"](),
      classPrefix = _useClassName.classPrefix,
      virtualScrollClasses = _useClassName.virtualScrollClasses,
      tableLayoutClasses = _useClassName.tableLayoutClasses,
      tableBaseClass = _useClassName.tableBaseClass,
      tableColFixedClasses = _useClassName.tableColFixedClasses;
    var _useStyle = table_hooks_useStyle["default"](props2),
      tableClasses = _useStyle.tableClasses,
      sizeClassNames = _useStyle.sizeClassNames,
      tableContentStyles = _useStyle.tableContentStyles,
      tableElementStyles = _useStyle.tableElementStyles;
    var _useConfig = configProvider_hooks_useConfig.useConfig("table", props2.locale),
      globalConfig = _useConfig.globalConfig;
    var _useTableHeader = table_hooks_useTableHeader["default"](props2),
      isMultipleHeader = _useTableHeader.isMultipleHeader,
      spansAndLeafNodes = _useTableHeader.spansAndLeafNodes,
      thList = _useTableHeader.thList;
    var finalColumns = Vue.computed(function () {
      var _spansAndLeafNodes$va;
      return ((_spansAndLeafNodes$va = spansAndLeafNodes.value) === null || _spansAndLeafNodes$va === void 0 ? void 0 : _spansAndLeafNodes$va.leafColumns) || props2.columns;
    });
    var tableSize = Vue.computed(function () {
      var _props2$size;
      return (_props2$size = props2.size) !== null && _props2$size !== void 0 ? _props2$size : globalConfig.value.size;
    });
    var _useElementLazyRender = useElementLazyRender(tableRef, lazyLoad),
      showElement = _useElementLazyRender.showElement;
    var paginationAffixRef = Vue.ref();
    var horizontalScrollAffixRef = Vue.ref();
    var headerTopAffixRef = Vue.ref();
    var footerBottomAffixRef = Vue.ref();
    var _useFixed = table_hooks_useFixed["default"](props2, context, finalColumns, {
        paginationAffixRef: paginationAffixRef,
        horizontalScrollAffixRef: horizontalScrollAffixRef,
        headerTopAffixRef: headerTopAffixRef,
        footerBottomAffixRef: footerBottomAffixRef
      }),
      scrollbarWidth = _useFixed.scrollbarWidth,
      tableWidth = _useFixed.tableWidth,
      tableElmWidth = _useFixed.tableElmWidth,
      tableContentRef = _useFixed.tableContentRef,
      isFixedHeader = _useFixed.isFixedHeader,
      isWidthOverflow = _useFixed.isWidthOverflow,
      isFixedColumn = _useFixed.isFixedColumn,
      thWidthList = _useFixed.thWidthList,
      showColumnShadow = _useFixed.showColumnShadow,
      rowAndColFixedPosition = _useFixed.rowAndColFixedPosition,
      setData = _useFixed.setData,
      refreshTable = _useFixed.refreshTable,
      setTableElmWidth = _useFixed.setTableElmWidth,
      emitScrollEvent = _useFixed.emitScrollEvent,
      setUseFixedTableElmRef = _useFixed.setUseFixedTableElmRef,
      updateColumnFixedShadow = _useFixed.updateColumnFixedShadow,
      getThWidthList = _useFixed.getThWidthList,
      updateThWidthList = _useFixed.updateThWidthList,
      addTableResizeObserver = _useFixed.addTableResizeObserver,
      updateTableAfterColumnResize = _useFixed.updateTableAfterColumnResize;
    var _useAffix = table_hooks_useAffix["default"](props2),
      affixHeaderRef = _useAffix.affixHeaderRef,
      affixFooterRef = _useAffix.affixFooterRef,
      horizontalScrollbarRef = _useAffix.horizontalScrollbarRef,
      paginationRef = _useAffix.paginationRef,
      showAffixHeader = _useAffix.showAffixHeader,
      showAffixFooter = _useAffix.showAffixFooter,
      showAffixPagination = _useAffix.showAffixPagination,
      onHorizontalScroll = _useAffix.onHorizontalScroll,
      setTableContentRef = _useAffix.setTableContentRef,
      updateAffixHeaderOrFooter = _useAffix.updateAffixHeaderOrFooter;
    var _usePagination = table_hooks_usePagination["default"](props2, context, tableContentRef),
      dataSource = _usePagination.dataSource,
      innerPagination = _usePagination.innerPagination,
      isPaginateData = _usePagination.isPaginateData,
      renderPagination = _usePagination.renderPagination;
    var columnResizeParams = table_hooks_useColumnResize["default"]({
      isWidthOverflow: isWidthOverflow,
      tableContentRef: tableContentRef,
      showColumnShadow: showColumnShadow,
      getThWidthList: getThWidthList,
      updateThWidthList: updateThWidthList,
      setTableElmWidth: setTableElmWidth,
      updateTableAfterColumnResize: updateTableAfterColumnResize,
      onColumnResizeChange: props2.onColumnResizeChange
    });
    var resizeLineRef = columnResizeParams.resizeLineRef,
      resizeLineStyle = columnResizeParams.resizeLineStyle,
      setEffectColMap = columnResizeParams.setEffectColMap;
    var dynamicBaseTableClasses = Vue.computed(function () {
      return [tableClasses.value, _defineProperty__default["default"](_defineProperty__default["default"](_defineProperty__default["default"](_defineProperty__default["default"](_defineProperty__default["default"](_defineProperty__default["default"](_defineProperty__default["default"](_defineProperty__default["default"]({}, tableBaseClass.headerFixed, isFixedHeader.value), tableBaseClass.columnFixed, isFixedColumn.value), tableBaseClass.widthOverflow, isWidthOverflow.value), tableBaseClass.multipleHeader, isMultipleHeader.value), tableColFixedClasses.leftShadow, showColumnShadow.left), tableColFixedClasses.rightShadow, showColumnShadow.right), tableBaseClass.columnResizableTable, props2.resizable), "".concat(classPrefix, "-table__row--active-").concat(props2.activeRowType), props2.activeRowType)];
    });
    var tableElmClasses = Vue.computed(function () {
      return [[tableLayoutClasses[props2.tableLayout]]];
    });
    var showRightDivider = Vue.computed(function () {
      return props2.bordered && isFixedHeader.value && (isMultipleHeader.value && isWidthOverflow.value || !isMultipleHeader.value);
    });
    var dividerBottom = Vue.computed(function () {
      var _bottomContentRef$val, _paginationRef$value;
      if (!props2.bordered) return 0;
      var bottomRect = (_bottomContentRef$val = bottomContentRef.value) === null || _bottomContentRef$val === void 0 ? void 0 : _bottomContentRef$val.getBoundingClientRect();
      var paginationRect = (_paginationRef$value = paginationRef.value) === null || _paginationRef$value === void 0 ? void 0 : _paginationRef$value.getBoundingClientRect();
      return ((bottomRect === null || bottomRect === void 0 ? void 0 : bottomRect.height) || 0) + ((paginationRect === null || paginationRect === void 0 ? void 0 : paginationRect.height) || 0);
    });
    var _useRowHighlight = table_hooks_useRowHighlight.useRowHighlight(props2, tableRef),
      tActiveRow = _useRowHighlight.tActiveRow,
      onHighlightRow = _useRowHighlight.onHighlightRow,
      addHighlightKeyboardListener = _useRowHighlight.addHighlightKeyboardListener,
      removeHighlightKeyboardListener = _useRowHighlight.removeHighlightKeyboardListener;
    var _useHoverKeyboardEven = table_hooks_useHoverKeyboardEvent.useHoverKeyboardEvent(props2, tableRef),
      hoverRow = _useHoverKeyboardEven.hoverRow,
      needKeyboardRowHover = _useHoverKeyboardEven.needKeyboardRowHover,
      clearHoverRow = _useHoverKeyboardEven.clearHoverRow,
      addRowHoverKeyboardListener = _useHoverKeyboardEven.addRowHoverKeyboardListener,
      removeRowHoverKeyboardListener = _useHoverKeyboardEven.removeRowHoverKeyboardListener,
      tableRefTabIndex = _useHoverKeyboardEven.tableRefTabIndex;
    Vue.watch(tableElmRef, function () {
      setUseFixedTableElmRef(tableElmRef.value);
    });
    Vue.watch(function () {
      return [props2.data, dataSource];
    }, function () {
      setData(isPaginateData.value ? dataSource.value : props2.data);
    });
    Vue.watch(spansAndLeafNodes, function () {
      var _props2$onLeafColumns;
      (_props2$onLeafColumns = props2.onLeafColumnsChange) === null || _props2$onLeafColumns === void 0 || _props2$onLeafColumns.call(props2, spansAndLeafNodes.value.leafColumns);
      setEffectColMap(spansAndLeafNodes.value.leafColumns, null);
    }, {
      immediate: true
    });
    var onFixedChange = function onFixedChange() {
      Vue.nextTick(function () {
        onHorizontalScroll();
        updateAffixHeaderOrFooter();
      });
    };
    var syncThWidthList = throttle.throttle(function () {
      updateThWidthList(getThWidthList("calculate"));
    });
    var virtualScrollParams = Vue.computed(function () {
      return {
        data: props2.data,
        scroll: _objectSpread(_objectSpread({}, props2.scroll), {}, {
          fixedRows: props2.fixedRows
        })
      };
    });
    var virtualConfig = index$1.useVirtualScrollNew(tableContentRef, virtualScrollParams);
    var lastScrollY = -1;
    var onInnerVirtualScroll = function onInnerVirtualScroll(e) {
      var target = e.target || e.srcElement;
      var top = target.scrollTop;
      if (lastScrollY !== top) {
        virtualConfig.isVirtualScroll.value && virtualConfig.handleScroll();
      } else {
        lastScrollY = -1;
        updateColumnFixedShadow(target);
      }
      lastScrollY = top;
      emitScrollEvent(e);
      if (props2.tableLayout === "auto") {
        syncThWidthList();
      }
    };
    var getTFootHeight = function getTFootHeight() {
      var _tableElmRef$value$qu;
      if (!tableElmRef.value) return;
      tableFootHeight.value = (_tableElmRef$value$qu = tableElmRef.value.querySelector("tfoot")) === null || _tableElmRef$value$qu === void 0 ? void 0 : _tableElmRef$value$qu.getBoundingClientRect().height;
    };
    var scrollColumnIntoView = function scrollColumnIntoView(colKey) {
      if (!tableContentRef.value) return;
      var thDom = tableContentRef.value.querySelector("th[data-colkey=\"".concat(colKey, "\"]"));
      var fixedThDom = tableContentRef.value.querySelectorAll("th.t-table__cell--fixed-left");
      var totalWidth = 0;
      for (var i = 0, len = fixedThDom.length; i < len; i++) {
        totalWidth += fixedThDom[i].getBoundingClientRect().width;
      }
      var domRect = thDom.getBoundingClientRect();
      var contentRect = tableContentRef.value.getBoundingClientRect();
      var distance = domRect.left - contentRect.left - totalWidth;
      if (tableContentRef.value.scrollTo) {
        tableContentRef.value.scrollTo({
          left: distance,
          behavior: "smooth"
        });
      } else {
        tableContentRef.value.scrollLeft = distance;
      }
    };
    Vue.watch(tableContentRef, function () {
      setTableContentRef(tableContentRef.value);
      if (props2.tableLayout === "auto") {
        syncThWidthList();
      }
    });
    Vue.watch(function () {
      return [tableElmRef.value, props2.footData, props2.footerSummary, props2.columns];
    }, function () {
      var timer = setTimeout(function () {
        getTFootHeight();
        clearTimeout(timer);
      }, 0);
    });
    Vue.watch(tableRef, function (tableRef2) {
      addTableResizeObserver(tableRef2);
    });
    Vue.onMounted(function () {
      getTFootHeight();
      setTableContentRef(tableContentRef.value);
      addTableResizeObserver(tableRef.value);
    });
    var onTableFocus = function onTableFocus() {
      props2.activeRowType && addHighlightKeyboardListener();
      needKeyboardRowHover.value && addRowHoverKeyboardListener();
    };
    var onTableBlur = function onTableBlur() {
      props2.activeRowType && removeHighlightKeyboardListener();
      needKeyboardRowHover.value && removeRowHoverKeyboardListener();
    };
    var onInnerRowClick = function onInnerRowClick(ctx) {
      var _props2$onRowClick;
      (_props2$onRowClick = props2.onRowClick) === null || _props2$onRowClick === void 0 || _props2$onRowClick.call(props2, ctx);
      props2.activeRowType && onHighlightRow(ctx);
      needKeyboardRowHover.value && clearHoverRow();
    };
    Vue.watch([showElement], function (_ref2) {
      var _ref3 = _slicedToArray__default["default"](_ref2, 1),
        showElement2 = _ref3[0];
      context.emit("show-element-change", showElement2);
    }, {
      immediate: true
    });
    var tableData = Vue.computed(function () {
      return isPaginateData.value ? dataSource.value : props2.data;
    });
    var scrollToElement = function scrollToElement(params) {
      var index = params.index;
      if (!index && index !== 0) {
        var _tableData$value;
        if (!params.key) {
          log.log.error("Table", "scrollToElement: one of `index` or `key` must exist.");
          return;
        }
        index = (_tableData$value = tableData.value) === null || _tableData$value === void 0 ? void 0 : _tableData$value.findIndex(function (item) {
          return get.get(item, props2.rowKey) === params.key;
        });
        if (index < 0) {
          log.log.error("Table", "".concat(params.key, " does not exist in data, check `rowKey` or `data` please."));
        }
      }
      if (virtualConfig.isVirtualScroll.value) {
        virtualConfig.scrollToElement(_objectSpread(_objectSpread({}, params), {}, {
          index: index + 1
        }));
      } else {
        var _tableBodyRef$value, _el$children;
        var el = (_tableBodyRef$value = tableBodyRef.value) === null || _tableBodyRef$value === void 0 ? void 0 : _tableBodyRef$value.$el;
        var row = el === null || el === void 0 || (_el$children = el.children) === null || _el$children === void 0 ? void 0 : _el$children[index];
        if (row) {
          var _params$top, _params$behavior;
          var offsetTop = row.offsetTop;
          var scrollTop = tableContentRef.value.scrollTop;
          var scrollHeight = offsetTop - scrollTop - ((_params$top = params.top) !== null && _params$top !== void 0 ? _params$top : 0);
          tableContentRef.value.scrollBy({
            top: scrollHeight,
            behavior: (_params$behavior = params.behavior) !== null && _params$behavior !== void 0 ? _params$behavior : "auto"
          });
        }
      }
    };
    context.expose({
      refreshTable: refreshTable,
      scrollColumnIntoView: scrollColumnIntoView,
      scrollToElement: scrollToElement
    });
    return function () {
      var _props2$allowResizeCo, _affixHeaderRef$value, _props2$footData, _tableFootHeight$valu, _tableFootHeight$valu2, _affixHeaderHeight$va, _tableContentRef$valu;
      if (!showElement.value) {
        return Vue.createVNode("div", {
          "ref": tableRef
        }, null);
      }
      var data = isPaginateData.value ? dataSource.value : props2.data;
      var columns = (spansAndLeafNodes === null || spansAndLeafNodes === void 0 ? void 0 : spansAndLeafNodes.value.leafColumns) || props2.columns;
      var columnResizable = (_props2$allowResizeCo = props2.allowResizeColumnWidth) !== null && _props2$allowResizeCo !== void 0 ? _props2$allowResizeCo : props2.resizable;
      if (columnResizable && props2.tableLayout === "auto") {
        log.log.warn("Table", "table-layout can not be `auto`, cause you are using column resizable, set `table-layout: fixed` please.");
      }
      var defaultColWidth = props2.tableLayout === "fixed" && isWidthOverflow.value ? "100px" : void 0;
      var renderColGroup = function renderColGroup() {
        var isAffixHeader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return Vue.createVNode("colgroup", null, [columns.map(function (col) {
          var style = {
            width: table_hooks_useStyle.formatCSSUnit((isAffixHeader || columnResizable ? thWidthList.value[col.colKey] : void 0) || col.width) || defaultColWidth
          };
          if (col.minWidth) {
            style.minWidth = table_hooks_useStyle.formatCSSUnit(col.minWidth);
          }
          if (!style.width && !col.minWidth && props2.tableLayout === "fixed") {
            style.minWidth = "80px";
          }
          return Vue.createVNode("col", {
            "key": col.colKey,
            "style": style
          }, null);
        })]);
      };
      var renderAffixedHeader = function renderAffixedHeader() {
        if (props2.showHeader === false) return null;
        return !!(virtualConfig.isVirtualScroll.value || props2.headerAffixedTop) && (props2.headerAffixedTop ? Vue.createVNode(affix_index.Affix, Vue.mergeProps({
          "offsetTop": 0
        }, table_utils_index.getAffixProps(props2.headerAffixedTop), {
          "onFixedChange": onFixedChange,
          "ref": headerTopAffixRef
        }), _isSlot(affixHeaderWithWrap) ? affixHeaderWithWrap : {
          "default": function _default() {
            return [affixHeaderWithWrap];
          }
        }) : isFixedHeader.value && affixHeaderWithWrap);
      };
      var renderAffixedHorizontalScrollbar = function renderAffixedHorizontalScrollbar() {
        return Vue.createVNode(affix_index.Affix, Vue.mergeProps({
          "offsetBottom": 0
        }, table_utils_index.getAffixProps(props2.horizontalScrollAffixedBottom), {
          "style": {
            marginTop: "-".concat(scrollbarWidth.value * 2, "px")
          },
          "horizontalScrollAffixedBottom": true,
          "ref": horizontalScrollAffixRef
        }), {
          "default": function _default() {
            return [Vue.createVNode("div", {
              "ref": horizontalScrollbarRef,
              "class": ["scrollbar", tableBaseClass.obviousScrollbar],
              "style": {
                width: "".concat(tableWidth.value, "px"),
                overflow: "auto",
                opacity: Number(showAffixFooter.value)
              }
            }, [Vue.createVNode("div", {
              "style": {
                width: "".concat(tableElmWidth.value, "px"),
                height: "5px"
              }
            }, null)])];
          }
        });
      };
      var headProps = {
        isFixedHeader: isFixedHeader.value,
        rowAndColFixedPosition: rowAndColFixedPosition.value,
        isMultipleHeader: isMultipleHeader.value,
        bordered: props2.bordered,
        maxHeight: props2.maxHeight,
        height: props2.height,
        spansAndLeafNodes: spansAndLeafNodes.value,
        thList: thList.value,
        thWidthList: thWidthList.value,
        resizable: props2.resizable,
        columnResizeParams: columnResizeParams,
        classPrefix: classPrefix,
        ellipsisOverlayClassName: tableSize.value !== "medium" ? sizeClassNames[tableSize.value] : "",
        attach: props2.attach,
        showColumnShadow: showColumnShadow,
        thDraggable: props2.thDraggable
      };
      var IEHeaderWrap = helper.getIEVersion() <= 11 ? 4 : 0;
      var barWidth = isWidthOverflow.value ? scrollbarWidth.value : 0;
      var affixHeaderHeight = Vue.ref((((_affixHeaderRef$value = affixHeaderRef.value) === null || _affixHeaderRef$value === void 0 ? void 0 : _affixHeaderRef$value.getBoundingClientRect().height) || 0) - IEHeaderWrap);
      var timer = setTimeout(function () {
        var _affixHeaderRef$value2;
        affixHeaderHeight.value = (((_affixHeaderRef$value2 = affixHeaderRef.value) === null || _affixHeaderRef$value2 === void 0 ? void 0 : _affixHeaderRef$value2.getBoundingClientRect().height) || 0) - IEHeaderWrap;
        clearTimeout(timer);
      }, 0);
      var affixHeaderWrapHeight = Vue.computed(function () {
        return affixHeaderHeight.value - barWidth;
      });
      var headerOpacity = props2.headerAffixedTop ? Number(showAffixHeader.value) : 1;
      var affixHeaderWrapHeightStyle = Vue.computed(function () {
        return {
          width: "".concat(tableWidth.value, "px"),
          height: "".concat(affixHeaderWrapHeight.value, "px"),
          opacity: headerOpacity
        };
      });
      var affixedLeftBorder = props2.bordered ? 1 : 0;
      var affixedHeader = Boolean((props2.headerAffixedTop || virtualConfig.isVirtualScroll.value) && tableWidth.value) && Vue.createVNode("div", {
        "ref": affixHeaderRef,
        "style": {
          width: "".concat(tableWidth.value - affixedLeftBorder, "px"),
          opacity: Number(showAffixHeader.value)
        },
        "class": ["scrollbar", _defineProperty__default["default"]({}, tableBaseClass.affixedHeaderElm, props2.headerAffixedTop || virtualConfig.isVirtualScroll.value)]
      }, [Vue.createVNode("table", {
        "class": tableElmClasses.value,
        "style": _objectSpread(_objectSpread({}, tableElementStyles.value), {}, {
          width: "".concat(tableElmWidth.value, "px")
        })
      }, [renderColGroup(true), Vue.createVNode(table_components_thead["default"], headProps, context.slots)])]);
      var affixHeaderWithWrap = Vue.createVNode("div", {
        "class": tableBaseClass.affixedHeaderWrap,
        "style": affixHeaderWrapHeightStyle.value
      }, [affixedHeader]);
      var marginScrollbarWidth = isWidthOverflow.value ? scrollbarWidth.value : 0;
      if (props2.bordered) {
        marginScrollbarWidth += 1;
      }
      var showFooter = Boolean(virtualConfig.isVirtualScroll.value || props2.footerAffixedBottom);
      var hasFooter = ((_props2$footData = props2.footData) === null || _props2$footData === void 0 ? void 0 : _props2$footData.length) || props2.footerSummary || context.slots["footerSummary"];
      var affixedFooter = Boolean(showFooter && hasFooter && tableWidth.value) && Vue.createVNode(affix_index.Affix, Vue.mergeProps({
        "class": tableBaseClass.affixedFooterWrap,
        "onFixedChange": onFixedChange,
        "offsetBottom": marginScrollbarWidth || 0
      }, table_utils_index.getAffixProps(props2.footerAffixedBottom), {
        "style": {
          marginTop: "".concat(-1 * (((_tableFootHeight$valu = tableFootHeight.value) !== null && _tableFootHeight$valu !== void 0 ? _tableFootHeight$valu : 0) + marginScrollbarWidth), "px")
        },
        "ref": footerBottomAffixRef
      }), {
        "default": function _default() {
          return [Vue.createVNode("div", {
            "ref": affixFooterRef,
            "style": {
              width: "".concat(tableWidth.value - affixedLeftBorder, "px"),
              opacity: Number(showAffixFooter.value)
            },
            "class": ["scrollbar", _defineProperty__default["default"]({}, tableBaseClass.affixedFooterElm, props2.footerAffixedBottom || virtualConfig.isVirtualScroll.value)]
          }, [Vue.createVNode("table", {
            "class": tableElmClasses.value,
            "style": _objectSpread(_objectSpread({}, tableElementStyles.value), {}, {
              width: "".concat(tableElmWidth.value, "px")
            })
          }, [renderColGroup(true), Vue.createVNode(table_components_tfoot["default"], {
            "rowKey": props2.rowKey,
            "isFixedHeader": isFixedHeader.value,
            "rowAndColFixedPosition": rowAndColFixedPosition.value,
            "footData": props2.footData,
            "columns": spansAndLeafNodes.value.leafColumns,
            "rowAttributes": props2.rowAttributes,
            "rowClassName": props2.rowClassName,
            "thWidthList": thWidthList.value,
            "footerSummary": props2.footerSummary,
            "rowspanAndColspanInFooter": props2.rowspanAndColspanInFooter
          }, context.slots)])])];
        }
      });
      var translate = "translate(0, ".concat(virtualConfig.scrollHeight.value + ((_tableFootHeight$valu2 = tableFootHeight.value) !== null && _tableFootHeight$valu2 !== void 0 ? _tableFootHeight$valu2 : 0) + ((_affixHeaderHeight$va = affixHeaderHeight.value) !== null && _affixHeaderHeight$va !== void 0 ? _affixHeaderHeight$va : 0), "px)");
      var virtualStyle = {
        transform: translate,
        "-ms-transform": translate,
        "-moz-transform": translate,
        "-webkit-transform": translate
      };
      var tableBodyProps = _objectSpread(_objectSpread({
        classPrefix: classPrefix,
        ellipsisOverlayClassName: tableSize.value !== "medium" ? sizeClassNames[tableSize.value] : "",
        rowAndColFixedPosition: rowAndColFixedPosition.value,
        showColumnShadow: showColumnShadow,
        data: data,
        virtualConfig: virtualConfig,
        columns: spansAndLeafNodes.value.leafColumns,
        tableElm: tableRef.value,
        tableWidth: tableWidth.value,
        isWidthOverflow: isWidthOverflow.value,
        scroll: props2.scroll,
        cellEmptyContent: props2.cellEmptyContent,
        tableContentElm: tableContentRef.value,
        handleRowMounted: virtualConfig.handleRowMounted,
        renderExpandedRow: props2.renderExpandedRow
      }, pick.pick(props2, table_components_tbody.extendTableProps)), {}, {
        pagination: innerPagination.value,
        attach: props2.attach,
        hoverRow: hoverRow.value,
        activeRow: tActiveRow.value,
        onRowClick: onInnerRowClick
      });
      var tableContent = Vue.createVNode("div", {
        "ref": tableContentRef,
        "class": tableBaseClass.content,
        "style": tableContentStyles.value,
        "onScroll": onInnerVirtualScroll
      }, [virtualConfig.isVirtualScroll.value && Vue.createVNode("div", {
        "class": virtualScrollClasses.cursor,
        "style": virtualStyle
      }, null), Vue.createVNode("table", {
        "ref": tableElmRef,
        "class": tableElmClasses.value,
        "style": _objectSpread(_objectSpread({}, tableElementStyles.value), {}, {
          width: props2.resizable && isWidthOverflow.value && tableElmWidth.value ? "".concat(tableElmWidth.value, "px") : tableElementStyles.value.width
        })
      }, [renderColGroup(false), props2.showHeader && Vue.createVNode(table_components_thead["default"], _objectSpread(_objectSpread({}, headProps), {}, {
        thWidthList: columnResizable ? thWidthList.value : {}
      }), context.slots), Vue.createVNode(table_components_tbody["default"], Vue.mergeProps({
        "ref": tableBodyRef
      }, tableBodyProps), context.slots), Vue.createVNode(table_components_tfoot["default"], {
        "rowKey": props2.rowKey,
        "isFixedHeader": isFixedHeader.value,
        "rowAndColFixedPosition": rowAndColFixedPosition.value,
        "footData": props2.footData,
        "columns": spansAndLeafNodes.value.leafColumns,
        "rowAttributes": props2.rowAttributes,
        "rowClassName": props2.rowClassName,
        "footerSummary": props2.footerSummary,
        "rowspanAndColspanInFooter": props2.rowspanAndColspanInFooter,
        "virtualScroll": virtualConfig.isVirtualScroll.value
      }, context.slots)])]);
      var getCustomLoadingText = isFunction.isFunction(props2.loading) ? props2.loading : context.slots.loading;
      var loadingContent = props2.loading !== void 0 && Vue.createVNode(loading_index.Loading, Vue.mergeProps({
        "loading": !!props2.loading,
        "text": getCustomLoadingText,
        "attach": tableRef.value ? function () {
          return tableRef.value;
        } : void 0,
        "showOverlay": true,
        "size": "small"
      }, props2.loadingProps), null);
      var topContent = renderTNode("topContent");
      var bottomContent = renderTNode("bottomContent");
      var pagination = Vue.createVNode("div", {
        "ref": paginationRef,
        "class": tableBaseClass.paginationWrap,
        "style": {
          opacity: Number(showAffixPagination.value)
        }
      }, [renderPagination()]);
      var bottom = !!bottomContent && Vue.createVNode("div", {
        "ref": bottomContentRef,
        "class": tableBaseClass.bottomContent
      }, [bottomContent]);
      return Vue.createVNode("div", {
        "ref": tableRef,
        "tabindex": tableRefTabIndex.value,
        "class": dynamicBaseTableClasses.value,
        "onFocus": onTableFocus,
        "onBlur": onTableBlur
      }, [!!topContent && Vue.createVNode("div", {
        "class": tableBaseClass.topContent
      }, [topContent]), renderAffixedHeader(), tableContent, affixedFooter, loadingContent, bottom, showRightDivider.value && Vue.createVNode("div", {
        "class": tableBaseClass.scrollbarDivider,
        "style": {
          right: "".concat(scrollbarWidth.value, "px"),
          bottom: dividerBottom.value ? "".concat(dividerBottom.value, "px") : void 0,
          height: "".concat((_tableContentRef$valu = tableContentRef.value) === null || _tableContentRef$valu === void 0 ? void 0 : _tableContentRef$valu.getBoundingClientRect().height, "px")
        }
      }, null), props2.horizontalScrollAffixedBottom && renderAffixedHorizontalScrollbar(), props2.paginationAffixedBottom ? Vue.createVNode(affix_index.Affix, Vue.mergeProps({
        "offsetBottom": 0
      }, table_utils_index.getAffixProps(props2.paginationAffixedBottom), {
        "ref": paginationAffixRef
      }), _isSlot(pagination) ? pagination : {
        "default": function _default() {
          return [pagination];
        }
      }) : pagination, Vue.createVNode("div", {
        "ref": resizeLineRef,
        "class": tableBaseClass.resizeLine,
        "style": resizeLineStyle
      }, null)]);
    };
  }
});

exports.BASE_TABLE_ALL_EVENTS = BASE_TABLE_ALL_EVENTS;
exports.BASE_TABLE_EVENTS = BASE_TABLE_EVENTS;
exports["default"] = _BaseTable;
//# sourceMappingURL=base-table.js.map
