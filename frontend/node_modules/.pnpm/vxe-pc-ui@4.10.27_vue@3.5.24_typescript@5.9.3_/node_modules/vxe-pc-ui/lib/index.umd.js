(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"), require("xe-utils"));
	else if(typeof define === 'function' && define.amd)
		define([, "xe-utils"], factory);
	else if(typeof exports === 'object')
		exports["VxeUI"] = factory(require("vue"), require("xe-utils"));
	else
		root["VxeUI"] = factory(root["Vue"], root["XEUtils"]);
})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__9274__, __WEBPACK_EXTERNAL_MODULE__8871__) {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 9274:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__9274__;

/***/ }),

/***/ 8871:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__8871__;

/***/ }),

/***/ 9306:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var tryToString = __webpack_require__(6823);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 8551:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isObject = __webpack_require__(34);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 9617:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIndexedObject = __webpack_require__(5397);
var toAbsoluteIndex = __webpack_require__(5610);
var lengthOfArrayLike = __webpack_require__(6198);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 4527:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var isArray = __webpack_require__(4376);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw new $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};


/***/ }),

/***/ 4576:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 6955:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var TO_STRING_TAG_SUPPORT = __webpack_require__(2140);
var isCallable = __webpack_require__(4901);
var classofRaw = __webpack_require__(4576);
var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7740:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var hasOwn = __webpack_require__(9297);
var ownKeys = __webpack_require__(5031);
var getOwnPropertyDescriptorModule = __webpack_require__(7347);
var definePropertyModule = __webpack_require__(4913);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 6699:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var definePropertyModule = __webpack_require__(4913);
var createPropertyDescriptor = __webpack_require__(6980);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 6980:
/***/ (function(module) {


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 2106:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var makeBuiltIn = __webpack_require__(283);
var defineProperty = __webpack_require__(4913);

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ 6840:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var definePropertyModule = __webpack_require__(4913);
var makeBuiltIn = __webpack_require__(283);
var defineGlobalProperty = __webpack_require__(9433);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 9433:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 3724:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ 4055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var isObject = __webpack_require__(34);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 6837:
/***/ (function(module) {


var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ 9392:
/***/ (function(module) {


module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';


/***/ }),

/***/ 7388:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var userAgent = __webpack_require__(9392);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 8727:
/***/ (function(module) {


// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 6518:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var getOwnPropertyDescriptor = (__webpack_require__(7347).f);
var createNonEnumerableProperty = __webpack_require__(6699);
var defineBuiltIn = __webpack_require__(6840);
var defineGlobalProperty = __webpack_require__(9433);
var copyConstructorProperties = __webpack_require__(7740);
var isForced = __webpack_require__(2796);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = global[TARGET] && global[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 9039:
/***/ (function(module) {


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 616:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 9565:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 350:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var hasOwn = __webpack_require__(9297);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 9504:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 7751:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var isCallable = __webpack_require__(4901);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 5966:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var aCallable = __webpack_require__(9306);
var isNullOrUndefined = __webpack_require__(4117);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 4475:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 9297:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var toObject = __webpack_require__(8981);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 421:
/***/ (function(module) {


module.exports = {};


/***/ }),

/***/ 5917:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);
var createElement = __webpack_require__(4055);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ 7055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var classof = __webpack_require__(4576);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 3706:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var isCallable = __webpack_require__(4901);
var store = __webpack_require__(7629);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 1181:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_WEAK_MAP = __webpack_require__(8622);
var global = __webpack_require__(4475);
var isObject = __webpack_require__(34);
var createNonEnumerableProperty = __webpack_require__(6699);
var hasOwn = __webpack_require__(9297);
var shared = __webpack_require__(7629);
var sharedKey = __webpack_require__(6119);
var hiddenKeys = __webpack_require__(421);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 4376:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(4576);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ 4901:
/***/ (function(module) {


// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 2796:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 4117:
/***/ (function(module) {


// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 34:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 6395:
/***/ (function(module) {


module.exports = false;


/***/ }),

/***/ 757:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var isCallable = __webpack_require__(4901);
var isPrototypeOf = __webpack_require__(1625);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 6198:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toLength = __webpack_require__(8014);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 283:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);
var hasOwn = __webpack_require__(9297);
var DESCRIPTORS = __webpack_require__(3724);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(350).CONFIGURABLE);
var inspectSource = __webpack_require__(3706);
var InternalStateModule = __webpack_require__(1181);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 741:
/***/ (function(module) {


var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 4913:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var IE8_DOM_DEFINE = __webpack_require__(5917);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(8686);
var anObject = __webpack_require__(8551);
var toPropertyKey = __webpack_require__(6969);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7347:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var call = __webpack_require__(9565);
var propertyIsEnumerableModule = __webpack_require__(8773);
var createPropertyDescriptor = __webpack_require__(6980);
var toIndexedObject = __webpack_require__(5397);
var toPropertyKey = __webpack_require__(6969);
var hasOwn = __webpack_require__(9297);
var IE8_DOM_DEFINE = __webpack_require__(5917);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 8480:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var internalObjectKeys = __webpack_require__(1828);
var enumBugKeys = __webpack_require__(8727);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 3717:
/***/ (function(__unused_webpack_module, exports) {


// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 1625:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 1828:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var hasOwn = __webpack_require__(9297);
var toIndexedObject = __webpack_require__(5397);
var indexOf = (__webpack_require__(9617).indexOf);
var hiddenKeys = __webpack_require__(421);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 8773:
/***/ (function(__unused_webpack_module, exports) {


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 4270:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isCallable = __webpack_require__(4901);
var isObject = __webpack_require__(34);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 5031:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var uncurryThis = __webpack_require__(9504);
var getOwnPropertyNamesModule = __webpack_require__(8480);
var getOwnPropertySymbolsModule = __webpack_require__(3717);
var anObject = __webpack_require__(8551);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 7750:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isNullOrUndefined = __webpack_require__(4117);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 6119:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var shared = __webpack_require__(5745);
var uid = __webpack_require__(3392);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 7629:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var IS_PURE = __webpack_require__(6395);
var globalThis = __webpack_require__(4475);
var defineGlobalProperty = __webpack_require__(9433);

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.37.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: 'Â© 2014-2024 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 5745:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var store = __webpack_require__(7629);

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ }),

/***/ 4495:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(7388);
var fails = __webpack_require__(9039);
var global = __webpack_require__(4475);

var $String = global.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 5610:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 5397:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(7055);
var requireObjectCoercible = __webpack_require__(7750);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 1291:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var trunc = __webpack_require__(741);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 8014:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 8981:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var requireObjectCoercible = __webpack_require__(7750);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2777:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isObject = __webpack_require__(34);
var isSymbol = __webpack_require__(757);
var getMethod = __webpack_require__(5966);
var ordinaryToPrimitive = __webpack_require__(4270);
var wellKnownSymbol = __webpack_require__(8227);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 6969:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toPrimitive = __webpack_require__(2777);
var isSymbol = __webpack_require__(757);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 2140:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 655:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(6955);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 6823:
/***/ (function(module) {


var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 3392:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 7040:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(4495);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 8686:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ 2812:
/***/ (function(module) {


var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw new $TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ 8622:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var isCallable = __webpack_require__(4901);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 8227:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var shared = __webpack_require__(5745);
var hasOwn = __webpack_require__(9297);
var uid = __webpack_require__(3392);
var NATIVE_SYMBOL = __webpack_require__(4495);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 4114:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var toObject = __webpack_require__(8981);
var lengthOfArrayLike = __webpack_require__(6198);
var setArrayLength = __webpack_require__(4527);
var doesNotExceedSafeInteger = __webpack_require__(6837);
var fails = __webpack_require__(9039);

var INCORRECT_TO_LENGTH = fails(function () {
  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;
});

// V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError
// https://bugs.chromium.org/p/v8/issues/detail?id=12681
var properErrorOnNonWritableLength = function () {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).push();
  } catch (error) {
    return error instanceof TypeError;
  }
};

var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();

// `Array.prototype.push` method
// https://tc39.es/ecma262/#sec-array.prototype.push
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength(O, len);
    return len;
  }
});


/***/ }),

/***/ 4603:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var defineBuiltIn = __webpack_require__(6840);
var uncurryThis = __webpack_require__(9504);
var toString = __webpack_require__(655);
var validateArgumentsLength = __webpack_require__(2812);

var $URLSearchParams = URLSearchParams;
var URLSearchParamsPrototype = $URLSearchParams.prototype;
var append = uncurryThis(URLSearchParamsPrototype.append);
var $delete = uncurryThis(URLSearchParamsPrototype['delete']);
var forEach = uncurryThis(URLSearchParamsPrototype.forEach);
var push = uncurryThis([].push);
var params = new $URLSearchParams('a=1&a=2&b=3');

params['delete']('a', 1);
// `undefined` case is a Chromium 117 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=14222
params['delete']('b', undefined);

if (params + '' !== 'a=2') {
  defineBuiltIn(URLSearchParamsPrototype, 'delete', function (name /* , value */) {
    var length = arguments.length;
    var $value = length < 2 ? undefined : arguments[1];
    if (length && $value === undefined) return $delete(this, name);
    var entries = [];
    forEach(this, function (v, k) { // also validates `this`
      push(entries, { key: k, value: v });
    });
    validateArgumentsLength(length, 1);
    var key = toString(name);
    var value = toString($value);
    var index = 0;
    var dindex = 0;
    var found = false;
    var entriesLength = entries.length;
    var entry;
    while (index < entriesLength) {
      entry = entries[index++];
      if (found || entry.key === key) {
        found = true;
        $delete(this, entry.key);
      } else dindex++;
    }
    while (dindex < entriesLength) {
      entry = entries[dindex++];
      if (!(entry.key === key && entry.value === value)) append(this, entry.key, entry.value);
    }
  }, { enumerable: true, unsafe: true });
}


/***/ }),

/***/ 7566:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var defineBuiltIn = __webpack_require__(6840);
var uncurryThis = __webpack_require__(9504);
var toString = __webpack_require__(655);
var validateArgumentsLength = __webpack_require__(2812);

var $URLSearchParams = URLSearchParams;
var URLSearchParamsPrototype = $URLSearchParams.prototype;
var getAll = uncurryThis(URLSearchParamsPrototype.getAll);
var $has = uncurryThis(URLSearchParamsPrototype.has);
var params = new $URLSearchParams('a=1');

// `undefined` case is a Chromium 117 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=14222
if (params.has('a', 2) || !params.has('a', undefined)) {
  defineBuiltIn(URLSearchParamsPrototype, 'has', function has(name /* , value */) {
    var length = arguments.length;
    var $value = length < 2 ? undefined : arguments[1];
    if (length && $value === undefined) return $has(this, name);
    var values = getAll(this, name); // also validates `this`
    validateArgumentsLength(length, 1);
    var value = toString($value);
    var index = 0;
    while (index < values.length) {
      if (values[index++] === value) return true;
    } return false;
  }, { enumerable: true, unsafe: true });
}


/***/ }),

/***/ 8721:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var uncurryThis = __webpack_require__(9504);
var defineBuiltInAccessor = __webpack_require__(2106);

var URLSearchParamsPrototype = URLSearchParams.prototype;
var forEach = uncurryThis(URLSearchParamsPrototype.forEach);

// `URLSearchParams.prototype.size` getter
// https://github.com/whatwg/url/pull/734
if (DESCRIPTORS && !('size' in URLSearchParamsPrototype)) {
  defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {
    get: function size() {
      var count = 0;
      forEach(this, function () { count++; });
      return count;
    },
    configurable: true,
    enumerable: true
  });
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Alert: function() { return /* reexport */ Alert; },
  Anchor: function() { return /* reexport */ Anchor; },
  AnchorLink: function() { return /* reexport */ AnchorLink; },
  Avatar: function() { return /* reexport */ Avatar; },
  Badge: function() { return /* reexport */ Badge; },
  Breadcrumb: function() { return /* reexport */ Breadcrumb; },
  BreadcrumbItem: function() { return /* reexport */ BreadcrumbItem; },
  Button: function() { return /* reexport */ Button; },
  ButtonGroup: function() { return /* reexport */ ButtonGroup; },
  Calendar: function() { return /* reexport */ Calendar; },
  Card: function() { return /* reexport */ Card; },
  Carousel: function() { return /* reexport */ Carousel; },
  CarouselItem: function() { return /* reexport */ CarouselItem; },
  Checkbox: function() { return /* reexport */ Checkbox; },
  CheckboxButton: function() { return /* reexport */ CheckboxButton; },
  CheckboxGroup: function() { return /* reexport */ CheckboxGroup; },
  Col: function() { return /* reexport */ Col; },
  Collapse: function() { return /* reexport */ Collapse; },
  CollapsePane: function() { return /* reexport */ CollapsePane; },
  ColorPicker: function() { return /* reexport */ ColorPicker; },
  Countdown: function() { return /* reexport */ Countdown; },
  DatePanel: function() { return /* reexport */ DatePanel; },
  DatePicker: function() { return /* reexport */ DatePicker; },
  DateRangePicker: function() { return /* reexport */ DateRangePicker; },
  Drawer: function() { return /* reexport */ Drawer; },
  DrawerController: function() { return /* reexport */ DrawerController; },
  Empty: function() { return /* reexport */ Empty; },
  Form: function() { return /* reexport */ Form; },
  FormGather: function() { return /* reexport */ FormGather; },
  FormGroup: function() { return /* reexport */ FormGroup; },
  FormItem: function() { return /* reexport */ FormItem; },
  GLOBAL_EVENT_KEYS: function() { return /* reexport */ GLOBAL_EVENT_KEYS; },
  Icon: function() { return /* reexport */ Icon; },
  IconPicker: function() { return /* reexport */ IconPicker; },
  Image: function() { return /* reexport */ image_Image; },
  ImageGroup: function() { return /* reexport */ ImageGroup; },
  ImagePreview: function() { return /* reexport */ ImagePreview; },
  Input: function() { return /* reexport */ Input; },
  LayoutAside: function() { return /* reexport */ LayoutAside; },
  LayoutBody: function() { return /* reexport */ LayoutBody; },
  LayoutContainer: function() { return /* reexport */ LayoutContainer; },
  LayoutFooter: function() { return /* reexport */ LayoutFooter; },
  LayoutHeader: function() { return /* reexport */ LayoutHeader; },
  Link: function() { return /* reexport */ Link; },
  List: function() { return /* reexport */ List; },
  Loading: function() { return /* reexport */ Loading; },
  LoadingController: function() { return /* reexport */ LoadingController; },
  Menu: function() { return /* reexport */ Menu; },
  Modal: function() { return /* reexport */ Modal; },
  ModalController: function() { return /* reexport */ ModalController; },
  NoticeBar: function() { return /* reexport */ NoticeBar; },
  NumberInput: function() { return /* reexport */ NumberInput; },
  Optgroup: function() { return /* reexport */ Optgroup; },
  Option: function() { return /* reexport */ Option; },
  Pager: function() { return /* reexport */ Pager; },
  PasswordInput: function() { return /* reexport */ PasswordInput; },
  Print: function() { return /* reexport */ Print; },
  PrintPageBreak: function() { return /* reexport */ PrintPageBreak; },
  Pulldown: function() { return /* reexport */ Pulldown; },
  Radio: function() { return /* reexport */ Radio; },
  RadioButton: function() { return /* reexport */ RadioButton; },
  RadioGroup: function() { return /* reexport */ RadioGroup; },
  Rate: function() { return /* reexport */ Rate; },
  Result: function() { return /* reexport */ Result; },
  Row: function() { return /* reexport */ Row; },
  Select: function() { return /* reexport */ Select; },
  Slider: function() { return /* reexport */ Slider; },
  Split: function() { return /* reexport */ Split; },
  SplitPane: function() { return /* reexport */ SplitPane; },
  Splitter: function() { return /* reexport */ Splitter; },
  SplitterPanel: function() { return /* reexport */ SplitterPanel; },
  Steps: function() { return /* reexport */ Steps; },
  Switch: function() { return /* reexport */ Switch; },
  TabPane: function() { return /* reexport */ TabPane; },
  TableSelect: function() { return /* reexport */ TableSelect; },
  Tabs: function() { return /* reexport */ Tabs; },
  Tag: function() { return /* reexport */ Tag; },
  Text: function() { return /* reexport */ Text; },
  TextEllipsis: function() { return /* reexport */ TextEllipsis; },
  Textarea: function() { return /* reexport */ Textarea; },
  Tip: function() { return /* reexport */ Tip; },
  Tips: function() { return /* reexport */ Tips; },
  Tooltip: function() { return /* reexport */ Tooltip; },
  Tree: function() { return /* reexport */ Tree; },
  TreeSelect: function() { return /* reexport */ TreeSelect; },
  Upload: function() { return /* reexport */ Upload; },
  VxeAlert: function() { return /* reexport */ VxeAlert; },
  VxeAnchor: function() { return /* reexport */ VxeAnchor; },
  VxeAnchorLink: function() { return /* reexport */ VxeAnchorLink; },
  VxeAvatar: function() { return /* reexport */ VxeAvatar; },
  VxeBadge: function() { return /* reexport */ VxeBadge; },
  VxeBreadcrumb: function() { return /* reexport */ VxeBreadcrumb; },
  VxeBreadcrumbItem: function() { return /* reexport */ VxeBreadcrumbItem; },
  VxeButton: function() { return /* reexport */ VxeButton; },
  VxeButtonGroup: function() { return /* reexport */ VxeButtonGroup; },
  VxeCalendar: function() { return /* reexport */ VxeCalendar; },
  VxeCard: function() { return /* reexport */ VxeCard; },
  VxeCarousel: function() { return /* reexport */ VxeCarousel; },
  VxeCarouselItem: function() { return /* reexport */ VxeCarouselItem; },
  VxeCheckbox: function() { return /* reexport */ VxeCheckbox; },
  VxeCheckboxButton: function() { return /* reexport */ VxeCheckboxButton; },
  VxeCheckboxGroup: function() { return /* reexport */ VxeCheckboxGroup; },
  VxeCol: function() { return /* reexport */ VxeCol; },
  VxeCollapse: function() { return /* reexport */ VxeCollapse; },
  VxeCollapsePane: function() { return /* reexport */ VxeCollapsePane; },
  VxeColorPicker: function() { return /* reexport */ VxeColorPicker; },
  VxeCore: function() { return /* reexport */ VxeCore; },
  VxeCountdown: function() { return /* reexport */ VxeCountdown; },
  VxeDatePanel: function() { return /* reexport */ VxeDatePanel; },
  VxeDatePicker: function() { return /* reexport */ VxeDatePicker; },
  VxeDateRangePicker: function() { return /* reexport */ VxeDateRangePicker; },
  VxeDrawer: function() { return /* reexport */ VxeDrawer; },
  VxeEmpty: function() { return /* reexport */ VxeEmpty; },
  VxeForm: function() { return /* reexport */ VxeForm; },
  VxeFormGather: function() { return /* reexport */ VxeFormGather; },
  VxeFormGroup: function() { return /* reexport */ VxeFormGroup; },
  VxeFormItem: function() { return /* reexport */ VxeFormItem; },
  VxeIcon: function() { return /* reexport */ VxeIcon; },
  VxeIconPicker: function() { return /* reexport */ VxeIconPicker; },
  VxeImage: function() { return /* reexport */ VxeImage; },
  VxeImageGroup: function() { return /* reexport */ VxeImageGroup; },
  VxeImagePreview: function() { return /* reexport */ VxeImagePreview; },
  VxeInput: function() { return /* reexport */ VxeInput; },
  VxeLayoutAside: function() { return /* reexport */ VxeLayoutAside; },
  VxeLayoutBody: function() { return /* reexport */ VxeLayoutBody; },
  VxeLayoutContainer: function() { return /* reexport */ VxeLayoutContainer; },
  VxeLayoutFooter: function() { return /* reexport */ VxeLayoutFooter; },
  VxeLayoutHeader: function() { return /* reexport */ VxeLayoutHeader; },
  VxeLink: function() { return /* reexport */ VxeLink; },
  VxeList: function() { return /* reexport */ VxeList; },
  VxeLoading: function() { return /* reexport */ VxeLoading; },
  VxeMenu: function() { return /* reexport */ VxeMenu; },
  VxeModal: function() { return /* reexport */ VxeModal; },
  VxeNoticeBar: function() { return /* reexport */ VxeNoticeBar; },
  VxeNumberInput: function() { return /* reexport */ VxeNumberInput; },
  VxeOptgroup: function() { return /* reexport */ VxeOptgroup; },
  VxeOption: function() { return /* reexport */ VxeOption; },
  VxePager: function() { return /* reexport */ VxePager; },
  VxePasswordInput: function() { return /* reexport */ VxePasswordInput; },
  VxePrint: function() { return /* reexport */ VxePrint; },
  VxePrintPageBreak: function() { return /* reexport */ VxePrintPageBreak; },
  VxePulldown: function() { return /* reexport */ VxePulldown; },
  VxeRadio: function() { return /* reexport */ VxeRadio; },
  VxeRadioButton: function() { return /* reexport */ VxeRadioButton; },
  VxeRadioGroup: function() { return /* reexport */ VxeRadioGroup; },
  VxeRate: function() { return /* reexport */ VxeRate; },
  VxeResult: function() { return /* reexport */ VxeResult; },
  VxeRow: function() { return /* reexport */ VxeRow; },
  VxeSelect: function() { return /* reexport */ VxeSelect; },
  VxeSlider: function() { return /* reexport */ VxeSlider; },
  VxeSplit: function() { return /* reexport */ VxeSplit; },
  VxeSplitPane: function() { return /* reexport */ VxeSplitPane; },
  VxeSplitter: function() { return /* reexport */ VxeSplitter; },
  VxeSplitterPanel: function() { return /* reexport */ VxeSplitterPanel; },
  VxeSteps: function() { return /* reexport */ VxeSteps; },
  VxeSwitch: function() { return /* reexport */ VxeSwitch; },
  VxeTabPane: function() { return /* reexport */ VxeTabPane; },
  VxeTableSelect: function() { return /* reexport */ VxeTableSelect; },
  VxeTabs: function() { return /* reexport */ VxeTabs; },
  VxeTag: function() { return /* reexport */ VxeTag; },
  VxeText: function() { return /* reexport */ VxeText; },
  VxeTextEllipsis: function() { return /* reexport */ VxeTextEllipsis; },
  VxeTextarea: function() { return /* reexport */ VxeTextarea; },
  VxeTip: function() { return /* reexport */ VxeTip; },
  VxeTooltip: function() { return /* reexport */ VxeTooltip; },
  VxeTree: function() { return /* reexport */ VxeTree; },
  VxeTreeSelect: function() { return /* reexport */ VxeTreeSelect; },
  VxeUI: function() { return /* reexport */ index_esm_VxeUI; },
  VxeUpload: function() { return /* reexport */ VxeUpload; },
  VxeWatermark: function() { return /* reexport */ VxeWatermark; },
  Watermark: function() { return /* reexport */ Watermark; },
  WatermarkController: function() { return /* reexport */ WatermarkController; },
  checkVersion: function() { return /* reexport */ checkVersion; },
  clipboard: function() { return /* reexport */ clipboard; },
  commands: function() { return /* reexport */ commands; },
  component: function() { return /* reexport */ component; },
  config: function() { return /* reexport */ config; },
  coreVersion: function() { return /* reexport */ coreVersion; },
  createEvent: function() { return /* reexport */ createEvent; },
  "default": function() { return /* binding */ entry_lib; },
  drawer: function() { return /* reexport */ components_drawer; },
  formats: function() { return /* reexport */ formats; },
  getComponent: function() { return /* reexport */ getComponent; },
  getConfig: function() { return /* reexport */ getConfig; },
  getI18n: function() { return /* reexport */ getI18n; },
  getIcon: function() { return /* reexport */ getIcon; },
  getLanguage: function() { return /* reexport */ getLanguage; },
  getSlotVNs: function() { return /* reexport */ getSlotVNs; },
  getTheme: function() { return /* reexport */ getTheme; },
  globalEvents: function() { return /* reexport */ globalEvents; },
  globalResize: function() { return /* reexport */ globalResize; },
  globalStore: function() { return /* reexport */ globalStore; },
  handleCheckInfo: function() { return /* reexport */ handleCheckInfo; },
  hasComponent: function() { return /* reexport */ hasComponent; },
  hasLanguage: function() { return /* reexport */ hasLanguage; },
  hooks: function() { return /* reexport */ hooks; },
  install: function() { return /* reexport */ install; },
  interceptor: function() { return /* reexport */ interceptor; },
  loading: function() { return /* reexport */ components_loading; },
  log: function() { return /* reexport */ log; },
  menus: function() { return /* reexport */ menus; },
  modal: function() { return /* reexport */ components_modal; },
  permission: function() { return /* reexport */ permission; },
  print: function() { return /* reexport */ components_print; },
  readFile: function() { return /* reexport */ readFile; },
  renderCustomIcon: function() { return /* reexport */ renderCustomIcon; },
  renderEmptyElement: function() { return /* reexport */ renderEmptyElement; },
  renderGlobalIcon: function() { return /* reexport */ renderGlobalIcon; },
  renderer: function() { return /* reexport */ renderer; },
  saveFile: function() { return /* reexport */ saveFile; },
  setConfig: function() { return /* reexport */ setConfig; },
  setI18n: function() { return /* reexport */ setI18n; },
  setIcon: function() { return /* reexport */ setIcon; },
  setLanguage: function() { return /* reexport */ setLanguage; },
  setTheme: function() { return /* reexport */ setTheme; },
  setup: function() { return /* reexport */ setup; },
  use: function() { return /* reexport */ use; },
  useFns: function() { return /* reexport */ useFns; },
  usePermission: function() { return /* reexport */ usePermission; },
  useSize: function() { return /* reexport */ useSize; },
  validators: function() { return /* reexport */ validators; },
  version: function() { return /* reexport */ ui_version; },
  watermark: function() { return /* reexport */ components_watermark; }
});

// NAMESPACE OBJECT: ./packages/components.ts
var components_namespaceObject = {};
__webpack_require__.r(components_namespaceObject);
__webpack_require__.d(components_namespaceObject, {
  Alert: function() { return Alert; },
  Anchor: function() { return Anchor; },
  AnchorLink: function() { return AnchorLink; },
  Avatar: function() { return Avatar; },
  Badge: function() { return Badge; },
  Breadcrumb: function() { return Breadcrumb; },
  BreadcrumbItem: function() { return BreadcrumbItem; },
  Button: function() { return Button; },
  ButtonGroup: function() { return ButtonGroup; },
  Calendar: function() { return Calendar; },
  Card: function() { return Card; },
  Carousel: function() { return Carousel; },
  CarouselItem: function() { return CarouselItem; },
  Checkbox: function() { return Checkbox; },
  CheckboxButton: function() { return CheckboxButton; },
  CheckboxGroup: function() { return CheckboxGroup; },
  Col: function() { return Col; },
  Collapse: function() { return Collapse; },
  CollapsePane: function() { return CollapsePane; },
  ColorPicker: function() { return ColorPicker; },
  Countdown: function() { return Countdown; },
  DatePanel: function() { return DatePanel; },
  DatePicker: function() { return DatePicker; },
  DateRangePicker: function() { return DateRangePicker; },
  Drawer: function() { return Drawer; },
  DrawerController: function() { return DrawerController; },
  Empty: function() { return Empty; },
  Form: function() { return Form; },
  FormGather: function() { return FormGather; },
  FormGroup: function() { return FormGroup; },
  FormItem: function() { return FormItem; },
  GLOBAL_EVENT_KEYS: function() { return GLOBAL_EVENT_KEYS; },
  Icon: function() { return Icon; },
  IconPicker: function() { return IconPicker; },
  Image: function() { return image_Image; },
  ImageGroup: function() { return ImageGroup; },
  ImagePreview: function() { return ImagePreview; },
  Input: function() { return Input; },
  LayoutAside: function() { return LayoutAside; },
  LayoutBody: function() { return LayoutBody; },
  LayoutContainer: function() { return LayoutContainer; },
  LayoutFooter: function() { return LayoutFooter; },
  LayoutHeader: function() { return LayoutHeader; },
  Link: function() { return Link; },
  List: function() { return List; },
  Loading: function() { return Loading; },
  LoadingController: function() { return LoadingController; },
  Menu: function() { return Menu; },
  Modal: function() { return Modal; },
  ModalController: function() { return ModalController; },
  NoticeBar: function() { return NoticeBar; },
  NumberInput: function() { return NumberInput; },
  Optgroup: function() { return Optgroup; },
  Option: function() { return Option; },
  Pager: function() { return Pager; },
  PasswordInput: function() { return PasswordInput; },
  Print: function() { return Print; },
  PrintPageBreak: function() { return PrintPageBreak; },
  Pulldown: function() { return Pulldown; },
  Radio: function() { return Radio; },
  RadioButton: function() { return RadioButton; },
  RadioGroup: function() { return RadioGroup; },
  Rate: function() { return Rate; },
  Result: function() { return Result; },
  Row: function() { return Row; },
  Select: function() { return Select; },
  Slider: function() { return Slider; },
  Split: function() { return Split; },
  SplitPane: function() { return SplitPane; },
  Splitter: function() { return Splitter; },
  SplitterPanel: function() { return SplitterPanel; },
  Steps: function() { return Steps; },
  Switch: function() { return Switch; },
  TabPane: function() { return TabPane; },
  TableSelect: function() { return TableSelect; },
  Tabs: function() { return Tabs; },
  Tag: function() { return Tag; },
  Text: function() { return Text; },
  TextEllipsis: function() { return TextEllipsis; },
  Textarea: function() { return Textarea; },
  Tip: function() { return Tip; },
  Tips: function() { return Tips; },
  Tooltip: function() { return Tooltip; },
  Tree: function() { return Tree; },
  TreeSelect: function() { return TreeSelect; },
  Upload: function() { return Upload; },
  VxeAlert: function() { return VxeAlert; },
  VxeAnchor: function() { return VxeAnchor; },
  VxeAnchorLink: function() { return VxeAnchorLink; },
  VxeAvatar: function() { return VxeAvatar; },
  VxeBadge: function() { return VxeBadge; },
  VxeBreadcrumb: function() { return VxeBreadcrumb; },
  VxeBreadcrumbItem: function() { return VxeBreadcrumbItem; },
  VxeButton: function() { return VxeButton; },
  VxeButtonGroup: function() { return VxeButtonGroup; },
  VxeCalendar: function() { return VxeCalendar; },
  VxeCard: function() { return VxeCard; },
  VxeCarousel: function() { return VxeCarousel; },
  VxeCarouselItem: function() { return VxeCarouselItem; },
  VxeCheckbox: function() { return VxeCheckbox; },
  VxeCheckboxButton: function() { return VxeCheckboxButton; },
  VxeCheckboxGroup: function() { return VxeCheckboxGroup; },
  VxeCol: function() { return VxeCol; },
  VxeCollapse: function() { return VxeCollapse; },
  VxeCollapsePane: function() { return VxeCollapsePane; },
  VxeColorPicker: function() { return VxeColorPicker; },
  VxeCore: function() { return VxeCore; },
  VxeCountdown: function() { return VxeCountdown; },
  VxeDatePanel: function() { return VxeDatePanel; },
  VxeDatePicker: function() { return VxeDatePicker; },
  VxeDateRangePicker: function() { return VxeDateRangePicker; },
  VxeDrawer: function() { return VxeDrawer; },
  VxeEmpty: function() { return VxeEmpty; },
  VxeForm: function() { return VxeForm; },
  VxeFormGather: function() { return VxeFormGather; },
  VxeFormGroup: function() { return VxeFormGroup; },
  VxeFormItem: function() { return VxeFormItem; },
  VxeIcon: function() { return VxeIcon; },
  VxeIconPicker: function() { return VxeIconPicker; },
  VxeImage: function() { return VxeImage; },
  VxeImageGroup: function() { return VxeImageGroup; },
  VxeImagePreview: function() { return VxeImagePreview; },
  VxeInput: function() { return VxeInput; },
  VxeLayoutAside: function() { return VxeLayoutAside; },
  VxeLayoutBody: function() { return VxeLayoutBody; },
  VxeLayoutContainer: function() { return VxeLayoutContainer; },
  VxeLayoutFooter: function() { return VxeLayoutFooter; },
  VxeLayoutHeader: function() { return VxeLayoutHeader; },
  VxeLink: function() { return VxeLink; },
  VxeList: function() { return VxeList; },
  VxeLoading: function() { return VxeLoading; },
  VxeMenu: function() { return VxeMenu; },
  VxeModal: function() { return VxeModal; },
  VxeNoticeBar: function() { return VxeNoticeBar; },
  VxeNumberInput: function() { return VxeNumberInput; },
  VxeOptgroup: function() { return VxeOptgroup; },
  VxeOption: function() { return VxeOption; },
  VxePager: function() { return VxePager; },
  VxePasswordInput: function() { return VxePasswordInput; },
  VxePrint: function() { return VxePrint; },
  VxePrintPageBreak: function() { return VxePrintPageBreak; },
  VxePulldown: function() { return VxePulldown; },
  VxeRadio: function() { return VxeRadio; },
  VxeRadioButton: function() { return VxeRadioButton; },
  VxeRadioGroup: function() { return VxeRadioGroup; },
  VxeRate: function() { return VxeRate; },
  VxeResult: function() { return VxeResult; },
  VxeRow: function() { return VxeRow; },
  VxeSelect: function() { return VxeSelect; },
  VxeSlider: function() { return VxeSlider; },
  VxeSplit: function() { return VxeSplit; },
  VxeSplitPane: function() { return VxeSplitPane; },
  VxeSplitter: function() { return VxeSplitter; },
  VxeSplitterPanel: function() { return VxeSplitterPanel; },
  VxeSteps: function() { return VxeSteps; },
  VxeSwitch: function() { return VxeSwitch; },
  VxeTabPane: function() { return VxeTabPane; },
  VxeTableSelect: function() { return VxeTableSelect; },
  VxeTabs: function() { return VxeTabs; },
  VxeTag: function() { return VxeTag; },
  VxeText: function() { return VxeText; },
  VxeTextEllipsis: function() { return VxeTextEllipsis; },
  VxeTextarea: function() { return VxeTextarea; },
  VxeTip: function() { return VxeTip; },
  VxeTooltip: function() { return VxeTooltip; },
  VxeTree: function() { return VxeTree; },
  VxeTreeSelect: function() { return VxeTreeSelect; },
  VxeUI: function() { return index_esm_VxeUI; },
  VxeUpload: function() { return VxeUpload; },
  VxeWatermark: function() { return VxeWatermark; },
  Watermark: function() { return Watermark; },
  WatermarkController: function() { return WatermarkController; },
  checkVersion: function() { return checkVersion; },
  clipboard: function() { return clipboard; },
  commands: function() { return commands; },
  component: function() { return component; },
  config: function() { return config; },
  coreVersion: function() { return coreVersion; },
  createEvent: function() { return createEvent; },
  drawer: function() { return components_drawer; },
  formats: function() { return formats; },
  getComponent: function() { return getComponent; },
  getConfig: function() { return getConfig; },
  getI18n: function() { return getI18n; },
  getIcon: function() { return getIcon; },
  getLanguage: function() { return getLanguage; },
  getSlotVNs: function() { return getSlotVNs; },
  getTheme: function() { return getTheme; },
  globalEvents: function() { return globalEvents; },
  globalResize: function() { return globalResize; },
  globalStore: function() { return globalStore; },
  handleCheckInfo: function() { return handleCheckInfo; },
  hasComponent: function() { return hasComponent; },
  hasLanguage: function() { return hasLanguage; },
  hooks: function() { return hooks; },
  install: function() { return install; },
  interceptor: function() { return interceptor; },
  loading: function() { return components_loading; },
  log: function() { return log; },
  menus: function() { return menus; },
  modal: function() { return components_modal; },
  permission: function() { return permission; },
  print: function() { return components_print; },
  readFile: function() { return readFile; },
  renderCustomIcon: function() { return renderCustomIcon; },
  renderEmptyElement: function() { return renderEmptyElement; },
  renderGlobalIcon: function() { return renderGlobalIcon; },
  renderer: function() { return renderer; },
  saveFile: function() { return saveFile; },
  setConfig: function() { return setConfig; },
  setI18n: function() { return setI18n; },
  setIcon: function() { return setIcon; },
  setLanguage: function() { return setLanguage; },
  setTheme: function() { return setTheme; },
  setup: function() { return setup; },
  use: function() { return use; },
  useFns: function() { return useFns; },
  usePermission: function() { return usePermission; },
  useSize: function() { return useSize; },
  validators: function() { return validators; },
  version: function() { return ui_version; },
  watermark: function() { return components_watermark; }
});

;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
/* eslint-disable no-var */
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (false) { var getCurrentScript; }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__(4114);
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/core.js
const coreVersion = "4.2.12";
const VxeCore = {
  coreVersion,
  uiVersion: '',
  tableVersion: '',
  designVersion: '',
  ganttVersion: ''
};
// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__(9274);
// EXTERNAL MODULE: external {"root":"XEUtils","commonjs":"xe-utils","commonjs2":"xe-utils","amd":"xe-utils"}
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_ = __webpack_require__(8871);
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default = /*#__PURE__*/__webpack_require__.n(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_);
;// CONCATENATED MODULE: ./node_modules/dom-zindex/es/index.esm.js
var winDom = null;
var bodyEl = null;
var storeEl = null;
var storeId = 'z-index-manage';
var styleEl = null;
var styleId = 'z-index-style';
var storeMainKey = 'm';
var storeSubKey = 's';
var storeData = {
  m: 1000,
  s: 1000
};
function getDocument() {
  if (!winDom) {
    if (typeof document !== 'undefined') {
      winDom = document;
    }
  }
  return winDom;
}
function getBody() {
  if (winDom && !bodyEl) {
    bodyEl = winDom.body || winDom.getElementsByTagName('body')[0];
  }
  return bodyEl;
}
function getDomMaxZIndex() {
  var max = 0;
  var dom = getDocument();
  if (dom) {
    var body = getBody();
    if (body) {
      var allElem = body.getElementsByTagName('*');
      for (var i = 0; i < allElem.length; i++) {
        var elem = allElem[i];
        if (elem && elem.style && elem.nodeType === 1) {
          var zIndex = elem.style.zIndex;
          if (zIndex && /^\d+$/.test(zIndex)) {
            max = Math.max(max, Number(zIndex));
          }
        }
      }
    }
  }
  return max;
}
function getStyle() {
  if (!styleEl) {
    var dom = getDocument();
    if (dom) {
      styleEl = dom.getElementById(styleId);
      if (!styleEl) {
        styleEl = dom.createElement('style');
        styleEl.id = styleId;
        dom.getElementsByTagName('head')[0].appendChild(styleEl);
      }
    }
  }
  return styleEl;
}
function updateVar() {
  var styEl = getStyle();
  if (styEl) {
    var prefixes = '--dom-';
    var propKey = '-z-index';
    styEl.innerHTML = ':root{' + prefixes + 'main' + propKey + ':' + getCurrent() + ';' + prefixes + 'sub' + propKey + ':' + getSubCurrent() + '}';
  }
}
function getStoreDom() {
  if (!storeEl) {
    var dom = getDocument();
    if (dom) {
      storeEl = dom.getElementById(storeId);
      if (!storeEl) {
        var body = getBody();
        if (body) {
          storeEl = dom.createElement('div');
          storeEl.id = storeId;
          storeEl.style.display = 'none';
          body.appendChild(storeEl);
          setCurrent(storeData.m);
          setSubCurrent(storeData.s);
        }
      }
    }
  }
  return storeEl;
}
function createSetHandle(key) {
  return function (value) {
    if (value) {
      value = Number(value);
      storeData[key] = value;
      var el = getStoreDom();
      if (el) {
        if (el.dataset) {
          el.dataset[key] = value + '';
        } else {
          el.setAttribute('data-' + key, value + '');
        }
      }
    }
    updateVar();
    return storeData[key];
  };
}
var setCurrent = createSetHandle(storeMainKey);
function createGetHandle(key, nextMethod) {
  return function getCurrent(currZindex) {
    var zIndex;
    var el = getStoreDom();
    if (el) {
      var domVal = el.dataset ? el.dataset[key] : el.getAttribute('data-' + key);
      if (domVal) {
        zIndex = Number(domVal);
      }
    }
    if (!zIndex) {
      zIndex = storeData[key];
    }
    if (currZindex) {
      if (Number(currZindex) < zIndex) {
        return nextMethod();
      }
      return currZindex;
    }
    return zIndex;
  };
}
var getCurrent = createGetHandle(storeMainKey, getNext);
function getNext() {
  return setCurrent(getCurrent() + 1);
}
var setSubCurrent = createSetHandle(storeSubKey);
var _getSubCurrent = createGetHandle(storeSubKey, getSubNext);
function getSubCurrent() {
  return getCurrent() + _getSubCurrent();
}
function getSubNext() {
  setSubCurrent(_getSubCurrent() + 1);
  return getSubCurrent();
}
/**
 * Web common z-index style management
 */
var DomZIndex = {
  setCurrent: setCurrent,
  getCurrent: getCurrent,
  getNext: getNext,
  setSubCurrent: setSubCurrent,
  getSubCurrent: getSubCurrent,
  getSubNext: getSubNext,
  getMax: getDomMaxZIndex
};
updateVar();
/* harmony default export */ var index_esm = (DomZIndex);
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/configStore.js
const globalConfigStore = {
  size: '',
  version: 1,
  zIndex: 999,
  resizeInterval: 500
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/themeStore.js
const themeConfigStore = {
  theme: ''
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/theme.js


function setTheme(name) {
  const theme = !name || name === 'default' ? 'light' : name;
  themeConfigStore.theme = theme;
  if (typeof document !== 'undefined') {
    const documentElement = document.documentElement;
    if (documentElement) {
      documentElement.setAttribute('data-vxe-ui-theme', theme);
    }
  }
  return VxeCore;
}
function getTheme() {
  return themeConfigStore.theme;
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/config.js





/**
* å¨å±åæ°è®¾ç½®
*/
function setConfig(options) {
  if (options) {
    if (options.zIndex) {
      index_esm.setCurrent(options.zIndex);
    }
    if (options.theme) {
      setTheme(options.theme);
    }
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(globalConfigStore, options);
  }
  return VxeCore;
}
/**
* è·åå¨å±åæ°
*/
function getConfig(key, defaultValue) {
  return arguments.length ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(globalConfigStore, key, defaultValue) : globalConfigStore;
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/dataStore.js
const globalStore = {};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/iconStore.js
const iconConfigStore = {};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/vm.js

function getSlotVNs(vns) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(vns)) {
    return vns;
  }
  return vns ? [vns] : [];
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/icon.js





function setIcon(options) {
  if (options) {
    Object.assign(iconConfigStore, options);
  }
  return VxeCore;
}
function getIcon(key) {
  return arguments.length ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(iconConfigStore, key) : iconConfigStore;
}
function renderGlobalIcon(name) {
  const icon = getIcon(name);
  return renderCustomIcon(icon, name);
}
function renderCustomIcon(icon, name) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(icon)) {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, getSlotVNs(icon({
      name
    })));
  }
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
    class: icon
  });
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/event.js


const GLOBAL_EVENT_KEYS = {
  F2: 'F2',
  ESCAPE: 'Escape',
  ENTER: 'Enter',
  TAB: 'Tab',
  DELETE: 'Delete',
  BACKSPACE: 'Backspace',
  SPACEBAR: ' ',
  CONTEXT_MENU: 'ContextMenu',
  ARROW_UP: 'ArrowUp',
  ARROW_DOWN: 'ArrowDown',
  ARROW_LEFT: 'ArrowLeft',
  ARROW_RIGHT: 'ArrowRight',
  PAGE_UP: 'PageUp',
  PAGE_DOWN: 'PageDown',
  Control: 'Control',
  R: 'R',
  P: 'P',
  Z: 'Z',
  X: 'X',
  C: 'C',
  V: 'V',
  M: 'M'
};
const browse = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
const convertEventKeys = {
  ' ': 'Spacebar',
  Apps: GLOBAL_EVENT_KEYS.CONTEXT_MENU,
  Del: GLOBAL_EVENT_KEYS.DELETE,
  Up: GLOBAL_EVENT_KEYS.ARROW_UP,
  Down: GLOBAL_EVENT_KEYS.ARROW_DOWN,
  Left: GLOBAL_EVENT_KEYS.ARROW_LEFT,
  Right: GLOBAL_EVENT_KEYS.ARROW_RIGHT
};
// çå¬å¨å±äºä»¶
const wheelName = browse.firefox ? 'DOMMouseScroll' : 'mousewheel';
const eventStore = [];
function triggerEvent(evnt) {
  const isWheel = evnt.type === wheelName;
  eventStore.forEach(({
    type,
    cb
  }) => {
    // å¦æè¢«åæ¶åæ³¡ï¼ä¸åæ§è¡
    if (!evnt.cancelBubble) {
      if (type === evnt.type || isWheel && type === 'mousewheel') {
        cb(evnt);
      }
    }
  });
}
class VxeComponentEvent {
  constructor(evnt, params1, params2) {
    Object.defineProperty(this, "$event", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ''
    });
    Object.defineProperty(this, "key", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ''
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ''
    });
    this.$event = evnt;
    if (evnt) {
      if (evnt.type) {
        this.type = evnt.type;
      }
      if (evnt.key) {
        this.key = evnt.key;
      }
      if (evnt.code) {
        this.code = evnt.code;
      }
    }
    Object.assign(this, params1);
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(params2, (val, key) => {
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(val)) {
        let rest = null;
        let isRun = false;
        Object.defineProperty(this, key, {
          get() {
            if (!isRun) {
              isRun = true;
              rest = val();
            }
            return rest;
          }
        });
      } else {
        this[key] = val;
      }
    });
  }
  stopPropagation() {
    const evnt = this.$event;
    if (evnt) {
      evnt.stopPropagation();
    }
  }
  preventDefault() {
    const evnt = this.$event;
    if (evnt) {
      evnt.preventDefault();
    }
  }
}
const createEvent = (evnt, params1, params2) => {
  if (evnt instanceof VxeComponentEvent) {
    evnt = evnt.$event;
  }
  return new VxeComponentEvent(evnt, params1, params2);
};
const globalEvents = {
  on(comp, type, cb) {
    eventStore.push({
      comp,
      type,
      cb
    });
  },
  off(comp, type) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(eventStore, item => item.comp === comp && item.type === type);
  },
  hasKey(evnt, targetKey) {
    const {
      key
    } = evnt;
    targetKey = targetKey.toLowerCase();
    return key ? targetKey === key.toLowerCase() || !!(convertEventKeys[key] && convertEventKeys[key].toLowerCase() === targetKey) : false;
  }
};
if (browse.isDoc) {
  if (!browse.msie) {
    window.addEventListener('copy', triggerEvent, false);
    window.addEventListener('cut', triggerEvent, false);
    window.addEventListener('paste', triggerEvent, false);
  }
  document.addEventListener('keydown', triggerEvent, false);
  document.addEventListener('contextmenu', triggerEvent, false);
  window.addEventListener('mousedown', triggerEvent, false);
  window.addEventListener('blur', triggerEvent, false);
  window.addEventListener('resize', triggerEvent, false);
  window.addEventListener(wheelName, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().throttle(triggerEvent, 100, {
    leading: true,
    trailing: false
  }), {
    passive: true,
    capture: false
  });
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/resize.js



/**
 * çå¬ resize äºä»¶
 * å¦æé¡¹ç®ä¸­å·²ä½¿ç¨äº resize-observer-polyfillï¼é£ä¹åªéè¦å°æ¹æ³å®ä¹å¨å±ï¼è¯¥ç»ä»¶å°±ä¼èªå¨ä½¿ç¨
 */
let resizeTimeout;
/* eslint-disable no-use-before-define */
const resize_eventStore = [];
const defaultInterval = 500;
function eventHandle() {
  if (resize_eventStore.length) {
    resize_eventStore.forEach(item => {
      item.tarList.forEach(observer => {
        const {
          target,
          width,
          heighe
        } = observer;
        const clientWidth = target.clientWidth;
        const clientHeight = target.clientHeight;
        const rWidth = clientWidth && width !== clientWidth;
        const rHeight = clientHeight && heighe !== clientHeight;
        if (rWidth || rHeight) {
          observer.width = clientWidth;
          observer.heighe = clientHeight;
          setTimeout(item.callback);
        }
      });
    });
    /* eslint-disable @typescript-eslint/no-use-before-define */
    eventListener();
  }
}
function eventListener() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(eventHandle, globalConfigStore.resizeInterval || defaultInterval);
}
class XEResizeObserver {
  constructor(callback) {
    Object.defineProperty(this, "tarList", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "callback", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.callback = callback;
  }
  observe(target) {
    if (target) {
      const {
        tarList
      } = this;
      if (!tarList.some(observer => observer.target === target)) {
        tarList.push({
          target,
          width: target.clientWidth,
          heighe: target.clientHeight
        });
      }
      if (!resize_eventStore.length) {
        eventListener();
      }
      if (!resize_eventStore.some(item => item === this)) {
        resize_eventStore.push(this);
      }
    }
  }
  unobserve(target) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(resize_eventStore, item => item.tarList.some(observer => observer.target === target));
  }
  disconnect() {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(resize_eventStore, item => item === this);
  }
}
const globalResize = {
  create(callback) {
    if (window.ResizeObserver) {
      return new window.ResizeObserver(callback);
    }
    return new XEResizeObserver(callback);
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/i18nStore.js

const i18nConfigStore = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
  language: '',
  langMaps: {}
});
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/i18n.js




let checkInstall = false;
let cacheMaps = {};
function getI18n(key, args) {
  const {
    langMaps,
    language
  } = i18nConfigStore;
  const {
    i18n
  } = globalConfigStore;
  if (i18n) {
    return `${i18n(key, args) || ''}`;
  }
  if (!checkInstall) {
    if (!langMaps[language]) {
      console.error(`[vxe core] è¯­è¨åæªå®è£ãLanguage not installed. https://${VxeCore.uiVersion ? 'vxeui.com' : 'vxetable.cn'}/#/start/i18n`);
    }
    checkInstall = true;
  }
  if (!args && cacheMaps[key]) {
    return cacheMaps[key];
  }
  const i18nLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFormatString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(langMaps[language], key, key), args);
  if (!args) {
    cacheMaps[key] = i18nLabel;
  }
  return i18nLabel;
}
function setLanguage(locale) {
  const {
    language
  } = i18nConfigStore;
  const targetlang = locale || 'zh-CN';
  if (language !== targetlang) {
    i18nConfigStore.language = targetlang;
    cacheMaps = {};
  }
  return VxeCore;
}
function setI18n(locale, data) {
  i18nConfigStore.langMaps[locale] = Object.assign({}, data);
  return VxeCore;
}
function hasLanguage(language) {
  const {
    langMaps
  } = i18nConfigStore;
  return !!langMaps[language];
}
function getLanguage() {
  const {
    language
  } = i18nConfigStore;
  return language;
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/log.js

function createLog(type, name) {
  return function (key, args) {
    const msg = `[vxe ${name || ''}] ${getI18n(key, args)}`;
    console[type](msg);
    return msg;
  };
}
const version = "4.2.12";
const log = {
  create: createLog,
  warn: createLog('warn', `v${version}`),
  err: createLog('error', `v${version}`)
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/renderer.js


/**
 * åç½®çç»ä»¶æ¸²æ
 */
const renderMap = {};
/**
 * å¨å±æ¸²æå¨
 */
const renderer = {
  mixin(opts) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(opts, (options, name) => renderer.add(name, options));
    return renderer;
  },
  get(name) {
    return renderMap[name] || null;
  },
  add(name, options) {
    if (name && options) {
      const renders = renderMap[name];
      if (renders) {
        // æ£æµæ¯å¦è¦ç
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (val, key) => {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(renders[key]) && renders[key] !== val) {
            log.warn('vxe.error.coverProp', [`Renderer.${name}`, key]);
          }
        });
        Object.assign(renders, options);
      } else {
        renderMap[name] = options;
      }
    }
    return renderer;
  },
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(renderMap, callback);
    return renderer;
  },
  delete(name) {
    delete renderMap[name];
    return renderer;
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/store.js


/**
 * åå»ºæ°æ®ä»åº
 */
class Store {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, options) {
    const conf = this.store[name];
    // æ£æµæ¯å¦è¦ç
    const confKeys = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(conf);
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      if (confKeys.includes(key)) {
        log.warn('vxe.error.coverProp', [name, key]);
      }
    });
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, options) : options;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
/* harmony default export */ var store = (Store);
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/validators.js

const validators = new store();
Object.assign(validators, {
  _name: 'Validators'
});
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/menus.js


class VXEMenusStore {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    // å¼å®¹
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      log.warn('vxe.error.delProp', ['menus -> callback', 'menuMethod']);
      render = {
        menuMethod: render
      };
    }
    // æ£æµæ¯å¦è¦ç
    const confKeys = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(conf);
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(render, (item, key) => {
      if (confKeys.includes(key)) {
        log.warn('vxe.error.coverProp', [name, key]);
      }
    });
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
const menus = new VXEMenusStore();
Object.assign(menus, {
  _name: 'Menus'
});
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/formats.js


class VXEFormatsStore {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    // å¼å®¹
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      log.warn('vxe.error.delProp', ['formats -> callback', 'cellFormatMethod']);
      render = {
        cellFormatMethod: render
      };
    }
    // æ£æµæ¯å¦è¦ç
    const confKeys = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(conf);
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(render, (item, key) => {
      if (confKeys.includes(key)) {
        log.warn('vxe.error.coverProp', [name, key]);
      }
    });
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
const formats = new VXEFormatsStore();
Object.assign(formats, {
  _name: 'Formats'
});
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/commands.js


class VXECommandsStore {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    // å¼å®¹
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      log.warn('vxe.error.delProp', ['commands -> callback', 'commandMethod']);
      render = {
        commandMethod: render
      };
    }
    // æ£æµæ¯å¦è¦ç
    const confKeys = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(conf);
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(render, (item, key) => {
      if (confKeys.includes(key)) {
        log.warn('vxe.error.coverProp', [name, key]);
      }
    });
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
const commands = new VXECommandsStore();
Object.assign(commands, {
  _name: 'Commands'
});
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/interceptor.js



const storeMap = {};
const interceptor = {
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (render, type) => {
      interceptor.add(type, render);
    });
    return interceptor;
  },
  get(type) {
    return storeMap[type] || [];
  },
  add(type, render) {
    // å¼å®¹
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      //   log.warn('vxe.error.delProp', ['interceptor -> callback', 'tableInterceptorMethod'])
      render = {
        tableInterceptorMethod: render
      };
    }
    const callback = render.tableInterceptorMethod;
    if (callback) {
      let eList = storeMap[type];
      if (!eList) {
        eList = storeMap[type] = [];
      }
      // æ£æµéå¤
      if (eList.indexOf(callback) > -1) {
        log.warn('vxe.error.coverProp', ['Interceptor', type]);
      }
      eList.push(callback);
    }
    return interceptor;
  },
  delete(type, render) {
    const eList = storeMap[type];
    if (eList) {
      // å¼å®¹
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
        render = {
          tableInterceptorMethod: render
        };
      }
      const callback = render ? render.tableInterceptorMethod : null;
      if (callback) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(eList, fn => fn === callback);
      } else {
        delete storeMap[type];
      }
    }
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/clipboard.js

let copyElem;
const clipStore = {
  text: '',
  html: ''
};
function handleText(text) {
  if (!copyElem) {
    copyElem = document.createElement('textarea');
    copyElem.id = '$VxeCopy';
    const styles = copyElem.style;
    styles.width = '48px';
    styles.height = '24px';
    styles.position = 'fixed';
    styles.zIndex = '0';
    styles.left = '-500px';
    styles.top = '-500px';
    document.body.appendChild(copyElem);
  }
  copyElem.value = text;
}
const clipboard = {
  getStore() {
    return clipStore;
  },
  setStore(data) {
    Object.assign(clipStore, data || {});
  },
  /**
   * å¤å¶åå®¹å°åªè´´æ¿
   *
   * @param {String} content Text åå®¹
   */
  copy(content) {
    let result = false;
    try {
      const text = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content);
      handleText(text);
      copyElem.select();
      copyElem.setSelectionRange(0, copyElem.value.length);
      result = document.execCommand('copy');
      copyElem.blur();
      clipStore.text = text;
      clipStore.html = '';
    } catch (e) {}
    return result;
  },
  getText() {
    return clipStore.text || '';
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/permission.js


function handleCheckInfo(permissionCode, permissionMethod) {
  let checkVisible = true;
  let checkDisabled = false;
  const checkMethod = permissionMethod || globalConfigStore.permissionMethod;
  if (permissionCode && checkMethod) {
    checkVisible = false;
    checkDisabled = true;
    let vDone = false;
    let dDone = false;
    // æ ä½¿ç¨ | éå¼ï¼ä»»æä¸ä¸ªä¸ºå¯è§ï¼åå¯è§ï¼ä»»æä¸ä¸ªç¦ç¨ï¼åç¦ç¨
    const codeList = String(permissionCode).split('|');
    for (let i = 0; i < codeList.length; i++) {
      const code = codeList[i];
      let visible = true;
      let disabled = false;
      const rest = checkMethod({
        code
      });
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(rest)) {
        visible = rest;
      } else if (rest) {
        visible = !!rest.visible;
        disabled = !!rest.disabled;
      }
      if (!disabled && !dDone) {
        dDone = true;
        checkDisabled = disabled;
      }
      if (visible && !vDone) {
        vDone = true;
        checkVisible = visible;
      }
      if (vDone && dDone) {
        break;
      }
    }
  }
  const info = {
    code: permissionCode,
    visible: checkVisible,
    disabled: checkDisabled
  };
  return info;
}
const permission = {
  getCheckInfo(code) {
    return handleCheckInfo(code);
  },
  checkVisible(code) {
    const permissionInfo = handleCheckInfo(code);
    return permissionInfo.visible;
  },
  checkDisable(code) {
    const permissionInfo = handleCheckInfo(code);
    return permissionInfo.disabled;
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/hooks.js

const hooks = new store();
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/useFns.js


function useSize(props) {
  // ç»ä»¶å°ºå¯¸ä¸ä¸æ
  const xeSizeInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeSizeInfo', null);
  const computeSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return props.size || (xeSizeInfo ? xeSizeInfo.value : null);
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeSizeInfo', computeSize);
  return {
    computeSize
  };
}
function usePermission(props) {
  const computePermissionInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return handleCheckInfo(props.permissionCode, props.permissionMethod);
  });
  return {
    computePermissionInfo
  };
}
const useFns = {
  useSize,
  usePermission
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/index.esm.js























const installedPlugins = [];
function use(Plugin, options) {
  if (Plugin && Plugin.install) {
    if (installedPlugins.indexOf(Plugin) === -1) {
      Plugin.install(index_esm_VxeUI, options);
      installedPlugins.push(Plugin);
    }
  }
  return index_esm_VxeUI;
}
const components = {};
function getComponent(name) {
  return components[name] || null;
}
function hasComponent(name) {
  return !!components[name];
}
function component(comp) {
  if (comp && comp.name) {
    components[comp.name] = comp;
    components[external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().kebabCase(comp.name)] = comp;
  }
}
function renderEmptyElement() {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
}
function checkVersion(version, pVersion, sVersion) {
  if (version) {
    const vRest = `${version}`.match(/(\d+).(\d+).(\d+)/);
    if (vRest) {
      const pV = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(vRest[1]);
      if (sVersion) {
        const sV = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(vRest[2]);
        return pV >= pVersion && sV >= sVersion;
      }
      return pV >= pVersion;
    }
  }
  return false;
}
const index_esm_VxeUI = Object.assign(VxeCore, {
  renderEmptyElement,
  setTheme: setTheme,
  getTheme: getTheme,
  setConfig: setConfig,
  getConfig: getConfig,
  setIcon: setIcon,
  getIcon: getIcon,
  renderGlobalIcon: renderGlobalIcon,
  renderCustomIcon: renderCustomIcon,
  setLanguage: setLanguage,
  hasLanguage: hasLanguage,
  getLanguage: getLanguage,
  setI18n: setI18n,
  getI18n: getI18n,
  globalEvents: globalEvents,
  GLOBAL_EVENT_KEYS: GLOBAL_EVENT_KEYS,
  createEvent: createEvent,
  globalResize: globalResize,
  renderer: renderer,
  validators: validators,
  menus: menus,
  formats: formats,
  commands: commands,
  interceptor: interceptor,
  clipboard: clipboard,
  log: log,
  permission: permission,
  globalStore: globalStore,
  hooks: hooks,
  component,
  getComponent,
  hasComponent,
  useFns: useFns,
  getSlotVNs: getSlotVNs,
  checkVersion,
  use
});
setTheme();




















/* harmony default export */ var es_index_esm = ((/* unused pure expression or super */ null && (index_esm_VxeUI)));
;// CONCATENATED MODULE: ./packages/ui/src/comp.ts

const defineVxeComponent = external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent;
;// CONCATENATED MODULE: ./packages/dynamics/index.ts



let dynamicContainerElem;
const dynamicStore = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
  modals: [],
  drawers: [],
  globalLoading: null,
  globalWatermark: null
});
/**
 * å¨æç»ä»¶
 */
const VxeDynamics = defineVxeComponent({
  setup() {
    const VxeUIModalComponent = index_esm_VxeUI.getComponent('vxe-modal');
    const VxeUIDrawerComponent = index_esm_VxeUI.getComponent('vxe-drawer');
    const VxeUILoadingComponent = index_esm_VxeUI.getComponent('vxe-loading');
    const VxeUIWatermarkComponent = index_esm_VxeUI.getComponent('vxe-watermark');
    return () => {
      const {
        modals,
        drawers,
        globalWatermark,
        globalLoading
      } = dynamicStore;
      return [modals.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 1,
        class: 'vxe-dynamics--modal'
      }, modals.map(item => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIModalComponent, item))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), drawers.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 2,
        class: 'vxe-dynamics--drawer'
      }, drawers.map(item => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIDrawerComponent, item))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), globalWatermark ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIWatermarkComponent, globalWatermark) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), globalLoading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUILoadingComponent, globalLoading) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()];
    };
  }
});
const dynamicApp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createApp)(VxeDynamics);
function checkDynamic() {
  if (!dynamicContainerElem) {
    dynamicContainerElem = document.createElement('div');
    dynamicContainerElem.className = 'vxe-dynamics';
    document.body.appendChild(dynamicContainerElem);
    dynamicApp.mount(dynamicContainerElem);
  }
}
;// CONCATENATED MODULE: ./packages/ui/src/log.ts

const log_version = `ui v${"4.10.27"}`;
const warnLog = log.create('warn', log_version);
const errLog = log.create('error', log_version);
;// CONCATENATED MODULE: ./packages/ui/index.ts



const ui_version = "4.10.27";
index_esm_VxeUI.uiVersion = ui_version;
index_esm_VxeUI.dynamicApp = dynamicApp;
function config(options) {
  warnLog('vxe.error.delFunc', ['config', 'setConfig']);
  return setConfig(options);
}
function setup(options) {
  warnLog('vxe.error.delFunc', ['setup', 'setConfig']);
  return setConfig(options);
}
index_esm_VxeUI.config = config;
index_esm_VxeUI.setup = setup;
setConfig({
  alert: {},
  anchor: {},
  anchorLink: {},
  avatar: {},
  badge: {},
  breadcrumb: {
    separator: '/'
  },
  breadcrumbItem: {},
  button: {
    trigger: 'hover',
    // destroyOnClose: false,
    prefixTooltip: {
      enterable: true
    },
    suffixTooltip: {
      enterable: true
    }
  },
  buttonGroup: {},
  calendar: {
    minDate: new Date(1900, 0, 1),
    maxDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1
  },
  card: {
    border: true,
    padding: true
  },
  carousel: {
    height: 200,
    loop: true,
    interval: 5000
  },
  carouselItem: {},
  checkbox: {},
  checkboxButton: {},
  checkboxGroup: {},
  col: {},
  collapse: {
    padding: true,
    expandConfig: {
      showIcon: true
    }
  },
  collapsePane: {},
  countdown: {},
  colorPicker: {
    type: 'rgb',
    clearable: true,
    showAlpha: true,
    clickToCopy: true,
    showColorExtractor: true,
    showQuick: true
  },
  datePanel: {
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1
  },
  datePicker: {
    // size: null,
    // transfer: false,
    shortcutConfig: {
      // position: 'left',
      align: 'left',
      mode: 'text',
      autoClose: true
    },
    startDay: 1,
    selectDay: 1,
    autoClose: true,
    showClearButton: null,
    showConfirmButton: null
  },
  dateRangePicker: {
    // size: null,
    // transfer: false,
    shortcutConfig: {
      // position: 'left',
      align: 'left',
      mode: 'text',
      autoClose: true
    },
    startDay: 1,
    selectDay: 1,
    separator: ' ~ ',
    autoClose: true,
    showClearButton: null,
    showConfirmButton: null
  },
  drawer: {
    // size: null,
    position: 'right',
    showHeader: true,
    lockView: true,
    mask: true,
    showTitleOverflow: true,
    showClose: true,
    padding: true,
    // destroyOnClose: false,
    cancelClosable: true,
    confirmClosable: true
  },
  empty: {},
  form: {
    // preventSubmit: false,
    // size: null,
    // colon: false,
    validConfig: {
      showErrorMessage: true,
      autoPos: true,
      theme: 'beautify'
    },
    tooltipConfig: {
      enterable: true
    },
    titleAsterisk: true,
    titleOverflow: false,
    padding: true
  },
  formDesign: {
    height: 400,
    showHeader: true,
    showPc: true
  },
  formGather: {},
  formGroup: {},
  formItem: {},
  formView: {},
  icon: {},
  iconPicker: {
    icons: ['home', 'company', 'comment', 'setting', 'send', 'envelope', 'envelope-open', 'bell', 'search', 'print', 'pc', 'goods', 'chart-line', 'edit', 'delete', 'save', 'folder', 'microphone', 'flag', 'link', 'location', 'sunny', 'rmb', 'usd', 'user', 'add-user', 'add-users', 'star', 'unlock', 'time', 'text', 'feedback', 'calendar', 'association-form', 'cloud-download', 'cloud-upload', 'file', 'subtable', 'chart-bar-x', 'chart-bar-y', 'chart-line', 'chart-pie', 'chart-radar']
  },
  image: {
    showPreview: true,
    showPrintButton: true,
    maskClosable: true
  },
  imageGroup: {
    showPreview: true,
    showPrintButton: true
  },
  imagePreview: {
    showPrintButton: true
  },
  input: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1,
    digits: 2,
    controls: true
  },
  layoutAside: {},
  layoutBody: {},
  layoutContainer: {},
  layoutFooter: {},
  layoutHeader: {},
  link: {
    underline: true
  },
  listDesign: {
    height: 400,
    showPc: true
  },
  listView: {},
  list: {
    // size: null,
    virtualYConfig: {
      enabled: true,
      gt: 100
      // oSize: 0
    }
  },
  loading: {
    showIcon: true,
    showText: true
  },
  menu: {},
  modal: {
    // size: null,
    top: 16,
    showHeader: true,
    minWidth: 340,
    minHeight: 140,
    lockView: true,
    mask: true,
    duration: 3000,
    marginSize: 0,
    dblclickZoom: true,
    showTitleOverflow: true,
    animat: true,
    showClose: true,
    padding: true,
    draggable: true,
    showConfirmButton: null,
    cancelClosable: true,
    confirmClosable: true,
    zoomConfig: {
      minimizeMaxSize: 10,
      minimizeVerticalOffset: {
        top: -24,
        left: 0
      },
      minimizeHorizontalOffset: {
        top: 0,
        left: 32
      }
    },
    // destroyOnClose: false,
    // remember: false,
    // storage: false,
    storageKey: 'VXE_MODAL_POSITION'
  },
  noticeBar: {},
  numberInput: {
    // size: null,
    // transfer: false
    digits: 2,
    autoFill: true,
    controlConfig: {
      enabled: true,
      layout: 'right',
      showButton: true,
      isWheel: true,
      isArrow: true
    }
  },
  optgroup: {},
  option: {},
  pager: {
    pageSizePlacement: 'top'
    // size: null,
    // autoHidden: false,
    // perfect: true,
    // pageSize: 10,
    // pagerCount: 7,
    // pageSizes: [10, 15, 20, 50, 100],
    // layouts: ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
  },
  print: {
    pageStyle: {}
  },
  passwordInput: {
    controls: true
  },
  printPageBreak: {},
  pulldown: {
    // destroyOnClose: false
  },
  radio: {
    strict: true
  },
  radioButton: {
    strict: true
  },
  radioGroup: {
    strict: true
  },
  rate: {},
  result: {},
  row: {},
  select: {
    multiCharOverflow: 8,
    remoteConfig: {
      enabled: true,
      autoLoad: true
    },
    virtualYConfig: {
      enabled: true,
      gt: 50,
      oSize: 2
    }
  },
  splitter: {
    resize: true,
    itemConfig: {
      minWidth: 40,
      minHeight: 40
    },
    resizeConfig: {
      // immediate: false,
      showTip: true
    }
  },
  splitterPanel: {},
  slider: {
    max: 100,
    min: 0
  },
  steps: {},
  switch: {},
  tabPane: {},
  tableSelect: {
    gridConfig: {
      showOverflow: true,
      showHeaderOverflow: true,
      showFooterOverflow: true,
      rowConfig: {
        isHover: true
      },
      virtualXConfig: {
        enabled: true,
        gt: 0
      },
      virtualYConfig: {
        enabled: true,
        gt: 0
      }
    }
  },
  tabs: {
    // destroyOnClose: false
  },
  tag: {},
  textEllipsis: {
    underline: true
  },
  text: {
    copyConfig: {
      showMessage: true
    }
  },
  textarea: {
    resize: 'none'
  },
  tip: {},
  tooltip: {
    // size: null,
    // enterable: false,
    trigger: 'hover',
    theme: 'dark',
    enterDelay: 500,
    leaveDelay: 300,
    isArrow: true
  },
  tree: {
    // autoResize: false,
    indent: 20,
    minHeight: 60,
    radioConfig: {
      strict: true
    },
    virtualYConfig: {
      enabled: true,
      gt: 50,
      oSize: 2
    }
  },
  treeSelect: {
    autoClose: true,
    virtualYConfig: {
      enabled: true,
      gt: 0,
      oSize: 2
    },
    treeConfig: {
      maxHeight: 300,
      radioConfig: {},
      checkboxConfig: {},
      filterConfig: {
        autoExpandAll: true
      }
    }
  },
  upload: {
    mode: 'all',
    imageTypes: ['jpg', 'jpeg', 'png', 'gif'],
    showList: true,
    showUploadButton: true,
    showButtonText: true,
    showRemoveButton: true,
    showButtonIcon: true,
    showPreview: true,
    dragToUpload: true,
    // imageConfig: {},
    showLimitSize: true,
    showLimitCount: true,
    autoSubmit: true,
    // urlArgs: false,
    maxSimultaneousUploads: 5
  },
  watermark: {
    rotate: -30,
    gap: [100, 100]
  },
  table: {},
  colgroup: {},
  column: {},
  toolbar: {},
  grid: {},
  gantt: {}
});
const iconPrefix = 'vxe-icon-';
setIcon({
  // loading
  LOADING: iconPrefix + 'spinner roll vxe-loading--default-icon',
  // button
  BUTTON_DROPDOWN: iconPrefix + 'arrow-down',
  BUTTON_LOADING: iconPrefix + 'spinner roll',
  BUTTON_TOOLTIP_ICON: iconPrefix + 'question-circle-fill',
  // menu
  MENU_ITEM_EXPAND_OPEN: iconPrefix + 'arrow-down rotate180',
  MENU_ITEM_EXPAND_CLOSE: iconPrefix + 'arrow-down',
  // select
  SELECT_LOADED: iconPrefix + 'spinner roll',
  SELECT_OPEN: iconPrefix + 'caret-down rotate180',
  SELECT_CLOSE: iconPrefix + 'caret-down',
  SELECT_ADD_OPTION: iconPrefix + 'add',
  // icon-picker
  ICON_PICKER_OPEN: iconPrefix + 'caret-down rotate180',
  ICON_PICKER_CLOSE: iconPrefix + 'caret-down',
  // pager
  PAGER_HOME: iconPrefix + 'home-page',
  PAGER_END: iconPrefix + 'end-page',
  PAGER_JUMP_PREV: iconPrefix + 'arrow-double-left',
  PAGER_JUMP_NEXT: iconPrefix + 'arrow-double-right',
  PAGER_PREV_PAGE: iconPrefix + 'arrow-left',
  PAGER_NEXT_PAGE: iconPrefix + 'arrow-right',
  PAGER_JUMP_MORE: iconPrefix + 'ellipsis-h',
  // radio
  RADIO_CHECKED: iconPrefix + 'radio-checked-fill',
  RADIO_UNCHECKED: iconPrefix + 'radio-unchecked',
  RADIO_DISABLED_UNCHECKED: iconPrefix + 'radio-unchecked-fill',
  // checkbox
  CHECKBOX_INDETERMINATE: iconPrefix + 'checkbox-indeterminate-fill',
  CHECKBOX_CHECKED: iconPrefix + 'checkbox-checked-fill',
  CHECKBOX_UNCHECKED: iconPrefix + 'checkbox-unchecked',
  CHECKBOX_DISABLED_UNCHECKED: iconPrefix + 'checkbox-unchecked-fill',
  // input
  INPUT_CLEAR: iconPrefix + 'error-circle-fill',
  INPUT_SEARCH: iconPrefix + 'search',
  INPUT_PLUS_NUM: iconPrefix + 'caret-up',
  INPUT_MINUS_NUM: iconPrefix + 'caret-down',
  // number-picker
  NUMBER_INPUT_MINUS_NUM: iconPrefix + 'minus',
  NUMBER_INPUT_PLUS_NUM: iconPrefix + 'add',
  // date-picker
  DATE_PICKER_DATE: iconPrefix + 'calendar',
  // password-input
  PASSWORD_INPUT_SHOW_PWD: iconPrefix + 'eye-fill-close',
  PASSWORD_INPUT_HIDE_PWD: iconPrefix + 'eye-fill',
  // modal
  MODAL_ZOOM_MIN: iconPrefix + 'minus',
  MODAL_ZOOM_REVERT: iconPrefix + 'recover',
  MODAL_ZOOM_IN: iconPrefix + 'square',
  MODAL_ZOOM_OUT: iconPrefix + 'maximize',
  MODAL_CLOSE: iconPrefix + 'close',
  MODAL_INFO: iconPrefix + 'info-circle-fill',
  MODAL_SUCCESS: iconPrefix + 'success-circle-fill',
  MODAL_WARNING: iconPrefix + 'warning-circle-fill',
  MODAL_ERROR: iconPrefix + 'error-circle-fill',
  MODAL_QUESTION: iconPrefix + 'question-circle-fill',
  MODAL_LOADING: iconPrefix + 'spinner roll',
  // drawer
  DRAWER_CLOSE: iconPrefix + 'close',
  // form
  FORM_PREFIX: iconPrefix + 'question-circle-fill',
  FORM_SUFFIX: iconPrefix + 'question-circle-fill',
  FORM_FOLDING: iconPrefix + 'arrow-up rotate180',
  FORM_UNFOLDING: iconPrefix + 'arrow-up',
  FORM_VALID_ERROR_ICON: iconPrefix + 'warning-circle-fill',
  // form-design
  FORM_DESIGN_STYLE_SETTING: iconPrefix + 'layout',
  FORM_DESIGN_PROPS_PC: iconPrefix + 'pc',
  FORM_DESIGN_PROPS_MOBILE: iconPrefix + 'mobile',
  FORM_DESIGN_PROPS_ADD: iconPrefix + 'add',
  FORM_DESIGN_PROPS_EDIT: iconPrefix + 'edit',
  FORM_DESIGN_WIDGET_ADD: iconPrefix + 'square-plus-fill',
  FORM_DESIGN_WIDGET_COPY: iconPrefix + 'copy',
  FORM_DESIGN_WIDGET_DELETE: iconPrefix + 'delete',
  FORM_DESIGN_WIDGET_SWAP_LR: iconPrefix + 'swap',
  FORM_DESIGN_WIDGET_OPTION_DELETE: iconPrefix + 'delete',
  FORM_DESIGN_WIDGET_OPTION_EXPAND_OPEN: iconPrefix + 'square-plus',
  FORM_DESIGN_WIDGET_OPTION_EXPAND_CLOSE: iconPrefix + 'square-minus',
  // list-design
  LIST_DESIGN_FIELD_SETTING: iconPrefix + 'custom-column',
  LIST_DESIGN_LIST_SETTING: iconPrefix + 'menu',
  LIST_DESIGN_LIST_SETTING_SEARCH_DELETE: iconPrefix + 'delete',
  LIST_DESIGN_LIST_SETTING_ACTIVE_DELETE: iconPrefix + 'delete',
  // upload
  UPLOAD_FILE_ERROR: iconPrefix + 'warning-circle-fill',
  UPLOAD_FILE_ADD: iconPrefix + 'upload',
  UPLOAD_FILE_REMOVE: iconPrefix + 'delete',
  UPLOAD_FILE_DOWNLOAD: iconPrefix + 'download',
  UPLOAD_IMAGE_UPLOAD: iconPrefix + 'upload',
  UPLOAD_IMAGE_RE_UPLOAD: iconPrefix + 'repeat',
  UPLOAD_IMAGE_ADD: iconPrefix + 'add',
  UPLOAD_IMAGE_REMOVE: iconPrefix + 'close',
  UPLOAD_LOADING: iconPrefix + 'spinner roll vxe-loading--default-icon',
  UPLOAD_FILE_TYPE_DEFAULT: iconPrefix + 'file',
  UPLOAD_FILE_TYPE_XLSX: iconPrefix + 'file-excel',
  UPLOAD_FILE_TYPE_XLS: iconPrefix + 'file-excel',
  UPLOAD_FILE_TYPE_PDF: iconPrefix + 'file-pdf',
  UPLOAD_FILE_TYPE_PNG: iconPrefix + 'file-image',
  UPLOAD_FILE_TYPE_GIF: iconPrefix + 'file-image',
  UPLOAD_FILE_TYPE_JPG: iconPrefix + 'file-image',
  UPLOAD_FILE_TYPE_JPEG: iconPrefix + 'file-image',
  UPLOAD_FILE_TYPE_MD: iconPrefix + 'file-markdown',
  UPLOAD_FILE_TYPE_PPD: iconPrefix + 'file-ppt',
  UPLOAD_FILE_TYPE_DOCX: iconPrefix + 'file-word',
  UPLOAD_FILE_TYPE_DOC: iconPrefix + 'file-word',
  UPLOAD_FILE_TYPE_ZIP: iconPrefix + 'file-zip',
  UPLOAD_FILE_TYPE_TXT: iconPrefix + 'file-txt',
  // image-preview
  IMAGE_PREVIEW_CLOSE: iconPrefix + 'close',
  IMAGE_PREVIEW_PREVIOUS: iconPrefix + 'arrow-left',
  IMAGE_PREVIEW_NEXT: iconPrefix + 'arrow-right',
  IMAGE_PREVIEW_PCT_FULL: iconPrefix + 'pct-full',
  IMAGE_PREVIEW_PCT_1_1: iconPrefix + 'pct-1-1',
  IMAGE_PREVIEW_ZOOM_OUT: iconPrefix + 'search-zoom-out',
  IMAGE_PREVIEW_ZOOM_IN: iconPrefix + 'search-zoom-in',
  IMAGE_PREVIEW_ROTATE_LEFT: iconPrefix + 'rotate-left',
  IMAGE_PREVIEW_ROTATE_RIGHT: iconPrefix + 'rotate-right',
  IMAGE_PREVIEW_PRINT: iconPrefix + 'print',
  IMAGE_PREVIEW_DOWNLOAD: iconPrefix + 'download',
  // alert
  ALERT_CLOSE: iconPrefix + 'close',
  ALERT_INFO: iconPrefix + 'info-circle-fill',
  ALERT_SUCCESS: iconPrefix + 'success-circle-fill',
  ALERT_WARNING: iconPrefix + 'warning-circle-fill',
  ALERT_ERROR: iconPrefix + 'error-circle-fill',
  // tree
  TREE_NODE_OPEN: iconPrefix + 'caret-right rotate90',
  TREE_NODE_CLOSE: iconPrefix + 'caret-right',
  TREE_NODE_LOADED: iconPrefix + 'spinner roll',
  // tree-select
  TREE_SELECT_LOADED: iconPrefix + 'spinner roll',
  TREE_SELECT_OPEN: iconPrefix + 'caret-down rotate180',
  TREE_SELECT_CLOSE: iconPrefix + 'caret-down',
  // table-select
  TABLE_SELECT_LOADED: iconPrefix + 'spinner roll',
  TABLE_SELECT_OPEN: iconPrefix + 'caret-down rotate180',
  TABLE_SELECT_CLOSE: iconPrefix + 'caret-down',
  // tabs
  TABS_TAB_BUTTON_TOP: iconPrefix + 'arrow-up',
  TABS_TAB_BUTTON_BOTTOM: iconPrefix + 'arrow-down',
  TABS_TAB_BUTTON_LEFT: iconPrefix + 'arrow-left',
  TABS_TAB_BUTTON_RIGHT: iconPrefix + 'arrow-right',
  TABS_TAB_CLOSE: iconPrefix + 'close',
  TABS_TAB_REFRESH: iconPrefix + 'refresh',
  TABS_TAB_REFRESH_LOADING: iconPrefix + 'refresh roll',
  // text
  TEXT_COPY: iconPrefix + 'copy',
  TEXT_LOADING: iconPrefix + 'spinner roll',
  // tag
  TAG_CLOSE: iconPrefix + 'close',
  TAG_LOADING: iconPrefix + 'spinner roll',
  // carousel
  CAROUSEL_HORIZONTAL_PREVIOUS: iconPrefix + 'arrow-left',
  CAROUSEL_HORIZONTAL_NEXT: iconPrefix + 'arrow-right',
  CAROUSEL_VERTICAL_PREVIOUS: iconPrefix + 'arrow-up',
  CAROUSEL_VERTICAL_NEXT: iconPrefix + 'arrow-down',
  // collapse
  COLLAPSE_OPEN: iconPrefix + 'arrow-right rotate90',
  COLLAPSE_CLOSE: iconPrefix + 'arrow-right',
  // empty
  EMPTY_DEFAULT: iconPrefix + 'empty',
  // result
  RESULT_INFO: iconPrefix + 'info-circle-fill',
  RESULT_SUCCESS: iconPrefix + 'success-circle-fill',
  RESULT_WARNING: iconPrefix + 'warning-circle-fill',
  RESULT_ERROR: iconPrefix + 'error-circle-fill',
  RESULT_QUESTION: iconPrefix + 'question-circle-fill',
  RESULT_LOADING: iconPrefix + 'spinner roll',
  // rate
  RATE_CHECKED: iconPrefix + 'star-fill',
  RATE_UNCHECKED: iconPrefix + 'star',
  // color-picker
  COLOR_PICKER_COLOR_COPY: iconPrefix + 'copy',
  COLOR_PICKER_EYE_DROPPER: iconPrefix + 'dropper',
  COLOR_PICKER_TPTY_OPEN: iconPrefix + 'arrow-down rotate180',
  COLOR_PICKER_TPTY_CLOSE: iconPrefix + 'arrow-down',
  // split
  SPLIT_TOP_ACTION: iconPrefix + 'arrow-up',
  SPLIT_BOTTOM_ACTION: iconPrefix + 'arrow-down',
  SPLIT_LEFT_ACTION: iconPrefix + 'arrow-left',
  SPLIT_RIGHT_ACTION: iconPrefix + 'arrow-right'
});

/* harmony default export */ var ui = ((/* unused pure expression or super */ null && (VxeUI)));
;// CONCATENATED MODULE: ./packages/language/zh-CN.ts
/* harmony default export */ var zh_CN = ({
  vxe: {
    base: {
      pleaseInput: 'è¯·è¾å¥',
      pleaseSelect: 'è¯·éæ©',
      comma: 'ï¼',
      fullStop: 'ã'
    },
    loading: {
      text: 'å è½½ä¸­...'
    },
    error: {
      downErr: 'ä¸è½½å¤±è´¥',
      errLargeData: 'å½ç»å®çæ°æ®éè¿å¤§æ¶ï¼åºè¯¥è¯·ä½¿ç¨ {0}ï¼å¦åå¯è½ä¼åºç°å¡é¡¿',
      groupFixed: 'å¦æä½¿ç¨åç»è¡¨å¤´ï¼å»ç»åå¿é¡»æç»è®¾ç½®',
      groupMouseRange: 'åç»è¡¨å¤´ä¸ "{0}" ä¸è½åæ¶ä½¿ç¨ï¼è¿å¯è½ä¼åºç°éè¯¯',
      groupTag: 'åç»åå¤´åºè¯¥ä½¿ç¨ "{0}" èä¸æ¯ "{1}"ï¼è¿å¯è½ä¼åºç°éè¯¯',
      scrollErrProp: 'å¯ç¨èææ»å¨åä¸æ¯æè¯¥åæ° "{0}"',
      errConflicts: 'åæ° "{0}" ä¸ "{1}" æå²çª',
      modelConflicts: 'ç»å®çå­æ®µå¼ "{0}" ä¸ "{1}" å­å¨å²çªï¼å°ä¼åºç°éè¯¯',
      notSupportProp: 'å½å¯ç¨åæ° "{0}" æ¶ä¸æ¯æ "{1}"ï¼åºè¯¥ä¸º "{2}"ï¼å¦åå°ä¼åºç°éè¯¯',
      reqSupportProp: 'å½ä½¿ç¨ "{0}" æ¶ï¼åºè¯¥è®¾ç½® "{1}"ï¼å¦åå¯è½ä¼åºç°éè¯¯',
      notConflictProp: 'å½ä½¿ç¨ "{0}" æ¶ï¼åºè¯¥è®¾ç½® "{1}"ï¼å¦åå¯è½ä¼å­å¨åè½å²çª',
      unableInsert: 'æ æ³æå¥å°æå®ä½ç½®ï¼è¯·æ£æ¥åæ°æ¯å¦æ­£ç¡®',
      useErr: 'å®è£ "{0}" æ¨¡åæ¶åçéè¯¯ï¼å¯è½é¡ºåºä¸æ­£ç¡®ï¼ä¾èµçæ¨¡åéè¦å¨ Table ä¹åå®è£',
      barUnableLink: 'å·¥å·æ æ æ³å³èè¡¨æ ¼',
      expandContent: 'å±å¼è¡çææ§½åºè¯¥æ¯ "content"ï¼è¯·æ£æ¥æ¯å¦æ­£ç¡®',
      reqComp: 'ç¼ºå° "{0}" ç»ä»¶ï¼è¯·æ£æ¥æ¯å¦æ­£ç¡®å®è£ã https://vxeui.com/#/start/useGlobal',
      reqModule: 'ç¼ºå° "{0}" æ¨¡å',
      reqProp: 'ç¼ºå°å¿è¦ç "{0}" åæ°ï¼è¿å¯è½ä¼å¯¼è´åºç°éè¯¯',
      emptyProp: 'åæ° "{0}" ä¸åè®¸ä¸ºç©º',
      errProp: 'ä¸æ¯æçåæ° "{0}"ï¼å¯è½ä¸º "{1}"',
      colRepet: 'column.{0}="{1}" éå¤äºï¼è¿å¯è½ä¼å¯¼è´æäºåè½æ æ³ä½¿ç¨',
      notFunc: 'æ¹æ³ "{0}" ä¸å­å¨',
      errFunc: 'åæ° "{0}" ä¸æ¯ä¸ä¸ªæ¹æ³',
      notValidators: 'å¨å±æ ¡éª "{0}" ä¸å­å¨',
      notFormats: 'å¨å±æ ¼å¼å "{0}" ä¸å­å¨',
      notCommands: 'å¨å±æä»¤ "{0}" ä¸å­å¨',
      notSlot: 'ææ§½ "{0}" ä¸å­å¨',
      noTree: 'æ ç»æä¸æ¯æ "{0}"',
      noGroup: 'æ°æ®åç»åä¸æ¯æ "{0}"',
      notProp: 'ä¸æ¯æçåæ° "{0}"',
      checkProp: 'å½æ°æ®éè¿å¤§æ¶å¯è½ä¼å¯¼è´å¤éæ¡å¡é¡¿ï¼å»ºè®®è®¾ç½®åæ° "{0}" æåæ¸²æéåº¦',
      coverProp: '"{0}" çåæ° "{1}" éå¤å®ä¹ï¼è¿å¯è½ä¼åºç°éè¯¯',
      uniField: 'å­æ®µå "{0}" éå¤å®ä¹ï¼è¿å¯è½ä¼åºç°éè¯¯',
      repeatKey: 'ä¸»é®éå¤ {0}="{1}"ï¼è¿å¯è½ä¼åºç°éè¯¯',
      repeatProp: 'åæ°éå¤ {0}="{1}"ï¼è¿å¯è½ä¼åºç°éè¯¯',
      delFunc: 'æ¹æ³ "{0}" å·²åºå¼ï¼è¯·ä½¿ç¨ "{1}"',
      delProp: 'åæ° "{0}" å·²åºå¼ï¼è¯·ä½¿ç¨ "{1}"',
      delEvent: 'äºä»¶ "{0}" å·²åºå¼ï¼è¯·ä½¿ç¨ "{1}"',
      removeProp: 'åæ° "{0}" å·²åºå¼ï¼ä¸å»ºè®®ä½¿ç¨ï¼è¿å¯è½ä¼å¯¼è´åºç°éè¯¯',
      errFormat: 'å¨å±çæ ¼å¼ååå®¹åºè¯¥ä½¿ç¨ "VXETable.formats" å®ä¹ï¼æè½½ "formatter={0}" çæ¹å¼å·²ä¸å»ºè®®ä½¿ç¨',
      notType: 'ä¸æ¯æçæä»¶ç±»å "{0}"',
      notExp: 'è¯¥æµè§å¨ä¸æ¯æå¯¼å¥/å¯¼åºåè½',
      impFields: 'å¯¼å¥å¤±è´¥ï¼è¯·æ£æ¥å­æ®µååæ°æ®æ ¼å¼æ¯å¦æ­£ç¡®',
      treeNotImp: 'æ è¡¨æ ¼ä¸æ¯æå¯¼å¥',
      treeCrossDrag: 'åªè½ææ½ç¬¬ä¸å±çº§',
      treeDragChild: 'ç¶çº§ä¸è½ææ½å°èªå·±çå­çº§ä¸­',
      reqPlugin: 'æ©å±æä»¶æªå®è£ "{1}" https://vxeui.com/other{0}/#/{1}/install',
      errMaxRow: 'è¶è¿æ¯æçæå¤§æ°æ®é {0} è¡ï¼è¿å¯è½ä¼å¯¼è´åºç°éè¯¯',
      useNew: 'ä¸å»ºè®®ä½¿ç¨ {0}ï¼è¯·ä½¿ç¨ {1}',
      errorVersion: 'çæ¬ä¸å¹éï¼å½åçæ¬ {0}ï¼æä½æ¯æçæ¬ä¸º {1}'
    },
    table: {
      emptyText: 'ææ æ°æ®',
      allTitle: 'å¨é/åæ¶',
      seqTitle: 'åºå·',
      actionTitle: 'æä½',
      confirmFilter: 'ç­é',
      resetFilter: 'éç½®',
      allFilter: 'å¨é¨',
      sortAsc: 'ååºï¼æä½å°æé«',
      sortDesc: 'éåºï¼æé«å°æä½',
      filter: 'å¯¹æéçåå¯ç¨ç­é',
      impSuccess: 'æåå¯¼å¥ {0} æ¡è®°å½',
      expLoading: 'æ­£å¨å¯¼åºä¸­',
      expSuccess: 'å¯¼åºæå',
      expError: 'å¯¼åºå¤±è´¥',
      expFilename: 'å¯¼åº_{0}',
      expOriginFilename: 'å¯¼åº_æº_{0}',
      customTitle: 'åè®¾ç½®',
      customAll: 'å¨é¨',
      customConfirm: 'ç¡®è®¤',
      customClose: 'å³é­',
      customCancel: 'åæ¶',
      customRestore: 'æ¢å¤é»è®¤',
      maxFixedCol: 'æå¤§å»ç»åçæ°éä¸è½è¶è¿ {0} ä¸ª',
      maxGroupCol: 'æå¤§åç»å­æ®µçæ°éä¸è½è¶è¿ {0} ä¸ª',
      dragTip: 'ç§»å¨ï¼{0}',
      resizeColTip: 'å®½ï¼{0} åç´ ',
      resizeRowTip: 'é«ï¼{0} åç´ ',
      rowGroupContentTotal: '{0}ï¼{1}ï¼',
      menuLoading: 'å è½½ä¸­...'
    },
    grid: {
      selectOneRecord: 'è¯·è³å°éæ©ä¸æ¡è®°å½ï¼',
      deleteSelectRecord: 'æ¨ç¡®å®è¦å é¤æéè®°å½åï¼',
      removeSelectRecord: 'æ¨ç¡®å®è¦ç§»é¤æéè®°å½åï¼',
      dataUnchanged: 'æ°æ®æªæ¹å¨ï¼',
      delSuccess: 'æåå é¤æéè®°å½ï¼',
      saveSuccess: 'ä¿å­æåï¼',
      operError: 'åçéè¯¯ï¼æä½å¤±è´¥ï¼'
    },
    select: {
      clear: 'æ¸é¤',
      allChecked: 'å¨é',
      total: '{0} / {1}',
      search: 'æç´¢',
      loadingText: 'å è½½ä¸­',
      emptyText: 'ææ æ°æ®',
      maxSize: 'æå¤§å¯éæ©çæ°éä¸è½è¶è¿ {0} ä¸ª',
      overSizeErr: 'å·²è¶åºæå¤§å¯éæ°é {0} ä¸ªï¼è¶åºé¨åå°è¢«å¿½ç¥ï¼',
      searchEmpty: 'æªå¹éå°æ°æ®ï¼'
    },
    tree: {
      searchEmpty: 'æªå¹éå°æ°æ®ï¼'
    },
    treeSelect: {
      clearChecked: 'æ¸é¤',
      allChecked: 'å¨é',
      allExpand: 'å¨é¨å±å¼',
      clearExpand: 'å¨é¨æ¶èµ·',
      total: 'å·²é {0}',
      search: 'æç´¢',
      emptyText: 'ææ æ°æ®'
    },
    pager: {
      goto: 'åå¾',
      gotoTitle: 'é¡µæ°',
      pagesize: '{0}æ¡/é¡µ',
      total: 'å± {0} æ¡è®°å½',
      pageClassifier: 'é¡µ',
      homePage: 'é¦é¡µ',
      homePageTitle: 'é¦é¡µ',
      prevPage: 'ä¸ä¸é¡µ',
      prevPageTitle: 'ä¸ä¸é¡µ',
      nextPage: 'ä¸ä¸é¡µ',
      nextPageTitle: 'ä¸ä¸é¡µ',
      prevJump: 'åä¸è·³é¡µ',
      prevJumpTitle: 'åä¸è·³é¡µ',
      nextJump: 'åä¸è·³é¡µ',
      nextJumpTitle: 'åä¸è·³é¡µ',
      endPage: 'æ«é¡µ',
      endPageTitle: 'æ«é¡µ'
    },
    alert: {
      title: 'ç³»ç»æç¤º'
    },
    button: {
      confirm: 'ç¡®è®¤',
      cancel: 'åæ¶',
      clear: 'æ¸é¤'
    },
    filter: {
      search: 'æç´¢'
    },
    custom: {
      cstmTitle: 'åè®¾ç½®',
      cstmRestore: 'æ¢å¤é»è®¤',
      cstmCancel: 'åæ¶',
      cstmConfirm: 'ç¡®å®',
      cstmConfirmRestore: 'è¯·ç¡®è®¤æ¯å¦æ¢å¤æé»è®¤åéç½®ï¼',
      cstmDragTarget: 'ç§»å¨ï¼{0}',
      setting: {
        colSort: 'æåº',
        sortHelpTip: 'ç¹å»å¹¶æå¨å¾æ å¯ä»¥è°æ´é¡ºåº',
        colTitle: 'åæ é¢',
        colResizable: 'åå®½ï¼åç´ ï¼',
        colVisible: 'æ¯å¦æ¾ç¤º',
        colFixed: 'å»ç»å',
        colFixedMax: 'å»ç»åï¼æå¤ {0} åï¼',
        fixedLeft: 'å·¦ä¾§',
        fixedUnset: 'ä¸è®¾ç½®',
        fixedRight: 'å³ä¾§'
      }
    },
    import: {
      modes: {
        covering: 'è¦çæ¹å¼ï¼ç´æ¥è¦çè¡¨æ ¼æ°æ®ï¼',
        insert: 'åºé¨è¿½å ï¼å¨è¡¨æ ¼çåºé¨è¿½å æ°æ°æ®ï¼',
        insertTop: 'é¡¶é¨è¿½å ï¼å¨è¡¨æ ¼çé¡¶é¨è¿½å æ°æ°æ®ï¼',
        insertBottom: 'åºé¨è¿½å ï¼å¨è¡¨æ ¼çåºé¨è¿½å æ°æ°æ®ï¼'
      },
      impTitle: 'å¯¼å¥æ°æ®',
      impFile: 'æä»¶å',
      impSelect: 'éæ©æä»¶',
      impType: 'æä»¶ç±»å',
      impOpts: 'åæ°è®¾ç½®',
      impMode: 'å¯¼å¥æ¨¡å¼',
      impConfirm: 'å¯¼å¥',
      impCancel: 'åæ¶'
    },
    export: {
      types: {
        csv: 'CSV (éå·åé)(*.csv)',
        html: 'ç½é¡µ(*.html)',
        xml: 'XML æ°æ®(*.xml)',
        txt: 'ææ¬æä»¶(å¶è¡¨ç¬¦åé)(*.txt)',
        xls: 'Excel 97-2003 å·¥ä½ç°¿(*.xls)',
        xlsx: 'Excel å·¥ä½ç°¿(*.xlsx)',
        pdf: 'PDF (*.pdf)'
      },
      modes: {
        empty: 'ç©ºæ°æ®',
        current: 'å½åæ°æ®ï¼å½åé¡µçæ°æ®ï¼',
        selected: 'éä¸­æ°æ®ï¼å½åé¡µéä¸­çæ°æ®ï¼',
        all: 'å¨éæ°æ®ï¼åæ¬ææåé¡µçæ°æ®ï¼'
      },
      printTitle: 'æå°æ°æ®',
      expTitle: 'å¯¼åºæ°æ®',
      expName: 'æä»¶å',
      expNamePlaceholder: 'è¯·è¾å¥æä»¶å',
      expSheetName: 'æ é¢',
      expSheetNamePlaceholder: 'è¯·è¾å¥æ é¢',
      expType: 'ä¿å­ç±»å',
      expMode: 'éæ©æ°æ®',
      expCurrentColumn: 'å¨é¨å­æ®µ',
      expColumn: 'éæ©å­æ®µ',
      expOpts: 'åæ°è®¾ç½®',
      expOptHeader: 'è¡¨å¤´',
      expHeaderTitle: 'æ¯å¦éè¦è¡¨å¤´',
      expOptFooter: 'è¡¨å°¾',
      expFooterTitle: 'æ¯å¦éè¦è¡¨å°¾',
      expOptColgroup: 'åç»è¡¨å¤´',
      expOptTitle: 'åæ é¢',
      expTitleTitle: 'æ¯å¦ä¸ºåæ é¢ï¼å¦åæ¾ç¤ºä¸ºåçå­æ®µå',
      expColgroupTitle: 'å¦æå­å¨ï¼åæ¯æå¸¦æåç»ç»æçè¡¨å¤´',
      expOptMerge: 'åå¹¶',
      expMergeTitle: 'å¦æå­å¨ï¼åæ¯æå¸¦æåå¹¶ç»æçååæ ¼',
      expOptAllExpand: 'å±å¼æ ',
      expAllExpandTitle: 'å¦æå­å¨ï¼åæ¯æå°å¸¦æå±çº§ç»æçæ°æ®å¨é¨å±å¼',
      expOptUseStyle: 'æ ·å¼',
      expUseStyleTitle: 'å¦æå­å¨ï¼åæ¯æå¸¦æ ·å¼çååæ ¼',
      expOptOriginal: 'æºæ°æ®',
      expOriginalTitle: 'å¦æä¸ºæºæ°æ®ï¼åæ¯æå¯¼å¥å°è¡¨æ ¼ä¸­',
      expPrint: 'æå°',
      expConfirm: 'å¯¼åº',
      expCancel: 'åæ¶'
    },
    modal: {
      errTitle: 'éè¯¯æç¤º',
      zoomMin: 'æå°å',
      zoomIn: 'æå¤§å',
      zoomOut: 'è¿å',
      close: 'å³é­',
      miniMaxSize: 'æå°åçªå£çæ°éä¸è½è¶è¿ {0} ä¸ª',
      footPropErr: 'show-footer ä»ç¨äºå¯ç¨è¡¨å°¾ï¼ééå show-confirm-button | show-cancel-button | ææ§½ä½¿ç¨'
    },
    drawer: {
      close: 'å³é­'
    },
    form: {
      folding: 'æ¶èµ·',
      unfolding: 'å±å¼'
    },
    toolbar: {
      import: 'å¯¼å¥',
      export: 'å¯¼åº',
      print: 'æå°',
      refresh: 'å·æ°',
      zoomIn: 'å¨å±',
      zoomOut: 'è¿å',
      custom: 'åè®¾ç½®',
      customAll: 'å¨é¨',
      customConfirm: 'ç¡®è®¤',
      customRestore: 'éç½®',
      fixedLeft: 'å»ç»å¨å·¦ä¾§',
      fixedRight: 'å»ç»å¨å³ä¾§',
      cancelFixed: 'åæ¶å»ç»å'
    },
    datePicker: {
      yearTitle: '{0} å¹´'
    },
    dateRangePicker: {
      pleaseRange: 'è¯·éæ©å¼å§æ¥æä¸ç»ææ¥æ'
    },
    input: {
      date: {
        m1: '01 æ',
        m2: '02 æ',
        m3: '03 æ',
        m4: '04 æ',
        m5: '05 æ',
        m6: '06 æ',
        m7: '07 æ',
        m8: '08 æ',
        m9: '09 æ',
        m10: '10 æ',
        m11: '11 æ',
        m12: '12 æ',
        quarterLabel: '{0} å¹´',
        monthLabel: '{0} å¹´',
        dayLabel: '{0} å¹´ {1}',
        labelFormat: {
          date: 'yyyy-MM-dd',
          time: 'HH:mm:ss',
          datetime: 'yyyy-MM-dd HH:mm:ss',
          week: 'yyyy å¹´ç¬¬ WW å¨',
          month: 'yyyy-MM',
          quarter: 'yyyy å¹´ç¬¬ q å­£åº¦',
          year: 'yyyy'
        },
        weeks: {
          w: '',
          w0: 'å¨æ¥',
          w1: 'å¨ä¸',
          w2: 'å¨äº',
          w3: 'å¨ä¸',
          w4: 'å¨å',
          w5: 'å¨äº',
          w6: 'å¨å­'
        },
        months: {
          m0: 'ä¸æ',
          m1: 'äºæ',
          m2: 'ä¸æ',
          m3: 'åæ',
          m4: 'äºæ',
          m5: 'å­æ',
          m6: 'ä¸æ',
          m7: 'å«æ',
          m8: 'ä¹æ',
          m9: 'åæ',
          m10: 'åä¸æ',
          m11: 'åäºæ'
        },
        quarters: {
          q1: 'ç¬¬ä¸å­£åº¦',
          q2: 'ç¬¬äºå­£åº¦',
          q3: 'ç¬¬ä¸å­£åº¦',
          q4: 'ç¬¬åå­£åº¦'
        }
      }
    },
    numberInput: {
      currencySymbol: 'Â¥'
    },
    imagePreview: {
      popupTitle: 'é¢è§',
      operBtn: {
        zoomOut: 'ç¼©å°',
        zoomIn: 'æ¾å¤§',
        pctFull: 'ç­æ¯ä¾ç¼©æ¾',
        pct11: 'æ¾ç¤ºåå§å°ºå¯¸',
        rotateLeft: 'åå·¦æè½¬',
        rotateRight: 'åå³æè½¬',
        print: 'ç¹å»æå°å¾ç',
        download: 'ç¹å»ä¸è½½å¾ç'
      }
    },
    upload: {
      fileBtnText: 'ç¹å»æææ½ä¸ä¼ ',
      imgBtnText: 'ç¹å»æææ½ä¸ä¼ ',
      dragPlaceholder: 'è¯·ææä»¶ææ¾å°è¿ä¸ªåºåå³å¯ä¸ä¼ ',
      imgSizeHint: 'åå¼ {0}',
      imgCountHint: 'æå¤{0}å¼ ',
      fileTypeHint: 'æ¯æ {0} æä»¶ç±»å',
      fileSizeHint: 'åä¸ªæä»¶å¤§å°ä¸è¶è¿{0}',
      fileCountHint: 'æå¤å¯ä¸ä¼ {0}ä¸ªæä»¶',
      uploadTypeErr: 'æä»¶ç±»åä¸å¹éï¼',
      overCountErr: 'æå¤åªè½éæ©{0}ä¸ªæä»¶ï¼',
      overCountExtraErr: 'å·²è¶åºæå¤§æ°é{0}ä¸ªï¼è¶åºç{1}ä¸ªæä»¶å°è¢«å¿½ç¥ï¼',
      overSizeErr: 'æä»¶å¤§å°æå¤§ä¸è½è¶è¿{0}ï¼',
      manualUpload: 'ç¹å»ä¸ä¼ ',
      reUpload: 'éæ°ä¸ä¼ ',
      uploadProgress: 'ä¸ä¼ ä¸­ {0}%',
      uploadErr: 'ä¸ä¼ å¤±è´¥',
      uploadSuccess: 'ä¸ä¼ æå',
      moreBtnText: 'æ´å¤ï¼{0}ï¼',
      viewItemTitle: 'ç¹å»æ¥ç',
      morePopup: {
        readTitle: 'æ¥çåè¡¨',
        imageTitle: 'ä¸ä¼ å¾ç',
        fileTitle: 'ä¸ä¼ æä»¶'
      }
    },
    empty: {
      defText: 'ææ æ°æ®'
    },
    colorPicker: {
      clear: 'æ¸é¤',
      confirm: 'ç¡®è®¤',
      copySuccess: 'å·²å¤å¶å°åªè´´æ¿ï¼{0}',
      hex: 'åå­è¿å¶'
    },
    formDesign: {
      formName: 'è¡¨ååç§°',
      defFormTitle: 'æªå½åçè¡¨å',
      widgetPropTab: 'æ§ä»¶å±æ§',
      widgetFormTab: 'è¡¨åå±æ§',
      error: {
        wdFormUni: 'è¯¥ç±»åçæ§ä»¶å¨è¡¨åä¸­åªåè®¸æ·»å ä¸ä¸ª',
        wdSubUni: 'è¯¥ç±»åçæ§ä»¶å¨å­è¡¨ä¸­åªåè®¸æ·»å ä¸ä¸ª'
      },
      styleSetting: {
        btn: 'æ ·å¼è®¾ç½®',
        title: 'è¡¨åçæ ·å¼è®¾ç½®',
        layoutTitle: 'æ§ä»¶å¸å±',
        verticalLayout: 'ä¸ä¸å¸å±',
        horizontalLayout: 'æ¨ªåå¸å±',
        styleTitle: 'æ é¢æ ·å¼',
        boldTitle: 'æ é¢å ç²',
        fontBold: 'å ç²',
        fontNormal: 'å¸¸è§',
        colonTitle: 'æ¾ç¤ºåå·',
        colonVisible: 'æ¾ç¤º',
        colonHidden: 'éè',
        alignTitle: 'å¯¹é½æ¹å¼',
        widthTitle: 'æ é¢å®½åº¦',
        alignLeft: 'å±å·¦',
        alignRight: 'å±å³',
        unitPx: 'åç´ ',
        unitPct: 'ç¾åæ¯'
      },
      widget: {
        group: {
          base: 'åºç¡æ§ä»¶',
          layout: 'å¸å±æ§ä»¶',
          system: 'ç³»ç»æ§ä»¶',
          module: 'æ¨¡åæ§ä»¶',
          chart: 'å¾è¡¨æ§ä»¶',
          advanced: 'é«çº§æ§ä»¶'
        },
        copyTitle: 'å¯æ¬_{0}',
        component: {
          input: 'è¾å¥æ¡',
          textarea: 'ææ¬å',
          select: 'ä¸æéæ©',
          row: 'ä¸è¡å¤å',
          title: 'æ é¢',
          text: 'ææ¬',
          subtable: 'å­è¡¨',
          VxeSwitch: 'æ¯/å¦',
          VxeInput: 'è¾å¥æ¡',
          VxeNumberInput: 'æ°å­',
          VxeDatePicker: 'æ¥æ',
          VxeTextarea: 'ææ¬å',
          VxeSelect: 'ä¸æéæ©',
          VxeTreeSelect: 'æ å½¢éæ©',
          VxeRadioGroup: 'åéæ¡',
          VxeCheckboxGroup: 'å¤éæ¡',
          VxeUploadFile: 'æä»¶',
          VxeUploadImage: 'å¾ç',
          VxeRate: 'è¯å',
          VxeSlider: 'æ»å'
        }
      },
      widgetProp: {
        name: 'æ§ä»¶åç§°',
        placeholder: 'æç¤ºè¯­',
        required: 'å¿å¡«æ ¡éª',
        multiple: 'åè®¸å¤é',
        displaySetting: {
          name: 'æ¾ç¤ºè®¾ç½®',
          pc: 'çµèç«¯',
          mobile: 'ææºç«¯',
          visible: 'æ¾ç¤º',
          hidden: 'éè'
        },
        dataSource: {
          name: 'æ°æ®æº',
          defValue: 'éé¡¹{0}',
          addOption: 'æ·»å éé¡¹',
          batchEditOption: 'æ¹éç¼è¾',
          batchEditTip: 'æ¯è¡å¯¹åºä¸ä¸ªéé¡¹ï¼æ¯æä»è¡¨æ ¼ãExcelãWPS ä¸­ç´æ¥å¤å¶ç²è´´ã',
          batchEditSubTip: 'æ¯è¡å¯¹åºä¸ä¸ªéé¡¹ï¼å¦ææ¯åç»ï¼å­é¡¹å¯ä»¥æ¯ç©ºæ ¼æå¶è¡¨é®å¼å¤´ï¼æ¯æä»è¡¨æ ¼ãExcelãWPS ä¸­ç´æ¥å¤å¶ç²è´´ã',
          buildOption: 'çæéé¡¹'
        },
        rowProp: {
          colSize: 'åæ°',
          col2: 'ä¸¤å',
          col3: 'ä¸å',
          col4: 'åå',
          col6: 'å­å',
          layout: 'å¸å±'
        },
        textProp: {
          name: 'åå®¹',
          alignTitle: 'å¯¹é½æ¹å¼',
          alignLeft: 'å±å·¦',
          alignCenter: 'å±ä¸­',
          alignRight: 'å±å³',
          colorTitle: 'å­ä½é¢è²',
          sizeTitle: 'å­ä½å¤§å°',
          boldTitle: 'å­ä½å ç²',
          fontNormal: 'å¸¸è§',
          fontBold: 'å ç²'
        },
        subtableProp: {
          seqTitle: 'åºå·',
          showSeq: 'æ¾ç¤ºåºå·',
          showCheckbox: 'åè®¸å¤é',
          errSubDrag: 'å­è¡¨ä¸æ¯æè¯¥æ§ä»¶ï¼è¯·ä½¿ç¨å¶ä»æ§ä»¶',
          colPlace: 'å°æ§ä»¶ææ½è¿æ¥'
        },
        uploadProp: {
          limitFileCount: 'æä»¶æ°ééå¶',
          limitFileSize: 'æä»¶å¤§å°éå¶',
          multiFile: 'åè®¸ä¸ä¼ å¤ä¸ªæä»¶',
          limitImgCount: 'å¾çæ°ééå¶',
          limitImgSize: 'å¾çå¤§å°éå¶',
          multiImg: 'åè®¸ä¸ä¼ å¤å¼ å¾ç'
        }
      }
    },
    listDesign: {
      fieldSettingTab: 'å­æ®µè®¾ç½®',
      listSettingTab: 'åæ°è®¾ç½®',
      searchTitle: 'æ¥è¯¢æ¡ä»¶',
      listTitle: 'åè¡¨å­æ®µ',
      searchField: 'æ¥è¯¢å­æ®µ',
      listField: 'åè¡¨å­æ®µ',
      activeBtn: {
        ActionButtonUpdate: 'ç¼è¾',
        ActionButtonDelete: 'å é¤'
      },
      search: {
        addBtn: 'ç¼è¾',
        emptyText: 'æªéç½®æ¥è¯¢æ¡ä»¶',
        editPopupTitle: 'ç¼è¾æ¥è¯¢å­æ®µ'
      },
      searchPopup: {
        colTitle: 'æ é¢',
        saveBtn: 'ä¿å­'
      }
    },
    text: {
      copySuccess: 'å·²å¤å¶å°åªè´´æ¿',
      copyError: 'å½åç¯å¢ä¸æ¯æè¯¥æä½'
    },
    countdown: {
      formats: {
        yyyy: 'å¹´',
        MM: 'æ',
        dd: 'å¤©',
        HH: 'æ¶',
        mm: 'å',
        ss: 'ç§'
      }
    },
    gantt: {
      tFullFormat: {
        year: '{yy}å¹´',
        quarter: '{yy}å¹´ç¬¬{q}å­£åº¦',
        month: '{yy}å¹´{M}æ',
        week: '{yy}å¹´ç¬¬{W}å¨',
        day: '{yy}å¹´{M}æ{E}æ¥',
        date: '{yy}å¹´{M}æ{d}æ¥',
        hour: '{yy}å¹´ {M}æ{d}æ¥{H}æ¶',
        minute: '{yy}å¹´{M}æ{d}æ¥{H}æ¶{m}å'
      },
      tSimpleFormat: {
        year: '{yy}å¹´',
        quarter: '{q}å­£åº¦',
        month: '{M}æ',
        week: '{W}å¨',
        day: '{d}',
        date: '{d}',
        hour: '{H}æ¶',
        minute: '{m}å'
      },
      dayss: {
        w0: 'æ¥',
        w1: 'ä¸',
        w2: 'äº',
        w3: 'ä¸',
        w4: 'å',
        w5: 'äº',
        w6: 'å­'
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: 'æ æ³å¯¹åå¹¶ååæ ¼è¿è¡è¯¥æä½',
          multiErr: 'æ æ³å¯¹å¤ééæ©åºåè¿è¡è¯¥æä½',
          selectErr: 'æ æ³æä½æå®åºåçååæ ¼',
          extendErr: 'å¦æå»¶ä¼¸çåºååå«è¢«åå¹¶çååæ ¼ï¼ææåå¹¶çååæ ¼éå¤§å°ç¸å',
          pasteMultiErr: 'æ æ³ç²è´´ï¼éè¦ç¸åå¤§å°çå¤å¶çåºååç²è´´çåºåæè½æ§è¡æ­¤æä½',
          cpInvalidErr: 'è¯¥æä½æ æ³è¿è¡ï¼æ¨éæ©çåºåä¸­å­å¨è¢«ç¦æ­¢çåï¼{0}ï¼'
        },
        fnr: {
          title: 'æ¥æ¾åæ¿æ¢',
          findLabel: 'æ¥æ¾',
          replaceLabel: 'æ¿æ¢',
          findTitle: 'æ¥æ¾åå®¹ï¼',
          replaceTitle: 'æ¿æ¢ä¸ºï¼',
          tabs: {
            find: 'æ¥æ¾',
            replace: 'æ¿æ¢'
          },
          filter: {
            re: 'æ­£åè¡¨è¾¾å¼',
            whole: 'å¨è¯å¹é',
            sensitive: 'åºåå¤§å°å'
          },
          btns: {
            findNext: 'æ¥æ¾ä¸ä¸ä¸ª',
            findAll: 'æ¥æ¾å¨é¨',
            replace: 'æ¿æ¢',
            replaceAll: 'æ¿æ¢å¨é¨',
            cancel: 'åæ¶'
          },
          header: {
            seq: '#',
            cell: 'ååæ ¼',
            value: 'å¼'
          },
          body: {
            row: 'è¡ï¼{0}',
            col: 'åï¼{0}'
          },
          empty: '(ç©ºå¼)',
          reError: 'æ æçæ­£åè¡¨è¾¾å¼',
          recordCount: 'å·²æ¾å° {0} ä¸ªååæ ¼',
          notCell: 'æ¾ä¸å°å¹éçååæ ¼',
          replaceSuccess: 'æåæ¿æ¢ {0} ä¸ªååæ ¼'
        }
      },
      extendPivotTable: {
        aggregation: {
          grouping: 'åç»',
          values: 'å¼',
          groupPlaceholder: 'æè³æ­¤å¤è¿è¡åç»',
          valuesPlaceholder: 'æè³æ­¤å¤è¿è¡èå',
          dragExistCol: 'è¯¥åå·²å­å¨',
          sortHelpTip: 'ç¹å»å¹¶æå¨å¾æ å¯ä»¥è°æ´é¡ºåº'
        },
        aggFuncs: {
          sum: 'æ±å',
          count: 'è®¡æ°',
          avg: 'å¹³åå¼',
          min: 'æå°å¼',
          max: 'æå¤§å¼',
          first: 'é¦ä¸ªå¼',
          last: 'æ«å°¾å¼'
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: 'å»ç»å',
          fixedGroup: 'å»ç»åç»',
          cancelFixed: 'åæ¶å»ç»',
          fixedLeft: 'å»ç»å·¦ä¾§',
          fixedRight: 'å»ç»å³ä¾§'
        },
        cases: {
          equal: 'ç­äº',
          gt: 'å¤§äº',
          lt: 'å°äº',
          begin: 'å¼å¤´æ¯',
          endin: 'ç»å°¾æ¯',
          include: 'åå«',
          isSensitive: 'åºåå¤§å°å'
        }
      },
      filterCombination: {
        menus: {
          sort: 'æåº',
          clearSort: 'æ¸é¤æåº',
          sortAsc: 'ååº',
          sortDesc: 'éåº',
          fixedColumn: 'å»ç»å',
          fixedGroup: 'å»ç»åç»',
          cancelFixed: 'åæ¶å»ç»',
          fixedLeft: 'å»ç»å·¦ä¾§',
          fixedRight: 'å»ç»å³ä¾§',
          clearFilter: 'æ¸é¤ç­é',
          textOption: 'ææ¬ç­é',
          numberOption: 'æ°å¼ç­é'
        },
        popup: {
          title: 'èªå®ä¹ç­éçæ¹å¼',
          currColumnTitle: 'å½ååï¼',
          and: 'ä¸',
          or: 'æ',
          describeHtml: 'å¯ç¨ ? ä»£è¡¨åä¸ªå­ç¬¦<br/>ç¨ * ä»£è¡¨ä»»æå¤ä¸ªå­ç¬¦'
        },
        cases: {
          equal: 'ç­äº',
          unequal: 'ä¸ç­äº',
          gt: 'å¤§äº',
          ge: 'å¤§äºæç­äº',
          lt: 'å°äº',
          le: 'å°äºæç­äº',
          begin: 'å¼å¤´æ¯',
          notbegin: 'å¼å¤´ä¸æ¯',
          endin: 'ç»å°¾æ¯',
          notendin: 'ç»å°¾ä¸æ¯',
          include: 'åå«',
          exclude: 'ä¸åå«',
          between: 'ä»äº',
          custom: 'èªå®ä¹ç­é',
          insensitive: 'ä¸åºåå¤§å°å',
          isSensitive: 'åºåå¤§å°å'
        },
        empty: '(ç©ºç½)',
        notData: 'æ å¹éé¡¹'
      }
    },
    pro: {
      area: {
        mergeErr: 'æ æ³å¯¹åå¹¶ååæ ¼è¿è¡è¯¥æä½',
        multiErr: 'æ æ³å¯¹å¤ééæ©åºåè¿è¡è¯¥æä½',
        extendErr: 'å¦æå»¶ä¼¸çåºååå«è¢«åå¹¶çååæ ¼ï¼ææåå¹¶çååæ ¼éå¤§å°ç¸å',
        pasteMultiErr: 'æ æ³ç²è´´ï¼éè¦ç¸åå¤§å°çå¤å¶çåºååç²è´´çåºåæè½æ§è¡æ­¤æä½'
      },
      fnr: {
        title: 'æ¥æ¾åæ¿æ¢',
        findLabel: 'æ¥æ¾',
        replaceLabel: 'æ¿æ¢',
        findTitle: 'æ¥æ¾åå®¹ï¼',
        replaceTitle: 'æ¿æ¢ä¸ºï¼',
        tabs: {
          find: 'æ¥æ¾',
          replace: 'æ¿æ¢'
        },
        filter: {
          re: 'æ­£åè¡¨è¾¾å¼',
          whole: 'å¨è¯å¹é',
          sensitive: 'åºåå¤§å°å'
        },
        btns: {
          findNext: 'æ¥æ¾ä¸ä¸ä¸ª',
          findAll: 'æ¥æ¾å¨é¨',
          replace: 'æ¿æ¢',
          replaceAll: 'æ¿æ¢å¨é¨',
          cancel: 'åæ¶'
        },
        header: {
          seq: '#',
          cell: 'ååæ ¼',
          value: 'å¼'
        },
        empty: '(ç©ºå¼)',
        reError: 'æ æçæ­£åè¡¨è¾¾å¼',
        recordCount: 'å·²æ¾å° {0} ä¸ªååæ ¼',
        notCell: 'æ¾ä¸å°å¹éçååæ ¼',
        replaceSuccess: 'æåæ¿æ¢ {0} ä¸ªååæ ¼'
      }
    },
    renderer: {
      search: 'æç´¢',
      cases: {
        equal: 'ç­äº',
        unequal: 'ä¸ç­äº',
        gt: 'å¤§äº',
        ge: 'å¤§äºæç­äº',
        lt: 'å°äº',
        le: 'å°äºæç­äº',
        begin: 'å¼å¤´æ¯',
        notbegin: 'å¼å¤´ä¸æ¯',
        endin: 'ç»å°¾æ¯',
        notendin: 'ç»å°¾ä¸æ¯',
        include: 'åå«',
        exclude: 'ä¸åå«',
        between: 'ä»äº',
        custom: 'èªå®ä¹ç­é',
        insensitive: 'ä¸åºåå¤§å°å',
        isSensitive: 'åºåå¤§å°å'
      },
      combination: {
        menus: {
          sort: 'æåº',
          clearSort: 'æ¸é¤æåº',
          sortAsc: 'ååº',
          sortDesc: 'éåº',
          fixedColumn: 'å»ç»å',
          fixedGroup: 'å»ç»åç»',
          cancelFixed: 'åæ¶å»ç»',
          fixedLeft: 'å»ç»å°å·¦ä¾§',
          fixedRight: 'å»ç»å°å³ä¾§',
          clearFilter: 'æ¸é¤ç­é',
          textOption: 'ææ¬ç­é',
          numberOption: 'æ°å¼ç­é'
        },
        popup: {
          title: 'èªå®ä¹ç­éçæ¹å¼',
          currColumnTitle: 'å½ååï¼',
          and: 'ä¸',
          or: 'æ',
          describeHtml: 'å¯ç¨ ? ä»£è¡¨åä¸ªå­ç¬¦<br/>ç¨ * ä»£è¡¨ä»»æå¤ä¸ªå­ç¬¦'
        },
        empty: '(ç©ºç½)',
        notData: 'æ å¹éé¡¹'
      }
    }
  }
});
;// CONCATENATED MODULE: ./packages/ui/src/vn.ts

function getOnName(type) {
  return 'on' + type.substring(0, 1).toLocaleUpperCase() + type.substring(1);
}
function getModelEvent(renderOpts) {
  switch (renderOpts.name) {
    case 'input':
    case 'textarea':
      return 'input';
    case 'select':
      return 'change';
  }
  return 'update:modelValue';
}
function getChangeEvent(renderOpts) {
  switch (renderOpts.name) {
    case 'input':
    case 'textarea':
    case 'VxeInput':
    case 'VxeTextarea':
    case '$input': // å·²åºå¼
    case '$textarea':
      // å·²åºå¼
      return 'input';
  }
  return 'change';
}
function vn_getSlotVNs(vns) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(vns)) {
    return vns;
  }
  return vns ? [vns] : [];
}
;// CONCATENATED MODULE: ./packages/alert/src/alert.ts





/* harmony default export */ var src_alert = (defineVxeComponent({
  name: 'VxeAlert',
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().alert.title
    },
    content: [String, Number],
    status: String,
    showIcon: Boolean,
    showClose: Boolean,
    icon: {
      type: String,
      default: () => getConfig().alert.icon
    }
  },
  emits: ['close'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeAlert = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const alertMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $alert: $xeAlert
        }, params));
      }
    };
    const closeEvent = evnt => {
      alertMethods.dispatchEvent('close', {}, evnt);
    };
    const alertPrivateMethods = {};
    Object.assign($xeAlert, alertMethods, alertPrivateMethods);
    const renderVN = () => {
      const {
        status,
        content,
        icon,
        title,
        showIcon,
        showClose
      } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-alert', {
          [`theme--${status}`]: status
        }]
      }, [iconSlot || showIcon && status || icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--icon'
      }, iconSlot ? vn_getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon || getIcon()[`ALERT_${status?.toUpperCase()}`]
      })]) : renderEmptyElement($xeAlert), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--body'
      }, [titleSlot || title ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--title'
      }, titleSlot ? vn_getSlotVNs(titleSlot({})) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(title)) : renderEmptyElement($xeAlert), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--content'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({})) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content))]), showClose ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--close-btn',
        onClick: closeEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().ALERT_CLOSE
      })]) : renderEmptyElement($xeAlert)]);
    };
    $xeAlert.renderVN = renderVN;
    return $xeAlert;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/alert/index.ts



const VxeAlert = Object.assign({}, src_alert, {
  install(app) {
    app.component(src_alert.name, src_alert);
  }
});
dynamicApp.use(VxeAlert);
index_esm_VxeUI.component(src_alert);
const Alert = VxeAlert;
/* harmony default export */ var packages_alert = (VxeAlert);
;// CONCATENATED MODULE: ./packages/ui/src/dom.ts

let tpImgEl;
function initTpImg() {
  if (!tpImgEl) {
    tpImgEl = new Image();
    tpImgEl.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
  }
  return tpImgEl;
}
function getTpImg() {
  if (!tpImgEl) {
    return initTpImg();
  }
  return tpImgEl;
}
const reClsMap = {};
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, 'g');
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function isPx(val) {
  return val && /^\d+(px)?$/.test(val);
}
function isScale(val) {
  return val && /^\d+%$/.test(val);
}
function hasClass(elem, cls) {
  return !!(elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls)));
}
function removeClass(elem, cls) {
  if (elem && hasClass(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), '');
  }
}
function addClass(elem, cls) {
  if (elem && !hasClass(elem, cls)) {
    removeClass(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function hasControlKey(evnt) {
  return evnt.ctrlKey || evnt.metaKey;
}
function toCssUnit(val, unit = 'px') {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(val) || /^\d+$/.test(`${val}`)) {
    return `${val}${unit}`;
  }
  return `${val || ''}`;
}
function getDomNode() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
/**
 * æ£æ¥è§¦åæºæ¯å¦å±äºç®æ èç¹
 */
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return {
        flag: queryCls ? !!targetElem : true,
        container,
        targetElem: targetElem
      };
    }
    target = target.parentNode;
  }
  return {
    flag: false
  };
}
/**
 * è·ååç´ ç¸å¯¹äº document çä½ç½®
 */
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, {
    left: 0,
    top: 0
  });
}
function getAbsolutePos(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const {
    scrollTop,
    scrollLeft,
    visibleHeight,
    visibleWidth
  } = getDomNode();
  return {
    boundingTop,
    top: scrollTop + boundingTop,
    boundingLeft,
    left: scrollLeft + boundingLeft,
    visibleHeight,
    visibleWidth
  };
}
function getPaddingTopBottomSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingTop);
    const paddingBottom = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingBottom);
    return paddingTop + paddingBottom;
  }
  return 0;
}
function getPaddingLeftRightSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingLeft = XEUtils.toNumber(computedStyle.paddingLeft);
    const paddingRight = XEUtils.toNumber(computedStyle.paddingRight);
    return paddingLeft + paddingRight;
  }
  return 0;
}
const scrollIntoViewIfNeeded = 'scrollIntoViewIfNeeded';
const scrollIntoView = 'scrollIntoView';
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}
function dom_triggerEvent(targetElem, type) {
  if (targetElem) {
    targetElem.dispatchEvent(new Event(type));
  }
}
function isNodeElement(elem) {
  return elem && elem.nodeType === 1;
}
function updatePanelPlacement(targetElem, panelElem, options) {
  const {
    placement,
    teleportTo,
    marginSize
  } = Object.assign({
    teleportTo: false,
    marginSize: 18
  }, options);
  let panelPlacement = 'bottom';
  let top = '';
  let bottom = '';
  let left = '';
  const right = '';
  let minWidth = '';
  const stys = {};
  if (panelElem && targetElem) {
    const documentElement = document.documentElement;
    const bodyElem = document.body;
    const targetHeight = targetElem.offsetHeight;
    const panelHeight = panelElem.offsetHeight;
    const panelWidth = panelElem.offsetWidth;
    const panelRect = panelElem.getBoundingClientRect();
    const targetRect = targetElem.getBoundingClientRect();
    const visibleHeight = documentElement.clientHeight || bodyElem.clientHeight;
    const visibleWidth = documentElement.clientWidth || bodyElem.clientWidth;
    minWidth = targetElem.offsetWidth;
    if (teleportTo) {
      left = targetRect.left;
      top = targetRect.top + targetHeight;
      if (placement === 'top') {
        panelPlacement = 'top';
        top = targetRect.top - panelHeight;
      } else if (!placement) {
        // å¦æä¸é¢ä¸å¤æ¾ï¼ååä¸
        if (top + panelHeight + marginSize > visibleHeight) {
          panelPlacement = 'top';
          top = targetRect.top - panelHeight;
        }
        // å¦æä¸é¢ä¸å¤æ¾ï¼ååä¸ï¼ä¼åï¼
        if (top < marginSize) {
          panelPlacement = 'bottom';
          top = targetRect.top + targetHeight;
        }
      }
      // å¦ææº¢åºå³è¾¹
      if (left + panelWidth + marginSize > visibleWidth) {
        left -= left + panelWidth + marginSize - visibleWidth;
      }
      // å¦ææº¢åºå·¦è¾¹
      if (left < marginSize) {
        left = marginSize;
      }
    } else {
      if (placement === 'top') {
        panelPlacement = 'top';
        bottom = targetHeight;
      } else if (!placement) {
        // å¦æä¸é¢ä¸å¤æ¾ï¼ååä¸
        top = targetHeight;
        if (targetRect.top + targetRect.height + marginSize > visibleHeight) {
          // å¦æä¸é¢ä¸å¤æ¾ï¼ååä¸ï¼ä¼åï¼
          if (targetRect.top - targetHeight - panelHeight > marginSize) {
            panelPlacement = 'top';
            top = '';
            bottom = targetHeight;
          }
        }
      }
      // æ¯å¦è¶åºå³ä¾§
      if (panelRect.left + panelRect.width + marginSize > visibleWidth) {
        left = -(panelRect.left + panelRect.width + marginSize - visibleWidth);
      }
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(top)) {
      stys.top = toCssUnit(top);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(bottom)) {
      stys.bottom = toCssUnit(bottom);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(left)) {
      stys.left = toCssUnit(left);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(right)) {
      stys.right = toCssUnit(right);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(minWidth)) {
      stys.minWidth = toCssUnit(minWidth);
    }
  }
  return {
    top: top || 0,
    bottom: bottom || 0,
    left: left || 0,
    right: right || 0,
    style: stys,
    placement: panelPlacement
  };
}
;// CONCATENATED MODULE: ./packages/anchor/src/util.ts

function assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const parentElem = elem.parentNode;
  const parentLinkConfig = $xeParentAnchorLink ? $xeParentAnchorLink.linkConfig : null;
  const parentLinks = parentLinkConfig ? parentLinkConfig.children : staticLinks;
  if (parentElem && parentLinks) {
    parentLinks.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, linkConfig);
    $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
  }
}
function destroyAnchorLink($xeAnchor, linkConfig) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticLinks, item => item.id === linkConfig.id, {
    children: 'children'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
}
;// CONCATENATED MODULE: ./packages/anchor/src/anchor-link.ts





/* harmony default export */ var anchor_link = (defineVxeComponent({
  name: 'VxeAnchorLink',
  props: {
    content: [String, Number],
    title: [String, Number],
    href: String
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const $xeAnchor = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeAnchor', null);
    const $xeParentAnchorLink = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeAnchorLink', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const linkConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      href: props.href,
      children: []
    });
    const refMaps = {
      refElem
    };
    const computeIsActive = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        href
      } = props;
      if ($xeAnchor) {
        return $xeAnchor.reactData.activeHref === href;
      }
      return null;
    });
    const computeMaps = {};
    const $xeAnchorLink = {
      xID,
      props,
      context,
      reactData,
      linkConfig,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = event => {
      const {
        href
      } = props;
      if ($xeAnchor) {
        $xeAnchor.handleClickLink(event, href);
      }
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.href, val => {
      linkConfig.href = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if ($xeAnchor && elem) {
        assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xeAnchor) {
        destroyAnchorLink($xeAnchor, linkConfig);
      }
    });
    const renderVN = () => {
      const {
        href,
        content,
        title
      } = props;
      const defaultSlot = slots.default;
      const subSlot = slots.sub;
      const isActive = computeIsActive.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-anchor-link', {
          'is--active': isActive
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
        class: 'vxe-anchor-link--item',
        href,
        title,
        onClick: clickEvent
      }, defaultSlot ? defaultSlot({}) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content)), subSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-anchor-link--sub-items'
      }, subSlot({})) : renderEmptyElement($xeAnchorLink)]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeAnchorLink', $xeAnchorLink);
    $xeAnchorLink.renderVN = renderVN;
    return $xeAnchorLink;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/anchor/src/anchor.ts







/* harmony default export */ var src_anchor = (defineVxeComponent({
  name: 'VxeAnchor',
  props: {
    modelValue: String,
    options: Array,
    container: [String, Object, Function],
    showMarker: {
      type: Boolean,
      default: true
    }
  },
  emits: ['update:modelValue', 'change', 'click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMarkerElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      activeHref: null,
      staticLinks: [],
      containerElem: null
    });
    const refMaps = {
      refElem
    };
    const computeAllHrefList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(reactData.staticLinks, item => {
        list.push(item.href || '');
      }, {
        children: 'children'
      });
      return list;
    });
    const computeMaps = {};
    const $xeAnchor = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const anchorMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $anchor: $xeAnchor
        }, params));
      }
    };
    const getContainerElem = () => {
      const {
        container
      } = props;
      if (container) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isElement(container)) {
          return container;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(container)) {
          return document.querySelector(container);
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(container)) {
          return container({
            $anchor: $xeAnchor
          });
        }
      }
      return null;
    };
    const emitEvent = value => {
      reactData.activeHref = value;
      emit('update:modelValue', value);
    };
    const handleContainerScrollEvent = () => {
      const allHrefList = computeAllHrefList.value;
      const {
        containerElem
      } = reactData;
      if (containerElem) {
        const wrapperElList = containerElem.querySelectorAll(allHrefList.map(href => `${href}`).join(','));
        for (let i = 0; i < wrapperElList.length; i++) {
          const wrapperEl = wrapperElList[i];
          const wrapperRect = wrapperEl.getBoundingClientRect();
          if (wrapperRect.top > 0) {
            const href = wrapperEl.id;
            reactData.activeHref = `#${href}`;
            break;
          }
        }
      }
    };
    const removeContainerElemScroll = () => {
      const {
        containerElem
      } = reactData;
      if (containerElem) {
        containerElem.removeEventListener('scroll', handleContainerScrollEvent);
      }
    };
    const updateContainerElem = () => {
      const containerElem = getContainerElem();
      reactData.containerElem = containerElem;
      if (containerElem) {
        containerElem.addEventListener('scroll', handleContainerScrollEvent, {
          passive: false
        });
      }
    };
    const updateMarkerPos = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          activeHref
        } = reactData;
        const elem = refElem.value;
        const markerEl = refMarkerElem.value;
        if (elem && markerEl) {
          if (activeHref) {
            const linkEl = elem.querySelector(`[href="${activeHref}"]`);
            if (linkEl) {
              const {
                top
              } = getOffsetPos(linkEl, elem);
              markerEl.style.top = `${top}px`;
            }
          }
        }
      });
    };
    const anchorPrivateMethods = {
      handleClickLink(evnt, href) {
        evnt.preventDefault();
        const targetEl = document.getElementById(`${href}`.replace('#', ''));
        if (targetEl) {
          targetEl.scrollIntoView({
            behavior: 'smooth'
          });
        }
        emitEvent(href);
        anchorMethods.dispatchEvent('click', {
          href
        }, evnt);
      }
    };
    Object.assign($xeAnchor, anchorMethods, anchorPrivateMethods);
    const renderSubItems = options => {
      const itemVNs = [];
      if (options) {
        options.forEach(item => {
          const subItems = item.children;
          if (subItems && subItems.length) {
            itemVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(anchor_link, {
              content: item.content,
              title: item.title,
              href: item.href
            }, {
              sub: () => renderSubItems(subItems)
            }));
          } else {
            itemVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(anchor_link, {
              content: item.content,
              title: item.title,
              href: item.href
            }));
          }
        });
      }
      return itemVNs;
    };
    const renderVN = () => {
      const {
        options,
        showMarker
      } = props;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-anchor', {
          'is--marker': showMarker
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-anchor--list'
      }, defaultSlot ? defaultSlot({}) : renderSubItems(options)), showMarker ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refMarkerElem,
        class: 'vxe-anchor--marker'
      }) : renderEmptyElement($xeAnchor)]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.activeHref = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.activeHref, () => {
      updateMarkerPos();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.container, () => {
      removeContainerElemScroll();
      updateContainerElem();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        updateContainerElem();
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      removeContainerElemScroll();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeAnchor', $xeAnchor);
    $xeAnchor.renderVN = renderVN;
    return $xeAnchor;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/anchor/index.ts



const VxeAnchor = Object.assign({}, src_anchor, {
  install(app) {
    app.component(src_anchor.name, src_anchor);
  }
});
dynamicApp.use(VxeAnchor);
index_esm_VxeUI.component(src_anchor);
const Anchor = VxeAnchor;
/* harmony default export */ var packages_anchor = (VxeAnchor);
;// CONCATENATED MODULE: ./packages/anchor-link/index.ts



const VxeAnchorLink = Object.assign({}, anchor_link, {
  install(app) {
    app.component(anchor_link.name, anchor_link);
  }
});
dynamicApp.use(VxeAnchorLink);
index_esm_VxeUI.component(anchor_link);
const AnchorLink = VxeAnchorLink;
/* harmony default export */ var packages_anchor_link = (VxeAnchorLink);
;// CONCATENATED MODULE: ./packages/avatar/src/avatar.ts





/* harmony default export */ var avatar = (defineVxeComponent({
  name: 'VxeAvatar',
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    icon: String,
    src: String,
    width: [String, Number],
    height: [String, Number],
    circle: {
      type: Boolean,
      default: () => getConfig().avatar.circle
    },
    status: {
      type: String,
      default: () => getConfig().avatar.status
    },
    size: {
      type: String,
      default: () => getConfig().avatar.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeAvatarStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        height
      } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeCountNum = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        count
      } = props;
      return count ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(count) : 0;
    });
    const computeMaps = {};
    const $xeAvatar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $avatar: $xeAvatar
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeAvatar, collapsePaneMethods, collapsePanePrivateMethods);
    const renderContent = () => {
      const {
        icon,
        content,
        src
      } = props;
      if (icon) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-avatar--icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: icon
        })]);
      }
      if (content) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-avatar--content'
        }, `${content}`);
      }
      if (src) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
          class: 'vxe-avatar--img',
          src
        });
      }
      return renderEmptyElement($xeAvatar);
    };
    const renderVN = () => {
      const {
        circle,
        dot,
        status
      } = props;
      const vSize = computeSize.value;
      const countNum = computeCountNum.value;
      const avatarStyle = computeAvatarStyle.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-avatar', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--circle': circle,
          'is--dot': dot
        }],
        style: avatarStyle
      }, [renderContent(), countNum ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-avatar--count'
      }, countNum > 99 ? '99+' : `${countNum}`) : renderEmptyElement($xeAvatar)]);
    };
    $xeAvatar.renderVN = renderVN;
    return $xeAvatar;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/avatar/index.ts



const VxeAvatar = Object.assign({}, avatar, {
  install(app) {
    app.component(avatar.name, avatar);
  }
});
dynamicApp.use(VxeAvatar);
index_esm_VxeUI.component(avatar);
const Avatar = VxeAvatar;
/* harmony default export */ var packages_avatar = (VxeAvatar);
;// CONCATENATED MODULE: ./packages/badge/src/badge.ts




/* harmony default export */ var badge = (defineVxeComponent({
  name: 'VxeBadge',
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().badge.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeCountNum = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        count
      } = props;
      return count ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(count) : 0;
    });
    const computeMaps = {};
    const $xeBadge = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $badge: $xeBadge
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeBadge, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const {
        dot,
        content
      } = props;
      const vSize = computeSize.value;
      const countNum = computeCountNum.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-badge', {
          [`size--${vSize}`]: vSize,
          'is--dot': dot
        }]
      }, [defaultSlot || content ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-badge--content'
      }, defaultSlot ? defaultSlot({}) : `${content || ''}`) : [], countNum ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-badge--count'
      }, countNum > 99 ? '99+' : `${countNum}`) : renderEmptyElement($xeBadge)]);
    };
    $xeBadge.renderVN = renderVN;
    return $xeBadge;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/badge/index.ts



const VxeBadge = Object.assign({}, badge, {
  install(app) {
    app.component(badge.name, badge);
  }
});
dynamicApp.use(VxeBadge);
index_esm_VxeUI.component(badge);
const Badge = VxeBadge;
/* harmony default export */ var packages_badge = (VxeBadge);
;// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb-item.ts




/* harmony default export */ var breadcrumb_item = (defineVxeComponent({
  name: 'VxeBreadcrumbItem',
  props: {
    title: String,
    routerLink: Object
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeBreadcrumb = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeBreadcrumb', null);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeSeparator = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeBreadcrumb) {
        return $xeBreadcrumb.props.separator;
      }
      return '';
    });
    const clickEvent = evnt => {
      if ($xeBreadcrumb) {
        const item = {
          title: props.title,
          routerLink: props.routerLink
        };
        $xeBreadcrumb.handleClickLink(evnt, item);
      }
    };
    const computeMaps = {};
    const $xeBreadcrumbItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const {
        title,
        routerLink
      } = props;
      const separator = computeSeparator.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        ref: refElem,
        class: 'vxe-breadcrumb-item',
        onClick: clickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-breadcrumb-item--content'
      }, [routerLink ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
        class: 'vxe-breadcrumb-item--content-link',
        title,
        to: routerLink
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-breadcrumb-item--content-text'
          }, defaultSlot ? defaultSlot({}) : `${title || ''}`);
        }
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-breadcrumb-item--content-text'
      }, defaultSlot ? defaultSlot({}) : `${title || ''}`)]), separator ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-breadcrumb-item--separator'
      }, `${separator}`) : renderEmptyElement($xeBreadcrumbItem)]);
    };
    $xeBreadcrumbItem.renderVN = renderVN;
    return $xeBreadcrumbItem;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb.ts





/* harmony default export */ var breadcrumb = (defineVxeComponent({
  name: 'VxeBreadcrumb',
  props: {
    separator: {
      type: String,
      default: () => getConfig().breadcrumb.separator
    },
    options: Array
  },
  emits: ['click'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeBreadcrumb = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const breadcrumbMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $breadcrumb: $xeBreadcrumb
        }, params));
      }
    };
    const breadcrumbPrivateMethods = {
      handleClickLink(evnt, option) {
        breadcrumbMethods.dispatchEvent('click', {
          option
        }, evnt);
      }
    };
    Object.assign($xeBreadcrumb, breadcrumbMethods, breadcrumbPrivateMethods);
    const renderItems = () => {
      const {
        options
      } = props;
      if (options && options.length) {
        return options.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(breadcrumb_item, {
            title: item.title,
            routerLink: item.routerLink
          });
        });
      }
      return [];
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: 'vxe-breadcrumb'
      }, defaultSlot ? defaultSlot({}) : renderItems());
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeBreadcrumb', $xeBreadcrumb);
    $xeBreadcrumb.renderVN = renderVN;
    return $xeBreadcrumb;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/breadcrumb/index.ts



const VxeBreadcrumb = Object.assign({}, breadcrumb, {
  install(app) {
    app.component(breadcrumb.name, breadcrumb);
  }
});
dynamicApp.use(VxeBreadcrumb);
index_esm_VxeUI.component(breadcrumb);
const Breadcrumb = VxeBreadcrumb;
/* harmony default export */ var packages_breadcrumb = (VxeBreadcrumb);
;// CONCATENATED MODULE: ./packages/breadcrumb-item/index.ts



const VxeBreadcrumbItem = Object.assign({}, breadcrumb_item, {
  install(app) {
    app.component(breadcrumb_item.name, breadcrumb_item);
  }
});
dynamicApp.use(VxeBreadcrumbItem);
index_esm_VxeUI.component(breadcrumb_item);
const BreadcrumbItem = VxeBreadcrumbItem;
/* harmony default export */ var packages_breadcrumb_item = (VxeBreadcrumbItem);
;// CONCATENATED MODULE: ./packages/ui/src/utils.ts



function isEnableConf(conf) {
  return conf && conf.enabled !== false;
}
function nextZIndex() {
  return index_esm.getNext();
}
function getLastZIndex() {
  return index_esm.getCurrent();
}
function nextSubZIndex() {
  return index_esm.getSubNext();
}
function getSubLastZIndex() {
  return index_esm.getSubCurrent();
}
function getGlobalDefaultConfig(value, globalValue) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(value)) {
    return globalValue;
  }
  return value;
}
function getFuncText(content, args) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(content)) {
    return '';
  }
  const translate = getConfig().translate;
  return `${translate ? translate('' + content, args) : content}`;
}
/**
 * å¤æ­å¼ä¸ºï¼'' | null | undefined æ¶é½å±äºç©ºå¼
 */
function eqEmptyValue(cellValue) {
  return cellValue === null || cellValue === undefined || cellValue === '';
}
function handleBooleanDefaultValue(value) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(value) ? value : null;
}
;// CONCATENATED MODULE: ./packages/tooltip/src/tooltip.ts








/* harmony default export */ var tooltip = (defineVxeComponent({
  name: 'VxeTooltip',
  props: {
    modelValue: Boolean,
    size: {
      type: String,
      default: () => getConfig().tooltip.size || getConfig().size
    },
    selector: String,
    trigger: {
      type: String,
      default: () => getConfig().tooltip.trigger || 'hover'
    },
    theme: {
      type: String,
      default: () => getConfig().tooltip.theme || 'dark'
    },
    content: {
      type: [String, Number],
      default: null
    },
    useHTML: Boolean,
    zIndex: [String, Number],
    popupClassName: [String, Function],
    width: {
      type: [String, Number],
      default: () => getConfig().tooltip.Width
    },
    height: {
      type: [String, Number],
      default: () => getConfig().tooltip.height
    },
    minWidth: {
      type: [String, Number],
      default: () => getConfig().tooltip.minWidth
    },
    minHeight: {
      type: [String, Number],
      default: () => getConfig().tooltip.minHeight
    },
    maxWidth: {
      type: [String, Number],
      default: () => getConfig().tooltip.maxWidth
    },
    maxHeight: {
      type: [String, Number],
      default: () => getConfig().tooltip.maxHeight
    },
    isArrow: {
      type: Boolean,
      default: () => getConfig().tooltip.isArrow
    },
    enterable: {
      type: Boolean,
      default: () => getConfig().tooltip.enterable
    },
    enterDelay: {
      type: Number,
      default: () => getConfig().tooltip.enterDelay
    },
    leaveDelay: {
      type: Number,
      default: () => getConfig().tooltip.leaveDelay
    }
  },
  emits: ['update:modelValue'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      target: null,
      isUpdate: false,
      visible: false,
      tipContent: '',
      tipActive: false,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: '',
        arrowStyle: {}
      }
    });
    const internalData = {};
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const contentWrapperfElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const computeWrapperStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        height,
        minHeight,
        minWidth,
        maxHeight,
        maxWidth
      } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (minWidth) {
        stys.minWidth = toCssUnit(minWidth);
      }
      if (minHeight) {
        stys.minHeight = toCssUnit(minHeight);
      }
      if (maxWidth) {
        stys.maxWidth = toCssUnit(maxWidth);
      }
      if (maxHeight) {
        stys.maxHeight = toCssUnit(maxHeight);
      }
      return stys;
    });
    const refMaps = {
      refElem
    };
    const $xeTooltip = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let tooltipMethods = {};
    const updateTipStyle = () => {
      const {
        tipTarget,
        tipStore
      } = reactData;
      if (tipTarget) {
        const {
          scrollTop,
          scrollLeft,
          visibleWidth
        } = getDomNode();
        const {
          top,
          left
        } = getAbsolutePos(tipTarget);
        const el = refElem.value;
        if (!el) {
          return;
        }
        const marginSize = 6;
        const offsetHeight = el.offsetHeight;
        const offsetWidth = el.offsetWidth;
        let tipLeft = left;
        let tipTop = top - offsetHeight - marginSize;
        tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));
        if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {
          tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;
        }
        if (top - offsetHeight < scrollTop + marginSize) {
          tipStore.placement = 'bottom';
          tipTop = top + tipTarget.offsetHeight + marginSize;
        }
        tipStore.style.top = `${tipTop}px`;
        tipStore.style.left = `${tipLeft}px`;
        tipStore.arrowStyle.left = `${left - tipLeft + tipTarget.offsetWidth / 2}px`;
      }
    };
    const updateValue = value => {
      if (value !== reactData.visible) {
        reactData.visible = value;
        reactData.isUpdate = true;
        emit('update:modelValue', value);
      }
    };
    const updateZindex = () => {
      if (reactData.tipZindex < getLastZIndex()) {
        reactData.tipZindex = nextZIndex();
      }
    };
    const clickEvent = () => {
      if (reactData.visible) {
        tooltipMethods.close();
      } else {
        handleVisible(reactData.target || getSelectorEl(), props.content);
      }
    };
    const targetMouseenterEvent = () => {
      handleVisible(reactData.target || getSelectorEl(), props.content);
    };
    const targetMouseleaveEvent = () => {
      const {
        trigger,
        enterable,
        leaveDelay
      } = props;
      reactData.tipActive = false;
      if (enterable && trigger === 'hover') {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      } else {
        tooltipMethods.close();
      }
    };
    const wrapperMouseenterEvent = () => {
      reactData.tipActive = true;
    };
    const wrapperMouseleaveEvent = () => {
      const {
        trigger,
        enterable,
        leaveDelay
      } = props;
      reactData.tipActive = false;
      if (enterable && trigger === 'hover') {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      }
    };
    const showTip = () => {
      const {
        tipStore
      } = reactData;
      const el = refElem.value;
      if (el) {
        const parentNode = el.parentNode;
        if (!parentNode) {
          document.body.appendChild(el);
        }
      }
      updateValue(true);
      updateZindex();
      tipStore.placement = 'top';
      tipStore.style = {
        width: 'auto',
        left: 0,
        top: 0,
        zIndex: props.zIndex || reactData.tipZindex
      };
      tipStore.arrowStyle = {
        left: '50%'
      };
      return tooltipMethods.updatePlacement();
    };
    const handleDelayFn = () => {
      internalData.showDelayTip = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().debounce(() => {
        if (reactData.tipActive) {
          showTip();
        }
      }, props.enterDelay, {
        leading: false,
        trailing: true
      });
    };
    const handleVisible = (target, content) => {
      const contentSlot = slots.content;
      if (!contentSlot && (content === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(content))) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
      if (target) {
        const {
          showDelayTip
        } = internalData;
        const {
          trigger,
          enterDelay
        } = props;
        reactData.tipActive = true;
        reactData.tipTarget = target;
        reactData.tipContent = content;
        if (enterDelay && trigger === 'hover') {
          if (showDelayTip) {
            showDelayTip();
          }
        } else {
          return showTip();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const getSelectorEl = () => {
      const {
        selector
      } = props;
      if (selector) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isElement(selector)) {
          return selector;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(selector)) {
          return document.querySelector(selector);
        }
      }
      return null;
    };
    tooltipMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $tooltip: $xeTooltip
        }, params));
      },
      open(target, content) {
        return handleVisible(target || reactData.target || getSelectorEl(), content);
      },
      close() {
        reactData.tipTarget = null;
        reactData.tipActive = false;
        Object.assign(reactData.tipStore, {
          style: {},
          placement: '',
          arrowStyle: null
        });
        updateValue(false);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      toVisible(target, content) {
        return handleVisible(target, content);
      },
      updatePlacement() {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          const {
            tipTarget
          } = reactData;
          const el = refElem.value;
          if (tipTarget && el) {
            updateTipStyle();
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
              updateTipStyle();
            });
          }
        });
      },
      isActived() {
        return reactData.tipActive;
      },
      setActived(active) {
        reactData.tipActive = !!active;
      }
    };
    const wheelEvent = evnt => {
      evnt.stopPropagation();
    };
    Object.assign($xeTooltip, tooltipMethods);
    const renderContent = () => {
      const {
        useHTML
      } = props;
      const {
        tipContent
      } = reactData;
      const wrapperStyle = computeWrapperStyle.value;
      const contentSlot = slots.content;
      const contVNs = [];
      if (contentSlot) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 1
        }, vn_getSlotVNs(contentSlot({}))));
      } else if (useHTML) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 2,
          innerHTML: tipContent
        }));
      } else {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          key: 3
        }, `${tipContent}`));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 3,
        ref: contentWrapperfElem,
        class: 'vxe-tooltip--content',
        style: wrapperStyle
      }, contVNs);
    };
    const renderVN = () => {
      const {
        popupClassName,
        theme,
        isArrow,
        enterable
      } = props;
      const {
        tipActive,
        visible,
        tipStore
      } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      let ons;
      if (enterable) {
        ons = {
          onMouseenter: wrapperMouseenterEvent,
          onMouseleave: wrapperMouseleaveEvent
        };
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tooltip--wrapper', `theme--${theme}`, popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $tooltip: $xeTooltip
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          [`placement--${tipStore.placement}`]: tipStore.placement,
          'is--enterable': enterable,
          'is--visible': visible,
          'is--arrow': isArrow,
          'is--active': tipActive
        }],
        style: tipStore.style,
        ...ons
      }, [renderContent(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tooltip--arrow',
        style: tipStore.arrowStyle
      }), ...(defaultSlot ? vn_getSlotVNs(defaultSlot({})) : [])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.enterDelay, () => {
      handleDelayFn();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.content, val => {
      reactData.tipContent = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      if (!reactData.isUpdate) {
        if (val) {
          handleVisible(reactData.target || getSelectorEl(), props.content);
        } else {
          tooltipMethods.close();
        }
      }
      reactData.isUpdate = false;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const contentWrapperfEl = contentWrapperfElem.value;
      if (contentWrapperfEl) {
        contentWrapperfEl.addEventListener('wheel', wheelEvent, {
          passive: false
        });
      }
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          trigger,
          content
        } = props;
        const wrapperElem = refElem.value;
        if (wrapperElem) {
          const parentNode = wrapperElem.parentNode;
          if (parentNode) {
            reactData.tipContent = content;
            reactData.tipZindex = nextZIndex();
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(wrapperElem.children, (elem, index) => {
              if (index > 1) {
                parentNode.insertBefore(elem, wrapperElem);
                if (!reactData.target) {
                  reactData.target = elem;
                }
              }
            });
            parentNode.removeChild(wrapperElem);
            const {
              target
            } = reactData;
            if (target) {
              if (trigger === 'hover') {
                target.onmouseenter = targetMouseenterEvent;
                target.onmouseleave = targetMouseleaveEvent;
              } else if (trigger === 'click') {
                target.onclick = clickEvent;
              }
            }
            if (props.modelValue) {
              handleVisible(target || getSelectorEl(), content);
            }
          }
        }
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      const {
        target
      } = reactData;
      const wrapperElem = refElem.value;
      if (target) {
        target.onmouseenter = null;
        target.onmouseleave = null;
        target.onclick = null;
      }
      const contentWrapperfEl = contentWrapperfElem.value;
      if (contentWrapperfEl) {
        contentWrapperfEl.removeEventListener('wheel', wheelEvent);
      }
      if (wrapperElem) {
        const parentNode = wrapperElem.parentNode;
        if (parentNode) {
          parentNode.removeChild(wrapperElem);
        }
      }
    });
    handleDelayFn();
    $xeTooltip.renderVN = renderVN;
    return $xeTooltip;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/button/src/button.ts










const VxeButtonComponent = defineVxeComponent({
  name: 'VxeButton',
  props: {
    /**
     * æé®ç±»å
     */
    type: String,
    mode: String,
    className: [String, Function],
    popupClassName: [String, Function],
    /**
     * æé®å°ºå¯¸
     */
    size: {
      type: String,
      default: () => getConfig().button.size || getConfig().size
    },
    zIndex: Number,
    /**
     * ç¨æ¥æ è¯è¿ä¸é¡¹
     */
    name: [String, Number],
    routerLink: Object,
    /**
     * æéç 
     */
    permissionCode: [String, Number],
    /**
     * æé®åå®¹
     */
    content: String,
    /**
     * åºå®æ¾ç¤ºä¸æé¢æ¿çæ¹å
     */
    placement: String,
    /**
     * æé®ç¶æ
     */
    status: String,
    /**
     * æ é¢
     */
    title: String,
    /**
     * æé®çåç¼å¾æ ï¼å±äº prefix-icon çç®å
     */
    icon: String,
    iconRender: Object,
    /**
     * æé®çåç¼å¾æ 
     */
    prefixIcon: String,
    prefixRender: Object,
    /**
     * æé®çåç¼å¾æ 
     */
    suffixIcon: String,
    suffixRender: Object,
    /**
     * åè§è¾¹æ¡
     */
    round: Boolean,
    /**
     * åè§æé®
     */
    circle: Boolean,
    /**
     * æ¯å¦ç¦ç¨
     */
    disabled: Boolean,
    /**
     * æ¯å¦å è½½ä¸­
     */
    loading: Boolean,
    trigger: {
      type: String,
      default: () => getConfig().button.trigger
    },
    align: String,
    prefixTooltip: Object,
    suffixTooltip: Object,
    options: Array,
    /**
     * å¨ä¸æé¢æ¿å³é­æ¶éæ¯åå®¹
     */
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().button.destroyOnClose
    },
    /**
     * æ¯å¦å°å¼¹æ¡å®¹å¨æå¥äº body å
     */
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['click', 'mouseenter', 'mouseleave', 'dropdown-click', 'dropdownClick'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const $xeButtonGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeButtonGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: ''
    });
    const internalData = {
      showTime: undefined,
      tooltipTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refButton = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBtnPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeButton = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let buttonMethods = {};
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().button.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeBtnDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      const permissionInfo = computePermissionInfo.value;
      return disabled || permissionInfo.disabled;
    });
    const computeIsFormBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      if (type) {
        return ['submit', 'reset', 'button'].indexOf(type) > -1;
      }
      return false;
    });
    const computeBtnMode = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        mode
      } = props;
      if (mode === 'text' || type === 'text' || $xeButtonGroup && $xeButtonGroup.props.mode === 'text') {
        return 'text';
      }
      return 'button';
    });
    const computeBtnStatus = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        status
      } = props;
      if (status) {
        return status;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.status;
      }
      return '';
    });
    const computeBtnAlign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        align
      } = props;
      if (align) {
        return align;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.align;
      }
      return false;
    });
    const computeBtnRound = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        round
      } = props;
      if (round) {
        return round;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.round;
      }
      return false;
    });
    const computeBtnCircle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        circle
      } = props;
      if (circle) {
        return circle;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.circle;
      }
      return false;
    });
    const computeDownBtnList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        options
      } = props;
      if (options) {
        return options.filter(item => {
          const {
            permissionCode
          } = item;
          return !permissionCode || permission.checkVisible(permissionCode);
        });
      }
      return [];
    });
    const computePrefixTipOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().button.prefixTooltip, props.prefixTooltip);
    });
    const computeSuffixTipOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().button.suffixTooltip, props.suffixTooltip);
    });
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refButton.value;
      const panelElem = refBtnPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const clickEvent = evnt => {
      if ($xeButtonGroup) {
        $xeButtonGroup.handleClick({
          name: props.name
        }, evnt);
      }
      dispatchEvent('click', {
        $event: evnt
      }, evnt);
    };
    const downBtnClickEvent = (params, option) => {
      const {
        $event
      } = params;
      hidePanel();
      dispatchEvent('dropdown-click', {
        name: option.name,
        option
      }, $event);
    };
    const mousedownDropdownEvent = evnt => {
      const isLeftBtn = evnt.button === 0;
      if (isLeftBtn) {
        evnt.stopPropagation();
      }
    };
    const clickDropdownEvent = evnt => {
      const dropdownElem = evnt.currentTarget;
      const panelElem = refBtnPanel.value;
      const {
        flag,
        targetElem
      } = getEventTargetNode(evnt, dropdownElem, 'vxe-button');
      if (flag) {
        if (panelElem) {
          panelElem.dataset.active = 'N';
        }
        reactData.visiblePanel = false;
        setTimeout(() => {
          if (!panelElem || panelElem.dataset.active !== 'Y') {
            reactData.isAniVisible = false;
          }
        }, 350);
        dispatchEvent('dropdown-click', {
          name: targetElem.getAttribute('name'),
          option: null
        }, evnt);
      }
    };
    const mouseenterDropdownEvent = () => {
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = 'Y';
        reactData.isAniVisible = true;
        setTimeout(() => {
          if (panelElem.dataset.active === 'Y') {
            reactData.visiblePanel = true;
            updateZindex();
            updatePlacement();
            setTimeout(() => {
              if (reactData.visiblePanel) {
                updatePlacement();
              }
            }, 50);
          }
        }, 20);
      }
    };
    const mouseenterTargetEvent = evnt => {
      const {
        loading
      } = props;
      const btnDisabled = computeBtnDisabled.value;
      if (!(btnDisabled || loading)) {
        openPanel();
        mouseenterEvent(evnt);
      }
    };
    const mouseleaveTargetEvent = evnt => {
      hidePanel();
      mouseleaveEvent(evnt);
    };
    const mouseenterEvent = evnt => {
      dispatchEvent('mouseenter', {}, evnt);
    };
    const mouseleaveEvent = evnt => {
      dispatchEvent('mouseleave', {}, evnt);
    };
    const clickTargetEvent = evnt => {
      const {
        loading,
        trigger
      } = props;
      const btnDisabled = computeBtnDisabled.value;
      if (!(btnDisabled || loading)) {
        if (trigger === 'click') {
          if (reactData.visiblePanel) {
            hidePanel();
          } else {
            openPanel();
          }
        }
        clickEvent(evnt);
      }
    };
    const openPanel = () => {
      const {
        trigger
      } = props;
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = 'Y';
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        internalData.showTime = setTimeout(() => {
          if (panelElem.dataset.active === 'Y') {
            mouseenterDropdownEvent();
          } else {
            reactData.isAniVisible = false;
          }
        }, trigger === 'click' ? 50 : 250);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const hidePanel = () => {
      const panelElem = refBtnPanel.value;
      clearTimeout(internalData.showTime);
      if (panelElem) {
        panelElem.dataset.active = 'N';
        setTimeout(() => {
          if (panelElem.dataset.active !== 'Y') {
            reactData.visiblePanel = false;
            setTimeout(() => {
              if (panelElem.dataset.active !== 'Y') {
                reactData.isAniVisible = false;
              }
            }, 350);
          }
        }, 100);
      } else {
        reactData.isAniVisible = false;
        reactData.visiblePanel = false;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const mouseleaveDropdownEvent = () => {
      hidePanel();
    };
    const renderTooltipIcon = (tipOpts, type) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tooltip, {
        useHTML: tipOpts.useHTML,
        content: tipOpts.content,
        enterable: tipOpts.enterable,
        theme: tipOpts.theme
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: `vxe-button--item vxe-button--tooltip-${type}-icon`
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: tipOpts.icon || getIcon().BUTTON_TOOLTIP_ICON
          })]);
        }
      });
    };
    const renderContent = () => {
      const {
        content,
        suffixIcon,
        loading,
        prefixTooltip,
        suffixTooltip,
        suffixRender
      } = props;
      const prefixIcon = props.prefixIcon || props.icon;
      const prefixRender = props.prefixRender || props.iconRender;
      const prefixTipOpts = computePrefixTipOpts.value;
      const suffixTipOpts = computeSuffixTipOpts.value;
      const prefixIconSlot = slots.prefix || slots.icon;
      const suffixIconSlot = slots.suffix;
      const defaultSlot = slots.default;
      const contVNs = [];
      if (prefixTooltip) {
        contVNs.push(renderTooltipIcon(prefixTipOpts, 'prefix'));
      }
      if (loading) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-button--item vxe-button--loading-icon', getIcon().BUTTON_LOADING]
        }));
      } else if (prefixIconSlot) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--item vxe-button--custom-prefix-icon'
        }, prefixIconSlot({})));
      } else if (prefixRender) {
        const compConf = renderer.get(prefixRender.name);
        const pIconMethod = compConf ? compConf.renderButtonPrefix : null;
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-button--item vxe-button--custom-prefix-icon']
        }, pIconMethod ? vn_getSlotVNs(pIconMethod(prefixRender, {
          $button: $xeButton
        })) : []));
      } else if (prefixIcon) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-button--item vxe-button--prefix-icon', prefixIcon]
        }));
      }
      if (defaultSlot) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--item vxe-button--content'
        }, defaultSlot({})));
      } else if (content) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--item vxe-button--content'
        }, getFuncText(content)));
      }
      if (suffixIconSlot) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--item vxe-button--custom-suffix-icon'
        }, suffixIconSlot({})));
      } else if (suffixRender) {
        const compConf = renderer.get(suffixRender.name);
        const sIconMethod = compConf ? compConf.renderButtonSuffix : null;
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-button--item vxe-button--custom-suffix-icon']
        }, sIconMethod ? vn_getSlotVNs(sIconMethod(suffixRender, {
          $button: $xeButton
        })) : []));
      } else if (suffixIcon) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-button--item vxe-button--suffix-icon', suffixIcon]
        }));
      }
      if (suffixTooltip) {
        contVNs.push(renderTooltipIcon(suffixTipOpts, 'suffix'));
      }
      return contVNs;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $button: $xeButton
      }, params));
    };
    buttonMethods = {
      dispatchEvent,
      openPanel,
      closePanel: hidePanel,
      focus() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.focus();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.blur();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const panelElem = refBtnPanel.value;
      if (reactData.visiblePanel && !getEventTargetNode(evnt, panelElem).flag) {
        hidePanel();
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const btnDisabled = computeBtnDisabled.value;
      const {
        visiblePanel
      } = reactData;
      if (!btnDisabled) {
        const el = refElem.value;
        const panelElem = refBtnPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hidePanel();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    Object.assign($xeButton, buttonMethods);
    const renderVN = () => {
      const {
        className,
        popupClassName,
        trigger,
        title,
        routerLink,
        type,
        destroyOnClose,
        name,
        loading
      } = props;
      const {
        initialized,
        isAniVisible,
        visiblePanel
      } = reactData;
      const isFormBtn = computeIsFormBtn.value;
      const btnMode = computeBtnMode.value;
      const btnStatus = computeBtnStatus.value;
      const btnRound = computeBtnRound.value;
      const btnAlign = computeBtnAlign.value;
      const btnCircle = computeBtnCircle.value;
      const btnTransfer = computeBtnTransfer.value;
      const btnDisabled = computeBtnDisabled.value;
      const permissionInfo = computePermissionInfo.value;
      const downBtnList = computeDownBtnList.value;
      const vSize = computeSize.value;
      const dropdownsSlot = slots.dropdowns;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeButton);
      }
      if (dropdownsSlot || downBtnList.length) {
        const btnOns = {};
        const panelOns = {};
        if (trigger === 'hover') {
          // hover è§¦å
          btnOns.onMouseenter = mouseenterTargetEvent;
          btnOns.onMouseleave = mouseleaveTargetEvent;
          panelOns.onMouseenter = mouseenterDropdownEvent;
          panelOns.onMouseleave = mouseleaveDropdownEvent;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-button--dropdown', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
            $button: $xeButton
          }) : className : '', {
            [`size--${vSize}`]: vSize,
            'is--active': visiblePanel
          }]
        }, [routerLink ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
          ref: refButton,
          class: ['vxe-button', 'vxe-button--link', `type--${btnMode}`, btnAlign ? `align--${btnAlign}` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
            $button: $xeButton
          }) : className : '', {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            'is--round': btnRound,
            'is--circle': btnCircle,
            'is--disabled': btnDisabled || loading,
            'is--loading': loading
          }],
          title,
          name,
          type: isFormBtn ? type : 'button',
          disabled: btnDisabled || loading,
          to: routerLink,
          onClick: clickTargetEvent,
          ...btnOns
        }, {
          default() {
            return renderContent().concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
              class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
            })]);
          }
        }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
          ref: refButton,
          class: ['vxe-button', `type--${btnMode}`, btnAlign ? `align--${btnAlign}` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
            $button: $xeButton
          }) : className : '', {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            'is--round': btnRound,
            'is--circle': btnCircle,
            'is--disabled': btnDisabled || loading,
            'is--loading': loading
          }],
          title,
          name,
          type: isFormBtn ? type : 'button',
          disabled: btnDisabled || loading,
          onClick: clickTargetEvent,
          ...btnOns
        }, renderContent().concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
        })])), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
          to: 'body',
          disabled: btnTransfer ? !initialized : true
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refBtnPanel,
          class: ['vxe-button--dropdown-panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
            $button: $xeButton
          }) : popupClassName : '', {
            [`size--${vSize}`]: vSize,
            'is--transfer': btnTransfer,
            'ani--leave': isAniVisible,
            'ani--enter': visiblePanel
          }],
          placement: reactData.panelPlacement,
          style: reactData.panelStyle,
          ...panelOns
        }, initialized && (visiblePanel || isAniVisible) ? [dropdownsSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-button--dropdown-wrapper',
          onMousedown: mousedownDropdownEvent,
          onClick: clickDropdownEvent
        }, initialized && (destroyOnClose ? visiblePanel || isAniVisible : true) ? dropdownsSlot({}) : []) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-button--dropdown-wrapper'
        }, initialized && (destroyOnClose ? visiblePanel || isAniVisible : true) ? downBtnList.map((option, i) => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeButtonComponent, {
            key: i,
            type: option.type,
            mode: option.mode || btnMode,
            className: option.className,
            name: option.name,
            routerLink: option.routerLink,
            permissionCode: option.permissionCode,
            title: option.title,
            content: option.content,
            status: option.status,
            icon: option.icon,
            round: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(option.round) ? option.round : btnMode === 'text' ? false : btnRound,
            circle: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(option.circle) ? option.circle : btnMode === 'text' ? false : btnCircle,
            disabled: option.disabled,
            loading: option.loading,
            align: option.align,
            onClick(params) {
              downBtnClickEvent(params, option);
            }
          });
        }) : [])] : [])])]);
      }
      if (routerLink) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
          ref: refButton,
          class: ['vxe-button', 'vxe-button--link', `type--${btnMode}`, btnAlign ? `align--${btnAlign}` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
            $button: $xeButton
          }) : className : '', {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            'is--round': btnRound,
            'is--circle': btnCircle,
            'is--disabled': btnDisabled || loading,
            'is--loading': loading
          }],
          title,
          name,
          type: isFormBtn ? type : 'button',
          disabled: btnDisabled || loading,
          to: routerLink,
          onClick: clickEvent,
          onMouseenter: mouseenterEvent,
          onMouseleave: mouseleaveEvent
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        ref: refButton,
        class: ['vxe-button', `type--${btnMode}`, btnAlign ? `align--${btnAlign}` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $button: $xeButton
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          [`theme--${btnStatus}`]: btnStatus,
          'is--round': btnRound,
          'is--circle': btnCircle,
          'is--disabled': btnDisabled || loading,
          'is--loading': loading
        }],
        title,
        name,
        type: isFormBtn ? type : 'button',
        disabled: btnDisabled || loading,
        onClick: clickEvent,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, renderContent());
    };
    $xeButton.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if (props.type === 'text') {
        warnLog('vxe.error.delProp', ['[button] type=text', 'mode=text']);
      }
      globalEvents.on($xeButton, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeButton, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeButton, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeButton, 'mousewheel');
      globalEvents.off($xeButton, 'mousedown');
      globalEvents.off($xeButton, 'resize');
    });
    return $xeButton;
  },
  render() {
    return this.renderVN();
  }
});
/* harmony default export */ var src_button = (VxeButtonComponent);
;// CONCATENATED MODULE: ./packages/button/index.ts



const VxeButton = Object.assign({}, src_button, {
  install(app) {
    app.component(src_button.name, src_button);
  }
});
dynamicApp.use(VxeButton);
index_esm_VxeUI.component(src_button);
const Button = VxeButton;
/* harmony default export */ var packages_button = (VxeButton);
;// CONCATENATED MODULE: ./packages/button/src/button-group.ts





/* harmony default export */ var button_group = (defineVxeComponent({
  name: 'VxeButtonGroup',
  props: {
    options: Array,
    mode: String,
    status: String,
    round: Boolean,
    vertical: Boolean,
    circle: Boolean,
    align: String,
    className: [String, Function],
    disabled: Boolean,
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().buttonGroup.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const computeMaps = {};
    const $xeButtonGroup = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const buttonGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $buttonGroup: $xeButtonGroup
        }, params));
      }
    };
    const buttonGroupPrivateMethods = {
      handleClick(params, evnt) {
        const {
          options
        } = props;
        const {
          name
        } = params;
        const option = options ? options.find(item => item.name === name) : null;
        buttonGroupMethods.dispatchEvent('click', {
          ...params,
          option
        }, evnt);
      }
    };
    Object.assign($xeButtonGroup, buttonGroupMethods, buttonGroupPrivateMethods);
    const renderVN = () => {
      const {
        className,
        options,
        vertical
      } = props;
      const permissionInfo = computePermissionInfo.value;
      const defaultSlot = slots.default;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeButtonGroup);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-button-group', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $buttonGroup: $xeButtonGroup
        }) : className : '', {
          'is--vertical': vertical
        }]
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: index,
          ...item
        });
      }) : []);
    };
    $xeButtonGroup.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeButtonGroup', $xeButtonGroup);
    return $xeButtonGroup;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/button-group/index.ts



const VxeButtonGroup = Object.assign({}, button_group, {
  install(app) {
    app.component(button_group.name, button_group);
  }
});
dynamicApp.use(VxeButtonGroup);
index_esm_VxeUI.component(button_group);
const ButtonGroup = VxeButtonGroup;
/* harmony default export */ var packages_button_group = (VxeButtonGroup);
;// CONCATENATED MODULE: ./packages/date-panel/src/util.ts

function hasTimestampValueType(valueFormat) {
  return valueFormat === 'timestamp';
}
function hasDateValueType(valueFormat) {
  return valueFormat === 'date';
}
function handleValueFormat(type, valueFormat) {
  if (valueFormat) {
    if (!(hasDateValueType(valueFormat) || hasTimestampValueType(valueFormat))) {
      return valueFormat;
    }
  }
  if (type === 'time') {
    return 'HH:mm:ss';
  }
  if (type === 'datetime') {
    return 'yyyy-MM-dd HH:mm:ss';
  }
  return 'yyyy-MM-dd';
}
function toStringTimeDate(str) {
  const rest = new Date(2e3, 0, 1);
  if (str) {
    let h = 0;
    let m = 0;
    let s = 0;
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(str) || /^[0-9]{11,15}$/.test(`${str}`)) {
      str = new Date(Number(str));
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDate(str)) {
      h = str.getHours();
      m = str.getMinutes();
      s = str.getSeconds();
    } else {
      str = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(str);
      const parses = str.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      if (parses) {
        h = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[1]);
        m = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[3]);
        s = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[5]);
      }
    }
    rest.setHours(h);
    rest.setMinutes(m);
    rest.setSeconds(s);
    return rest;
  }
  return rest;
}
function getDateQuarter(date) {
  const month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}
const parseDateValue = (val, type, options) => {
  const {
    valueFormat
  } = options;
  if (val) {
    if (type === 'time') {
      return toStringTimeDate(val);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(val) || /^[0-9]{10,15}$/.test(`${val}`)) {
      return new Date(Number(val));
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val)) {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().last(val.split(',')), valueFormat);
    }
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(val, valueFormat);
  }
  return null;
};
const parseDateString = (val, type, options) => {
  const dValue = parseDateValue(val, type, options);
  return dValue ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dValue, options.valueFormat) : '';
};
function parseDateObj(val, type, options) {
  const {
    labelFormat,
    firstDay
  } = options;
  let dValue = null;
  let dLabel = '';
  if (val) {
    dValue = parseDateValue(val, type, options);
  }
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(dValue)) {
    dLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dValue, labelFormat, {
      firstDay
    });
    // å¨éæ©å¨ï¼ç±äºå¹´ä»½åç¬¬å å¨æ¯å²çªçè¡ä¸ºï¼æä»¥éè¦ç¹æ®å¤çï¼å¤æ­æ¯å¦è·¨å¹´ï¼ä¾å¦
    // '2024-12-31' 'yyyy-MM-dd W' >> '2024-12-31 1'
    // '2025-01-01' 'yyyy-MM-dd W' >> '2025-01-01 1'
    if (labelFormat && type === 'week') {
      const weekNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(dValue, firstDay);
      const weekDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(dValue, 0, weekNum === 1 ? (6 + firstDay) % 7 : firstDay, firstDay);
      const weekFullYear = weekDate.getFullYear();
      if (weekFullYear !== dValue.getFullYear()) {
        const yyIndex = labelFormat.indexOf('yyyy');
        if (yyIndex > -1) {
          const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
          if (yyNum && !isNaN(yyNum)) {
            dLabel = dLabel.replace(`${yyNum}`, `${weekFullYear}`);
          }
        }
      }
    }
  } else {
    dValue = null;
  }
  return {
    label: dLabel,
    value: dValue
  };
}
function getDateByCode(code, val, type, options) {
  const {
    valueFormat,
    firstDay
  } = options;
  let dValue = null;
  const value = (code === 'prev' || code === 'next' ? new Date() : val ? parseDateValue(val, type, options) : null) || new Date();
  switch (code) {
    case 'prev':
    case 'next':
    case 'minus':
    case 'plus':
      {
        const offsetNum = code === 'plus' || code === 'next' ? 1 : -1;
        switch (type) {
          case 'date':
          case 'datetime':
            dValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(value, offsetNum);
            break;
          case 'week':
            dValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(value, offsetNum, firstDay, firstDay);
            break;
          case 'month':
            dValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(value, offsetNum);
            break;
          case 'quarter':
            dValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(value, offsetNum);
            break;
          case 'year':
            dValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(value, offsetNum);
            break;
        }
        break;
      }
    default:
      dValue = new Date();
      break;
  }
  return {
    value: dValue ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dValue, valueFormat) : ''
  };
}
const rangeDateOffsetNumMaps = {
  last180: -180,
  last90: -90,
  last60: -60,
  last30: -30,
  last7: -7,
  last3: -3,
  last1: -1
};
function getRangeDateOffsetNum(code) {
  return rangeDateOffsetNumMaps[code] || 0;
}
function getRangeDateByCode(code, val, type, options) {
  const {
    valueFormat,
    firstDay
  } = options;
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(val)) {
    val = val.join('');
  }
  const value = (val ? parseDateValue(val, type, options) : null) || new Date();
  let sValue = null;
  const eValue = value;
  switch (code) {
    case 'last1':
    case 'last3':
    case 'last7':
    case 'last30':
    case 'last60':
    case 'last90':
    case 'last180':
      {
        const offsetNum = getRangeDateOffsetNum(code);
        switch (type) {
          case 'date':
          case 'datetime':
            sValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(value, offsetNum);
            break;
          case 'week':
            sValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(value, offsetNum, firstDay, firstDay);
            break;
          case 'month':
            sValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(value, offsetNum);
            break;
          case 'quarter':
            sValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(value, offsetNum);
            break;
          case 'year':
            sValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(value, offsetNum);
            break;
        }
        break;
      }
    default:
      sValue = new Date();
      break;
  }
  const startValue = sValue ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(sValue, valueFormat) : '';
  const endValue = eValue ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(eValue, valueFormat) : '';
  return {
    startValue,
    endValue
  };
}
;// CONCATENATED MODULE: ./packages/calendar/src/calendar.ts








/* harmony default export */ var calendar = (defineVxeComponent({
  name: 'VxeCalendar',
  props: {
    modelValue: [String, Number, Date],
    type: {
      type: String,
      default: 'date'
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().calendar.size || getConfig().size
    },
    multiple: Boolean,
    width: [String, Number],
    height: [String, Number],
    // dateãweekãmonthãquarterãyear
    minDate: {
      type: [String, Number, Date],
      default: () => getConfig().calendar.minDate
    },
    maxDate: {
      type: [String, Number, Date],
      default: () => getConfig().calendar.maxDate
    },
    startDay: {
      type: [String, Number],
      default: () => getConfig().calendar.startDay
    },
    labelFormat: String,
    valueFormat: String,
    festivalMethod: {
      type: Function,
      default: () => getConfig().calendar.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().calendar.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().calendar.selectDay
    }
  },
  emits: ['update:modelValue', 'change', 'click', 'date-prev', 'date-today', 'date-next', 'view-change'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      selectValue: props.modelValue,
      inputValue: props.modelValue,
      datePanelValue: null,
      datePanelLabel: '',
      datePanelType: 'day',
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeCalendar = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeCalendarStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        height,
        width
      } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return false;
    });
    const computeIsCalendarType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeDateStartTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.minDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.minDate) : null;
    });
    const computeDateEndTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.maxDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.maxDate) : null;
    });
    const computeSupportMultiples = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeDateListValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        multiple
      } = props;
      const {
        selectValue
      } = reactData;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && selectValue && isCalendarType) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(selectValue).split(',').map(item => {
          const date = parseDate(item, dateValueFormat);
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateLabelFormat)).join(', ');
    });
    const computeDateValueFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        valueFormat
      } = props;
      if (valueFormat) {
        return valueFormat;
      }
      return 'yyyy-MM-dd';
    });
    const computeDateValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectValue
      } = reactData;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (selectValue && isCalendarType) {
        const date = parseDate(selectValue, dateValueFormat);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateStartTime = computeDateStartTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateEndTime = computeDateEndTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateHMSTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValue = computeDateValue.value;
      return dateValue ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1000 : 0;
    });
    const computeDateLabelFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        labelFormat
      } = props;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (isCalendarType) {
        return labelFormat || dateValueFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const {
        yearSize
      } = internalData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(startYearDate, index, 'first');
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelObj = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isCalendarType = computeIsCalendarType.value;
      let y = '';
      let m = '';
      if (isCalendarType) {
        const {
          datePanelType,
          selectMonth
        } = reactData;
        const yearList = computeYearList.value;
        let year = '';
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === 'quarter' || datePanelType === 'month') {
          y = `${year}`;
        } else if (datePanelType === 'year') {
          y = yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : '';
        } else {
          y = `${year}`;
          m = month ? getI18n(`vxe.input.date.m${month}`) : '-';
        }
      }
      return {
        y,
        m
      };
    });
    const computeFirstDayOfWeek = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startDay
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(startDay);
    });
    const computeWeekDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const weeks = [];
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map(day => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const dateHeaders = computeDateHeaders.value;
        return [{
          label: getI18n('vxe.input.date.weeks.w')
        }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const yearList = computeYearList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(yearList, 4);
    });
    const computeQuarterList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const {
        quarterSize
      } = internalData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first');
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const quarterList = computeQuarterList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(quarterList, 2);
    });
    const computeMonthList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const {
        monthSize
      } = internalData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first').getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const monthList = computeMonthList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(monthList, 4);
    });
    const computeDayList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayList = computeDayList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(dayList, 7);
    });
    const computeWeekDates = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map(list => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const parseDate = (value, format) => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value, format);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit('update:modelValue', value);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        dispatchEvent('change', {
          value
        }, evnt);
      }
    };
    const dateParseValue = value => {
      const {
        type
      } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = '';
      if (value) {
        dValue = parseDate(value, dateValueFormat);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(dValue)) {
        dLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dValue, dateLabelFormat, {
          firstDay: firstDayOfWeek
        });
        // ç±äºå¹´ä»½åç¬¬å å¨æ¯å²çªçè¡ä¸ºï¼æä»¥éè¦ç¹æ®å¤çï¼å¤æ­æ¯å¦è·¨å¹´
        if (dateLabelFormat && type === 'week') {
          const firstWeekDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf('yyyy');
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    /**
     * å¼ååæ¶å¤ç
     */
    const changeValue = () => {
      const isCalendarType = computeIsCalendarType.value;
      const {
        inputValue
      } = reactData;
      if (isCalendarType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    /**
     * æ£æ¥åå§å¼
     */
    const initValue = () => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        changeValue();
      }
    };
    const dateCheckMonth = date => {
      const month = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(date, 0, 'first');
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = date => {
      const {
        modelValue,
        multiple
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === 'week') {
        const sWeek = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.selectDay);
        date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      }
      const inpVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat, {
        firstDay: firstDayOfWeek
      });
      dateCheckMonth(date);
      reactData.selectValue = date;
      if (multiple) {
        // å¦æä¸ºå¤é
        const dateMultipleValue = computeDateMultipleValue.value;
        // å¦ææ¯æ¥æç±»å
        if (dateMultipleValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal))) {
          handleChange(dateMultipleValue.filter(val => !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal)).join(','), {
            type: 'update'
          });
        } else {
          handleChange(dateMultipleValue.concat([inpVal]).join(','), {
            type: 'update'
          });
        }
      } else {
        // å¦æä¸ºåé
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(modelValue, inpVal)) {
          handleChange(inpVal, {
            type: 'update'
          });
        }
      }
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(date, offsetMonth, 'first');
    };
    const dateNowHandle = () => {
      const currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleYearTypeEvent = () => {
      reactData.datePanelType = 'year';
    };
    const dateToggleMonthTypeEvent = evnt => {
      let {
        datePanelType
      } = reactData;
      if (datePanelType === 'month' || datePanelType === 'quarter') {
        datePanelType = 'year';
      } else {
        datePanelType = 'month';
      }
      reactData.datePanelType = datePanelType;
      changeViewEvent(evnt);
    };
    const datePrevEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth
      } = reactData;
      const {
        yearSize
      } = internalData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type === 'year') {
          reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else if (datePanelType === 'month') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, -1, 'first');
          }
        }
        dispatchEvent('date-prev', {
          type
        }, evnt);
        changeViewEvent(evnt);
      }
    };
    const dateTodayMonthEvent = evnt => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
      }
      dispatchEvent('date-today', {
        type: props.type
      }, evnt);
      changeViewEvent(evnt);
    };
    const dateNextEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth
      } = reactData;
      const {
        yearSize
      } = internalData;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type === 'year') {
          reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else if (datePanelType === 'month') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, 1, 'first');
          }
        }
        dispatchEvent('date-next', {
          type
        }, evnt);
        changeViewEvent(evnt);
      }
    };
    const isDateDisabled = item => {
      const {
        disabledMethod
      } = props;
      const {
        datePanelType
      } = reactData;
      return disabledMethod && disabledMethod({
        type: datePanelType,
        viewType: datePanelType,
        date: item.date,
        $calendar: $xeCalendar
      });
    };
    const changeViewEvent = evnt => {
      const {
        datePanelType
      } = reactData;
      const yearDatas = computeYearDatas.value;
      const quarterDatas = computeQuarterDatas.value;
      const monthDatas = computeMonthDatas.value;
      const weekDates = computeWeekDates.value;
      const dayDatas = computeDayDatas.value;
      const viewDates = [];
      let dataList = [];
      switch (datePanelType) {
        case 'year':
          dataList = yearDatas;
          break;
        case 'quarter':
          dataList = quarterDatas;
          break;
        case 'month':
          dataList = monthDatas;
          break;
        case 'week':
          dataList = weekDates;
          break;
        case 'day':
          dataList = dayDatas;
          break;
      }
      dataList.forEach(rows => {
        rows.forEach(item => {
          viewDates.push(item.date);
        });
      });
      dispatchEvent('view-change', {
        viewType: datePanelType,
        viewDates
      }, evnt);
    };
    const dateSelectItem = date => {
      const {
        type
      } = props;
      const {
        datePanelType
      } = reactData;
      if (type === 'month') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
          changeViewEvent(null);
        } else {
          dateChange(date);
        }
      } else if (type === 'year') {
        dateChange(date);
      } else if (type === 'quarter') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'quarter';
          dateCheckMonth(date);
          changeViewEvent(null);
        } else {
          dateChange(date);
        }
      } else {
        if (datePanelType === 'month') {
          reactData.datePanelType = type === 'week' ? type : 'day';
          dateCheckMonth(date);
          changeViewEvent(null);
        } else if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
          changeViewEvent(null);
        } else {
          dateChange(date);
        }
      }
    };
    const dateSelectEvent = item => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = offsetDay => {
      if (!isDateDisabled({
        date: offsetDay
      })) {
        const dayList = computeDayList.value;
        if (!dayList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetDay, 'yyyyMMdd'))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = offsetYear => {
      if (!isDateDisabled({
        date: offsetYear
      })) {
        const yearList = computeYearList.value;
        if (!yearList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetYear, 'yyyy'))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = offsetQuarter => {
      if (!isDateDisabled({
        date: offsetQuarter
      })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetQuarter, 'yyyyq'))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = offsetMonth => {
      if (!isDateDisabled({
        date: offsetMonth
      })) {
        const monthList = computeMonthList.value;
        if (!monthList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetMonth, 'yyyyMM'))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = item => {
      if (!isDateDisabled(item)) {
        const {
          datePanelType
        } = reactData;
        if (datePanelType === 'month') {
          dateMoveMonth(item.date);
        } else if (datePanelType === 'quarter') {
          dateMoveQuarter(item.date);
        } else if (datePanelType === 'year') {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const dateConfirmEvent = () => {};
    const dateOpenPanel = () => {
      const {
        type
      } = props;
      const dateValue = computeDateValue.value;
      if (['year', 'quarter', 'month', 'week'].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = 'day';
      }
      reactData.currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
    };
    const renderDateLabel = (item, label) => {
      const {
        festivalMethod
      } = props;
      if (festivalMethod) {
        const {
          datePanelType
        } = reactData;
        const festivalRest = festivalMethod({
          type: datePanelType,
          viewType: datePanelType,
          date: item.date,
          $calendar: $xeCalendar
        });
        const festivalItem = festivalRest ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalRest) ? {
          label: festivalRest
        } : festivalRest : {};
        const extraItem = festivalItem.extra ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalItem.extra) ? {
          label: festivalItem.extra
        } : festivalItem.extra : null;
        const labels = [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-calendar--date-label', {
            'is-notice': festivalItem.notice
          }]
        }, extraItem && extraItem.label ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${label || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-calendar--date-label--extra', extraItem.important ? 'is-important' : '', extraItem.className],
          style: extraItem.style
        }, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(extraItem.label))] : [`${label || ''}`])];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          // é»è®¤æå¤æ¯æ3ä¸ªèæ¥éå 
          const festivalLabels = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(festivalLabel).split(',');
          labels.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-calendar--date-festival', festivalItem.important ? 'is-important' : '', festivalItem.className],
            style: festivalItem.style
          }, [festivalLabels.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-calendar--date-festival--overlap', `overlap--${festivalLabels.length}`]
          }, festivalLabels.map(label => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', label.substring(0, 3)))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-calendar--date-festival--label'
          }, festivalLabels[0].substring(0, 3))]));
        }
        return labels;
      }
      return `${label || ''}`;
    };
    const renderDateDayTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-calendar--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', dateHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {
          class: 'vxe-calendar--view-th'
        }, item.label);
      })), ...dayDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: ['vxe-calendar--view-td', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      })])];
    };
    const renderDateWeekTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-calendar--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', weekHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
          class: 'vxe-calendar--view-th'
        }, item.label);
      })), ...weekDates.map(rows => {
        const isSelected = multiple ? rows.some(item => dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat))) : rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat));
        const isHover = rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat));
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: ['vxe-calendar--view-td', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--hover': isHover
            }],
            // event
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      })])];
    };
    const renderDateMonthTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMM';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-calendar--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', monthDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: ['vxe-calendar--view-td', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
        }));
      }))])];
    };
    const renderDateQuarterTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyq';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-calendar--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', quarterDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: ['vxe-calendar--view-td', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
        }));
      }))])];
    };
    const renderDateYearTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyy';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-calendar--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', yearDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: ['vxe-calendar--view-td', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.year));
        }));
      }))])];
    };
    const renderDateTable = () => {
      const {
        datePanelType
      } = reactData;
      switch (datePanelType) {
        case 'week':
          return renderDateWeekTable();
        case 'month':
          return renderDateMonthTable();
        case 'quarter':
          return renderDateQuarterTable();
        case 'year':
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelObj = computeSelectDatePanelObj.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-calendar--header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-calendar--type-wrapper'
      }, [datePanelType === 'year' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        class: 'vxe-calendar--date-picker-label',
        disabled: datePanelType === 'year',
        content: selectDatePanelObj.y
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-calendar--date-picker-btns'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        class: 'vxe-calendar--date-picker-btn',
        content: selectDatePanelObj.y,
        onClick: dateToggleYearTypeEvent
      }), selectDatePanelObj.m ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        class: 'vxe-calendar--date-picker-btn',
        content: selectDatePanelObj.m,
        onClick: dateToggleMonthTypeEvent
      }) : renderEmptyElement($xeCalendar)])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-calendar--btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        disabled: isDisabledPrevDateBtn,
        icon: 'vxe-icon-caret-left',
        onClick: datePrevEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        icon: 'vxe-icon-dot',
        onClick: dateTodayMonthEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        disabled: isDisabledNextDateBtn,
        icon: 'vxe-icon-caret-right',
        onClick: dateNextEvent
      }), multiple && computeSupportMultiples.value ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-calendar--btn vxe-calendar--confirm-btn'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'vxe-calendar--confirm',
        type: 'button',
        onClick: dateConfirmEvent
      }, getI18n('vxe.button.confirm'))]) : null])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-calendar--body'
      }, renderDateTable())];
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $input: $xeCalendar
      }, params));
    };
    const calendarMethods = {
      dispatchEvent
    };
    Object.assign($xeCalendar, calendarMethods);
    const renderVN = () => {
      const {
        className,
        type
      } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const calendarStyle = computeCalendarStyle.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-calendar', `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          'is--disabled': isDisabled
        }],
        style: calendarStyle
      }, [renderDatePanel()]);
    };
    $xeCalendar.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
      changeValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      // åæ¢ç±»åæ¯éç½®åç½®åé
      Object.assign(reactData, {
        selectValue: null,
        inputValue: null,
        datePanelValue: null,
        datePanelLabel: '',
        datePanelType: 'day',
        selectMonth: null,
        currentDate: null
      });
      initValue();
      dateOpenPanel();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeDateLabelFormat, () => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      dateOpenPanel();
    });
    initValue();
    return $xeCalendar;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/calendar/index.ts



const VxeCalendar = Object.assign({}, calendar, {
  install(app) {
    app.component(calendar.name, calendar);
  }
});
dynamicApp.use(VxeCalendar);
index_esm_VxeUI.component(calendar);
const Calendar = VxeCalendar;
/* harmony default export */ var packages_calendar = (VxeCalendar);
;// CONCATENATED MODULE: ./packages/loading/src/loading.ts





/* harmony default export */ var src_loading = (defineVxeComponent({
  name: 'VxeLoading',
  props: {
    modelValue: Boolean,
    icon: {
      type: String,
      default: () => getConfig().loading.icon
    },
    showIcon: {
      type: Boolean,
      default: () => getConfig().loading.showIcon
    },
    text: {
      type: String,
      default: () => getConfig().loading.text
    },
    showText: {
      type: Boolean,
      default: () => getConfig().loading.showText
    },
    status: String,
    size: {
      type: String,
      default: () => getConfig().loading.size || getConfig().size
    }
  },
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false
    });
    const computeMaps = {
      computeSize
    };
    const $xeLoading = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    const computeLoadingIcon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.icon || getIcon().LOADING;
    });
    const computeLoadingText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        text
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(text) ? text : getI18n('vxe.loading.text');
    });
    const handleInit = () => {
      if (!reactData.initialized) {
        reactData.initialized = !!reactData.initialized;
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $loading: $xeLoading
      }, params));
    };
    const loadingMethods = {
      dispatchEvent
    };
    const loadingPrivateMethods = {};
    Object.assign($xeLoading, loadingMethods, loadingPrivateMethods);
    const renderVN = () => {
      const {
        modelValue,
        showIcon,
        status
      } = props;
      const {
        initialized
      } = reactData;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const textSlot = slots.text;
      const iconSlot = slots.icon;
      const loadingIcon = computeLoadingIcon.value;
      const loadingText = computeLoadingText.value;
      if (!initialized && !modelValue) {
        return renderEmptyElement($xeLoading);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-loading', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--visible': modelValue
        }]
      }, defaultSlot ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--wrapper'
      }, vn_getSlotVNs(defaultSlot({})))] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--chunk'
      }, [showIcon && (iconSlot || loadingIcon) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--icon'
      }, iconSlot ? vn_getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: loadingIcon
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--spinner'
      }), textSlot || loadingText ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--text'
      }, textSlot ? vn_getSlotVNs(textSlot({})) : `${loadingText}`) : null])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      handleInit();
    });
    handleInit();
    $xeLoading.renderVN = renderVN;
    return $xeLoading;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/card/src/card.ts







/* harmony default export */ var card = (defineVxeComponent({
  name: 'VxeCard',
  props: {
    title: String,
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().card.showTitleOverflow
    },
    width: [String, Number],
    height: [String, Number],
    border: {
      type: Boolean,
      default: () => getConfig().card.border
    },
    loading: Boolean,
    shadow: {
      type: Boolean,
      default: () => getConfig().card.shadow
    },
    padding: {
      type: Boolean,
      default: () => getConfig().card.padding
    },
    size: {
      type: String,
      default: () => getConfig().card.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeCardStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        height,
        width
      } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {
      computeSize
    };
    const $xeCard = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $card: $xeCard
      }, params));
    };
    const cardMethods = {
      dispatchEvent
    };
    const cardPrivateMethods = {};
    Object.assign($xeCard, cardMethods, cardPrivateMethods);
    const renderVN = () => {
      const {
        title,
        border,
        shadow,
        padding,
        loading,
        showTitleOverflow
      } = props;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const footerSlot = slots.footer;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const vSize = computeSize.value;
      const cardStyle = computeCardStyle.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-card', {
          [`size--${vSize}`]: vSize,
          'is--border': border,
          'is--shadow': shadow,
          'is--padding': padding
        }],
        style: cardStyle
      }, [title || titleSlot || headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--header'
      }, headerSlot ? vn_getSlotVNs(headerSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-card--header-title', {
          'is--ellipsis': showTitleOverflow
        }]
      }, titleSlot ? vn_getSlotVNs(titleSlot({})) : `${title || ''}`), extraSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--header-extra'
      }, vn_getSlotVNs(extraSlot({}))) : renderEmptyElement($xeCard)]) : renderEmptyElement($xeCard), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--body'
      }, [leftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--body-left'
      }, vn_getSlotVNs(leftSlot({}))) : renderEmptyElement($xeCard), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--body-content'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({})) : []), rightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--body-right'
      }, vn_getSlotVNs(rightSlot({}))) : renderEmptyElement($xeCard)]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--footer'
      }, vn_getSlotVNs(footerSlot({}))) : renderEmptyElement($xeCard),
      /**
       * å è½½ä¸­
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-card--loading',
        modelValue: loading
      })]);
    };
    $xeCard.renderVN = renderVN;
    return $xeCard;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/card/index.ts



const VxeCard = Object.assign({}, card, {
  install(app) {
    app.component(card.name, card);
  }
});
dynamicApp.use(VxeCard);
index_esm_VxeUI.component(card);
const Card = VxeCard;
/* harmony default export */ var packages_card = (VxeCard);
;// CONCATENATED MODULE: ./packages/carousel/src/carousel.ts







/* harmony default export */ var carousel = (defineVxeComponent({
  name: 'VxeCarousel',
  props: {
    modelValue: [String, Number],
    options: Array,
    loading: Boolean,
    height: {
      type: [Number, String],
      default: () => getConfig().carousel.height
    },
    width: {
      type: [Number, String],
      default: () => getConfig().carousel.width
    },
    autoPlay: {
      type: Boolean,
      default: () => getConfig().carousel.autoPlay
    },
    interval: {
      type: [Number, String],
      default: () => getConfig().carousel.interval
    },
    loop: {
      type: Boolean,
      default: () => getConfig().carousel.loop
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().carousel.vertical
    },
    showIndicators: {
      type: Boolean,
      default: () => getConfig().carousel.showIndicators
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refWrapperElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      activeName: '',
      staticItems: [],
      itemWidth: 0,
      itemHeight: 0
    });
    const internalData = {
      apTimeout: undefined,
      stopFlag: false
    };
    const refMaps = {
      refElem
    };
    const computeListStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        vertical,
        options
      } = props;
      const {
        activeName,
        itemWidth,
        itemHeight,
        staticItems
      } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const activeIndex = Math.max(0, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(list, item => item.name === activeName));
      const stys = {};
      if (vertical) {
        stys.transform = `translateY(-${activeIndex * itemHeight}px)`;
      } else {
        stys.width = `${itemWidth * list.length}px`;
        stys.transform = `translateX(-${activeIndex * itemWidth}px)`;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCarousel = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const updateStyle = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const wrapperElem = refWrapperElem.value;
        if (wrapperElem) {
          reactData.itemWidth = wrapperElem.clientWidth;
          reactData.itemHeight = wrapperElem.clientHeight;
        }
      });
    };
    const clickItemEvent = (evnt, item) => {
      const value = item.name;
      reactData.activeName = item.name;
      emit('update:modelValue', value);
      emit('change', {
        value
      }, evnt);
      updateStyle();
    };
    const initDefaultActive = list => {
      let activeName = null;
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach(item => {
          if (activeName === item.name) {
            validVal = true;
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          emit('update:modelValue', activeName);
        }
      }
      reactData.activeName = activeName;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $carousel: $xeCarousel
      }, params));
    };
    const handlePrevNext = isNext => {
      const {
        options,
        loop
      } = props;
      const {
        activeName,
        staticItems
      } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const index = Math.max(0, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(list, item => item.name === activeName));
      if (index > -1) {
        let item = null;
        if (isNext) {
          if (index < list.length - 1) {
            item = list[index + 1];
          } else {
            if (loop) {
              item = list[0];
            }
          }
        } else {
          if (index > 0) {
            item = list[index - 1];
          } else {
            if (loop) {
              item = list[list.length - 1];
            }
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emit('update:modelValue', value);
          return true;
        }
      }
      return false;
    };
    const carouselMethods = {
      dispatchEvent,
      prev() {
        if (handlePrevNext(false)) {
          handleAutoPlay();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      next() {
        if (handlePrevNext(true)) {
          handleAutoPlay();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    const prevEvent = evnt => {
      if (handlePrevNext(false)) {
        const value = reactData.activeName;
        emit('change', {
          value
        }, evnt);
      }
    };
    const nextEvent = evnt => {
      if (handlePrevNext(true)) {
        const value = reactData.activeName;
        emit('change', {
          value
        }, evnt);
      }
    };
    const stopAutoPlay = () => {
      const {
        apTimeout
      } = internalData;
      internalData.stopFlag = true;
      if (apTimeout) {
        clearTimeout(apTimeout);
        internalData.apTimeout = undefined;
      }
    };
    const handleAutoPlay = () => {
      const {
        autoPlay,
        interval
      } = props;
      const {
        stopFlag
      } = internalData;
      stopAutoPlay();
      if (autoPlay) {
        internalData.stopFlag = false;
        internalData.apTimeout = setTimeout(() => {
          if (!stopFlag) {
            handlePrevNext(true);
          }
        }, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(interval) || 300);
      }
    };
    const mouseenterEvent = () => {
      stopAutoPlay();
    };
    const mouseleaveEvent = () => {
      handleAutoPlay();
    };
    const carouselPrivateMethods = {};
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    Object.assign($xeCarousel, carouselMethods, carouselPrivateMethods);
    const renderItemWrapper = list => {
      const {
        height
      } = props;
      const {
        activeName
      } = reactData;
      const listStyle = computeListStyle.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--list',
        style: listStyle
      }, list.map(item => {
        const {
          name,
          url,
          slots
        } = item;
        const defaultSlot = slots ? slots.default : null;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: `${name}`,
          class: ['vxe-carousel--item-inner', {
            'is--active': activeName === name
          }],
          style: height ? {
            height: toCssUnit(height)
          } : null
        }, defaultSlot ? callSlot(defaultSlot, {}) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
          class: 'vxe-carousel--item-img',
          src: url
        })]);
      }));
    };
    const renderIndicators = list => {
      const {
        activeName
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--indicators'
      }, list.map(item => {
        const {
          name
        } = item;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: `${name}`,
          class: ['vxe-carousel--indicators-item', {
            'is--active': activeName === name
          }],
          onClick(evnt) {
            clickItemEvent(evnt, item);
          }
        });
      }));
    };
    const renderVN = () => {
      const {
        loading,
        height,
        width,
        showIndicators,
        vertical,
        options
      } = props;
      const {
        staticItems
      } = reactData;
      const defaultSlot = slots.default;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-carousel', `is--${vertical ? 'vertical' : 'horizontal'}`],
        style: width ? {
          width: toCssUnit(width)
        } : null,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--slots'
      }, defaultSlot ? defaultSlot({}) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refWrapperElem,
        class: 'vxe-carousel--item-wrapper',
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [renderItemWrapper(list)]), showIndicators ? renderIndicators(list) : renderEmptyElement($xeCarousel), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--previous-btn',
        onClick: prevEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: vertical ? getIcon().CAROUSEL_VERTICAL_PREVIOUS : getIcon().CAROUSEL_HORIZONTAL_PREVIOUS
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--next-btn',
        onClick: nextEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: vertical ? getIcon().CAROUSEL_VERTICAL_NEXT : getIcon().CAROUSEL_HORIZONTAL_NEXT
      })])]),
      /**
       * å è½½ä¸­
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-carousel--loading',
        modelValue: loading
      })]);
    };
    const optsFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(optsFlag, () => {
      initDefaultActive(props.options);
    });
    const stFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems ? reactData.staticItems.length : -1, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(stFlag, () => {
      initDefaultActive(reactData.staticItems);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.autoPlay, () => {
      handleAutoPlay();
    });
    initDefaultActive(reactData.staticItems.length ? reactData.staticItems : props.options);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      handleAutoPlay();
      updateStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      stopAutoPlay();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeCarousel', $xeCarousel);
    $xeCarousel.renderVN = renderVN;
    return $xeCarousel;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/carousel/index.ts



const VxeCarousel = Object.assign({}, carousel, {
  install(app) {
    app.component(carousel.name, carousel);
  }
});
dynamicApp.use(VxeCarousel);
index_esm_VxeUI.component(carousel);
const Carousel = VxeCarousel;
/* harmony default export */ var packages_carousel = (VxeCarousel);
;// CONCATENATED MODULE: ./packages/carousel/src/util.ts

function assembleCarouselItem($xeCarousel, elem, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticItems.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, itemConfig);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}
function destroyCarouselItem($xeCarousel, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(staticItems, item => item.id === itemConfig.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}
;// CONCATENATED MODULE: ./packages/carousel/src/carousel-item.ts





/* harmony default export */ var carousel_item = (defineVxeComponent({
  name: 'VxeCarouselItem',
  props: {
    name: [String, Number],
    className: String,
    url: String
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeCarousel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeCarousel', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const itemConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      name: props.name,
      url: props.url,
      className: props.className,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCarouselItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $carouselItem: $xeCarouselItem
      }, params));
    };
    const carouselItemMethods = {
      dispatchEvent
    };
    const carouselItemPrivateMethods = {};
    Object.assign($xeCarouselItem, carouselItemMethods, carouselItemPrivateMethods);
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.name, val => {
      itemConfig.name = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.url, val => {
      itemConfig.url = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if ($xeCarousel && elem) {
        assembleCarouselItem($xeCarousel, elem, itemConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xeCarousel) {
        destroyCarouselItem($xeCarousel, itemConfig);
      }
    });
    $xeCarouselItem.renderVN = renderVN;
    return $xeCarouselItem;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/carousel-item/index.ts



const VxeCarouselItem = Object.assign({}, carousel_item, {
  install(app) {
    app.component(carousel_item.name, carousel_item);
  }
});
dynamicApp.use(VxeCarouselItem);
index_esm_VxeUI.component(carousel_item);
const CarouselItem = VxeCarouselItem;
/* harmony default export */ var packages_carousel_item = (VxeCarouselItem);
;// CONCATENATED MODULE: ./packages/checkbox/src/checkbox.ts





/* harmony default export */ var src_checkbox = (defineVxeComponent({
  name: 'VxeCheckbox',
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number],
      default: null
    },
    indeterminate: Boolean,
    title: [String, Number],
    checkedValue: {
      type: [String, Number, Boolean],
      default: true
    },
    uncheckedValue: {
      type: [String, Number, Boolean],
      default: false
    },
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkbox.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const $xeCheckboxGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeCheckboxGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const $xeCheckbox = {
      xID,
      props,
      context,
      reactData
    };
    let checkboxMethods = {};
    const {
      computeSize
    } = useSize(props);
    const computeIsChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeCheckboxGroup) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes($xeCheckboxGroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      const isChecked = computeIsChecked.value;
      if (disabled === null) {
        if ($xeCheckboxGroup) {
          const {
            computeIsDisabled: computeIsGroupDisabled,
            computeIsMaximize: computeIsGroupMaximize
          } = $xeCheckboxGroup.getComputeMaps();
          const isGroupDisabled = computeIsGroupDisabled.value;
          const isGroupMaximize = computeIsGroupMaximize.value;
          return isGroupDisabled || isGroupMaximize && !isChecked;
        }
      }
      return disabled;
    });
    const changeEvent = evnt => {
      const {
        checkedValue,
        uncheckedValue
      } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const checked = evnt.target.checked;
        const value = checked ? checkedValue : uncheckedValue;
        const params = {
          checked,
          value,
          label: props.label
        };
        if ($xeCheckboxGroup) {
          $xeCheckboxGroup.handleChecked(params, evnt);
        } else {
          emit('update:modelValue', value);
          checkboxMethods.dispatchEvent('change', params, evnt);
          // èªå¨æ´æ°æ ¡éªç¶æ
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $checkbox: $xeCheckbox
      }, params));
    };
    checkboxMethods = {
      dispatchEvent
    };
    Object.assign($xeCheckbox, checkboxMethods);
    const renderVN = () => {
      const {
        label
      } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isChecked = computeIsChecked.value;
      const indeterminate = !isChecked && props.indeterminate;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        key: label,
        class: ['vxe-checkbox vxe-checkbox--default', {
          [`size--${vSize}`]: vSize,
          'is--indeterminate': indeterminate,
          'is--disabled': isDisabled,
          'is--checked': isChecked
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-checkbox--input',
        type: 'checkbox',
        disabled: isDisabled,
        checked: isChecked,
        onChange: changeEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', indeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : isDisabled ? getIcon().CHECKBOX_DISABLED_UNCHECKED : getIcon().CHECKBOX_UNCHECKED]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    $xeCheckbox.renderVN = renderVN;
    return $xeCheckbox;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/checkbox/index.ts



const VxeCheckbox = Object.assign(src_checkbox, {
  install(app) {
    app.component(src_checkbox.name, src_checkbox);
  }
});
dynamicApp.use(VxeCheckbox);
index_esm_VxeUI.component(src_checkbox);
const Checkbox = VxeCheckbox;
/* harmony default export */ var packages_checkbox = (VxeCheckbox);
;// CONCATENATED MODULE: ./packages/checkbox/src/button.ts





/* harmony default export */ var checkbox_src_button = (defineVxeComponent({
  name: 'VxeCheckboxButton',
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    checkedValue: {
      type: [String, Number, Boolean],
      default: true
    },
    uncheckedValue: {
      type: [String, Number, Boolean],
      default: false
    },
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkboxButton.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const $xeCheckboxGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeCheckboxGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const {
      computeSize
    } = useSize(props);
    const $xeCheckboxButton = {
      xID,
      props,
      context,
      reactData
    };
    const computeIsChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeCheckboxGroup) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes($xeCheckboxGroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      const isChecked = computeIsChecked.value;
      if (disabled === null) {
        if ($xeCheckboxGroup) {
          const {
            computeIsDisabled: computeIsGroupDisabled,
            computeIsMaximize: computeIsGroupMaximize
          } = $xeCheckboxGroup.getComputeMaps();
          const isGroupDisabled = computeIsGroupDisabled.value;
          const isGroupMaximize = computeIsGroupMaximize.value;
          return isGroupDisabled || isGroupMaximize && !isChecked;
        }
      }
      return disabled;
    });
    const changeEvent = evnt => {
      const {
        checkedValue,
        uncheckedValue
      } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const checked = evnt.target.checked;
        const value = checked ? checkedValue : uncheckedValue;
        const params = {
          checked,
          value,
          label: props.label
        };
        if ($xeCheckboxGroup) {
          $xeCheckboxGroup.handleChecked(params, evnt);
        } else {
          emit('update:modelValue', value);
          $xeCheckboxButton.dispatchEvent('change', params, evnt);
          // èªå¨æ´æ°æ ¡éªç¶æ
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const checkboxButtonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $checkboxButton: $xeCheckboxButton
        }, params));
      }
    };
    const checkboxButtonPrivateMethods = {};
    Object.assign($xeCheckboxButton, checkboxButtonMethods, checkboxButtonPrivateMethods);
    const renderVN = () => {
      const {
        label
      } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isChecked = computeIsChecked.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        key: label,
        class: ['vxe-checkbox vxe-checkbox--button', {
          [`size--${vSize}`]: vSize,
          'is--disabled': isDisabled
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-checkbox--input',
        type: 'checkbox',
        disabled: isDisabled,
        checked: isChecked,
        onChange: changeEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    $xeCheckboxButton.renderVN = renderVN;
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/checkbox-button/index.ts



const VxeCheckboxButton = Object.assign(checkbox_src_button, {
  install: function (app) {
    app.component(checkbox_src_button.name, checkbox_src_button);
  }
});
dynamicApp.use(VxeCheckboxButton);
index_esm_VxeUI.component(checkbox_src_button);
const CheckboxButton = VxeCheckboxButton;
/* harmony default export */ var checkbox_button = (VxeCheckboxButton);
;// CONCATENATED MODULE: ./packages/checkbox/src/group.ts






/* harmony default export */ var group = (defineVxeComponent({
  name: 'VxeCheckboxGroup',
  props: {
    modelValue: Array,
    options: Array,
    optionProps: Object,
    disabled: {
      type: Boolean,
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkboxGroup.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsMaximize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        max
      } = props;
      if (max) {
        return (modelValue ? modelValue.length : 0) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    });
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeDisabledField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || 'disabled';
    });
    const computeMaps = {
      computeIsMaximize,
      computeIsDisabled
    };
    const $xeCheckboxGroup = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $checkboxGroup: $xeCheckboxGroup
      }, params));
    };
    const checkboxGroupMethods = {
      dispatchEvent
    };
    const checkboxGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const {
          checked,
          label
        } = params;
        const checklist = props.modelValue || [];
        const checkIndex = checklist.indexOf(label);
        if (checked) {
          if (checkIndex === -1) {
            checklist.push(label);
          }
        } else {
          checklist.splice(checkIndex, 1);
        }
        emit('update:modelValue', checklist);
        $xeCheckboxGroup.dispatchEvent('change', Object.assign({}, params, {
          checklist,
          value: checklist
        }), evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, checklist);
        }
      }
    };
    Object.assign($xeCheckboxGroup, checkboxGroupMethods, checkboxGroupPrivateMethods);
    const renderVN = () => {
      const {
        options
      } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-checkbox-group'
      }, defaultSlot ? defaultSlot({}) : options ? options.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_checkbox, {
          key: item[valueField],
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeCheckboxGroup', $xeCheckboxGroup);
    $xeCheckboxGroup.renderVN = renderVN;
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/checkbox-group/index.ts



const VxeCheckboxGroup = Object.assign(group, {
  install(app) {
    app.component(group.name, group);
  }
});
dynamicApp.use(VxeCheckboxGroup);
index_esm_VxeUI.component(group);
const CheckboxGroup = VxeCheckboxGroup;
/* harmony default export */ var checkbox_group = (VxeCheckboxGroup);
;// CONCATENATED MODULE: ./packages/row/src/col.ts





/* harmony default export */ var col = (defineVxeComponent({
  name: 'VxeCol',
  props: {
    span: [Number, String],
    align: String,
    width: [Number, String],
    fill: Boolean,
    ellipsis: Boolean,
    size: {
      type: String,
      default: () => getConfig().col.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const $xeRow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeRow', null);
    const computeRowGutter = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeRow) {
        return $xeRow.props.gutter;
      }
      return null;
    });
    const computeRowVertical = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeRow) {
        return $xeRow.props.vertical;
      }
      return null;
    });
    const computeColStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width
      } = props;
      const rowGutter = computeRowGutter.value;
      const rowVertical = computeRowVertical.value;
      const style = {};
      if (rowGutter) {
        let [lrGutter, tbGutter] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rowGutter) ? rowGutter : [rowGutter];
        if (rowVertical) {
          tbGutter = lrGutter;
          lrGutter = '';
        }
        if (lrGutter) {
          const padding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(lrGutter) ? toCssUnit(lrGutter / 2) : `calc(${toCssUnit(lrGutter)} / 2)`;
          style.paddingLeft = padding;
          style.paddingRight = padding;
        }
        if (tbGutter) {
          const padding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(tbGutter) ? toCssUnit(tbGutter / 2) : `calc(${toCssUnit(tbGutter)} / 2)`;
          style.paddingTop = padding;
          style.paddingBottom = padding;
        }
      }
      if (width) {
        style.width = toCssUnit(width);
      }
      return style;
    });
    const computeMaps = {};
    const $xeCol = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $col: $xeCol
      }, params));
    };
    const colMethods = {
      dispatchEvent
    };
    const colPrivateMethods = {};
    Object.assign($xeCol, colMethods, colPrivateMethods);
    const renderVN = () => {
      const {
        span,
        fill,
        align,
        width,
        ellipsis
      } = props;
      const colStyle = computeColStyle.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-col', span ? `span${span}` : '', align ? `align--${align}` : '', {
          'is--span': !!span,
          'is--width': !!width,
          'is--fill': fill,
          'is--ellipsis': ellipsis
        }],
        style: colStyle
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-col--inner'
      }, defaultSlot ? defaultSlot({}) : [])]);
    };
    $xeCol.renderVN = renderVN;
    return $xeCol;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/col/index.ts



const VxeCol = Object.assign({}, col, {
  install(app) {
    app.component(col.name, col);
  }
});
dynamicApp.use(VxeCol);
index_esm_VxeUI.component(col);
const Col = VxeCol;
/* harmony default export */ var packages_col = (VxeCol);
;// CONCATENATED MODULE: ./packages/collapse/src/collapse.ts






/* harmony default export */ var collapse = (defineVxeComponent({
  name: 'VxeCollapse',
  props: {
    modelValue: Array,
    options: Array,
    padding: {
      type: Boolean,
      default: () => getConfig().collapse.padding
    },
    expandConfig: Object,
    size: {
      type: String,
      default: () => getConfig().collapse.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'load', 'change', 'toggle-expand'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      staticPanes: [],
      activeNames: [],
      initNames: [],
      cachePaneMaps: {}
    });
    const refMaps = {
      refElem
    };
    const computeItemOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        options
      } = props;
      return (options || []).filter(item => handleFilterItem(item));
    });
    const computeItemStaticOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        staticPanes
      } = reactData;
      return staticPanes.filter(item => handleFilterItem(item));
    });
    const computeExpandOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().collapse.expandConfig, props.expandConfig);
    });
    const computeMaps = {};
    const $xeCollapse = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleFilterItem = item => {
      const {
        permissionCode
      } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const addInitName = name => {
      const {
        initNames
      } = reactData;
      if (name && !initNames.includes(name)) {
        initNames.push(name);
        dispatchEvent('load', {
          name
        }, null);
        return true;
      }
      return false;
    };
    const initDefaultName = list => {
      const {
        activeNames
      } = reactData;
      const nameMaps = {};
      if (list && list.length) {
        list.forEach(item => {
          const {
            name,
            preload
          } = item || {};
          if (name) {
            const isActive = activeNames.includes(name);
            nameMaps[`${name}`] = {
              loading: false
            };
            if (isActive) {
              addInitName(name);
            }
            if (preload) {
              if (!isActive) {
                activeNames.push(name);
              }
            }
          }
        });
      }
      reactData.activeNames = activeNames ? activeNames.slice(0) : [];
      reactData.cachePaneMaps = nameMaps;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $collapse: $xeCollapse
      }, params));
    };
    const collapseMethods = {
      dispatchEvent
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const handleClickEvent = (evnt, item) => {
      const {
        activeNames
      } = reactData;
      const {
        name
      } = item;
      if (name) {
        const aIndex = activeNames.indexOf(name);
        let expanded = false;
        if (aIndex === -1) {
          expanded = true;
          activeNames.push(name);
        } else {
          activeNames.splice(aIndex, 1);
        }
        addInitName(name);
        dispatchEvent('change', {
          value: activeNames,
          name
        }, evnt);
        dispatchEvent('toggle-expand', {
          value: activeNames,
          name,
          expanded
        }, evnt);
      }
    };
    const collapsePrivateMethods = {};
    Object.assign($xeCollapse, collapseMethods, collapsePrivateMethods);
    const renderList = itemList => {
      const {
        activeNames,
        initNames
      } = reactData;
      const expandOpts = computeExpandOpts.value;
      return itemList.map(item => {
        const {
          icon,
          name,
          title,
          slots
        } = item;
        const titleSlot = slots ? slots.title : null;
        const defaultSlot = slots ? slots.default : null;
        const isActive = name && activeNames.includes(name);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-collapse-item'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-collapse--item-header',
          onClick(evnt) {
            handleClickEvent(evnt, item);
          }
        }, [expandOpts.showIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-collapse--item-switch'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: isActive ? getIcon().COLLAPSE_OPEN : getIcon().COLLAPSE_CLOSE
        })]) : renderEmptyElement($xeCollapse), icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-collapse--item-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: icon
        })]) : renderEmptyElement($xeCollapse), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-collapse--item-name'
        }, titleSlot ? callSlot(titleSlot, {
          name,
          title
        }) : `${title}`)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-collapse--item-content', {
            'is--visible': isActive
          }]
        }, [name && initNames.includes(name) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-collapse--item-inner'
        }, [defaultSlot ? callSlot(defaultSlot, {
          name,
          title
        }) : '']) : renderEmptyElement($xeCollapse)])]);
      });
    };
    const renderVN = () => {
      const {
        padding
      } = props;
      const vSize = computeSize.value;
      const itemOptions = computeItemOptions.value;
      const itemStaticOptions = computeItemStaticOptions.value;
      const defaultSlot = slots.default;
      const itemList = defaultSlot ? itemStaticOptions : itemOptions;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-collapse', {
          [`size--${vSize}`]: vSize,
          'is--padding': padding
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-collapse-slots'
      }, defaultSlot ? defaultSlot({}) : []), renderList(itemList)]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.activeNames = val || [];
    });
    const optsFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(optsFlag, () => {
      initDefaultName(props.options);
    });
    const stFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticPanes ? reactData.staticPanes.length : -1, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticPanes, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(stFlag, () => {
      initDefaultName(reactData.staticPanes);
    });
    reactData.activeNames = props.modelValue || [];
    initDefaultName(reactData.staticPanes.length ? reactData.staticPanes : props.options);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeCollapse', $xeCollapse);
    $xeCollapse.renderVN = renderVN;
    return $xeCollapse;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/collapse/index.ts



const VxeCollapse = Object.assign({}, collapse, {
  install(app) {
    app.component(collapse.name, collapse);
  }
});
dynamicApp.use(VxeCollapse);
index_esm_VxeUI.component(collapse);
const Collapse = VxeCollapse;
/* harmony default export */ var packages_collapse = (VxeCollapse);
;// CONCATENATED MODULE: ./packages/collapse/src/util.ts

function assembleCollapseItem($xeCollapse, elem, collapseConfig) {
  const staticPanes = $xeCollapse.reactData.staticPanes;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticPanes.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, collapseConfig);
    $xeCollapse.reactData.staticPanes = staticPanes.slice(0);
  }
}
function destroyCollapseItem($xeCollapse, collapseConfig) {
  const staticPanes = $xeCollapse.reactData.staticPanes;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticPanes, item => item.id === collapseConfig.id, {
    children: 'children'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeCollapse.reactData.staticPanes = staticPanes.slice(0);
}
;// CONCATENATED MODULE: ./packages/collapse/src/collapse-pane.ts





/* harmony default export */ var collapse_pane = (defineVxeComponent({
  name: 'VxeCollapsePane',
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeCollapse = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeCollapse', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const collapseConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots: slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCollapsePane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $collapsePane: $xeCollapsePane
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeCollapsePane, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      }, []);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.title, val => {
      collapseConfig.title = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.name, val => {
      collapseConfig.name = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.icon, val => {
      collapseConfig.icon = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.permissionCode, val => {
      collapseConfig.permissionCode = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if ($xeCollapse && elem) {
        assembleCollapseItem($xeCollapse, elem, collapseConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xeCollapse) {
        destroyCollapseItem($xeCollapse, collapseConfig);
      }
    });
    $xeCollapsePane.renderVN = renderVN;
    return $xeCollapsePane;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/collapse-pane/index.ts



const VxeCollapsePane = Object.assign({}, collapse_pane, {
  install(app) {
    app.component(collapse_pane.name, collapse_pane);
  }
});
dynamicApp.use(VxeCollapsePane);
index_esm_VxeUI.component(collapse_pane);
const CollapsePane = VxeCollapsePane;
/* harmony default export */ var packages_collapse_pane = (VxeCollapsePane);
;// CONCATENATED MODULE: ./packages/color-picker/src/util.ts

const hexAlphaKeyMaps = {};
const hexAlphaNumMaps = {};
'FF,FC,FA,F7,F5,F2,F0,ED,EB,E8,E6,E3,E0,DE,DB,D9,D6,D4,D1,CF,CC,C9,C7,C4,C2,BF,BD,BA,B8,B5,B3,B0,AD,AB,A8,A6,A3,A1,9E,9C,99,96,94,91,8F,8C,8A,87,85,82,80,7D,7A,78,75,73,70,6E,6B,69,66,63,61,5E,5C,59,57,54,52,4F,4D,4A,47,45,42,40,3D,3B,38,36,33,30,2E,2B,29,26,24,21,1F,1C,1A,17,14,12,0F,0D,0A,08,05,03,00'.split(',').forEach((key, i) => {
  const num = (100 - i) / 100;
  hexAlphaKeyMaps[key] = num;
  hexAlphaNumMaps[num] = key;
});
const rgbRE = /^rgb(a?)\((\d{1,3})[,\s]+(\d{1,3})[,\s]+(\d{1,3})([,//\s]+([0-9.]{1,4})(%?))?\)$/;
function hasRgb(value) {
  return value && rgbRE.test(value);
}
const hexRE = /^(#?)([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
function hasHex(value) {
  return value && hexRE.test(value);
}
function parseColor(value) {
  const rest = {
    value: '',
    type: '',
    hex: '',
    hexV: '',
    hexA: '',
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
  if (value) {
    const hexRest = value.match(hexRE);
    if (hexRest) {
      rest.value = value;
      rest.type = 'hex';
      rest.hex = value;
      rest.hexV = hexRest[2];
      rest.hexA = hexRest[3] || '';
      rest.a = (hexRest[3] ? hexAlphaKeyMaps[hexRest[3].toUpperCase()] : 1) || 1;
    }
    const rgbRest = value.match(rgbRE);
    if (rgbRest) {
      rest.value = value;
      rest.type = rgbRest[6] ? 'rgba' : 'rgb';
      rest.r = parseInt(rgbRest[2]);
      rest.g = parseInt(rgbRest[3]);
      rest.b = parseInt(rgbRest[4]);
      rest.a = rgbRest[7] ? parseInt(rgbRest[6]) / 100 : rgbRest[6] ? parseFloat(rgbRest[6]) : 1;
    }
  }
  return rest;
}
function updateColorAlpha(value, alpha = 1) {
  const colorRest = parseColor(value);
  const {
    type,
    hexV,
    r,
    g,
    b
  } = colorRest;
  if (type === 'rgb' || type === 'rgba') {
    return toRgb(r, g, b, alpha);
  }
  if (type === 'hex') {
    return `#${hexV}${alpha === 1 ? '' : hexAlphaNumMaps[alpha] || ''}`;
  }
  return '';
}
function toRgb(r, g, b, a) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(a)) {
    return `rgb(${r},${g},${b})`;
  }
  return `rgba(${r},${g},${b},${a})`;
}
function rgbToHex(rgbRest) {
  if (!rgbRest) {
    return '';
  }
  const {
    r,
    g,
    b,
    a = 1
  } = rgbRest;
  const hexR = r.toString(16).padStart(2, '0');
  const hexG = g.toString(16).padStart(2, '0');
  const hexB = b.toString(16).padStart(2, '0');
  const hexA = a === 1 ? '' : hexAlphaNumMaps[a] || '';
  // è¿ååå­è¿å¶é¢è²ä»£ç 
  return `#${hexR}${hexG}${hexB}${hexA}`.toUpperCase();
}
function rgbToHsv(rgbRest) {
  if (!rgbRest) {
    return null;
  }
  const {
    r,
    g,
    b
  } = rgbRest;
  const rAbs = r / 255;
  const gAbs = g / 255;
  const bAbs = b / 255;
  let h = 0;
  let s = 0;
  const val = Math.max(rAbs, gAbs, bAbs);
  const num = val - Math.min(rAbs, gAbs, bAbs);
  const handleDiff = c => (val - c) / 6 / num + 1 / 2;
  if (num === 0) {
    h = s = 0;
  } else {
    s = num / val;
    const rr = handleDiff(rAbs);
    const gg = handleDiff(gAbs);
    const bb = handleDiff(bAbs);
    if (rAbs === val) {
      h = bb - gg;
    } else if (gAbs === val) {
      h = 1 / 3 + rr - bb;
    } else if (bAbs === val) {
      h = 2 / 3 + gg - rr;
    }
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }
  return {
    h: Math.round(h * 360),
    s: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().round(s, 2),
    v: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().round(val, 2)
  };
}
function hsvToRgb(h, s, v) {
  let r = 0;
  let g = 0;
  let b = 0;
  const i = Math.floor(h / 60);
  const f = h / 60 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  switch (i) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
      r = v;
      g = p;
      b = q;
      break;
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}
function hexToHsv(str) {
  const rgbRest = hexToRgb(str);
  if (rgbRest) {
    return rgbToHsv(rgbRest);
  }
  return null;
}
function hexToRgb(str) {
  if (str) {
    const rests = str.match(/^(#?)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})?$/);
    if (rests) {
      return {
        r: parseInt(rests[2], 16),
        g: parseInt(rests[3], 16),
        b: parseInt(rests[4], 16),
        a: (rests[5] ? hexAlphaKeyMaps[rests[5].toUpperCase()] : 1) || 1
      };
    }
  }
  return null;
}
;// CONCATENATED MODULE: ./packages/number-input/src/util.ts

function handleNumber(val) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val) ? val.replace(/[^0-9e.-]/g, '') : val;
}
function toFloatValueFixed(inputValue, digitsValue) {
  if (/^-/.test('' + inputValue)) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil(inputValue, digitsValue), digitsValue);
  }
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(inputValue, digitsValue), digitsValue);
}
;// CONCATENATED MODULE: ./packages/input/src/input.ts











/* harmony default export */ var input = (defineVxeComponent({
  name: 'VxeInput',
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    title: String,
    type: {
      type: String,
      default: 'text'
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().input.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: {
      type: String,
      default: null
    },
    maxLength: {
      type: [String, Number],
      default: () => getConfig().input.maxLength
    },
    autoComplete: {
      type: String,
      default: 'off'
    },
    autoFocus: {
      type: Boolean,
      default: null
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().input.size || getConfig().size
    },
    multiple: Boolean,
    // text
    showWordCount: Boolean,
    countMethod: Function,
    // numberãintegerãfloat
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    trim: {
      type: Boolean,
      default: () => getConfig().input.trim
    },
    exponential: {
      type: Boolean,
      default: () => getConfig().input.exponential
    },
    // numberãintegerãfloatãpassword
    controls: {
      type: Boolean,
      default: () => getConfig().input.controls
    },
    // float
    digits: {
      type: [String, Number],
      default: () => getConfig().input.digits
    },
    // dateãweekãmonthãquarterãyear
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().input.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().input.endDate
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    // å·²åºå¼ startWeekï¼è¢« startDay æ¿æ¢
    startWeek: Number,
    startDay: {
      type: [String, Number],
      default: () => getConfig().input.startDay
    },
    labelFormat: String,
    valueFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().input.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().input.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().input.selectDay
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    // å·²åºå¼
    maxlength: [String, Number],
    // å·²åºå¼
    autocomplete: String
  },
  emits: ['update:modelValue', 'input', 'change', 'keydown', 'keyup', 'wheel', 'click', 'focus', 'blur', 'clear', 'lazy-change', 'search-click', 'toggle-visible', 'prev-number', 'next-number', 'prefix-click', 'suffix-click', 'date-prev', 'date-today', 'date-next'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeSelect = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeSelect', null);
    const $xeTreeSelect = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTreeSelect', null);
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      panelIndex: 0,
      showPwd: false,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: '',
      isActivated: false,
      inputValue: props.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: '',
      datePanelType: 'day',
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8,
      hpTimeout: undefined,
      dnTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPanelWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTimeBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeInput = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let inputMethods = {};
    const parseDate = (value, format) => {
      const {
        type
      } = props;
      if (type === 'time') {
        return toStringTimeDate(value);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value, format);
    };
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().input.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeForm) {
        return $xeForm.props.readonly;
      }
      return false;
    });
    const computeIsReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInpMaxLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        maxLength,
        maxlength
      } = props;
      const maxLen = maxLength || maxlength;
      const isNumType = computeIsNumType.value;
      // æ°å¼æå¤§é¿åº¦éå¶ 16 ä½ï¼åå«å°æ°
      if (isNumType) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(maxLen)) {
          return 16;
        }
      }
      return maxLen;
    });
    const computeIsDateTimeType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'time' || type === 'datetime';
    });
    const computeIsNumType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['number', 'integer', 'float'].indexOf(props.type) > -1;
    });
    const computeInputCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getSize(reactData.inputValue);
    });
    const computeIsCountError = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpMaxLength);
    });
    const computeIsDatePickerType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeIsPawdType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.type === 'password';
    });
    const computeIsSearchType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.type === 'search';
    });
    const computeDigitsValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(props.digits) || 1;
    });
    const computeStepValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const digitsValue = computeDigitsValue.value;
      const step = props.step;
      if (type === 'integer') {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(step) || 1;
      } else if (type === 'float') {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1;
    });
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      return props.clearable && (isPawdType || isNumType || isDatePickerType || type === 'text' || type === 'search');
    });
    const computeDateStartTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.startDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.endDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeDateListValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        multiple
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue).split(',').map(item => {
          const date = parseDate(item, dateValueFormat);
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateLabelFormat)).join(', ');
    });
    const computeDateValueFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        valueFormat
      } = props;
      if (valueFormat) {
        return valueFormat;
      }
      if (type === 'time') {
        return 'HH:mm:ss';
      }
      if (type === 'datetime') {
        return 'yyyy-MM-dd HH:mm:ss';
      }
      return 'yyyy-MM-dd';
    });
    const computeDateValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate(modelValue, dateValueFormat);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateStartTime = computeDateStartTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateEndTime = computeDateEndTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        datetimePanelValue
      } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      if (datetimePanelValue) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(datetimePanelValue, hasTimeSecond ? 'HH:mm:ss' : 'HH:mm');
      }
      return '';
    });
    const computeDateHMSTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1000 : 0;
    });
    const computeDateLabelFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        labelFormat
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return '';
    });
    const computeYearList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const {
        yearSize
      } = internalData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(startYearDate, index, 'first');
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelObj = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      let y = '';
      let m = '';
      if (isDatePickerType) {
        const {
          datePanelType,
          selectMonth
        } = reactData;
        const yearList = computeYearList.value;
        let year = '';
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === 'quarter' || datePanelType === 'month') {
          y = getI18n('vxe.datePicker.yearTitle', [year]);
        } else if (datePanelType === 'year') {
          y = yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : '';
        } else {
          y = getI18n('vxe.datePicker.yearTitle', [year]);
          m = month ? getI18n(`vxe.input.date.m${month}`) : '-';
        }
      }
      return {
        y,
        m
      };
    });
    const computeFirstDayOfWeek = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startDay,
        startWeek
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(startDay) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map(day => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{
          label: getI18n('vxe.input.date.weeks.w')
        }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const yearList = computeYearList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(yearList, 4);
    });
    const computeQuarterList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const {
        quarterSize
      } = internalData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first');
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const quarterList = computeQuarterList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(quarterList, 2);
    });
    const computeMonthList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const {
        monthSize
      } = internalData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first').getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const monthList = computeMonthList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(monthList, 4);
    });
    const computeDayList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayList = computeDayList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(dayList, 7);
    });
    const computeWeekDates = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map(list => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeMinuteList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /mm/.test(dateValueFormat);
    });
    const computeHasTimeSecond = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /ss/.test(dateValueFormat);
    });
    const computeSecondList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInputReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        editable,
        multiple
      } = props;
      const isReadonly = computeIsReadonly.value;
      return isReadonly || multiple || !editable || type === 'week' || type === 'quarter';
    });
    const computeInputType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const {
        showPwd
      } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      if (isDatePickerType || isNumType || isPawdType && showPwd || type === 'number') {
        return 'text';
      }
      return type;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(placeholder)) {
        const globalPlaceholder = getConfig().input.placeholder;
        if (globalPlaceholder) {
          return getFuncText(globalPlaceholder);
        }
        return getI18n('vxe.base.pleaseInput');
      }
      return placeholder;
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        immediate
      } = props;
      return immediate || !(type === 'text' || type === 'number' || type === 'integer' || type === 'float');
    });
    const computeNumValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        return type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
      }
      return 0;
    });
    const computeIsDisabledSubtractNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        min
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      // å½æå¼æ¶åè¿è¡å¤æ­
      if ((inputValue || inputValue === 0) && isNumType && min !== null) {
        return numValue <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        max
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      // å½æå¼æ¶åè¿è¡å¤æ­
      if ((inputValue || inputValue === 0) && isNumType && max !== null) {
        return numValue >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    });
    const getNumberValue = val => {
      const {
        type,
        exponential
      } = props;
      const inpMaxLength = computeInpMaxLength.value;
      const digitsValue = computeDigitsValue.value;
      const restVal = type === 'float' ? toFloatValueFixed(val, digitsValue) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(val);
      if (exponential && (val === restVal || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(val).toLowerCase() === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxLength);
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const triggerEvent = evnt => {
      const {
        inputValue
      } = reactData;
      inputMethods.dispatchEvent(evnt.type, {
        value: inputValue
      }, evnt);
    };
    const handleChange = (value, evnt) => {
      if (props.trim) {
        value = `${value || ''}`.trim();
      }
      reactData.inputValue = value;
      emitModel(value);
      inputMethods.dispatchEvent('input', {
        value
      }, evnt);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        inputMethods.dispatchEvent('change', {
          value
        }, evnt);
        if (!$xeSelect && !$xeTreeSelect) {
          // èªå¨æ´æ°æ ¡éªç¶æ
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const emitInputEvent = (value, evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          handleChange(value, evnt);
        } else {
          inputMethods.dispatchEvent('input', {
            value
          }, evnt);
        }
      }
    };
    const inputEvent = evnt => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = evnt => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
      $xeInput.dispatchEvent('lazy-change', {
        value: reactData.inputValue
      }, evnt);
    };
    const blurEvent = evnt => {
      const {
        inputValue
      } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue;
      if (!inpImmediate) {
        handleChange(value, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      inputMethods.dispatchEvent('blur', {
        value
      }, evnt);
      if (!$xeSelect && !$xeTreeSelect) {
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const focusEvent = evnt => {
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      reactData.isActivated = true;
      if (isNumType) {
        reactData.inputValue = eqEmptyValue(inputValue) ? '' : `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inputValue)}`;
      } else if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent(evnt);
    };
    const clickPrefixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        $xeInput.dispatchEvent('prefix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise(resolve => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const {
        type,
        autoFocus
      } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      if (autoFocus || autoFocus === null) {
        if (isNumType || ['text', 'search', 'password'].indexOf(type) > -1) {
          focus();
        }
      }
      handleChange('', evnt);
      $xeInput.dispatchEvent('clear', {
        value
      }, evnt);
      $xeInput.dispatchEvent('lazy-change', {
        value
      }, evnt);
    };
    const clickSuffixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        $xeInput.dispatchEvent('suffix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const dateParseValue = value => {
      const {
        type
      } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = '';
      if (value) {
        dValue = parseDate(value, dateValueFormat);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(dValue)) {
        dLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dValue, dateLabelFormat, {
          firstDay: firstDayOfWeek
        });
        // å¨éæ©å¨ï¼ç±äºå¹´ä»½åç¬¬å å¨æ¯å²çªçè¡ä¸ºï¼æä»¥éè¦ç¹æ®å¤çï¼å¤æ­æ¯å¦è·¨å¹´ï¼ä¾å¦
        // '2024-12-31' 'yyyy-MM-dd W' >> '2024-12-31 1'
        // '2025-01-01' 'yyyy-MM-dd W' >> '2025-01-01 1'
        if (dateLabelFormat && type === 'week') {
          const weekNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(dValue, firstDayOfWeek);
          const weekDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(dValue, 0, weekNum === 1 ? (6 + firstDayOfWeek) % 7 : firstDayOfWeek, firstDayOfWeek);
          const weekFullYear = weekDate.getFullYear();
          if (weekFullYear !== dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf('yyyy');
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${weekFullYear}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    /**
     * å¼ååæ¶å¤ç
     */
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const {
        inputValue
      } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    /**
     * æ£æ¥åå§å¼
     */
    const initValue = () => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const digitsValue = computeDigitsValue.value;
      if (isDatePickerType) {
        changeValue();
      } else if (type === 'float') {
        if (inputValue) {
          const validValue = toFloatValueFixed(inputValue, digitsValue);
          if (inputValue !== validValue) {
            handleChange(validValue, {
              type: 'init'
            });
          }
        }
      }
    };
    const validMaxNum = num => {
      return props.max === null || props.max === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.max);
    };
    const validMinNum = num => {
      return props.min === null || props.min === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.min);
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = date => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(date, firstDayOfWeek);
      const weekStartDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(weekNum === 1 ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(weekStartDate, 6) : date, 0, 'first');
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = date => {
      const {
        modelValue,
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === 'week') {
        const sWeek = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.selectDay);
        date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        date.setHours(datetimePanelValue.getHours());
        date.setMinutes(datetimePanelValue.getMinutes());
        date.setSeconds(datetimePanelValue.getSeconds());
      }
      const inpVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat, {
        firstDay: firstDayOfWeek
      });
      dateCheckMonth(date);
      if (multiple) {
        // å¦æä¸ºå¤é
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          // å¦ææ¯datetimeç¹æ®ç±»å
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(dateListValue, val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(date, val, 'yyyyMMdd'));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach(item => {
            if (item) {
              item.setHours(datetimePanelValue.getHours());
              item.setMinutes(datetimePanelValue.getMinutes());
              item.setSeconds(datetimePanelValue.getSeconds());
              datetimeRest.push(item);
            }
          });
          handleChange(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
            type: 'update'
          });
        } else {
          // å¦ææ¯æ¥æç±»å
          if (dateMultipleValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal))) {
            handleChange(dateMultipleValue.filter(val => !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal)).join(','), {
              type: 'update'
            });
          } else {
            handleChange(dateMultipleValue.concat([inpVal]).join(','), {
              type: 'update'
            });
          }
        }
      } else {
        // å¦æä¸ºåé
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(modelValue, inpVal)) {
          handleChange(inpVal, {
            type: 'update'
          });
        }
      }
    };
    const afterCheckValue = () => {
      const {
        type,
        min,
        max,
        exponential
      } = props;
      const {
        inputValue,
        datetimePanelValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (isNumType) {
          if (inputValue) {
            const inpVal = `${handleNumber(inputValue)}`;
            if (inpVal) {
              let inpNumVal = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(inpVal) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpVal);
              if (!validMinNum(inpNumVal)) {
                inpNumVal = min;
              } else if (!validMaxNum(inpNumVal)) {
                inpNumVal = max;
              }
              if (exponential) {
                const inpStringVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(inputValue).toLowerCase();
                if (inpStringVal === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpNumVal).toExponential()) {
                  inpNumVal = inpStringVal;
                }
              }
              handleChange(getNumberValue(inpNumVal), {
                type: 'check'
              });
            } else {
              // è¾å¥éè¯¯å­ç¬¦ï¼æ¸ç©º
              let inpValue = '';
              if (min || min === 0) {
                inpValue = `${min}`;
              }
              handleChange(inpValue, {
                type: 'check'
              });
            }
          }
        } else if (isDatePickerType) {
          if (inputValue) {
            let inpDateVal = parseDate(inputValue, dateLabelFormat);
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(inpDateVal)) {
              if (type === 'time') {
                inpDateVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat);
                if (inputValue !== inpDateVal) {
                  handleChange(inpDateVal, {
                    type: 'check'
                  });
                }
                reactData.inputValue = inpDateVal;
              } else {
                let isChange = false;
                const firstDayOfWeek = computeFirstDayOfWeek.value;
                if (type === 'datetime') {
                  const dateValue = computeDateValue.value;
                  if (inputValue !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dateValue, dateLabelFormat) || inputValue !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat)) {
                    isChange = true;
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                } else {
                  isChange = true;
                }
                reactData.inputValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat, {
                  firstDay: firstDayOfWeek
                });
                if (isChange) {
                  dateChange(inpDateVal);
                }
              }
            } else {
              dateRevert();
            }
          } else {
            handleChange('', {
              type: 'check'
            });
          }
        }
      }
    };
    // å¯ç 
    const passwordToggleEvent = evnt => {
      const {
        showPwd
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!isDisabled && !isReadonly) {
        reactData.showPwd = !showPwd;
      }
      inputMethods.dispatchEvent('toggle-visible', {
        visible: reactData.showPwd
      }, evnt);
    };
    // å¯ç 
    // æç´¢
    const searchEvent = evnt => {
      inputMethods.dispatchEvent('search-click', {}, evnt);
    };
    // æç´¢
    // æ°å¼
    const numberChange = (isPlus, evnt) => {
      const {
        min,
        max,
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
      const newValue = isPlus ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().add(numValue, stepValue) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    const numberNextEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      numberStopDown();
      if (!isDisabled && !isReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      inputMethods.dispatchEvent('next-number', {
        value: reactData.inputValue
      }, evnt);
    };
    const numberDownNextEvent = evnt => {
      internalData.dnTimeout = setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      numberStopDown();
      if (!isDisabled && !isReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      inputMethods.dispatchEvent('prev-number', {
        value: reactData.inputValue
      }, evnt);
    };
    const numberKeydownEvent = evnt => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = evnt => {
      const {
        type,
        exponential,
        controls
      } = props;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        const isControlKey = hasControlKey(evnt);
        const isShiftKey = evnt.shiftKey;
        const isAltKey = evnt.altKey;
        const keyCode = evnt.keyCode;
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (!isControlKey && !isShiftKey && !isAltKey) {
          if (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || type === 'integer' && keyCode === 110 || (!exponential || keyCode !== 69) && keyCode >= 65 && keyCode <= 90 || keyCode >= 186 && keyCode <= 188 || keyCode >= 191) {
            evnt.preventDefault();
          }
        }
        if (isEsc) {
          afterCheckValue();
        } else if (isUpArrow || isDwArrow) {
          if (controls) {
            numberKeydownEvent(evnt);
          }
        }
      }
      triggerEvent(evnt);
    };
    const keyupEvent = evnt => {
      triggerEvent(evnt);
    };
    // æ°å¼
    const numberStopDown = () => {
      const {
        dnTimeout
      } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = undefined;
      }
    };
    const numberDownPrevEvent = evnt => {
      internalData.dnTimeout = setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = evnt => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass(evnt.currentTarget, 'is--prev');
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        internalData.dnTimeout = setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = evnt => {
      const isNumType = computeIsNumType.value;
      if (isNumType && props.controls) {
        if (reactData.isActivated) {
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
          evnt.preventDefault();
        }
      }
      triggerEvent(evnt);
    };
    // æ¥æ
    const dateMonthHandle = (date, offsetMonth) => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(date, firstDayOfWeek);
      const weekStartDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(weekNum === 1 ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(weekStartDate, 6) : date, offsetMonth, 'first');
      reactData.selectMonth = month;
    };
    const dateNowHandle = () => {
      const currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleYearTypeEvent = () => {
      reactData.datePanelType = 'year';
    };
    const dateToggleMonthTypeEvent = () => {
      let {
        datePanelType
      } = reactData;
      if (datePanelType === 'month' || datePanelType === 'quarter') {
        datePanelType = 'year';
      } else {
        datePanelType = 'month';
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth,
        inputValue
      } = reactData;
      const {
        yearSize
      } = internalData;
      const value = inputValue;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        let viewDate;
        if (type === 'year') {
          viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else if (datePanelType === 'month') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, -1, 'first');
          }
        }
        reactData.selectMonth = viewDate;
        inputMethods.dispatchEvent('date-prev', {
          viewType: datePanelType,
          viewDate,
          value,
          type
        }, evnt);
      }
    };
    const dateTodayMonthEvent = evnt => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      inputMethods.dispatchEvent('date-today', {
        type: props.type
      }, evnt);
    };
    const dateNextEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth,
        inputValue
      } = reactData;
      const {
        yearSize
      } = internalData;
      const value = inputValue;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        let viewDate;
        if (type === 'year') {
          viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else if (datePanelType === 'month') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, 1, 'first');
          }
        }
        reactData.selectMonth = viewDate;
        inputMethods.dispatchEvent('date-next', {
          viewType: datePanelType,
          viewDate,
          value,
          type
        }, evnt);
      }
    };
    const isDateDisabled = item => {
      const {
        disabledMethod
      } = props;
      const {
        datePanelType
      } = reactData;
      const dateStartTime = computeDateStartTime.value;
      const dateEndTime = computeDateEndTime.value;
      const {
        date
      } = item;
      if (dateStartTime && dateStartTime.getTime() > date.getTime()) {
        return true;
      }
      if (dateEndTime && dateEndTime.getTime() < date.getTime()) {
        return true;
      }
      if (disabledMethod) {
        return disabledMethod({
          type: datePanelType,
          viewType: datePanelType,
          date,
          $input: $xeInput
        });
      }
      return false;
    };
    const dateSelectItem = date => {
      const {
        type,
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      if (type === 'month') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === 'year') {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === 'quarter') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'quarter';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === 'month') {
          reactData.datePanelType = type === 'week' ? type : 'day';
          dateCheckMonth(date);
        } else if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === 'datetime') {
            // æ¥æå¸¦æ¶é´
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = item => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = offsetDay => {
      if (!isDateDisabled({
        date: offsetDay
      })) {
        const dayList = computeDayList.value;
        if (!dayList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetDay, 'yyyyMMdd'))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = offsetYear => {
      if (!isDateDisabled({
        date: offsetYear
      })) {
        const yearList = computeYearList.value;
        if (!yearList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetYear, 'yyyy'))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = offsetQuarter => {
      if (!isDateDisabled({
        date: offsetQuarter
      })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetQuarter, 'yyyyq'))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = offsetMonth => {
      if (!isDateDisabled({
        date: offsetMonth
      })) {
        const monthList = computeMonthList.value;
        if (!monthList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetMonth, 'yyyyMM'))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = item => {
      if (!isDateDisabled(item)) {
        const {
          datePanelType
        } = reactData;
        if (datePanelType === 'month') {
          dateMoveMonth(item.date);
        } else if (datePanelType === 'quarter') {
          dateMoveQuarter(item.date);
        } else if (datePanelType === 'year') {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = liElem => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = evnt => {
      reactData.datetimePanelValue = new Date(reactData.datetimePanelValue.getTime());
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      reactData.datetimePanelValue.setHours(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const {
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          // å¦æä¸ºå¤é
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            // å¦ææ¯datetimeç¹æ®ç±»å
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach(item => {
              if (item) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
                datetimeRest.push(item);
              }
            });
            handleChange(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
              type: 'update'
            });
          } else {
            // å¦ææ¯æ¥æç±»å
            handleChange(dateMultipleValue.join(','), {
              type: 'update'
            });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      reactData.datetimePanelValue.setMinutes(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      reactData.datetimePanelValue.setSeconds(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = evnt => {
      const {
        isActivated,
        datePanelValue,
        datePanelType
      } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === 'year') {
          let offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === 'quarter') {
          let offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === 'month') {
          let offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = evnt => {
      const {
        isActivated
      } = reactData;
      if (isActivated) {
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const {
        type
      } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (['year', 'quarter', 'month', 'week'].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = 'day';
      }
      reactData.currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const timeBodyElem = refInputTimeBody.value;
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(timeBodyElem.querySelectorAll('li.is--selected'), elem => {
            updateTimePos(elem);
          });
        });
      }
    };
    // æ¥æ
    // å¼¹åºé¢æ¿
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          placement
        } = props;
        const {
          panelIndex
        } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const {
            boundingTop,
            boundingLeft,
            visibleHeight,
            visibleWidth
          } = getAbsolutePos(targetElem);
          let panelPlacement = 'bottom';
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === 'top') {
              panelPlacement = 'top';
              top = boundingTop - panelHeight;
            } else if (!placement) {
              // å¦æä¸é¢ä¸å¤æ¾ï¼ååä¸
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = 'top';
                top = boundingTop - panelHeight;
              }
              // å¦æä¸é¢ä¸å¤æ¾ï¼ååä¸ï¼ä¼åï¼
              if (top < marginSize) {
                panelPlacement = 'bottom';
                top = boundingTop + targetHeight;
              }
            }
            // å¦ææº¢åºå³è¾¹
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            // å¦ææº¢åºå·¦è¾¹
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === 'top') {
              panelPlacement = 'top';
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              // å¦æä¸é¢ä¸å¤æ¾ï¼ååä¸
              panelStyle.top = `${targetHeight}px`;
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                // å¦æä¸é¢ä¸å¤æ¾ï¼ååä¸ï¼ä¼åï¼
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = 'top';
                  panelStyle.top = '';
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    const showPanel = () => {
      const {
        visiblePanel
      } = reactData;
      const {
        hpTimeout
      } = internalData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = undefined;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const datePickerOpenEvent = evnt => {
      const isReadonly = computeIsReadonly.value;
      if (!isReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    // å¼¹åºé¢æ¿
    // å¨å±äºä»¶
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          // å¦ææ¯æ¥æç±»å
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable
      } = props;
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        const isPgDn = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        isActivated,
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        hidePanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const inputElem = refInputTarget.value;
        afterCheckValue();
        if (inputElem) {
          inputElem.blur();
        }
      }
    };
    const renderDateLabel = (item, label) => {
      const {
        festivalMethod
      } = props;
      if (festivalMethod) {
        const {
          datePanelType
        } = reactData;
        const festivalRest = festivalMethod({
          type: datePanelType,
          viewType: datePanelType,
          date: item.date,
          $input: $xeInput
        });
        const festivalItem = festivalRest ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalRest) ? {
          label: festivalRest
        } : festivalRest : {};
        const extraItem = festivalItem.extra ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalItem.extra) ? {
          label: festivalItem.extra
        } : festivalItem.extra : null;
        const labels = [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-input--date-label', {
            'is-notice': festivalItem.notice
          }]
        }, extraItem && extraItem.label ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${label || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-input--date-label--extra', extraItem.important ? 'is-important' : '', extraItem.className],
          style: extraItem.style
        }, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(extraItem.label))] : [`${label || ''}`])];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          // é»è®¤æå¤æ¯æ3ä¸ªèæ¥éå 
          const festivalLabels = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(festivalLabel).split(',');
          labels.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-input--date-festival', festivalItem.important ? 'is-important' : '', festivalItem.className],
            style: festivalItem.style
          }, [festivalLabels.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-input--date-festival--overlap', `overlap--${festivalLabels.length}`]
          }, festivalLabels.map(label => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', label.substring(0, 3)))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-input--date-festival--label'
          }, festivalLabels[0].substring(0, 3))]));
        }
        return labels;
      }
      return [`${label || ''}`];
    };
    const renderDateDayTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', dateHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', item.label);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', dayDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      }))])];
    };
    const renderDateWeekTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', weekHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', item.label);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', weekDates.map(rows => {
        const isSelected = multiple ? rows.some(item => dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat))) : rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat));
        const isHover = rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat));
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--hover': isHover
            },
            // event
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      }))])];
    };
    const renderDateMonthTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMM';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', monthDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
        }));
      }))])];
    };
    const renderDateQuarterTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyq';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', quarterDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
        }));
      }))])];
    };
    const renderDateYearTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyy';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', yearDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.year));
        }));
      }))])];
    };
    const renderDateTable = () => {
      const {
        datePanelType
      } = reactData;
      switch (datePanelType) {
        case 'week':
          return renderDateWeekTable();
        case 'month':
          return renderDateMonthTable();
        case 'quarter':
          return renderDateQuarterTable();
        case 'year':
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelObj = computeSelectDatePanelObj.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-type-wrapper'
      }, [datePanelType === 'year' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-label'
      }, selectDatePanelObj.y) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btns'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn',
        onClick: dateToggleYearTypeEvent
      }, selectDatePanelObj.y), selectDatePanelObj.m ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn',
        onClick: dateToggleMonthTypeEvent
      }, selectDatePanelObj.m) : renderEmptyElement($xeInput)])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--date-picker-btn vxe-input--date-picker-prev-btn', {
          'is--disabled': isDisabledPrevDateBtn
        }],
        onClick: datePrevEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-left'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn vxe-input--date-picker-current-btn',
        onClick: dateTodayMonthEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-dot'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--date-picker-btn vxe-input--date-picker-next-btn', {
          'is--disabled': isDisabledNextDateBtn
        }],
        onClick: dateNextEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-right'
      })]), multiple && computeSupportMultiples.value ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn vxe-input--date-picker-confirm-btn'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'vxe-input--date-picker-confirm',
        type: 'button',
        onClick: dateConfirmEvent
      }, getI18n('vxe.button.confirm'))]) : null])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-body'
      }, renderDateTable())];
    };
    const renderTimePanel = () => {
      const {
        datetimePanelValue
      } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--time-picker-header'
      }, [hasTimeMinute ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--time-picker-title'
      }, dateTimeLabel) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--time-picker-btn'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'vxe-input--time-picker-confirm',
        type: 'button',
        onClick: dateConfirmEvent
      }, getI18n('vxe.button.confirm'))])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refInputTimeBody,
        class: 'vxe-input--time-picker-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-input--time-picker-hour-list'
      }, hourList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getHours() === item.value
          },
          onClick: evnt => dateHourEvent(evnt, item)
        }, item.label);
      })), hasTimeMinute ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-input--time-picker-minute-list'
      }, minuteList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getMinutes() === item.value
          },
          onClick: evnt => dateMinuteEvent(evnt, item)
        }, item.label);
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), hasTimeMinute && hasTimeSecond ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-input--time-picker-second-list'
      }, secondList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getSeconds() === item.value
          },
          onClick: evnt => dateSecondEvent(evnt, item)
        }, item.label);
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])];
    };
    const renderPanel = () => {
      const {
        type
      } = props;
      const {
        initialized,
        isAniVisible,
        visiblePanel,
        panelPlacement,
        panelStyle
      } = reactData;
      const vSize = computeSize.value;
      const btnTransfer = computeBtnTransfer.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === 'datetime') {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: type,
            ref: refPanelWrapper,
            class: 'vxe-input--panel-layout-wrapper'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-input--panel-left-wrapper'
          }, renderDatePanel()), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-input--panel-right-wrapper'
          }, renderTimePanel())]));
        } else if (type === 'time') {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: type,
            ref: refPanelWrapper,
            class: 'vxe-input--panel-wrapper'
          }, renderTimePanel()));
        } else {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: type || 'default',
            ref: refPanelWrapper,
            class: 'vxe-input--panel-wrapper'
          }, renderDatePanel()));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
          to: 'body',
          disabled: btnTransfer ? !initialized : true
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refInputPanel,
          class: ['vxe-table--ignore-clear vxe-input--panel', `type--${type}`, {
            [`size--${vSize}`]: vSize,
            'is--transfer': btnTransfer,
            'ani--leave': isAniVisible,
            'ani--enter': visiblePanel
          }],
          placement: panelPlacement,
          style: panelStyle
        }, visiblePanel || isAniVisible ? renders : [])]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--control-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--number-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-input--number-btn is--prev', {
          'is--disabled': isDisabledAddNumber
        }],
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopDown,
        onMouseleave: numberStopDown
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_PLUS_NUM
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-input--number-btn is--next', {
          'is--disabled': isDisabledSubtractNumber
        }],
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopDown,
        onMouseleave: numberStopDown
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_MINUS_NUM
      })])])]);
    };
    const renderDatePickerIcon = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--control-icon',
        onClick: datePickerOpenEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--date-picker-icon', getIcon().DATE_PICKER_DATE]
      })]);
    };
    const renderSearchIcon = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--control-icon',
        onClick: searchEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--search-icon', getIcon().INPUT_SEARCH]
      })]);
    };
    const renderPasswordIcon = () => {
      const {
        showPwd
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--control-icon',
        onClick: passwordToggleEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--password-icon', showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
      })]);
    };
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--prefix-icon'
      }, prefixSlot ? vn_getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : null;
    };
    const renderSuffixIcon = () => {
      const {
        suffixIcon
      } = props;
      const {
        inputValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      const isClearable = computeIsClearable.value;
      const isExtraBtn = isPawdType || isNumType || isDatePickerType || isSearchType;
      return isClearable || suffixSlot || suffixIcon || isExtraBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-input--suffix', {
          'is--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), isExtraBtn ? renderExtraSuffixIcon() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? vn_getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]) : null;
    };
    const renderExtraSuffixIcon = () => {
      const {
        controls
      } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      if (isPawdType) {
        return renderPasswordIcon();
      }
      if (isNumType) {
        if (controls) {
          return renderNumberIcon();
        }
      }
      if (isDatePickerType) {
        return renderDatePickerIcon();
      }
      if (isSearchType) {
        return renderSearchIcon();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $input: $xeInput
      }, params));
    };
    inputMethods = {
      dispatchEvent,
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeInput, inputMethods);
    const renderVN = () => {
      const {
        className,
        controls,
        type,
        title,
        align,
        showWordCount,
        countMethod,
        name,
        autoComplete,
        autocomplete
      } = props;
      const {
        inputValue,
        visiblePanel,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-input--readonly', `type--${type}`, className]
        }, inputValue);
      }
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const inpMaxLength = computeInpMaxLength.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const isWordCount = showWordCount && ['text', 'search'].includes(type);
      const prefix = renderPrefixIcon();
      const suffix = renderSuffixIcon();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-input', `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          'is--controls': controls,
          'is--prefix': !!prefix,
          'is--suffix': !!suffix,
          'is--visible': visiblePanel,
          'is--count': isWordCount,
          'is--disabled': isDisabled,
          'is--active': isActivated,
          'show--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }],
        spellcheck: false
      }, [prefix || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--wrapper',
        title: title || null
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-input--inner',
        value: inputValue,
        name,
        type: inputType,
        placeholder: inpPlaceholder,
        maxlength: inpMaxLength,
        readonly: inputReadonly,
        disabled: isDisabled,
        autocomplete: autoComplete || autocomplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), suffix || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      // ä¸æé¢æ¿
      renderPanel(),
      // å­æ°ç»è®¡
      isWordCount ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--count', {
          'is--error': isCountError
        }]
      }, countMethod ? `${countMethod({
        value: inputValue
      })}` : `${inputCount}${inpMaxLength ? `/${inpMaxLength}` : ''}`) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
      changeValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      // åæ¢ç±»åæ¯éç½®åç½®åé
      Object.assign(reactData, {
        inputValue: props.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: '',
        datePanelType: 'day',
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const {
        type
      } = props;
      if (['date', 'time', 'datetime', 'week', 'month', 'quarter', 'year'].includes(type)) {
        warnLog('vxe.error.useNew', [`<vxe-input type="${type}" ... />`, `<vxe-date-picker type="${type}" ... />`]);
      } else if (['number', 'integer', 'float'].includes(type)) {
        warnLog('vxe.error.useNew', [`<vxe-input type="${type}" ... />`, `<vxe-number-input type="${type}" ... />`]);
      } else if (['password'].includes(type)) {
        warnLog('vxe.error.useNew', [`<vxe-input type="${type}" ... />`, '<vxe-password-input ... />']);
      }
      const inputElem = refInputTarget.value;
      if (inputElem) {
        inputElem.addEventListener('wheel', wheelEvent, {
          passive: false
        });
      }
      globalEvents.on($xeInput, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeInput, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeInput, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeInput, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      numberStopDown();
      afterCheckValue();
      const inputElem = refInputTarget.value;
      if (inputElem) {
        inputElem.removeEventListener('wheel', wheelEvent);
      }
      globalEvents.off($xeInput, 'mousewheel');
      globalEvents.off($xeInput, 'mousedown');
      globalEvents.off($xeInput, 'keydown');
      globalEvents.off($xeInput, 'blur');
    });
    initValue();
    $xeInput.renderVN = renderVN;
    return $xeInput;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/number-input/src/number-input.ts








/* harmony default export */ var number_input = (defineVxeComponent({
  name: 'VxeNumberInput',
  props: {
    modelValue: [String, Number],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: 'number'
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().numberInput.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: {
      type: [String, Number],
      default: () => getConfig().numberInput.maxLength
    },
    autoComplete: {
      type: String,
      default: 'off'
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().numberInput.size || getConfig().size
    },
    // numberãintegerãfloat
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    exponential: {
      type: Boolean,
      default: () => getConfig().numberInput.exponential
    },
    showCurrency: {
      type: Boolean,
      default: () => getConfig().numberInput.showCurrency
    },
    currencySymbol: {
      type: String,
      default: () => getConfig().numberInput.currencySymbol
    },
    controlConfig: Object,
    // float
    digits: {
      type: [String, Number],
      default: null
    },
    autoFill: {
      type: Boolean,
      default: () => getConfig().numberInput.autoFill
    },
    editable: {
      type: Boolean,
      default: true
    },
    plusIcon: String,
    minusIcon: String,
    prefixIcon: String,
    suffixIcon: String,
    // å·²åºå¼
    controls: {
      type: Boolean,
      default: null
    },
    // å·²åºå¼
    maxlength: [String, Number],
    // å·²åºå¼
    autocomplete: String
  },
  emits: ['update:modelValue', 'input', 'change', 'keydown', 'keyup', 'wheel', 'click', 'focus', 'blur', 'clear', 'lazy-change', 'plus-number', 'minus-number', 'prefix-click', 'suffix-click',
  // å·²åºå¼
  'prev-number', 'next-number'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isFocus: false,
      isActivated: false,
      inputValue: props.modelValue
    });
    const internalData = {
      // dnTimeout: undefined,
      // ainTimeout: undefined,
      // isMouseDown: undefined,
      // isUM: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeDigitsValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        digits
      } = props;
      let defDigits = digits;
      if (defDigits === null) {
        defDigits = getConfig().numberInput.digits;
        if (defDigits === null) {
          if (type === 'amount') {
            defDigits = 2;
          }
        }
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(defDigits) || 1;
    });
    const computeControlOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().numberInput.controlConfig, props.controlConfig);
    });
    const computeDecimalsType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'float' || type === 'amount';
    });
    const computeStepValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      const step = props.step;
      if (type === 'integer') {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(step) || 1;
      } else if (decimalsType) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1;
    });
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.clearable;
    });
    const computeInputReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        editable
      } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || !editable;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().numberInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.base.pleaseInput');
    });
    const computeInpMaxLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        maxLength,
        maxlength
      } = props;
      // æ°å¼æå¤§é¿åº¦éå¶ 16 ä½ï¼åå«å°æ°
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(maxLength || maxlength) || 16;
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        immediate
      } = props;
      return immediate;
    });
    const computeNumValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      return type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
    });
    const computeNumLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        showCurrency,
        currencySymbol,
        autoFill
      } = props;
      const {
        inputValue
      } = reactData;
      const digitsValue = computeDigitsValue.value;
      if (type === 'amount') {
        const num = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inputValue);
        let amountLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().commafy(num, {
          digits: digitsValue
        });
        if (!autoFill) {
          const [iStr, dStr] = amountLabel.split('.');
          if (dStr) {
            const dRest = dStr.replace(/0+$/, '');
            amountLabel = dRest ? [iStr, '.', dRest].join('') : iStr;
          }
        }
        if (showCurrency) {
          return `${currencySymbol || getI18n('vxe.numberInput.currencySymbol') || ''}${amountLabel}`;
        }
        return amountLabel;
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toString(inputValue);
    });
    const computeIsDisabledSubtractNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        min
      } = props;
      const {
        inputValue
      } = reactData;
      const numValue = computeNumValue.value;
      // å½æå¼æ¶åè¿è¡å¤æ­
      if ((inputValue || inputValue === 0) && min !== null) {
        return numValue <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        max
      } = props;
      const {
        inputValue
      } = reactData;
      const numValue = computeNumValue.value;
      // å½æå¼æ¶åè¿è¡å¤æ­
      if ((inputValue || inputValue === 0) && max !== null) {
        return numValue >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    });
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const computeMaps = {
      computeControlOpts
    };
    const $xeNumberInput = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let numberInputMethods = {};
    const handleNumberString = val => {
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(val)) {
        return '';
      }
      return `${val}`;
    };
    const getNumberValue = val => {
      const {
        exponential,
        autoFill
      } = props;
      const inpMaxLength = computeInpMaxLength.value;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      let restVal = '';
      if (decimalsType) {
        restVal = toFloatValueFixed(val, digitsValue);
        if (!autoFill) {
          restVal = handleNumberString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(restVal));
        }
      } else {
        restVal = handleNumberString(val);
      }
      if (exponential && (val === restVal || handleNumberString(val).toLowerCase() === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxLength);
    };
    const triggerEvent = evnt => {
      const {
        inputValue
      } = reactData;
      numberInputMethods.dispatchEvent(evnt.type, {
        value: inputValue
      }, evnt);
    };
    const handleChange = (val, inputValue, evnt) => {
      const value = eqEmptyValue(val) ? null : Number(val);
      const isChange = value !== props.modelValue;
      if (isChange) {
        internalData.isUM = true;
        emit('update:modelValue', value);
      }
      if (reactData.inputValue !== inputValue) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          reactData.inputValue = inputValue || '';
        });
      }
      numberInputMethods.dispatchEvent('input', {
        value
      }, evnt);
      if (isChange) {
        numberInputMethods.dispatchEvent('change', {
          value
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const emitInputEvent = (inputValue, evnt) => {
      const inpImmediate = computeInpImmediate.value;
      const value = eqEmptyValue(inputValue) ? null : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inputValue);
      reactData.inputValue = inputValue;
      if (inpImmediate) {
        handleChange(value, inputValue, evnt);
      } else {
        numberInputMethods.dispatchEvent('input', {
          value
        }, evnt);
      }
    };
    const inputEvent = evnt => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = evnt => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
      $xeNumberInput.dispatchEvent('lazy-change', {
        value: reactData.inputValue
      }, evnt);
    };
    const focusEvent = evnt => {
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        const {
          inputValue
        } = reactData;
        reactData.inputValue = eqEmptyValue(inputValue) ? '' : `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inputValue)}`;
        reactData.isFocus = true;
        reactData.isActivated = true;
        triggerEvent(evnt);
      }
    };
    const clickPrefixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        numberInputMethods.dispatchEvent('prefix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      handleChange(null, '', evnt);
      numberInputMethods.dispatchEvent('clear', {
        value
      }, evnt);
      $xeNumberInput.dispatchEvent('lazy-change', {
        value
      }, evnt);
    };
    const clickSuffixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        numberInputMethods.dispatchEvent('suffix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const updateModel = val => {
      const {
        autoFill
      } = props;
      const {
        inputValue
      } = reactData;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      if (eqEmptyValue(val)) {
        reactData.inputValue = '';
      } else {
        let textValue = `${val}`;
        if (decimalsType) {
          textValue = toFloatValueFixed(val, digitsValue);
          if (!autoFill) {
            textValue = `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textValue)}`;
          }
        }
        if (textValue !== inputValue) {
          reactData.inputValue = textValue;
        }
      }
    };
    /**
     * æ£æ¥åå§å¼
     */
    const initValue = () => {
      const {
        autoFill
      } = props;
      const {
        inputValue
      } = reactData;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      if (decimalsType) {
        if (inputValue) {
          let textValue = '';
          let validValue = null;
          if (inputValue) {
            textValue = toFloatValueFixed(inputValue, digitsValue);
            validValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textValue);
            if (!autoFill) {
              textValue = `${validValue}`;
            }
          }
          if (inputValue !== validValue) {
            handleChange(validValue, textValue, {
              type: 'init'
            });
          } else {
            reactData.inputValue = textValue;
          }
        }
      }
    };
    const validMaxNum = num => {
      return props.max === null || props.max === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.max);
    };
    const validMinNum = num => {
      return props.min === null || props.min === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.min);
    };
    const afterCheckValue = () => {
      const {
        type,
        min,
        max,
        exponential
      } = props;
      const {
        inputValue
      } = reactData;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (eqEmptyValue(inputValue)) {
          let inpNumVal = null;
          let inpValue = inputValue;
          if (min || min === 0) {
            inpNumVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min);
            inpValue = `${inpNumVal}`;
          }
          handleChange(inpNumVal, `${inpValue || ''}`, {
            type: 'check'
          });
          return;
        }
        if (inputValue || min || max) {
          let inpNumVal = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
          if (!validMinNum(inpNumVal)) {
            inpNumVal = min;
          } else if (!validMaxNum(inpNumVal)) {
            inpNumVal = max;
          }
          if (exponential) {
            const inpStringVal = handleNumberString(inputValue).toLowerCase();
            if (inpStringVal === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpNumVal).toExponential()) {
              inpNumVal = inpStringVal;
            }
          }
          const inpValue = getNumberValue(inpNumVal);
          handleChange(eqEmptyValue(inpValue) ? null : Number(inpValue), inpValue, {
            type: 'check'
          });
        }
      }
    };
    const blurEvent = evnt => {
      const {
        inputValue
      } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue ? Number(inputValue) : null;
      if (!inpImmediate) {
        handleChange(value, handleNumberString(inputValue), evnt);
      }
      afterCheckValue();
      reactData.isFocus = false;
      reactData.isActivated = false;
      numberInputMethods.dispatchEvent('blur', {
        value
      }, evnt);
      // èªå¨æ´æ°æ ¡éªç¶æ
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    // æ°å¼
    const numberChange = (isPlus, evnt) => {
      const {
        min,
        max,
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
      const newValue = isPlus ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().add(numValue, stepValue) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    const numberPlusEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      if (!isDisabled && !formReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      reactData.isActivated = true;
      numberInputMethods.dispatchEvent('plus-number', {
        value: reactData.inputValue
      }, evnt);
      $xeNumberInput.dispatchEvent('lazy-change', {
        value: reactData.inputValue
      }, evnt);
      // å·²åºå¼
      numberInputMethods.dispatchEvent('next-number', {
        value: reactData.inputValue
      }, evnt);
    };
    const numberMinusEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      if (!isDisabled && !formReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      reactData.isActivated = true;
      numberInputMethods.dispatchEvent('minus-number', {
        value: reactData.inputValue
      }, evnt);
      $xeNumberInput.dispatchEvent('lazy-change', {
        value: reactData.inputValue
      }, evnt);
      // å·²åºå¼
      numberInputMethods.dispatchEvent('prev-number', {
        value: reactData.inputValue
      }, evnt);
    };
    const numberKeydownEvent = evnt => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPlusEvent(evnt);
        } else {
          numberMinusEvent(evnt);
        }
      }
    };
    const keydownEvent = evnt => {
      const {
        type,
        exponential,
        controls
      } = props;
      const controlOpts = computeControlOpts.value;
      const {
        isArrow
      } = controlOpts;
      const inputReadonly = computeInputReadonly.value;
      const isControlKey = hasControlKey(evnt);
      const isShiftKey = evnt.shiftKey;
      const isAltKey = evnt.altKey;
      const keyCode = evnt.keyCode;
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (!isControlKey && !isShiftKey && !isAltKey) {
        if (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || type === 'integer' && keyCode === 110 || (!exponential || keyCode !== 69) && keyCode >= 65 && keyCode <= 90 || keyCode >= 186 && keyCode <= 188 || keyCode >= 191) {
          evnt.preventDefault();
        }
      }
      if (isEsc) {
        afterCheckValue();
      } else if (isUpArrow || isDwArrow) {
        if (isEnableConf(controlOpts) && (controls === false ? controls : isArrow) && !inputReadonly) {
          numberKeydownEvent(evnt);
        }
      }
      triggerEvent(evnt);
    };
    const keyupEvent = evnt => {
      triggerEvent(evnt);
    };
    // æ°å¼
    const stopDown = () => {
      const {
        dnTimeout
      } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = undefined;
      }
    };
    const stopAutoIncrement = () => {
      const {
        ainTimeout
      } = internalData;
      if (ainTimeout) {
        clearTimeout(ainTimeout);
        internalData.ainTimeout = undefined;
      }
    };
    const numberDownMinusEvent = evnt => {
      numberStopAll();
      internalData.ainTimeout = setTimeout(() => {
        numberMinusEvent(evnt);
        numberDownMinusEvent(evnt);
      }, 60);
    };
    const numberDownPlusEvent = evnt => {
      numberStopAll();
      internalData.ainTimeout = setTimeout(() => {
        numberPlusEvent(evnt);
        numberDownPlusEvent(evnt);
      }, 60);
    };
    const numberStopAll = () => {
      stopDown();
      stopAutoIncrement();
    };
    const numberClickEvent = evnt => {
      if (internalData.isMouseDown) {
        internalData.isMouseDown = false;
      } else {
        numberStopAll();
        const isAddNumber = hasClass(evnt.currentTarget, 'is--plus');
        if (isAddNumber) {
          numberPlusEvent(evnt);
        } else {
          numberMinusEvent(evnt);
        }
      }
    };
    const numberMousedownEvent = evnt => {
      numberStopAll();
      internalData.isMouseDown = true;
      if (evnt.button === 0) {
        const isAddNumber = hasClass(evnt.currentTarget, 'is--plus');
        if (isAddNumber) {
          numberPlusEvent(evnt);
        } else {
          numberMinusEvent(evnt);
        }
        internalData.dnTimeout = setTimeout(() => {
          if (isAddNumber) {
            numberDownPlusEvent(evnt);
          } else {
            numberDownMinusEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = evnt => {
      const {
        controls
      } = props;
      const controlOpts = computeControlOpts.value;
      const {
        isWheel
      } = controlOpts;
      const inputReadonly = computeInputReadonly.value;
      if (isEnableConf(controlOpts) && (controls === false ? controls : isWheel) && !inputReadonly) {
        if (reactData.isActivated) {
          evnt.stopPropagation();
          evnt.preventDefault();
          const delta = evnt.deltaY;
          if (delta > 0) {
            // åä¸
            numberMinusEvent(evnt);
          } else if (delta < 0) {
            // åä¸
            numberPlusEvent(evnt);
          }
        }
      }
      triggerEvent(evnt);
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    // å¨å±äºä»¶
    const handleGlobalMousedownEvent = evnt => {
      const {
        isActivated
      } = reactData;
      const el = refElem.value;
      const panelElem = refInputPanel.value;
      const isDisabled = computeIsDisabled.value;
      const inputReadonly = computeInputReadonly.value;
      const inpImmediate = computeInpImmediate.value;
      if (!isDisabled && !inputReadonly && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (!reactData.isActivated) {
          if (!inpImmediate) {
            const {
              inputValue
            } = reactData;
            const value = inputValue ? Number(inputValue) : null;
            handleChange(value, handleNumberString(inputValue), evnt);
          }
          afterCheckValue();
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable
      } = props;
      const isDisabled = computeIsDisabled.value;
      const inputReadonly = computeInputReadonly.value;
      if (!isDisabled && !inputReadonly) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        }
        if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        isActivated
      } = reactData;
      if (isActivated) {
        afterCheckValue();
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $numberInput: $xeNumberInput
      }, params));
    };
    numberInputMethods = {
      dispatchEvent,
      focus() {
        const inputReadonly = computeInputReadonly.value;
        if (!inputReadonly) {
          const inputElem = refInputTarget.value;
          reactData.isActivated = true;
          inputElem.focus();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xeNumberInput, numberInputMethods);
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--prefix-icon'
      }, prefixSlot ? vn_getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : renderEmptyElement($xeNumberInput);
    };
    const renderSuffixIcon = () => {
      const {
        suffixIcon
      } = props;
      const {
        inputValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-number-input--suffix', {
          'is--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : renderEmptyElement($xeNumberInput), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? vn_getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : renderEmptyElement($xeNumberInput)]);
    };
    const renderInput = () => {
      const {
        type,
        name,
        autocomplete,
        autoComplete
      } = props;
      const {
        inputValue,
        isFocus
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const numLabel = computeNumLabel.value;
      const inputReadonly = computeInputReadonly.value;
      const inpMaxLength = computeInpMaxLength.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'ni',
        class: 'vxe-number-input--input-wrapper'
      }, [renderPrefixIcon(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--input-inner'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-number-input--input',
        value: !isFocus && type === 'amount' ? numLabel : inputValue,
        name,
        type: 'text',
        placeholder: inpPlaceholder,
        maxlength: inpMaxLength,
        readonly: inputReadonly,
        disabled: isDisabled,
        autocomplete: autoComplete || autocomplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), renderSuffixIcon()]);
    };
    const renderMinusBtn = () => {
      const {
        minusIcon
      } = props;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        key: 'prev',
        class: ['vxe-number-input--minus-btn is--minus', {
          'is--disabled': isDisabledSubtractNumber
        }],
        type: 'button',
        onClick: numberClickEvent,
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopAll,
        onMouseleave: numberStopAll
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: minusIcon || getIcon().NUMBER_INPUT_MINUS_NUM
      })]);
    };
    const renderPlusBtn = () => {
      const {
        plusIcon
      } = props;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        key: 'next',
        class: ['vxe-number-input--plus-btn is--plus', {
          'is--disabled': isDisabledAddNumber
        }],
        type: 'button',
        onClick: numberClickEvent,
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopAll,
        onMouseleave: numberStopAll
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: plusIcon || getIcon().NUMBER_INPUT_PLUS_NUM
      })]);
    };
    const renderSideControl = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'cplr',
        class: 'vxe-number-input--side-control'
      }, [renderPlusBtn(), renderMinusBtn()]);
    };
    const renderVN = () => {
      const {
        className,
        controls,
        type,
        align,
        prefixIcon,
        suffixIcon
      } = props;
      const {
        inputValue,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const controlOpts = computeControlOpts.value;
      const {
        layout,
        showButton
      } = controlOpts;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const numLabel = computeNumLabel.value;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-number-input--readonly', `type--${type}`, className]
        }, numLabel);
      }
      const inputReadonly = computeInputReadonly.value;
      const isClearable = computeIsClearable.value;
      const isControls = isEnableConf(controlOpts) && (controls === false ? controls : showButton);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-number-input', `type--${type}`, `ctl--${layout === 'right' || layout === 'left' ? layout : 'default'}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          'is--controls': isControls && !inputReadonly,
          'is--prefix': !!prefixSlot || prefixIcon,
          'is--suffix': !!suffixSlot || suffixIcon,
          'is--disabled': isDisabled,
          'is--active': isActivated,
          'show--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }],
        spellcheck: false
      }, isControls ? layout === 'right' ? [renderInput(), renderSideControl()] : layout === 'left' ? [renderSideControl(), renderInput()] : [renderMinusBtn(), renderInput(), renderPlusBtn()] : [renderInput()]);
    };
    $xeNumberInput.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      if (!internalData.isUM) {
        updateModel(val);
      }
      internalData.isUM = false;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      // åæ¢ç±»åæ¯éç½®åç½®åé
      Object.assign(reactData, {
        inputValue: props.modelValue
      });
      initValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const targetElem = refInputTarget.value;
      if (targetElem) {
        targetElem.addEventListener('wheel', wheelEvent, {
          passive: false
        });
      }
      globalEvents.on($xeNumberInput, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeNumberInput, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeNumberInput, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      reactData.isFocus = false;
      numberStopAll();
      afterCheckValue();
      const targetElem = refInputTarget.value;
      if (targetElem) {
        targetElem.removeEventListener('wheel', wheelEvent);
      }
      globalEvents.off($xeNumberInput, 'mousedown');
      globalEvents.off($xeNumberInput, 'keydown');
      globalEvents.off($xeNumberInput, 'blur');
    });
    initValue();
    return $xeNumberInput;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/color-picker/src/color-picker.ts










/* harmony default export */ var color_picker = (defineVxeComponent({
  name: 'VxeColorPicker',
  props: {
    modelValue: String,
    placeholder: String,
    clearable: {
      type: Boolean,
      default: () => getConfig().colorPicker.clearable
    },
    type: {
      type: String,
      default: () => getConfig().colorPicker.type
    },
    size: {
      type: String,
      default: () => getConfig().colorPicker.size || getConfig().size
    },
    className: [String, Function],
    popupClassName: [String, Function],
    colors: {
      type: Array,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().colorPicker.colors, true) || []
    },
    showAlpha: {
      type: Boolean,
      default: () => getConfig().colorPicker.showAlpha
    },
    showEyeDropper: {
      type: Boolean,
      default: () => getConfig().colorPicker.showEyeDropper
    },
    showColorExtractor: {
      type: Boolean,
      default: () => getConfig().colorPicker.showColorExtractor
    },
    showQuick: {
      type: Boolean,
      default: () => getConfig().colorPicker.showQuick
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    clickToCopy: {
      type: Boolean,
      default: () => getConfig().colorPicker.clickToCopy
    },
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'change', 'clear', 'click'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const WinEyeDropper = typeof window !== 'undefined' ? window.EyeDropper : null;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHueSliderElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHueSliderBtnElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refAlphaSliderElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refAlphaSliderBtnElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refColorPanelElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refColorActiveElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      selectTyle: 'hex',
      selectColor: `${props.modelValue || ''}`,
      showTypePopup: false,
      panelColor: '',
      hexValue: '',
      rValue: 0,
      gValue: 0,
      bValue: 0,
      aValue: 0,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const typeList = [{
      label: 'HEX',
      value: 'hex'
    }, {
      label: 'RGB',
      value: 'rgb'
    }];
    const internalData = {
      // hpTimeout: undefined
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().colorPicker.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeColorList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        colors
      } = props;
      if (colors) {
        return colors.map(item => {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
            return {
              label: item,
              value: item
            };
          }
          return {
            label: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.label) ? item.value : item.label,
            value: item.value
          };
        });
      }
      return [];
    });
    const computeIsRgb = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectTyle
      } = reactData;
      return selectTyle === 'rgb';
    });
    const computeSelectTypeItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectTyle
      } = reactData;
      return typeList.find(item => item.value === selectTyle);
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeColorPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const updateMode = () => {
      const {
        modelValue
      } = props;
      reactData.selectColor = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue);
      updateModelColor();
    };
    const updateType = () => {
      const {
        type
      } = props;
      let selectTyle = 'hex';
      if (type === 'rgb' || type === 'rgba') {
        selectTyle = 'rgb';
      }
      reactData.selectTyle = selectTyle;
      updateMode();
    };
    const updateModelColor = () => {
      const {
        selectColor,
        isAniVisible
      } = reactData;
      const isRgb = computeIsRgb.value;
      const hueSliderEl = refHueSliderElem.value;
      const alphaSliderEl = refAlphaSliderElem.value;
      const colorRest = parseColor(selectColor);
      reactData.hexValue = colorRest.hex;
      reactData.rValue = colorRest.r;
      reactData.gValue = colorRest.g;
      reactData.bValue = colorRest.b;
      reactData.aValue = colorRest.a;
      if (colorRest.value) {
        if (isRgb) {
          if (colorRest.type === 'hex') {
            const rgbRest = hexToRgb(colorRest.hex);
            if (rgbRest) {
              reactData.rValue = rgbRest.r;
              reactData.gValue = rgbRest.g;
              reactData.bValue = rgbRest.b;
              reactData.aValue = rgbRest.a;
            }
          }
        } else {
          if (colorRest.type !== 'hex') {
            reactData.hexValue = rgbToHex(colorRest);
          }
        }
      }
      if (isAniVisible) {
        const hsvRest = colorRest.type === 'hex' ? hexToHsv(colorRest.hex) : rgbToHsv(colorRest);
        const colorPanelEl = refColorPanelElem.value;
        if (hsvRest) {
          if (colorPanelEl) {
            const offsetTop = colorPanelEl.clientHeight * (1 - hsvRest.v);
            const offsetLeft = colorPanelEl.clientWidth * hsvRest.s;
            handlePanelColor(offsetLeft, offsetTop);
          }
          if (hueSliderEl) {
            handleHueColor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil((1 - hsvRest.h / 360) * hueSliderEl.clientWidth));
          }
        }
        if (alphaSliderEl) {
          handleAlphaColor(alphaSliderEl.clientWidth * colorRest.a);
        }
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refElem.value;
      const panelElem = refOptionPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const showOptionPanel = () => {
      const {
        hpTimeout
      } = internalData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = undefined;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          updateModelColor();
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, value) => {
      reactData.selectColor = value;
      if (value !== props.modelValue) {
        emitModel(value);
        dispatchEvent('change', {
          value
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const focusEvent = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
      }
    };
    const blurEvent = () => {
      reactData.isActivated = false;
    };
    const clearEvent = evnt => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const confirmEvent = evnt => {
      const {
        selectColor
      } = reactData;
      changeEvent(evnt, selectColor);
      hideOptionPanel();
    };
    const togglePanelEvent = evnt => {
      evnt.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const clickEvent = evnt => {
      togglePanelEvent(evnt);
      dispatchEvent('click', {}, evnt);
    };
    const handlePanelClickEvent = () => {
      reactData.showTypePopup = false;
    };
    const toggleTypeVisibleEvent = evnt => {
      evnt.stopPropagation();
      reactData.showTypePopup = !reactData.showTypePopup;
    };
    const handleChangeType = type => {
      const {
        selectTyle
      } = reactData;
      if (type !== selectTyle) {
        reactData.selectTyle = type;
        updateModelColor();
      }
      reactData.showTypePopup = false;
    };
    const handleHueColor = offsetLeft => {
      const hueSliderEl = refHueSliderElem.value;
      const hueSliderBtnEl = refHueSliderBtnElem.value;
      if (hueSliderEl && hueSliderBtnEl) {
        if (offsetLeft < 0) {
          offsetLeft = 0;
        }
        const barWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(hueSliderEl.clientWidth);
        const itemNum = 255;
        const countNum = itemNum * 6;
        const offsetX = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil(countNum / barWidth * offsetLeft);
        const offsetNum = offsetX % itemNum;
        let rNum = 0;
        let gNum = 0;
        let bNum = 0;
        switch (Math.ceil(offsetX / itemNum)) {
          case 1:
            rNum = itemNum;
            bNum = offsetNum;
            break;
          case 2:
            rNum = itemNum - offsetNum;
            bNum = itemNum;
            break;
          case 3:
            gNum = offsetNum;
            bNum = itemNum;
            break;
          case 4:
            gNum = itemNum;
            bNum = itemNum - offsetNum;
            break;
          case 5:
            rNum = offsetNum;
            gNum = itemNum;
            break;
          case 6:
            rNum = itemNum;
            gNum = itemNum - offsetNum;
            break;
        }
        reactData.panelColor = toRgb(rNum, gNum, bNum);
        hueSliderBtnEl.style.left = toCssUnit(offsetLeft);
      }
    };
    const handleHueBarEvent = evnt => {
      const hueSliderEl = refHueSliderElem.value;
      const hueSliderBtnEl = refHueSliderBtnElem.value;
      if (hueSliderEl && hueSliderBtnEl) {
        const hueSliderRect = hueSliderEl.getBoundingClientRect();
        const barWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(hueSliderEl.clientWidth);
        const offsetLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil(Math.min(barWidth - 1, Math.max(1, evnt.clientX - hueSliderRect.x)));
        handleHueColor(offsetLeft);
      }
    };
    const handleHueSliderMousedownEvent = evnt => {
      evnt.preventDefault();
      document.onmousemove = evnt => {
        evnt.preventDefault();
        handleHueBarEvent(evnt);
      };
      document.onmouseup = evnt => {
        document.onmousemove = null;
        document.onmouseup = null;
        handleHueBarEvent(evnt);
      };
    };
    const handleAlphaColor = offsetLeft => {
      const {
        selectColor
      } = reactData;
      const alphaSliderEl = refAlphaSliderElem.value;
      const alphaSliderBtnEl = refAlphaSliderBtnElem.value;
      if (alphaSliderEl && alphaSliderBtnEl) {
        const alphaSliderRect = alphaSliderEl.getBoundingClientRect();
        const barWidth = alphaSliderRect.width;
        if (offsetLeft < 0) {
          offsetLeft = 0;
        }
        if (offsetLeft > barWidth) {
          offsetLeft = barWidth;
        }
        const alpha = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil(100 / barWidth * offsetLeft / 100, 2);
        reactData.aValue = alpha;
        alphaSliderBtnEl.style.left = toCssUnit(offsetLeft);
        reactData.selectColor = updateColorAlpha(selectColor, alpha);
      }
    };
    const handleAlphaBarEvent = evnt => {
      const alphaSliderEl = refAlphaSliderElem.value;
      const alphaSliderBtnEl = refAlphaSliderBtnElem.value;
      if (alphaSliderEl && alphaSliderBtnEl) {
        const alphaSliderRect = alphaSliderEl.getBoundingClientRect();
        const barWidth = alphaSliderRect.width;
        const offsetLeft = Math.min(barWidth, Math.max(0, evnt.clientX - alphaSliderRect.x));
        handleAlphaColor(offsetLeft);
        updateModelColor();
      }
    };
    const handleAlphaSliderMousedownEvent = evnt => {
      evnt.preventDefault();
      document.onmousemove = evnt => {
        evnt.preventDefault();
        handleAlphaBarEvent(evnt);
      };
      document.onmouseup = evnt => {
        document.onmousemove = null;
        document.onmouseup = null;
        handleAlphaBarEvent(evnt);
      };
    };
    const handleInputRgbEvent = () => {
      const {
        rValue,
        gValue,
        bValue,
        aValue
      } = reactData;
      reactData.selectColor = toRgb(rValue, gValue, bValue, aValue);
      updateModelColor();
    };
    const handleInputAlphaEvent = () => {
      const {
        aValue
      } = reactData;
      const alphaSliderEl = refAlphaSliderElem.value;
      const alphaSliderBtnEl = refAlphaSliderBtnElem.value;
      if (alphaSliderEl && alphaSliderBtnEl) {
        const alphaSliderRect = alphaSliderEl.getBoundingClientRect();
        const barWidth = alphaSliderRect.width;
        const offsetLeft = barWidth * aValue;
        handleAlphaColor(offsetLeft);
      }
    };
    const handleQuickEvent = (evnt, item) => {
      const value = item.value;
      reactData.selectColor = value;
      updateModelColor();
    };
    const handlePanelColor = (offsetLeft, offsetTop) => {
      const colorActiveEl = refColorActiveElem.value;
      if (colorActiveEl) {
        colorActiveEl.style.top = toCssUnit(offsetTop);
        colorActiveEl.style.left = toCssUnit(offsetLeft);
      }
    };
    const handleEyeDropperEvent = () => {
      if (WinEyeDropper) {
        try {
          const eyeDropper = new WinEyeDropper();
          eyeDropper.open().then(rest => {
            if (rest && rest.sRGBHex) {
              reactData.selectColor = rest.sRGBHex;
              updateModelColor();
            }
          }).catch(() => {});
        } catch (e) {}
      }
    };
    const handleSelectColorByXY = (clientX, clientY) => {
      const {
        showAlpha
      } = props;
      const {
        panelColor,
        aValue
      } = reactData;
      const colorPanelEl = refColorPanelElem.value;
      const colorActiveEl = refColorActiveElem.value;
      if (colorPanelEl && colorActiveEl) {
        const {
          clientWidth,
          clientHeight
        } = colorPanelEl;
        const colorPanelRect = colorPanelEl.getBoundingClientRect();
        const offsetTop = Math.min(clientHeight, Math.max(0, clientY - colorPanelRect.y));
        const offsetLeft = Math.min(clientWidth, Math.max(0, clientX - colorPanelRect.x));
        const colorRest = parseColor(panelColor);
        if (colorRest) {
          const hsvRest = colorRest.type === 'hex' ? hexToHsv(colorRest.hex) : rgbToHsv(colorRest);
          if (hsvRest) {
            const ragRest = hsvToRgb(hsvRest.h, offsetLeft / clientWidth, 1 - offsetTop / clientHeight);
            reactData.selectColor = toRgb(ragRest.r, ragRest.g, ragRest.b, showAlpha ? aValue : null);
            updateModelColor();
          }
        }
        handlePanelColor(offsetLeft, offsetTop);
      }
    };
    const handleSelectColorMousedownEvent = evnt => {
      evnt.stopPropagation();
      evnt.preventDefault();
      handleSelectColorByXY(evnt.clientX, evnt.clientY);
      document.onmousemove = evnt => {
        handleSelectColorByXY(evnt.clientX, evnt.clientY);
      };
      document.onmouseup = () => {
        document.onmousemove = null;
        document.onmouseup = null;
      };
    };
    const handleCopyColorEvent = () => {
      const {
        selectColor
      } = reactData;
      if (selectColor) {
        if (index_esm_VxeUI.clipboard.copy(selectColor)) {
          if (index_esm_VxeUI.modal) {
            index_esm_VxeUI.modal.message({
              content: getI18n('vxe.colorPicker.copySuccess', [selectColor]),
              status: 'success'
            });
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const targetElem = refInputTarget.value;
        if (targetElem) {
          targetElem.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $colorPicker: $xeColorPicker
      }, params));
    };
    const colorPickerMethods = {
      dispatchEvent
    };
    const colorPickerPrivateMethods = {};
    Object.assign($xeColorPicker, colorPickerMethods, colorPickerPrivateMethods);
    const renderColorWrapper = () => {
      const {
        showColorExtractor
      } = props;
      const {
        panelColor
      } = reactData;
      if (showColorExtractor) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refColorPanelElem,
          class: 'vxe-color-picker--color-wrapper',
          onMousedown: handleSelectColorMousedownEvent
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-color-picker--color-bg',
          style: {
            backgroundColor: panelColor
          }
        }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-color-picker--white-bg'
        }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-color-picker--black-bg'
        }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refColorActiveElem,
          class: 'vxe-color-picker--color-active'
        })]);
      }
      return renderEmptyElement($xeColorPicker);
    };
    const renderColorBar = () => {
      const {
        showAlpha,
        clickToCopy,
        showEyeDropper
      } = props;
      const {
        selectTyle,
        showTypePopup,
        hexValue,
        rValue,
        gValue,
        bValue,
        aValue,
        selectColor,
        panelColor
      } = reactData;
      const isRgb = computeIsRgb.value;
      const selectTypeItem = computeSelectTypeItem.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--bar-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--slider-wrapper'
      }, [showEyeDropper && WinEyeDropper ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--color-dropper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-color-picker--color-dropper-btn',
        onClick: handleEyeDropperEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().COLOR_PICKER_EYE_DROPPER
      })])]) : renderEmptyElement($xeColorPicker), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--slider-preview'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--preview-btn'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--preview-color',
        style: {
          backgroundColor: selectColor
        }
      }, clickToCopy ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-color-picker--preview-copy-btn',
        onClick: handleCopyColorEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().COLOR_PICKER_COLOR_COPY
      })])] : [])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--slider-handle'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHueSliderElem,
        class: 'vxe-color-picker--bar-hue-slider',
        onClick: handleHueBarEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHueSliderBtnElem,
        class: 'vxe-color-picker--bar-hue-btn',
        onMousedown: handleHueSliderMousedownEvent
      })]), showAlpha ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refAlphaSliderElem,
        class: 'vxe-color-picker--bar-alpha-slider',
        onClick: handleAlphaBarEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--bar-alpha-bg',
        style: {
          background: `linear-gradient(to right, rgba(0, 0, 0, 0), ${panelColor})`
        }
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refAlphaSliderBtnElem,
        class: 'vxe-color-picker--bar-alpha-btn',
        onMousedown: handleAlphaSliderMousedownEvent
      })]) : renderEmptyElement($xeColorPicker)])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--custom-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--type-switch'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--type-label',
        onClick: toggleTypeVisibleEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${selectTypeItem ? selectTypeItem.label : selectTyle}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-color-picker--type-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: showTypePopup ? getIcon().COLOR_PICKER_TPTY_OPEN : getIcon().COLOR_PICKER_TPTY_CLOSE
      })])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-color-picker--type-popup', {
          'is--visible': showTypePopup
        }]
      }, typeList.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-color-picker--type-item',
          onClick(evnt) {
            evnt.stopPropagation();
            handleChangeType(item.value);
          }
        }, item.label);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: `vxe-color-picker--${selectTyle}-wrapper`
      }, isRgb ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--input-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(number_input, {
        type: 'integer',
        size: 'mini',
        align: 'center',
        min: 0,
        max: 255,
        maxLength: 3,
        placeholder: '',
        modelValue: rValue,
        controlConfig: {
          showButton: false
        },
        'onUpdate:modelValue'(val) {
          reactData.rValue = val;
        },
        onChange: handleInputRgbEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(number_input, {
        type: 'integer',
        size: 'mini',
        align: 'center',
        min: 0,
        max: 255,
        maxLength: 3,
        placeholder: '',
        modelValue: gValue,
        controlConfig: {
          showButton: false
        },
        'onUpdate:modelValue'(val) {
          reactData.gValue = val;
        },
        onChange: handleInputRgbEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(number_input, {
        type: 'integer',
        size: 'mini',
        align: 'center',
        min: 0,
        max: 255,
        maxLength: 3,
        placeholder: '',
        modelValue: bValue,
        controlConfig: {
          showButton: false
        },
        'onUpdate:modelValue'(val) {
          reactData.bValue = val;
        },
        onChange: handleInputRgbEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(number_input, {
        type: 'number',
        size: 'mini',
        align: 'center',
        min: 0,
        max: 1,
        step: 0.01,
        maxLength: 4,
        placeholder: '',
        modelValue: aValue,
        controlConfig: {
          showButton: false
        },
        'onUpdate:modelValue'(val) {
          reactData.aValue = val;
        },
        onChange: handleInputAlphaEvent
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--input-title'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', 'R'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', 'G'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', 'B'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', 'A')])] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--input-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        type: 'text',
        size: 'mini',
        align: 'center',
        maxLength: 9,
        placeholder: '',
        modelValue: hexValue,
        'onUpdate:modelValue'(val) {
          reactData.hexValue = val;
        },
        onChange() {
          const colorRest = parseColor(reactData.hexValue);
          if (colorRest) {
            if (colorRest.value) {
              reactData.selectColor = colorRest.value;
              updateModelColor();
            }
          }
        }
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--input-title'
      }, getI18n('vxe.colorPicker.hex'))])])]);
    };
    const renderQuickWrapper = () => {
      const {
        showQuick
      } = props;
      const colorList = computeColorList.value;
      if (showQuick && colorList.length) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-color-picker--quick-wrapper'
        }, colorList.map((item, i) => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: i,
            class: 'vxe-color-picker--quick-item',
            title: item.label || '',
            style: {
              backgroundColor: item.value
            },
            onClick(evnt) {
              handleQuickEvent(evnt, item);
            }
          });
        }));
      }
      return renderEmptyElement($xeColorPicker);
    };
    const renderVN = () => {
      const {
        className,
        popupClassName,
        clearable,
        modelValue
      } = props;
      const {
        initialized,
        isActivated,
        isAniVisible,
        visiblePanel
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-color-picker--readonly', className]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-color-picker--readonly-color',
          style: {
            backgroundColor: modelValue
          }
        })]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-color-picker', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $colorPicker: $xeColorPicker
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--selected': !!modelValue,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-color-picker--input',
        onFocus: focusEvent,
        onBlur: blurEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--inner',
        onClick: clickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--inner-color',
        style: {
          backgroundColor: modelValue
        }
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-color-picker--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $colorPicker: $xeColorPicker
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': isAniVisible,
          'ani--enter': visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, [initialized && (visiblePanel || isAniVisible) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--panel-wrapper',
        onClick: handlePanelClickEvent
      }, [renderColorWrapper(), renderColorBar(), renderQuickWrapper(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--footer-wrapper'
      }, [clearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.colorPicker.clear'),
        size: 'mini',
        onClick: clearEvent
      }) : renderEmptyElement($xeColorPicker), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.colorPicker.confirm'),
        size: 'mini',
        status: 'primary',
        onClick: confirmEvent
      })])]) : renderEmptyElement($xeColorPicker)])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      updateMode();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      updateType();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeColorPicker, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeColorPicker, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeColorPicker, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xeColorPicker, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeColorPicker, 'mousewheel');
      globalEvents.off($xeColorPicker, 'mousedown');
      globalEvents.off($xeColorPicker, 'blur');
      globalEvents.off($xeColorPicker, 'resize');
    });
    updateType();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeColorPicker', $xeColorPicker);
    $xeColorPicker.renderVN = renderVN;
    return $xeColorPicker;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/color-picker/index.ts



const VxeColorPicker = Object.assign({}, color_picker, {
  install(app) {
    app.component(color_picker.name, color_picker);
  }
});
dynamicApp.use(VxeColorPicker);
index_esm_VxeUI.component(color_picker);
const ColorPicker = VxeColorPicker;
/* harmony default export */ var packages_color_picker = (VxeColorPicker);
;// CONCATENATED MODULE: ./packages/text/src/text.ts





/* harmony default export */ var src_text = (defineVxeComponent({
  name: 'VxeText',
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    prefixIcon: String,
    suffixIcon: String,
    loading: Boolean,
    content: [String, Number],
    clickToCopy: {
      type: Boolean,
      default: () => getConfig().text.clickToCopy
    },
    copyConfig: Object,
    size: {
      type: String,
      default: () => getConfig().text.size || getConfig().size
    }
  },
  emits: ['click', 'dblclick', 'prefix-click', 'suffix-click', 'copy-success', 'copy-error'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refContentElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const computeCopyOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().text.copyConfig, props.copyConfig);
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const handleCopy = evnt => {
      const {
        content
      } = props;
      const copyOpts = computeCopyOpts.value;
      const {
        showMessage
      } = copyOpts;
      const contentEl = refContentElem.value;
      const copyVal = (contentEl ? contentEl.textContent : '') || content;
      if (copyVal) {
        if (index_esm_VxeUI.clipboard.copy(copyVal)) {
          if (showMessage && index_esm_VxeUI.modal) {
            index_esm_VxeUI.modal.message({
              content: getI18n('vxe.text.copySuccess'),
              status: 'success'
            });
          }
          dispatchEvent('copy-success', {}, evnt);
        } else {
          if (showMessage && index_esm_VxeUI.modal) {
            index_esm_VxeUI.modal.message({
              content: getI18n('vxe.text.copyError'),
              status: 'error'
            });
          }
          dispatchEvent('copy-error', {}, evnt);
        }
      }
    };
    const clickIconEvent = evnt => {
      const {
        clickToCopy
      } = props;
      const copyOpts = computeCopyOpts.value;
      if (clickToCopy && copyOpts.trigger !== 'dblclick') {
        handleCopy(evnt);
      }
    };
    const dblclickIconEvent = evnt => {
      const {
        clickToCopy
      } = props;
      const copyOpts = computeCopyOpts.value;
      if (clickToCopy && copyOpts.trigger === 'dblclick') {
        handleCopy(evnt);
      }
    };
    const $xeText = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $text: $xeText
      }, params));
    };
    const textMethods = {
      dispatchEvent
    };
    const clickEvent = evnt => {
      const {
        loading
      } = props;
      if (!loading) {
        dispatchEvent('click', {}, evnt);
      }
    };
    const dblclickEvent = evnt => {
      const {
        loading
      } = props;
      if (!loading) {
        dispatchEvent('dblclick', {}, evnt);
      }
    };
    const prefixEvent = evnt => {
      const {
        loading
      } = props;
      if (!loading) {
        dispatchEvent('prefix-click', {}, evnt);
      }
    };
    const suffixEvent = evnt => {
      const {
        loading
      } = props;
      if (!loading) {
        dispatchEvent('suffix-click', {}, evnt);
      }
    };
    const textPrivateMethods = {};
    Object.assign($xeText, textMethods, textPrivateMethods);
    const renderCopyIcon = () => {
      const copyOpts = computeCopyOpts.value;
      const {
        icon,
        status
      } = copyOpts;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        key: 'ci',
        class: ['vxe-text--copy-icon', {
          [`theme--${status}`]: status
        }],
        onClick: clickIconEvent,
        onDblclick: dblclickIconEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon || getIcon().TEXT_COPY
      })]);
    };
    const renderContent = () => {
      const {
        loading,
        icon,
        prefixIcon,
        suffixIcon,
        clickToCopy,
        content
      } = props;
      const copyOpts = computeCopyOpts.value;
      const defaultSlot = slots.default;
      const prefixIconSlot = slots.prefixIcon || slots['prefix-icon'] || slots.icon;
      const suffixIconSlot = slots.suffixIcon || slots['suffix-icon'];
      const copyToRight = copyOpts.layout === 'right';
      const contVNs = [];
      if (loading) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          key: 'lg',
          class: 'vxe-text--loading'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().TEXT_LOADING
        })]));
      } else if (clickToCopy && !copyToRight) {
        contVNs.push(renderCopyIcon());
      }
      if (prefixIcon || icon) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          key: 'si',
          class: 'vxe-text--prefix-icon',
          onClick: prefixEvent
        }, prefixIconSlot ? prefixIconSlot({}) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: prefixIcon || icon
        })]));
      }
      contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        key: 'ct',
        ref: refContentElem,
        class: 'vxe-text--content',
        onClick: clickEvent,
        onDblclick: dblclickEvent
      }, defaultSlot ? defaultSlot({}) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content)));
      if (suffixIcon) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          key: 'si',
          class: 'vxe-text--suffix-icon',
          onClick: suffixEvent
        }, suffixIconSlot ? suffixIconSlot({}) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: suffixIcon
        })]));
      }
      if (clickToCopy && copyToRight && !loading) {
        contVNs.push(renderCopyIcon());
      }
      return contVNs;
    };
    const renderVN = () => {
      const {
        loading,
        status,
        title,
        clickToCopy
      } = props;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        ref: refElem,
        title,
        class: ['vxe-text', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--copy': clickToCopy,
          'is--loading': loading
        }]
      }, renderContent());
    };
    $xeText.renderVN = renderVN;
    return $xeText;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/countdown/src/countdown.ts






/* harmony default export */ var countdown = (defineVxeComponent({
  name: 'VxeCountdown',
  props: {
    modelValue: [Number, String],
    format: String,
    prefixConfig: Object,
    suffixConfig: Object,
    size: {
      type: String,
      default: () => getConfig().countdown.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'start', 'end'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      currNum: 0,
      secondNum: 0
    });
    const internalData = {
      dnTimeout: undefined
    };
    const refMaps = {
      refElem
    };
    const computeTimeFormats = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        secondNum
      } = reactData;
      if (secondNum >= 31622400000) {
        return ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss'];
      }
      if (secondNum >= 2678400000) {
        return ['MM', 'dd', 'HH', 'mm', 'ss'];
      }
      if (secondNum >= 86400000) {
        return ['dd', 'HH', 'mm', 'ss'];
      }
      if (secondNum >= 3600000) {
        return ['HH', 'mm', 'ss'];
      }
      if (secondNum >= 60000) {
        return ['mm', 'ss'];
      }
      return ['ss'];
    });
    const computeDiffConf = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        currNum
      } = reactData;
      const diffRest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getDateDiff(Date.now(), Date.now() + currNum);
      return Object.assign(diffRest, {
        done: !(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(diffRest.status) ? diffRest.status : diffRest.done)
      });
    });
    const computeFormatLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        format
      } = props;
      const diffConf = computeDiffConf.value;
      let rest = '';
      if (format) {
        rest = `${format}`;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(diffConf, (val, key) => {
          rest = rest.replace(new RegExp(key, 'g'), external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().padStart(val, key.length, '0'));
        });
        return rest;
      }
      return rest;
    });
    const computePrefixOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.prefixConfig, getConfig().countdown.prefixConfig);
    });
    const computeSuffixOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.suffixConfig, getConfig().countdown.suffixConfig);
    });
    const computeMaps = {
      computeSize
    };
    const $xeCountdown = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $carousel: $xeCountdown
      }, params));
    };
    const updateCount = () => {
      const secondNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.modelValue || 0);
      reactData.secondNum = secondNum;
      reactData.currNum = secondNum;
    };
    const handleTime = () => {
      const {
        currNum
      } = reactData;
      if (currNum > 1000) {
        reactData.currNum -= 1000;
        internalData.dnTimeout = setTimeout(() => {
          handleTime();
        }, 1000);
      } else {
        reactData.currNum = 0;
        handleStop();
      }
    };
    const countdownMethods = {
      dispatchEvent
    };
    const handleStart = () => {
      dispatchEvent('start', {}, null);
      handleTime();
    };
    const handleStop = () => {
      const {
        dnTimeout
      } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = undefined;
        dispatchEvent('end', {}, null);
      }
    };
    const countdownPrivateMethods = {};
    Object.assign($xeCountdown, countdownMethods, countdownPrivateMethods);
    const renderDefaultContentVNs = () => {
      const {
        format
      } = props;
      const timeFormats = computeTimeFormats.value;
      const diffConf = computeDiffConf.value;
      const formatLabel = computeFormatLabel.value;
      if (format) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'format',
          class: 'vxe-countdown--content-format'
        }, formatLabel)];
      }
      return timeFormats.map((key, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: index,
          class: 'vxe-countdown--content-item'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-countdown--content-num'
        }, `${diffConf[key] || 0}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-countdown--content-unit'
        }, getI18n(`vxe.countdown.formats.${key}`))]);
      });
    };
    const renderVN = () => {
      const {
        prefixConfig,
        suffixConfig
      } = props;
      const {
        currNum
      } = reactData;
      const vSize = computeSize.value;
      const diffConf = computeDiffConf.value;
      const prefixOpts = computePrefixOpts.value;
      const suffixOpts = computeSuffixOpts.value;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-countdown', diffConf.done ? 'is--progress' : 'is-end', {
          [`size--${vSize}`]: vSize
        }]
      }, [prefixSlot || prefixConfig ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-countdown--prefix'
      }, prefixSlot ? vn_getSlotVNs(prefixSlot({
        currentValue: currNum,
        diffConf
      })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_text, {
        content: prefixOpts.content,
        icon: prefixOpts.icon,
        status: prefixOpts.status
      })]) : renderEmptyElement($xeCountdown), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-countdown--content'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({
        currentValue: currNum,
        diffConf
      })) : renderDefaultContentVNs()), suffixSlot || suffixConfig ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-countdown--suffix'
      }, suffixSlot ? vn_getSlotVNs(suffixSlot({
        currentValue: currNum,
        diffConf
      })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_text, {
        content: suffixOpts.content,
        icon: suffixOpts.icon,
        status: suffixOpts.status
      })]) : renderEmptyElement($xeCountdown)]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      updateCount();
      handleStop();
      handleStart();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      handleStop();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      handleStart();
    });
    updateCount();
    $xeCountdown.renderVN = renderVN;
    return $xeCountdown;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/countdown/index.ts



const VxeCountdown = Object.assign({}, countdown, {
  install(app) {
    app.component(countdown.name, countdown);
  }
});
dynamicApp.use(VxeCountdown);
index_esm_VxeUI.component(countdown);
const Countdown = VxeCountdown;
/* harmony default export */ var packages_countdown = (VxeCountdown);
;// CONCATENATED MODULE: ./packages/date-panel/src/date-panel.ts






/* harmony default export */ var date_panel = (defineVxeComponent({
  name: 'VxeDatePanel',
  props: {
    modelValue: [String, Number, Date],
    type: {
      type: String,
      default: 'date'
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().datePanel.size || getConfig().size
    },
    multiple: Boolean,
    limitCount: {
      type: [String, Number],
      default: () => getConfig().datePanel.limitCount
    },
    // dateãweekãmonthãquarterãyear
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePanel.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePanel.endDate
    },
    defaultDate: [String, Number, Date],
    defaultTime: [String, Number, Date],
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    startDay: {
      type: [String, Number],
      default: () => getConfig().datePanel.startDay
    },
    labelFormat: String,
    valueFormat: String,
    timeFormat: String,
    festivalMethod: {
      type: Function,
      default: () => getConfig().datePanel.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().datePanel.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().datePanel.selectDay
    }
  },
  emits: ['update:modelValue', 'change', 'click', 'clear', 'date-prev', 'date-today', 'date-next', 'confirm'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false,
      inputValue: '',
      inputLabel: '',
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: '',
      datePanelType: 'day',
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8,
      hpTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPanelWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTimeBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeDatePanel = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeIsDateTimeType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'time' || type === 'datetime';
    });
    const computeIsDatePanelType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeDateStartTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.startDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.endDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.endDate) : null;
    });
    const computeDateListValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        multiple
      } = props;
      const isDatePanelType = computeIsDatePanelType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePanelType) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue).split(',').map(item => {
          const date = parseDate(item, dateValueFormat);
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
            return date;
          }
          return date;
        });
      }
      return [];
    });
    const computeDateMultipleValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateLabelFormat)).join(', ');
    });
    const computeLimitMaxCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.multiple ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.limitCount) : 0;
    });
    const computeOverCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        multiple
      } = props;
      const limitMaxCount = computeLimitMaxCount.value;
      const dateMultipleValue = computeDateMultipleValue.value;
      if (multiple && limitMaxCount) {
        return dateMultipleValue.length >= limitMaxCount;
      }
      return false;
    });
    const computeDateValueFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        valueFormat
      } = props;
      return handleValueFormat(type, valueFormat);
    });
    const computeDateValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue
      } = props;
      const isDatePanelType = computeIsDatePanelType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePanelType) {
        const date = parseDate(modelValue, dateValueFormat);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateStartTime = computeDateStartTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateEndTime = computeDateEndTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateEndTime) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, 0, 'last') >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        datetimePanelValue
      } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      if (datetimePanelValue) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(datetimePanelValue, hasTimeMinute && hasTimeSecond ? 'HH:mm:ss' : hasTimeMinute ? 'HH:mm' : 'HH');
      }
      return '';
    });
    const computeDateHMSTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1000 : 0;
    });
    const computeDateLabelFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        labelFormat
      } = props;
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return '';
    });
    const computeYearList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        yearSize
      } = internalData;
      const {
        selectMonth,
        currentDate
      } = reactData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(startYearDate, index, 'first');
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelObj = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePanelType = computeIsDatePanelType.value;
      let y = '';
      let m = '';
      if (isDatePanelType) {
        const {
          datePanelType,
          selectMonth
        } = reactData;
        const yearList = computeYearList.value;
        let year = '';
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === 'quarter' || datePanelType === 'month') {
          y = getI18n('vxe.datePicker.yearTitle', [year]);
        } else if (datePanelType === 'year') {
          y = yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : '';
        } else {
          y = getI18n('vxe.datePicker.yearTitle', [year]);
          m = month ? getI18n(`vxe.input.date.m${month}`) : '-';
        }
      }
      return {
        y,
        m
      };
    });
    const computeFirstDayOfWeek = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startDay
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(startDay);
    });
    const computeWeekDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const weeks = [];
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map(day => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        const dateHeaders = computeDateHeaders.value;
        return [{
          label: getI18n('vxe.input.date.weeks.w')
        }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const yearList = computeYearList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(yearList, 4);
    });
    const computeQuarterList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        quarterSize
      } = internalData;
      const {
        selectMonth,
        currentDate
      } = reactData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first');
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const quarterList = computeQuarterList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(quarterList, 2);
    });
    const computeMonthList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        monthSize
      } = internalData;
      const {
        selectMonth,
        currentDate
      } = reactData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first').getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const monthList = computeMonthList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(monthList, 4);
    });
    const computeDayList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayList = computeDayList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(dayList, 7);
    });
    const computeWeekDates = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map(list => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeMinuteList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        timeFormat
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(timeFormat || dateValueFormat) || /mm/.test(timeFormat || dateValueFormat);
    });
    const computeHasTimeSecond = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        timeFormat
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(timeFormat || dateValueFormat) || /ss/.test(timeFormat || dateValueFormat);
    });
    const computeSecondList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const updateModelValue = modelValue => {
      const {
        type
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      const inpDate = parseDateValue(modelValue, type, {
        valueFormat: dateValueFormat
      });
      reactData.inputValue = inpDate;
      reactData.inputLabel = inpDate;
      dateOpenPanel();
    };
    const parseDate = (value, format) => {
      const {
        type,
        multiple
      } = props;
      if (type === 'time') {
        return toStringTimeDate(value);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(value)) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value[0], format);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(value)) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(multiple ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().last(value.split(',')) : value, format);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value, format);
    };
    const dateRevert = () => {
      reactData.inputLabel = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const afterCheckValue = inpVal => {
      const {
        type
      } = props;
      const {
        inputLabel,
        datetimePanelValue
      } = reactData;
      const dateLabelFormat = computeDateLabelFormat.value;
      if (inpVal) {
        let inpDateVal = parseDate(inpVal, dateLabelFormat);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(inpDateVal)) {
          if (type === 'time') {
            inpDateVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat);
            if (inputLabel !== inpDateVal) {
              handleChange(inpDateVal, {
                type: 'check'
              });
            }
            reactData.inputLabel = inpDateVal;
          } else {
            let isChange = false;
            const firstDayOfWeek = computeFirstDayOfWeek.value;
            if (type === 'datetime') {
              const dateValue = computeDateValue.value;
              if (inpVal !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dateValue, dateLabelFormat) || inpVal !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat)) {
                isChange = true;
                if (datetimePanelValue) {
                  datetimePanelValue.setHours(inpDateVal.getHours());
                  datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                  datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                }
              }
            } else {
              isChange = true;
            }
            reactData.inputLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat, {
              firstDay: firstDayOfWeek
            });
            if (isChange) {
              dateChange(inpDateVal);
            }
          }
        } else {
          dateRevert();
        }
      } else {
        handleChange('', {
          type: 'check'
        });
      }
    };
    const emitModel = value => {
      reactData.inputValue = value;
      emit('update:modelValue', value);
    };
    const handleChange = (value, evnt) => {
      const {
        type,
        modelValue,
        valueFormat
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      reactData.inputLabel = value;
      if (hasTimestampValueType(valueFormat)) {
        const dateVal = parseDateValue(value, type, {
          valueFormat: dateValueFormat
        });
        const timeNum = dateVal ? dateVal.getTime() : null;
        emitModel(timeNum);
        if (modelValue !== timeNum) {
          dispatchEvent('change', {
            value: timeNum
          }, evnt);
        }
      } else if (hasDateValueType(valueFormat)) {
        const dateVal = parseDateValue(value, type, {
          valueFormat: dateValueFormat
        });
        emitModel(dateVal);
        if (modelValue && dateVal ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(modelValue).getTime() !== dateVal.getTime() : modelValue !== dateVal) {
          dispatchEvent('change', {
            value: dateVal
          }, evnt);
        }
      } else {
        emitModel(value);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue) !== value) {
          dispatchEvent('change', {
            value
          }, evnt);
        }
      }
    };
    const hidePanel = () => {
      return new Promise(resolve => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const dateParseValue = val => {
      const {
        type
      } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const dateObj = parseDateObj(val, type, {
        valueFormat: dateValueFormat,
        labelFormat: dateLabelFormat,
        firstDay: firstDayOfWeek
      });
      reactData.datePanelValue = dateObj.value;
      reactData.datePanelLabel = dateObj.label;
    };
    /**
     * å¼ååæ¶å¤ç
     */
    const changeValue = () => {
      const isDatePanelType = computeIsDatePanelType.value;
      const {
        inputLabel
      } = reactData;
      if (isDatePanelType) {
        dateParseValue(inputLabel);
        reactData.inputLabel = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    /**
     * æ£æ¥åå§å¼
     */
    const initValue = () => {
      const {
        modelValue
      } = props;
      const isDatePanelType = computeIsDatePanelType.value;
      updateModelValue(modelValue);
      if (isDatePanelType) {
        changeValue();
      }
    };
    const dateCheckMonth = date => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(date, firstDayOfWeek);
      const weekStartDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(weekNum === 1 ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(weekStartDate, 6) : date, 0, 'first');
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date, isReload) => {
      const {
        modelValue,
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === 'week') {
        const sWeek = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.selectDay);
        date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        if (datetimePanelValue) {
          date.setHours(datetimePanelValue.getHours());
          date.setMinutes(datetimePanelValue.getMinutes());
          date.setSeconds(datetimePanelValue.getSeconds());
        }
      }
      const inpVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat, {
        firstDay: firstDayOfWeek
      });
      dateCheckMonth(date);
      if (multiple) {
        const overCount = computeOverCount.value;
        // å¦æä¸ºå¤é
        if (isDateTimeType) {
          // å¦ææ¯datetimeç¹æ®ç±»å
          const dateListValue = isReload ? [] : [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(dateListValue, val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(date, val, 'yyyyMMdd'));
          if (eqIndex === -1) {
            if (overCount) {
              // å¦æè¶åºæå¤§å¤éæ°é
              return;
            }
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach(item => {
            if (item) {
              if (datetimePanelValue) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
              }
              datetimeRest.push(item);
            }
          });
          handleChange(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
            type: 'update'
          });
        } else {
          const dateMultipleValue = isReload ? [] : computeDateMultipleValue.value;
          // å¦ææ¯æ¥æç±»å
          if (dateMultipleValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal))) {
            handleChange(dateMultipleValue.filter(val => !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal)).join(','), {
              type: 'update'
            });
          } else {
            if (overCount) {
              // å¦æè¶åºæå¤§å¤éæ°é
              return;
            }
            handleChange(dateMultipleValue.concat([inpVal]).join(','), {
              type: 'update'
            });
          }
        }
      } else {
        // å¦æä¸ºåé
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(modelValue, inpVal)) {
          handleChange(inpVal, {
            type: 'update'
          });
        }
      }
    };
    // æ¥æ
    const dateMonthHandle = (date, offsetMonth) => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(date, firstDayOfWeek);
      const weekStartDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(weekNum === 1 ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(weekStartDate, 6) : date, offsetMonth, 'first');
      reactData.selectMonth = month;
    };
    const dateNowHandle = () => {
      const {
        type
      } = props;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let currentDate = new Date();
      switch (type) {
        case 'week':
          currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(currentDate, 0, firstDayOfWeek);
          break;
        case 'datetime':
          currentDate = new Date();
          reactData.datetimePanelValue = new Date();
          break;
        default:
          currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
          break;
      }
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleYearTypeEvent = () => {
      reactData.datePanelType = 'year';
    };
    const dateToggleMonthTypeEvent = () => {
      let {
        datePanelType
      } = reactData;
      if (datePanelType === 'month' || datePanelType === 'quarter') {
        datePanelType = 'year';
      } else {
        datePanelType = 'month';
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth,
        inputLabel
      } = reactData;
      const {
        yearSize
      } = internalData;
      const value = inputLabel;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        let viewDate;
        if (type === 'year') {
          viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else if (datePanelType === 'month') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, -1, 'first');
          }
        }
        reactData.selectMonth = viewDate;
        dispatchEvent('date-prev', {
          viewType: datePanelType,
          viewDate,
          value,
          type
        }, evnt);
      }
    };
    const dateTodayMonthEvent = evnt => {
      dateNowHandle();
      dateChange(reactData.currentDate, true);
      if (!props.multiple) {
        hidePanel();
      }
      dispatchEvent('date-today', {
        type: props.type
      }, evnt);
    };
    const dateNextEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth,
        inputLabel
      } = reactData;
      const {
        yearSize
      } = internalData;
      const value = inputLabel;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        let viewDate;
        if (type === 'year') {
          viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else if (datePanelType === 'month') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, 1, 'first');
          }
        }
        reactData.selectMonth = viewDate;
        dispatchEvent('date-next', {
          viewType: datePanelType,
          value,
          type
        }, evnt);
      }
    };
    const isRangeDisabled = item => {
      const dateStartTime = computeDateStartTime.value;
      const dateEndTime = computeDateEndTime.value;
      const {
        date
      } = item;
      if (dateStartTime && dateStartTime.getTime() > date.getTime()) {
        return true;
      }
      if (dateEndTime && dateEndTime.getTime() < date.getTime()) {
        return true;
      }
      return false;
    };
    const isDateDisabled = item => {
      const {
        disabledMethod
      } = props;
      const {
        datePanelType
      } = reactData;
      const {
        date
      } = item;
      if (disabledMethod) {
        return disabledMethod({
          type: datePanelType,
          viewType: datePanelType,
          date,
          $datePanel: $xeDatePanel
        });
      }
      return false;
    };
    const hasAllDisabled = item => {
      return isRangeDisabled(item) || isDateDisabled(item);
    };
    const dateSelectItem = date => {
      const {
        type,
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      if (type === 'month') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === 'year') {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === 'quarter') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'quarter';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === 'month') {
          reactData.datePanelType = type === 'week' ? type : 'day';
          dateCheckMonth(date);
        } else if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === 'datetime') {
            // æ¥æå¸¦æ¶é´
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = item => {
      if (!hasAllDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = offsetDay => {
      if (!hasAllDisabled({
        date: offsetDay
      })) {
        const dayList = computeDayList.value;
        if (!dayList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetDay, 'yyyyMMdd'))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = offsetYear => {
      if (!hasAllDisabled({
        date: offsetYear
      })) {
        const yearList = computeYearList.value;
        if (!yearList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetYear, 'yyyy'))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = offsetQuarter => {
      if (!hasAllDisabled({
        date: offsetQuarter
      })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetQuarter, 'yyyyq'))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = offsetMonth => {
      if (!hasAllDisabled({
        date: offsetMonth
      })) {
        const monthList = computeMonthList.value;
        if (!monthList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetMonth, 'yyyyMM'))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = item => {
      if (!hasAllDisabled(item)) {
        const {
          datePanelType
        } = reactData;
        if (datePanelType === 'month') {
          dateMoveMonth(item.date);
        } else if (datePanelType === 'quarter') {
          dateMoveQuarter(item.date);
        } else if (datePanelType === 'year') {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const dateMouseleaveEvent = () => {
      reactData.datePanelValue = null;
    };
    const updateTimePos = liElem => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = evnt => {
      const {
        datetimePanelValue
      } = reactData;
      reactData.datetimePanelValue = datetimePanelValue ? new Date(datetimePanelValue.getTime()) : new Date();
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      const {
        datetimePanelValue
      } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setHours(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = evnt => {
      const {
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          // å¦æä¸ºå¤é
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            // å¦ææ¯datetimeç¹æ®ç±»å
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach(item => {
              if (item) {
                if (datetimePanelValue) {
                  item.setHours(datetimePanelValue.getHours());
                  item.setMinutes(datetimePanelValue.getMinutes());
                  item.setSeconds(datetimePanelValue.getSeconds());
                }
                datetimeRest.push(item);
              }
            });
            handleChange(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
              type: 'update'
            });
          } else {
            // å¦ææ¯æ¥æç±»å
            handleChange(dateMultipleValue.join(','), {
              type: 'update'
            });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
      dispatchEvent('confirm', {}, evnt);
    };
    const dateMinuteEvent = (evnt, item) => {
      const {
        datetimePanelValue
      } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setMinutes(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      const {
        datetimePanelValue
      } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setSeconds(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateOpenPanel = () => {
      const {
        type,
        defaultDate,
        defaultTime
      } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (['year', 'quarter', 'month', 'week'].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = 'day';
      }
      reactData.currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        if (defaultDate) {
          // é¢æ¿é»è®¤æ¥æä»æ¯æè§£æ yyyy-MM-dd
          const defDate = parseDate(defaultDate, 'yyyy-MM-dd');
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(defDate)) {
            dateMonthHandle(defDate, 0);
          } else {
            dateNowHandle();
          }
        } else {
          dateNowHandle();
        }
      }
      if (isDateTimeType) {
        let dtPanelValue = reactData.datePanelValue;
        if (!dtPanelValue) {
          dtPanelValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
          if (defaultTime) {
            const defTime = toStringTimeDate(defaultTime);
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(defTime)) {
              dtPanelValue.setHours(defTime.getHours());
              dtPanelValue.setMinutes(defTime.getMinutes());
              dtPanelValue.setSeconds(defTime.getSeconds());
            }
          }
        }
        reactData.datetimePanelValue = dtPanelValue;
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const timeBodyElem = refInputTimeBody.value;
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(timeBodyElem.querySelectorAll('li.is--selected'), elem => {
            updateTimePos(elem);
          });
        });
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $datePanel: $xeDatePanel
      }, params));
    };
    const datePanelMethods = {
      dispatchEvent,
      getModelValue() {
        return reactData.inputValue;
      },
      setPanelDate(date) {
        if (date) {
          dateCheckMonth(date);
        }
      },
      getPanelDate() {
        return reactData.selectMonth;
      },
      checkValue(value) {
        afterCheckValue(value);
      },
      confirmByEvent(evnt) {
        dateConfirmEvent(evnt);
      }
    };
    Object.assign($xeDatePanel, datePanelMethods);
    const renderDateLabel = (item, label) => {
      const {
        festivalMethod
      } = props;
      const labelVNs = [];
      if (festivalMethod) {
        const {
          datePanelType
        } = reactData;
        const festivalRest = festivalMethod({
          type: datePanelType,
          viewType: datePanelType,
          date: item.date,
          $datePanel: $xeDatePanel
        });
        const festivalItem = festivalRest ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalRest) ? {
          label: festivalRest
        } : festivalRest : {};
        const extraItem = festivalItem.extra ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalItem.extra) ? {
          label: festivalItem.extra
        } : festivalItem.extra : null;
        labelVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-date-panel--label', {
            'is-notice': festivalItem.notice
          }]
        }, extraItem && extraItem.label ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', `${label}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-date-panel--label--extra', extraItem.important ? 'is-important' : '', extraItem.className],
          style: extraItem.style
        }, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(extraItem.label))] : `${label}`));
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          // é»è®¤æå¤æ¯æ3ä¸ªèæ¥éå 
          const festivalLabels = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(festivalLabel).split(',');
          labelVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--festival', festivalItem.important ? 'is-important' : '', festivalItem.className],
            style: festivalItem.style
          }, [festivalLabels.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--festival--overlap', `overlap--${festivalLabels.length}`]
          }, festivalLabels.map(label => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', label.substring(0, 3)))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-panel--festival--label'
          }, festivalLabels[0].substring(0, 3))]));
        }
      }
      return labelVNs;
    };
    const renderDateDayTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-panel--view-wrapper', `type--${datePanelType}`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-row'
      }, dateHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-item',
          style: {
            width: `${100 / dateHeaders.length}%`
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-item-inner'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-item-label'
        }, item.label)])]);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-body'
      }, dayDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-row',
          style: {
            height: `${100 / dayDatas.length}%`
          }
        }, rows.map(item => {
          const isSelected = multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat);
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--view-item', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--range-disabled': isRangeDisabled(item),
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--over': overCount && !isSelected,
              'is--hover': !overCount && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            style: {
              width: `${100 / rows.length}%`
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item),
            onMouseleave: dateMouseleaveEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-panel--view-item-inner'
          }, renderDateLabel(item, item.label))]);
        }));
      }))])];
    };
    const renderDateWeekTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-panel--view-wrapper', `type--${datePanelType}`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-row'
      }, weekHeaders.map((item, rIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-item',
          style: {
            width: `${rIndex ? 13 : 9}%`
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-item-inner'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-item-label'
        }, item.label)])]);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-body'
      }, weekDates.map(rows => {
        const isSelected = multiple ? rows.some(item => dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat))) : rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat));
        const isHover = rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat));
        const isNowWeek = rows.some(item => item.isNow);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-row',
          style: {
            height: `${100 / weekDates.length}%`
          }
        }, rows.map((item, rIndex) => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--view-item', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': rIndex ? item.isNow : isNowWeek,
              'is--next': item.isNext,
              'is--range-disabled': isRangeDisabled(item),
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--over': overCount && !isSelected,
              'is--hover': !overCount && isHover
            }],
            style: {
              width: `${rIndex ? 13 : 9}%`
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item),
            onMouseleave: dateMouseleaveEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-panel--view-item-inner'
          }, renderDateLabel(item, item.label))]);
        }));
      }))])];
    };
    const renderDateMonthTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = 'yyyyMM';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-panel--view-wrapper', `type--${datePanelType}`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-body'
      }, monthDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-row',
          style: {
            height: `${100 / monthDatas.length}%`
          }
        }, rows.map(item => {
          const isSelected = multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat);
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--view-item', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--range-disabled': isRangeDisabled(item),
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--over': overCount && !isSelected,
              'is--hover': !overCount && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            style: {
              width: `${100 / rows.length}%`
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item),
            onMouseleave: dateMouseleaveEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-panel--view-item-inner'
          }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)))]);
        }));
      }))])];
    };
    const renderDateQuarterTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = 'yyyyq';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-panel--view-wrapper', `type--${datePanelType}`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-body'
      }, quarterDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-row',
          style: {
            height: `${100 / quarterDatas.length}%`
          }
        }, rows.map(item => {
          const isSelected = multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat);
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--view-item', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--range-disabled': isRangeDisabled(item),
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--over': overCount && !isSelected,
              'is--hover': !overCount && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            style: {
              width: `${100 / rows.length}%`
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item),
            onMouseleave: dateMouseleaveEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-panel--view-item-inner'
          }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)))]);
        }));
      }))])];
    };
    const renderDateYearTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = 'yyyy';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-panel--view-wrapper', `type--${datePanelType}`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-body'
      }, yearDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-row',
          style: {
            height: `${100 / yearDatas.length}%`
          }
        }, rows.map(item => {
          const isSelected = multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat);
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--view-item', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--range-disabled': isRangeDisabled(item),
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--over': overCount && !isSelected,
              'is--hover': !overCount && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            style: {
              width: `${100 / rows.length}%`
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item),
            onMouseleave: dateMouseleaveEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-panel--view-item-inner'
          }, renderDateLabel(item, item.year))]);
        }));
      }))])];
    };
    const renderDateTable = () => {
      const {
        datePanelType
      } = reactData;
      switch (datePanelType) {
        case 'week':
          return renderDateWeekTable();
        case 'month':
          return renderDateMonthTable();
        case 'quarter':
          return renderDateQuarterTable();
        case 'year':
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const {
        datePanelType
      } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelObj = computeSelectDatePanelObj.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--picker-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--picker-type-wrapper'
      }, [datePanelType === 'year' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-panel--picker-label'
      }, selectDatePanelObj.y) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-panel--picker-btns'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-panel--picker-btn',
        onClick: dateToggleYearTypeEvent
      }, selectDatePanelObj.y), selectDatePanelObj.m ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-panel--picker-btn',
        onClick: dateToggleMonthTypeEvent
      }, selectDatePanelObj.m) : renderEmptyElement($xeDatePanel)])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--picker-btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-date-panel--picker-btn vxe-date-panel--picker-prev-btn', {
          'is--disabled': isDisabledPrevDateBtn
        }],
        onClick: datePrevEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-left'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-panel--picker-btn vxe-date-panel--picker-current-btn',
        onClick: dateTodayMonthEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-dot'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-date-panel--picker-btn vxe-date-panel--picker-next-btn', {
          'is--disabled': isDisabledNextDateBtn
        }],
        onClick: dateNextEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-right'
      })])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--picker-body'
      }, renderDateTable())];
    };
    const renderTimePanel = () => {
      const {
        type
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [type === 'time' ? renderEmptyElement($xeDatePanel) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--time-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--time-title'
      }, dateTimeLabel)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refInputTimeBody,
        class: 'vxe-date-panel--time-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-date-panel--time-hour-list'
      }, hourList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getHours() === item.value
          },
          onClick: evnt => dateHourEvent(evnt, item)
        }, item.label);
      })), hasTimeMinute ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-date-panel--time-minute-list'
      }, minuteList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getMinutes() === item.value
          },
          onClick: evnt => dateMinuteEvent(evnt, item)
        }, item.label);
      })) : renderEmptyElement($xeDatePanel), hasTimeMinute && hasTimeSecond ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-date-panel--time-second-list'
      }, secondList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getSeconds() === item.value
          },
          onClick: evnt => dateSecondEvent(evnt, item)
        }, item.label);
      })) : renderEmptyElement($xeDatePanel)])];
    };
    const renderPickerPanel = () => {
      const {
        type
      } = props;
      if (type === 'datetime') {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: type,
          ref: refPanelWrapper,
          class: 'vxe-date-panel--time-layout-wrapper'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--time-left-wrapper'
        }, renderDatePanel()), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--time-right-wrapper'
        }, renderTimePanel())]);
      } else if (type === 'time') {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: type,
          ref: refPanelWrapper,
          class: 'vxe-date-panel--wrapper'
        }, renderTimePanel());
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: type || 'default',
        ref: refPanelWrapper,
        class: 'vxe-date-panel--wrapper'
      }, renderDatePanel());
    };
    const renderVN = () => {
      const {
        type
      } = props;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-panel', `type--${type}`, {
          [`size--${vSize}`]: vSize
        }]
      }, [renderPickerPanel()]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      updateModelValue(val);
      changeValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      // åæ¢ç±»åæ¯éç½®åç½®åé
      Object.assign(reactData, {
        inputLabel: '',
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: '',
        datePanelType: 'day',
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeDateLabelFormat, () => {
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputLabel = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    initValue();
    dateOpenPanel();
    $xeDatePanel.renderVN = renderVN;
    return $xeDatePanel;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/date-panel/index.ts



const VxeDatePanel = Object.assign({}, date_panel, {
  install(app) {
    app.component(date_panel.name, date_panel);
  }
});
dynamicApp.use(VxeDatePanel);
index_esm_VxeUI.component(date_panel);
const DatePanel = VxeDatePanel;
/* harmony default export */ var packages_date_panel = (VxeDatePanel);
;// CONCATENATED MODULE: ./packages/date-picker/src/date-picker.ts












/* harmony default export */ var date_picker = (defineVxeComponent({
  name: 'VxeDatePicker',
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: 'date'
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().datePicker.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    autoComplete: {
      type: String,
      default: 'off'
    },
    form: String,
    className: String,
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().datePicker.size || getConfig().size
    },
    multiple: Boolean,
    limitCount: {
      type: [String, Number],
      default: () => getConfig().datePicker.limitCount
    },
    // dateãweekãmonthãquarterãyear
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.endDate
    },
    defaultDate: [String, Number, Date],
    defaultTime: [String, Number, Date],
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    startDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.startDay
    },
    labelFormat: String,
    valueFormat: String,
    timeFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().datePicker.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().datePicker.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.selectDay
    },
    showClearButton: {
      type: Boolean,
      default: () => getConfig().datePicker.showClearButton
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().datePicker.showConfirmButton
    },
    autoClose: {
      type: Boolean,
      default: () => getConfig().datePicker.autoClose
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    shortcutConfig: Object,
    // å·²åºå¼ startWeekï¼è¢« startDay æ¿æ¢
    startWeek: Number
  },
  emits: ['update:modelValue', 'input', 'change', 'keydown', 'keyup', 'click', 'focus', 'blur', 'clear', 'confirm', 'prefix-click', 'suffix-click', 'date-prev', 'date-today', 'date-next', 'shortcut-click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      panelIndex: 0,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: '',
      isActivated: false,
      inputValue: '',
      inputLabel: ''
    });
    const internalData = {
      hpTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPanelWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refDatePanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeDatePicker = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().datePicker.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsDateTimeType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'time' || type === 'datetime';
    });
    const computeIsDatePickerType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.clearable;
    });
    const computeInputReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        editable,
        multiple
      } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || multiple || !editable || type === 'week' || type === 'quarter';
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().datePicker.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.base.pleaseSelect');
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        immediate
      } = props;
      return immediate;
    });
    const computeShortcutOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().datePicker.shortcutConfig, props.shortcutConfig);
    });
    const computeShortcutList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const shortcutOpts = computeShortcutOpts.value;
      const {
        options
      } = shortcutOpts;
      if (options) {
        return options.map((option, index) => {
          return Object.assign({
            name: `${option.name || option.code || index}`
          }, option);
        });
      }
      return [];
    });
    const computeDateLabelFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        labelFormat
      } = props;
      return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
    });
    const computeDateValueFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        valueFormat
      } = props;
      return handleValueFormat(type, valueFormat);
    });
    const computeFirstDayOfWeek = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startDay
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(startDay);
    });
    const computePanelLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        multiple
      } = props;
      const {
        inputValue
      } = reactData;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const vals = inputValue ? multiple ? inputValue.split(',') : [inputValue] : [];
      return vals.map(val => {
        const dateObj = parseDateObj(val, type, {
          valueFormat: dateValueFormat,
          labelFormat: dateLabelFormat,
          firstDay: firstDayOfWeek
        });
        return dateObj.label;
      }).join(', ');
    });
    const updateModelValue = () => {
      const {
        modelValue
      } = props;
      let val = '';
      if (modelValue) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(modelValue) && /^[0-9]{11,15}$/.test(`${modelValue}`)) {
          val = new Date(modelValue);
        } else {
          val = modelValue;
        }
      }
      reactData.inputValue = val;
    };
    const triggerEvent = evnt => {
      const {
        inputValue
      } = reactData;
      dispatchEvent(evnt.type, {
        value: inputValue
      }, evnt);
    };
    const handleChange = (value, evnt) => {
      const {
        type,
        modelValue,
        valueFormat
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      reactData.inputValue = value;
      if (hasTimestampValueType(valueFormat)) {
        const dateVal = parseDateValue(value, type, {
          valueFormat: dateValueFormat
        });
        const timeNum = dateVal ? dateVal.getTime() : null;
        emit('update:modelValue', timeNum);
        if (modelValue !== timeNum) {
          dispatchEvent('change', {
            value: timeNum
          }, evnt);
          // èªå¨æ´æ°æ ¡éªç¶æ
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, timeNum);
          }
        }
      } else if (hasDateValueType(valueFormat)) {
        const dateVal = parseDateValue(value, type, {
          valueFormat: dateValueFormat
        });
        emit('update:modelValue', dateVal);
        if (modelValue && dateVal ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(modelValue).getTime() !== dateVal.getTime() : modelValue !== dateVal) {
          dispatchEvent('change', {
            value: dateVal
          }, evnt);
          // èªå¨æ´æ°æ ¡éªç¶æ
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, dateVal);
          }
        }
      } else {
        emit('update:modelValue', value);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue) !== value) {
          dispatchEvent('change', {
            value
          }, evnt);
          // èªå¨æ´æ°æ ¡éªç¶æ
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const inputEvent = evnt => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      reactData.inputLabel = value;
      dispatchEvent('input', {
        value
      }, evnt);
    };
    const changeEvent = evnt => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent(evnt);
    };
    const clickPrefixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        dispatchEvent('prefix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise(resolve => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      handleChange('', evnt);
      dispatchEvent('clear', {
        value
      }, evnt);
    };
    const clickSuffixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        dispatchEvent('suffix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const blurEvent = evnt => {
      const $datePanel = refDatePanel.value;
      const {
        inputValue
      } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue;
      if (!inpImmediate) {
        handleChange(value, evnt);
      }
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
        // æªæå¼é¢æ¿æ¶ææ ¡éª
        if ($datePanel) {
          $datePanel.checkValue(reactData.inputLabel);
        }
      }
      dispatchEvent('blur', {
        value
      }, evnt);
      // èªå¨æ´æ°æ ¡éªç¶æ
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const keydownEvent = evnt => {
      triggerEvent(evnt);
    };
    const keyupEvent = evnt => {
      triggerEvent(evnt);
    };
    const confirmEvent = evnt => {
      const $datePanel = refDatePanel.value;
      if ($datePanel) {
        $datePanel.confirmByEvent(evnt);
      }
      hidePanel();
    };
    const panelChangeEvent = params => {
      const {
        multiple,
        autoClose
      } = props;
      const {
        value,
        $event
      } = params;
      const isDateTimeType = computeIsDateTimeType.value;
      handleChange(value, $event);
      if (!multiple && !isDateTimeType) {
        if (autoClose) {
          hidePanel();
        }
      }
    };
    const panelConfirmEvent = params => {
      dispatchEvent('confirm', params, params.$event);
    };
    // å¨å±äºä»¶
    const handleGlobalMousedownEvent = evnt => {
      const $datePanel = refDatePanel.value;
      const {
        visiblePanel,
        isActivated
      } = reactData;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (visiblePanel) {
            hidePanel();
            if ($datePanel) {
              $datePanel.checkValue(reactData.inputLabel);
            }
          }
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hidePanel();
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const $datePanel = refDatePanel.value;
      const {
        isActivated,
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        hidePanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        if ($datePanel) {
          $datePanel.checkValue(reactData.inputLabel);
        }
        const targetElem = refInputTarget.value;
        if (targetElem) {
          targetElem.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    // å¼¹åºé¢æ¿
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refInputTarget.value;
      const panelElem = refInputPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const showPanel = () => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
          internalData.hpTimeout = undefined;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const datePickerOpenEvent = evnt => {
      const formReadonly = computeFormReadonly.value;
      if (!formReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    const handleShortcutEvent = ({
      option,
      $event
    }) => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const shortcutOpts = computeShortcutOpts.value;
      const {
        autoClose
      } = shortcutOpts;
      const {
        code,
        clickMethod
      } = option;
      let value = inputValue;
      const shortcutParams = {
        $datePicker: $xeDatePicker,
        option,
        value,
        code
      };
      if (!clickMethod && code) {
        const gCommandOpts = commands.get(code);
        const dpCommandMethod = gCommandOpts ? gCommandOpts.datePickerCommandMethod : null;
        if (dpCommandMethod) {
          dpCommandMethod(shortcutParams);
        } else {
          const dateValueFormat = computeDateValueFormat.value;
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          switch (code) {
            case 'now':
            case 'prev':
            case 'next':
            case 'minus':
            case 'plus':
              {
                const restObj = getDateByCode(code, value, type, {
                  valueFormat: dateValueFormat,
                  firstDay: firstDayOfWeek
                });
                value = restObj.value;
                shortcutParams.value = value;
                handleChange(value, $event);
                break;
              }
            default:
              errLog('vxe.error.notCommands', [`[date-picker] ${code}`]);
              break;
          }
        }
      } else {
        const optClickMethod = clickMethod || shortcutOpts.clickMethod;
        if (optClickMethod) {
          optClickMethod(shortcutParams);
        }
      }
      if (autoClose) {
        hidePanel();
      }
      dispatchEvent('shortcut-click', shortcutParams, $event);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $datePicker: $xeDatePicker
      }, params));
    };
    const datePickerMethods = {
      dispatchEvent,
      setModelValue(value) {
        reactData.inputValue = value;
        emit('update:modelValue', value);
      },
      setModelValueByEvent(evnt, value) {
        handleChange(value || '', evnt);
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeDatePicker, datePickerMethods);
    const renderShortcutBtn = (pos, isVertical) => {
      const shortcutOpts = computeShortcutOpts.value;
      const {
        position,
        align,
        mode
      } = shortcutOpts;
      const shortcutList = computeShortcutList.value;
      if (isEnableConf(shortcutOpts) && shortcutList.length && (position || 'left') === pos) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: `vxe-date-picker--layout-${pos}-wrapper`
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(button_group, {
          options: shortcutList,
          mode,
          align,
          vertical: isVertical,
          onClick: handleShortcutEvent
        })]);
      }
      return renderEmptyElement($xeDatePicker);
    };
    const renderPanel = () => {
      const {
        type,
        multiple,
        showClearButton,
        showConfirmButton
      } = props;
      const {
        initialized,
        isAniVisible,
        visiblePanel,
        panelPlacement,
        panelStyle,
        inputValue
      } = reactData;
      const vSize = computeSize.value;
      const btnTransfer = computeBtnTransfer.value;
      const shortcutOpts = computeShortcutOpts.value;
      const isClearable = computeIsClearable.value;
      const isDateTimeType = computeIsDateTimeType.value;
      const shortcutList = computeShortcutList.value;
      const {
        position
      } = shortcutOpts;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const hasShortcutBtn = shortcutList.length > 0;
      const showConfirmBtn = showConfirmButton === null ? isDateTimeType || multiple : showConfirmButton;
      const showClearBtn = showClearButton === null ? isClearable && showConfirmBtn && type !== 'time' : showClearButton;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refInputPanel,
        class: ['vxe-table--ignore-clear vxe-date-picker--panel', `type--${type}`, {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': isAniVisible,
          'ani--enter': visiblePanel,
          'show--top': !!(topSlot || headerSlot || hasShortcutBtn && (position === 'top' || position === 'header')),
          'show--bottom': !!(bottomSlot || footerSlot || hasShortcutBtn && (position === 'bottom' || position === 'footer')),
          'show--left': !!(leftSlot || hasShortcutBtn && position === 'left'),
          'show--right': !!(rightSlot || hasShortcutBtn && position === 'right')
        }],
        placement: panelPlacement,
        style: panelStyle
      }, initialized && (visiblePanel || isAniVisible) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refPanelWrapper,
        class: ['vxe-date-picker--layout-all-wrapper', `type--${type}`, {
          [`size--${vSize}`]: vSize
        }]
      }, [topSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-top-wrapper'
      }, topSlot({})) : renderShortcutBtn('top'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-body-layout-wrapper'
      }, [leftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-left-wrapper'
      }, leftSlot({})) : renderShortcutBtn('left', true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-body-content-wrapper'
      }, [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-header-wrapper'
      }, headerSlot({})) : renderShortcutBtn('header'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-body-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(date_panel, {
        ref: refDatePanel,
        modelValue: reactData.inputValue,
        type: props.type,
        className: props.className,
        multiple: props.multiple,
        limitCount: props.limitCount,
        startDate: props.startDate,
        endDate: props.endDate,
        defaultDate: props.defaultDate,
        defaultTime: props.defaultTime,
        minDate: props.minDate,
        maxDate: props.maxDate,
        startDay: props.startDay,
        labelFormat: props.labelFormat,
        valueFormat: props.valueFormat,
        timeFormat: props.timeFormat,
        festivalMethod: props.festivalMethod,
        disabledMethod: props.disabledMethod,
        selectDay: props.selectDay,
        onChange: panelChangeEvent,
        onConfirm: panelConfirmEvent
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-footer-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-footer-custom'
      }, footerSlot ? footerSlot({}) : [renderShortcutBtn('footer')]), showClearBtn || showConfirmBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-footer-btns'
      }, [showClearBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        size: 'mini',
        disabled: inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue),
        content: getI18n('vxe.button.clear'),
        onClick: clearValueEvent
      }) : renderEmptyElement($xeDatePicker), showConfirmBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        size: 'mini',
        status: 'primary',
        content: getI18n('vxe.button.confirm'),
        onClick: confirmEvent
      }) : renderEmptyElement($xeDatePicker)]) : renderEmptyElement($xeDatePicker)])]), rightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-right-wrapper'
      }, rightSlot({})) : renderShortcutBtn('right', true)]), bottomSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-bottom-wrapper'
      }, bottomSlot({})) : renderShortcutBtn('bottom')])] : [])]);
    };
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--prefix-icon'
      }, prefixSlot ? vn_getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : null;
    };
    const renderSuffixIcon = () => {
      const {
        suffixIcon
      } = props;
      const {
        inputValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-picker--suffix', {
          'is--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : renderEmptyElement($xeDatePicker), renderExtraSuffixIcon(), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? vn_getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : renderEmptyElement($xeDatePicker)]);
    };
    const renderExtraSuffixIcon = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--control-icon',
        onClick: datePickerOpenEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-date-picker--date-picker-icon', getIcon().DATE_PICKER_DATE]
      })]);
    };
    const renderVN = () => {
      const {
        className,
        type,
        name,
        autoComplete
      } = props;
      const {
        inputValue,
        inputLabel,
        visiblePanel,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const panelLabel = computePanelLabel.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-date-picker--readonly', `type--${type}`, className]
        }, panelLabel);
      }
      const inputReadonly = computeInputReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon();
      const suffix = renderSuffixIcon();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-date-picker', `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          'is--prefix': !!prefix,
          'is--suffix': !!suffix,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--active': isActivated,
          'show--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }],
        spellcheck: false
      }, [prefix || renderEmptyElement($xeDatePicker), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-date-picker--inner',
        value: inputLabel,
        name,
        type: 'text',
        placeholder: inpPlaceholder,
        readonly: inputReadonly,
        disabled: isDisabled,
        autocomplete: autoComplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), suffix || renderEmptyElement($xeDatePicker),
      // ä¸æé¢æ¿
      renderPanel()]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computePanelLabel, val => {
      reactData.inputLabel = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      updateModelValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      globalEvents.on($xeDatePicker, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeDatePicker, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeDatePicker, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeDatePicker, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xeDatePicker, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeDatePicker, 'mousewheel');
      globalEvents.off($xeDatePicker, 'mousedown');
      globalEvents.off($xeDatePicker, 'blur');
      globalEvents.off($xeDatePicker, 'resize');
    });
    updateModelValue();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeDatePicker', $xeDatePicker);
    $xeDatePicker.renderVN = renderVN;
    return $xeDatePicker;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/date-picker/index.ts



const VxeDatePicker = Object.assign({}, date_picker, {
  install(app) {
    app.component(date_picker.name, date_picker);
  }
});
dynamicApp.use(VxeDatePicker);
index_esm_VxeUI.component(date_picker);
const DatePicker = VxeDatePicker;
/* harmony default export */ var packages_date_picker = (VxeDatePicker);
;// CONCATENATED MODULE: ./packages/date-range-picker/src/date-range-picker.ts












/* harmony default export */ var date_range_picker = (defineVxeComponent({
  name: 'VxeDateRangePicker',
  props: {
    modelValue: [String, Number, Date, Array],
    startValue: [String, Number, Date],
    endValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: 'date'
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().dateRangePicker.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    autoComplete: {
      type: String,
      default: 'off'
    },
    form: String,
    className: String,
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().dateRangePicker.size || getConfig().size
    },
    // startDate: {
    //   type: [String, Number, Date] as PropType<VxeDateRangePickerPropTypes.StartDate>,
    //   default: () => getConfig().dateRangePicker.startDate
    // },
    // endDate: {
    //   type: [String, Number, Date] as PropType<VxeDateRangePickerPropTypes.EndDate>,
    //   default: () => getConfig().dateRangePicker.endDate
    // },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    defaultDate: [String, Number, Date, Array],
    defaultTime: [String, Number, Date, Array],
    startDay: {
      type: [String, Number],
      default: () => getConfig().dateRangePicker.startDay
    },
    labelFormat: String,
    valueFormat: String,
    timeFormat: String,
    valueType: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().dateRangePicker.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().dateRangePicker.disabledMethod
    },
    separator: {
      type: [String, Number],
      default: () => getConfig().dateRangePicker.separator
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().dateRangePicker.selectDay
    },
    showClearButton: {
      type: Boolean,
      default: () => getConfig().dateRangePicker.showClearButton
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().dateRangePicker.showConfirmButton
    },
    autoClose: {
      type: Boolean,
      default: () => getConfig().dateRangePicker.autoClose
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    shortcutConfig: Object
  },
  emits: ['update:modelValue', 'update:startValue', 'update:endValue', 'input', 'change', 'keydown', 'keyup', 'click', 'focus', 'blur', 'clear', 'confirm', 'prefix-click', 'suffix-click', 'date-prev', 'date-today', 'date-next', 'shortcut-click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      panelIndex: 0,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: '',
      isActivated: false,
      startValue: '',
      endValue: ''
    });
    const internalData = {
      // selectStatus: false
      // hpTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPanelWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refStartDatePanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refEndDatePanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeDateRangePicker = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let dateRangePickerMethods = {};
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().dateRangePicker.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeDefaultDates = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        defaultDate
      } = props;
      if (defaultDate) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(defaultDate)) {
          return defaultDate;
        }
        if (`${defaultDate}`.indexOf(',') > -1) {
          return `${defaultDate}`.split(',');
        }
        return [defaultDate, defaultDate];
      }
      return [];
    });
    const computeDefaultTimes = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        defaultTime
      } = props;
      if (defaultTime) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(defaultTime)) {
          return defaultTime;
        }
        if (`${defaultTime}`.indexOf(',') > -1) {
          return `${defaultTime}`.split(',');
        }
        return [defaultTime, defaultTime];
      }
      return [];
    });
    const computeMVal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startValue,
        endValue
      } = props;
      return `${startValue || ''}${endValue || ''}`;
    });
    const computeIsDateTimeType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'time' || type === 'datetime';
    });
    const computeIsDatePickerType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.clearable;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().dateRangePicker.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.dateRangePicker.pleaseRange');
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        immediate
      } = props;
      return immediate;
    });
    const computeShortcutOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().dateRangePicker.shortcutConfig, props.shortcutConfig);
    });
    const computeShortcutList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const shortcutOpts = computeShortcutOpts.value;
      const {
        options
      } = shortcutOpts;
      if (options) {
        return options.map((option, index) => {
          return Object.assign({
            name: `${option.name || option.code || index}`
          }, option);
        });
      }
      return [];
    });
    const computeDateLabelFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        labelFormat
      } = props;
      return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
    });
    const computeDateValueFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        valueFormat
      } = props;
      return handleValueFormat(type, valueFormat);
    });
    const computeFirstDayOfWeek = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startDay
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(startDay);
    });
    const computePanelLabelObj = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startValue,
        endValue
      } = reactData;
      const vals = startValue || endValue ? [startValue || '', endValue || ''] : [];
      return formatRangeLabel(vals);
    });
    const computeInputLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const panelLabelObj = computePanelLabelObj.value;
      return panelLabelObj.label;
    });
    const formatRangeLabel = vals => {
      const {
        type,
        separator
      } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const startRest = vals[0] ? parseDateObj(vals[0], type, {
        valueFormat: dateValueFormat,
        labelFormat: dateLabelFormat,
        firstDay: firstDayOfWeek
      }) : null;
      const endRest = vals[1] ? parseDateObj(vals[1], type, {
        valueFormat: dateValueFormat,
        labelFormat: dateLabelFormat,
        firstDay: firstDayOfWeek
      }) : null;
      const startLabel = startRest ? startRest.label : '';
      const endLabel = endRest ? endRest.label : '';
      return {
        label: (startLabel || endLabel ? [startLabel, endLabel] : []).join(`${separator || ' ~ '}`),
        startLabel,
        endLabel
      };
    };
    const getRangeValue = (sValue, eValue) => {
      const {
        modelValue,
        valueType
      } = props;
      let isArr = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue);
      if (valueType) {
        switch (valueType) {
          case 'array':
            isArr = true;
            break;
          case 'string':
            isArr = false;
            break;
        }
      }
      if (sValue || eValue) {
        const rest = [sValue || '', eValue || ''];
        if (isArr) {
          return rest;
        }
        return rest.join(',');
      }
      return isArr ? [] : '';
    };
    const paraeUpdateModel = () => {
      const {
        type,
        modelValue
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      let sValue = '';
      let eValue = '';
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue)) {
        const date1 = parseDateString(modelValue[0], type, {
          valueFormat: dateValueFormat
        });
        const date2 = parseDateString(modelValue[1], type, {
          valueFormat: dateValueFormat
        });
        if (date1 || date2) {
          sValue = date1 || '';
          eValue = date2 || '';
        }
      } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(modelValue)) {
        const strArr = modelValue.split(',');
        if (strArr[0] || strArr[1]) {
          sValue = strArr[0] || '';
          eValue = strArr[1] || '';
        }
      }
      return {
        sValue,
        eValue
      };
    };
    const parseUpdateData = () => {
      const {
        type,
        startValue,
        endValue
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      let sValue = '';
      let eValue = '';
      sValue = parseDateString(startValue, type, {
        valueFormat: dateValueFormat
      });
      eValue = parseDateString(endValue, type, {
        valueFormat: dateValueFormat
      });
      return {
        sValue,
        eValue
      };
    };
    const updateModelValue = isModel => {
      const {
        modelValue,
        startValue,
        endValue
      } = props;
      let restObj = {
        sValue: '',
        eValue: ''
      };
      if (isModel) {
        if (modelValue) {
          restObj = paraeUpdateModel();
        } else {
          restObj = parseUpdateData();
        }
      } else {
        if (startValue || endValue) {
          restObj = parseUpdateData();
        } else {
          restObj = paraeUpdateModel();
        }
      }
      reactData.startValue = restObj.sValue;
      reactData.endValue = restObj.eValue;
    };
    const triggerEvent = evnt => {
      const {
        startValue,
        endValue
      } = reactData;
      const value = getRangeValue(startValue, endValue);
      dispatchEvent(evnt.type, {
        value,
        startValue,
        endValue
      }, evnt);
    };
    const handleChange = (sValue, eValue, evnt) => {
      const {
        modelValue
      } = props;
      reactData.startValue = sValue;
      reactData.endValue = eValue;
      const value = getRangeValue(sValue, eValue);
      emit('update:modelValue', value);
      emit('update:startValue', sValue || '');
      emit('update:endValue', eValue || '');
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue) !== value) {
        dispatchEvent('change', {
          value
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const changeEvent = evnt => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      dateRangePickerOpenEvent(evnt);
      triggerEvent(evnt);
    };
    const clickPrefixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          startValue,
          endValue
        } = reactData;
        const value = getRangeValue(startValue, endValue);
        dispatchEvent('prefix-click', {
          value,
          startValue,
          endValue
        }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise(resolve => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      const startValue = '';
      const endValue = '';
      handleChange(startValue, endValue, evnt);
      dispatchEvent('clear', {
        value,
        startValue,
        endValue
      }, evnt);
    };
    const checkValue = () => {
      const $startDatePanel = refStartDatePanel.value;
      const $endDatePanel = refEndDatePanel.value;
      if ($startDatePanel && $endDatePanel) {
        const startValue = $startDatePanel.getModelValue();
        const endValue = $endDatePanel.getModelValue();
        if (!startValue || !endValue) {
          handleChange('', '', {
            type: 'check'
          });
        }
      }
    };
    const handleSelectClose = () => {
      const {
        autoClose
      } = props;
      const {
        startValue,
        endValue
      } = reactData;
      const {
        selectStatus
      } = internalData;
      const isDatePickerType = computeIsDatePickerType.value;
      if (autoClose) {
        if (selectStatus && isDatePickerType) {
          if (startValue && endValue) {
            hidePanel();
          }
        }
      } else {
        if (startValue && endValue) {
          internalData.selectStatus = false;
        }
      }
    };
    const clickSuffixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          startValue,
          endValue
        } = reactData;
        const value = getRangeValue(startValue, endValue);
        dispatchEvent('suffix-click', {
          value,
          startValue,
          endValue
        }, evnt);
      }
    };
    const blurEvent = evnt => {
      const {
        startValue,
        endValue
      } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = '';
      if (!inpImmediate) {
        handleChange(startValue, endValue, evnt);
      }
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      dispatchEvent('blur', {
        value,
        startValue,
        endValue
      }, evnt);
      // èªå¨æ´æ°æ ¡éªç¶æ
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const keydownEvent = evnt => {
      triggerEvent(evnt);
    };
    const keyupEvent = evnt => {
      triggerEvent(evnt);
    };
    const confirmEvent = evnt => {
      const $startDatePanel = refStartDatePanel.value;
      const $endDatePanel = refEndDatePanel.value;
      if ($startDatePanel && $endDatePanel) {
        const startValue = $startDatePanel.getModelValue();
        const endValue = $endDatePanel.getModelValue();
        if (startValue && !endValue || !startValue && endValue) {
          handleChange('', '', evnt);
        } else {
          $startDatePanel.confirmByEvent(evnt);
          $endDatePanel.confirmByEvent(evnt);
        }
        const value = getRangeValue(startValue, endValue);
        dispatchEvent('confirm', {
          value,
          startValue,
          endValue
        }, evnt);
      }
      hidePanel();
    };
    const startPanelChangeEvent = params => {
      const {
        selectStatus
      } = internalData;
      const {
        value,
        $event
      } = params;
      const endValue = selectStatus ? reactData.endValue : '';
      handleChange(value, endValue, $event);
      handleSelectClose();
      if (!selectStatus) {
        internalData.selectStatus = true;
      }
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const $startDatePanel = refStartDatePanel.value;
        const $endDatePanel = refEndDatePanel.value;
        if ($startDatePanel && $endDatePanel) {
          const startValue = $startDatePanel.getModelValue();
          if (!endValue && startValue) {
            $endDatePanel.setPanelDate(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(startValue));
          }
        }
      });
    };
    const endPanelChangeEvent = params => {
      const {
        selectStatus
      } = internalData;
      const {
        value,
        $event
      } = params;
      const startValue = selectStatus ? reactData.startValue : '';
      handleChange(startValue, value, $event);
      handleSelectClose();
      if (!selectStatus) {
        internalData.selectStatus = true;
      }
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const $startDatePanel = refStartDatePanel.value;
        const $endDatePanel = refEndDatePanel.value;
        if ($startDatePanel && $endDatePanel) {
          const endValue = $endDatePanel.getModelValue();
          if (!startValue && endValue) {
            $startDatePanel.setPanelDate(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(endValue));
          }
        }
      });
    };
    // å¨å±äºä»¶
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (visiblePanel) {
            checkValue();
            hidePanel();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hidePanel();
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hidePanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const targetElem = refInputTarget.value;
        if (targetElem) {
          targetElem.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    // å¼¹åºé¢æ¿
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refInputTarget.value;
      const panelElem = refInputPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const showPanel = () => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
          internalData.hpTimeout = undefined;
        }
        internalData.selectStatus = false;
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const dateRangePickerOpenEvent = evnt => {
      const formReadonly = computeFormReadonly.value;
      if (!formReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    const handleShortcutEvent = ({
      option,
      $event
    }) => {
      const {
        type
      } = props;
      const shortcutOpts = computeShortcutOpts.value;
      const {
        autoClose
      } = shortcutOpts;
      const {
        code,
        clickMethod
      } = option;
      let startValue = reactData.startValue;
      let endValue = reactData.endValue;
      let value = getRangeValue(startValue, endValue);
      const shortcutParams = {
        $dateRangePicker: $xeDateRangePicker,
        option: option,
        value,
        startValue,
        endValue,
        code
      };
      if (!clickMethod && code) {
        const gCommandOpts = commands.get(code);
        const drpCommandMethod = gCommandOpts ? gCommandOpts.dateRangePickerCommandMethod : null;
        if (drpCommandMethod) {
          drpCommandMethod(shortcutParams);
        } else {
          const dateValueFormat = computeDateValueFormat.value;
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          switch (code) {
            case 'last1':
            case 'last3':
            case 'last7':
            case 'last30':
            case 'last60':
            case 'last90':
            case 'last180':
              {
                const restObj = getRangeDateByCode(code, value, type, {
                  valueFormat: dateValueFormat,
                  firstDay: firstDayOfWeek
                });
                startValue = restObj.startValue;
                endValue = restObj.endValue;
                value = getRangeValue(startValue, endValue);
                shortcutParams.value = value;
                shortcutParams.startValue = startValue;
                shortcutParams.endValue = endValue;
                handleChange(startValue, endValue, $event);
                break;
              }
            default:
              errLog('vxe.error.notCommands', [`[date-range-picker] ${code}`]);
              break;
          }
        }
      } else {
        const optClickMethod = clickMethod || shortcutOpts.clickMethod;
        if (optClickMethod) {
          optClickMethod(shortcutParams);
        }
      }
      if (autoClose) {
        hidePanel();
      }
      dispatchEvent('shortcut-click', shortcutParams, $event);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $dateRangePicker: $xeDateRangePicker
      }, params));
    };
    dateRangePickerMethods = {
      dispatchEvent,
      setModelValue(startValue, endValue) {
        reactData.startValue = startValue || '';
        reactData.endValue = endValue || '';
        const value = getRangeValue(startValue, endValue);
        emit('update:modelValue', value);
      },
      setModelValueByEvent(evnt, startValue, endValue) {
        handleChange(startValue || '', endValue || '', evnt);
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeDateRangePicker, dateRangePickerMethods);
    const renderShortcutBtn = (pos, isVertical) => {
      const shortcutOpts = computeShortcutOpts.value;
      const {
        position,
        align,
        mode
      } = shortcutOpts;
      const shortcutList = computeShortcutList.value;
      if (isEnableConf(shortcutOpts) && shortcutList.length && (position || 'left') === pos) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: `vxe-date-range-picker--layout-${pos}-wrapper`
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(button_group, {
          options: shortcutList,
          mode,
          align,
          vertical: isVertical,
          onClick: handleShortcutEvent
        })]);
      }
      return renderEmptyElement($xeDateRangePicker);
    };
    const renderPanel = () => {
      const {
        type,
        separator,
        autoClose,
        showConfirmButton,
        showClearButton
      } = props;
      const {
        initialized,
        isAniVisible,
        visiblePanel,
        panelPlacement,
        panelStyle,
        startValue,
        endValue
      } = reactData;
      const vSize = computeSize.value;
      const btnTransfer = computeBtnTransfer.value;
      const shortcutOpts = computeShortcutOpts.value;
      const isClearable = computeIsClearable.value;
      const panelLabelObj = computePanelLabelObj.value;
      const shortcutList = computeShortcutList.value;
      const isDateTimeType = computeIsDateTimeType.value;
      const defaultDates = computeDefaultDates.value;
      const defaultTimes = computeDefaultTimes.value;
      const {
        startLabel,
        endLabel
      } = panelLabelObj;
      const {
        position
      } = shortcutOpts;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const [sdDate, edDate] = defaultDates;
      const [sdTime, edTime] = defaultTimes;
      const hasShortcutBtn = shortcutList.length > 0;
      const showConfirmBtn = showConfirmButton === null ? isDateTimeType || !autoClose : showConfirmButton;
      const showClearBtn = showClearButton === null ? isClearable : showClearButton;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refInputPanel,
        class: ['vxe-table--ignore-clear vxe-date-range-picker--panel', `type--${type}`, {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': isAniVisible,
          'ani--enter': visiblePanel,
          'show--top': !!(topSlot || headerSlot || hasShortcutBtn && (position === 'top' || position === 'header')),
          'show--bottom': !!(bottomSlot || footerSlot || hasShortcutBtn && (position === 'bottom' || position === 'footer')),
          'show--left': !!(leftSlot || hasShortcutBtn && position === 'left'),
          'show--right': !!(rightSlot || hasShortcutBtn && position === 'right')
        }],
        placement: panelPlacement,
        style: panelStyle
      }, initialized && (visiblePanel || isAniVisible) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refPanelWrapper,
        class: ['vxe-date-range-picker--layout-all-wrapper', `type--${type}`, {
          [`size--${vSize}`]: vSize
        }]
      }, [topSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-top-wrapper'
      }, topSlot({})) : renderShortcutBtn('top'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-body-layout-wrapper'
      }, [leftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-left-wrapper'
      }, leftSlot({})) : renderShortcutBtn('left', true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-body-content-wrapper'
      }, [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-header-wrapper'
      }, headerSlot({})) : renderShortcutBtn('header'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-body-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(date_panel, {
        ref: refStartDatePanel,
        modelValue: startValue,
        type: props.type,
        className: props.className,
        minDate: props.minDate,
        maxDate: props.maxDate,
        endDate: endValue,
        startDay: props.startDay,
        labelFormat: props.labelFormat,
        valueFormat: props.valueFormat,
        timeFormat: props.timeFormat,
        defaultDate: sdDate,
        defaultTime: sdTime,
        festivalMethod: props.festivalMethod,
        disabledMethod: props.disabledMethod,
        selectDay: props.selectDay,
        onChange: startPanelChangeEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(date_panel, {
        ref: refEndDatePanel,
        modelValue: endValue,
        type: props.type,
        className: props.className,
        minDate: props.minDate,
        maxDate: props.maxDate,
        startDate: startValue,
        startDay: props.startDay,
        labelFormat: props.labelFormat,
        valueFormat: props.valueFormat,
        timeFormat: props.timeFormat,
        defaultDate: edDate,
        defaultTime: edTime,
        festivalMethod: props.festivalMethod,
        disabledMethod: props.disabledMethod,
        selectDay: props.selectDay,
        onChange: endPanelChangeEvent
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-footer-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-footer-label'
      }, startLabel || endLabel ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', startLabel), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${separator || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', endLabel)] : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-footer-custom'
      }, footerSlot ? footerSlot({}) : [renderShortcutBtn('footer')]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-footer-btns'
      }, [showClearBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        size: 'mini',
        disabled: !(startValue || endValue),
        content: getI18n('vxe.button.clear'),
        onClick: clearValueEvent
      }) : renderEmptyElement($xeDateRangePicker), showConfirmBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        size: 'mini',
        status: 'primary',
        content: getI18n('vxe.button.confirm'),
        onClick: confirmEvent
      }) : renderEmptyElement($xeDateRangePicker)])])]), rightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-right-wrapper'
      }, rightSlot({})) : renderShortcutBtn('right', true)]), bottomSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-bottom-wrapper'
      }, bottomSlot({})) : renderShortcutBtn('bottom')])] : [])]);
    };
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--prefix-icon'
      }, prefixSlot ? vn_getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : null;
    };
    const renderSuffixIcon = () => {
      const {
        suffixIcon
      } = props;
      const {
        startValue,
        endValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-range-picker--suffix', {
          'is--clear': isClearable && !isDisabled && (startValue || endValue)
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : renderEmptyElement($xeDateRangePicker), renderExtraSuffixIcon(), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? vn_getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : renderEmptyElement($xeDateRangePicker)]);
    };
    const renderExtraSuffixIcon = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--control-icon',
        onClick: dateRangePickerOpenEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-date-range-picker--date-picker-icon', getIcon().DATE_PICKER_DATE]
      })]);
    };
    const renderVN = () => {
      const {
        className,
        type,
        name,
        autoComplete
      } = props;
      const {
        startValue,
        endValue,
        visiblePanel,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const inputLabel = computeInputLabel.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-date-range-picker--readonly', `type--${type}`, className]
        }, inputLabel);
      }
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon();
      const suffix = renderSuffixIcon();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-date-range-picker', `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          'is--prefix': !!prefix,
          'is--suffix': !!suffix,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--active': isActivated,
          'show--clear': isClearable && !isDisabled && (startValue || endValue)
        }],
        spellcheck: false
      }, [prefix || renderEmptyElement($xeDateRangePicker), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-date-range-picker--inner',
        value: inputLabel,
        name,
        type: 'text',
        placeholder: inpPlaceholder,
        readonly: true,
        disabled: isDisabled,
        autocomplete: autoComplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onClick: clickEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), suffix || renderEmptyElement($xeDateRangePicker),
      // ä¸æé¢æ¿
      renderPanel()]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      updateModelValue(true);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeMVal, () => {
      updateModelValue(false);
    });
    updateModelValue(true);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      globalEvents.on($xeDateRangePicker, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeDateRangePicker, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeDateRangePicker, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeDateRangePicker, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xeDateRangePicker, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onDeactivated)(() => {
      checkValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeDateRangePicker, 'mousewheel');
      globalEvents.off($xeDateRangePicker, 'mousedown');
      globalEvents.off($xeDateRangePicker, 'blur');
      globalEvents.off($xeDateRangePicker, 'resize');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      checkValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeDateRangePicker', $xeDateRangePicker);
    $xeDateRangePicker.renderVN = renderVN;
    return $xeDateRangePicker;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/date-range-picker/index.ts



const VxeDateRangePicker = Object.assign({}, date_range_picker, {
  install(app) {
    app.component(date_range_picker.name, date_range_picker);
  }
});
dynamicApp.use(VxeDateRangePicker);
index_esm_VxeUI.component(date_range_picker);
const DateRangePicker = VxeDateRangePicker;
/* harmony default export */ var packages_date_range_picker = (VxeDateRangePicker);
;// CONCATENATED MODULE: ./packages/loading/index.ts



const VxeLoading = Object.assign({}, src_loading, {
  install(app) {
    app.component(src_loading.name, src_loading);
  }
});
const LoadingController = {
  open(options) {
    const opts = Object.assign({}, options);
    dynamicStore.globalLoading = {
      modelValue: true,
      text: opts.text,
      icon: opts.icon
    };
    checkDynamic();
  },
  close() {
    dynamicStore.globalLoading = null;
  }
};
dynamicApp.use(VxeLoading);
index_esm_VxeUI.component(src_loading);
index_esm_VxeUI.loading = LoadingController;
const Loading = VxeLoading;
/* harmony default export */ var loading = (VxeLoading);
;// CONCATENATED MODULE: ./packages/drawer/src/drawer.ts










const allActiveDrawers = [];
/* harmony default export */ var drawer = (defineVxeComponent({
  name: 'VxeDrawer',
  props: {
    modelValue: Boolean,
    id: String,
    title: String,
    loading: {
      type: Boolean,
      default: null
    },
    className: String,
    position: {
      type: [String, Object],
      default: () => getConfig().drawer.position
    },
    lockView: {
      type: Boolean,
      default: () => getConfig().drawer.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => getConfig().drawer.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().drawer.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => getConfig().drawer.escClosable
    },
    cancelClosable: {
      type: Boolean,
      default: () => getConfig().drawer.cancelClosable
    },
    confirmClosable: {
      type: Boolean,
      default: () => getConfig().drawer.confirmClosable
    },
    showHeader: {
      type: Boolean,
      default: () => getConfig().drawer.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => getConfig().drawer.showFooter
    },
    showClose: {
      type: Boolean,
      default: () => getConfig().drawer.showClose
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => getConfig().drawer.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().drawer.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => getConfig().drawer.confirmButtonText
    },
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().drawer.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().drawer.showTitleOverflow
    },
    width: [Number, String],
    height: [Number, String],
    resize: {
      type: Boolean,
      default: () => getConfig().drawer.resize
    },
    zIndex: Number,
    transfer: {
      type: Boolean,
      default: () => getConfig().drawer.transfer
    },
    padding: {
      type: Boolean,
      default: () => getConfig().drawer.padding
    },
    size: {
      type: String,
      default: () => getConfig().drawer.size || getConfig().size
    },
    beforeHideMethod: {
      type: Function,
      default: () => getConfig().drawer.beforeHideMethod
    },
    slots: Object
  },
  emits: ['update:modelValue', 'show', 'hide', 'before-hide', 'close', 'confirm', 'cancel', 'resize'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeParentDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refDrawerBox = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refConfirmBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refCancelBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      visible: false,
      contentVisible: false,
      drawerZIndex: 0,
      resizeFlag: 1
    });
    const refMaps = {
      refElem
    };
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().modal.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeParentDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeDragType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      switch (props.position) {
        case 'top':
          return 'sb';
        case 'bottom':
          return 'st';
        case 'left':
          return 'wr';
      }
      return 'wl';
    });
    const computeMaps = {};
    const $xeDrawer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getBox = () => {
      const boxElem = refDrawerBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const {
        width,
        height
      } = props;
      const boxElem = getBox();
      if (boxElem) {
        boxElem.style.width = toCssUnit(width);
        boxElem.style.height = toCssUnit(height);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      const {
        drawerZIndex
      } = reactData;
      if (zIndex) {
        reactData.drawerZIndex = zIndex;
      } else if (drawerZIndex < getLastZIndex()) {
        reactData.drawerZIndex = nextZIndex();
      }
    };
    const closeDrawer = type => {
      const {
        beforeHideMethod
      } = props;
      const {
        visible
      } = reactData;
      const params = {
        type
      };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then(rest => {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(rest)) {
            reactData.contentVisible = false;
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(allActiveDrawers, item => item === $xeDrawer);
            dispatchEvent('before-hide', params, null);
            setTimeout(() => {
              reactData.visible = false;
              emit('update:modelValue', false);
              dispatchEvent('hide', params, null);
            }, 200);
          }
        }).catch(e => e);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const closeEvent = evnt => {
      const type = 'close';
      dispatchEvent(type, {
        type
      }, evnt);
      closeDrawer(type);
    };
    const confirmEvent = evnt => {
      const {
        confirmClosable
      } = props;
      const type = 'confirm';
      dispatchEvent(type, {
        type
      }, evnt);
      if (confirmClosable) {
        closeDrawer(type);
      }
    };
    const cancelEvent = evnt => {
      const {
        cancelClosable
      } = props;
      const type = 'cancel';
      dispatchEvent(type, {
        type
      }, evnt);
      if (cancelClosable) {
        closeDrawer(type);
      }
    };
    const openDrawer = () => {
      const {
        showFooter
      } = props;
      const {
        initialized,
        visible
      } = reactData;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveDrawers.push($xeDrawer);
        setTimeout(() => {
          recalculate();
          reactData.contentVisible = true;
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = '';
            const params = {
              type
            };
            emit('update:modelValue', true);
            dispatchEvent('show', params, null);
          });
        }, 10);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $drawer: $xeDrawer
      }, params));
    };
    const drawerMethods = {
      dispatchEvent,
      open: openDrawer,
      close() {
        return closeDrawer('close');
      },
      getBox
    };
    const selfClickEvent = evnt => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = 'mask';
        closeDrawer(type);
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastDrawer = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().max(allActiveDrawers, item => item.reactData.drawerZIndex);
        // å¤ä¸ªæ¶ï¼åªå³ææä¸å±ççªå£
        if (lastDrawer) {
          setTimeout(() => {
            if (lastDrawer === $xeDrawer && lastDrawer.props.escClosable) {
              const type = 'exit';
              dispatchEvent('close', {
                type
              }, evnt);
              closeDrawer(type);
            }
          }, 10);
        }
      }
    };
    const boxMousedownEvent = () => {
      const {
        drawerZIndex
      } = reactData;
      if (allActiveDrawers.some(comp => comp.reactData.visible && comp.reactData.drawerZIndex > drawerZIndex)) {
        updateZindex();
      }
    };
    const dragEvent = evnt => {
      evnt.preventDefault();
      const {
        visibleHeight,
        visibleWidth
      } = getDomNode();
      const marginSize = 0;
      const targetElem = evnt.target;
      const type = targetElem.getAttribute('type');
      const minWidth = 0;
      const minHeight = 0;
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = {
        type: 'resize'
      };
      document.onmousemove = evnt => {
        evnt.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case 'wl':
            dragLeft = disX - evnt.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case 'st':
            dragTop = disY - evnt.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case 'wr':
            dragLeft = evnt.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case 'sb':
            dragTop = evnt.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, '') + ' is--drag';
        dispatchEvent('resize', params, evnt);
        reactData.resizeFlag++;
      };
      document.onmouseup = () => {
        document.onmousemove = null;
        document.onmouseup = null;
        reactData.resizeFlag++;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, '');
        }, 50);
      };
    };
    const formDesignPrivateMethods = {};
    Object.assign($xeDrawer, drawerMethods, formDesignPrivateMethods);
    const renderTitles = () => {
      const {
        slots: propSlots = {},
        showClose,
        title
      } = props;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--header-title'
      }, titleSlot ? vn_getSlotVNs(titleSlot({
        $drawer: $xeDrawer
      })) : title ? getFuncText(title) : getI18n('vxe.alert.title')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--header-right'
      }, [cornerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--corner-wrapper'
      }, vn_getSlotVNs(cornerSlot({
        $drawer: $xeDrawer
      }))) : renderEmptyElement($xeDrawer), showClose ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-drawer--close-btn', 'trigger--btn'],
        title: getI18n('vxe.drawer.close'),
        onClick: closeEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().DRAWER_CLOSE
      })]) : renderEmptyElement($xeDrawer)])];
    };
    const renderHeader = () => {
      const {
        slots: propSlots = {},
        showTitleOverflow
      } = props;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-drawer--header', {
            'is--ellipsis': showTitleOverflow
          }]
        }, headerSlot ? vn_getSlotVNs(headerSlot({
          $drawer: $xeDrawer
        })) : renderTitles());
      }
      return renderEmptyElement($xeDrawer);
    };
    const renderBody = () => {
      const {
        slots: propSlots = {},
        content
      } = props;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--body'
      }, [leftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--body-left'
      }, vn_getSlotVNs(leftSlot({
        $drawer: $xeDrawer
      }))) : renderEmptyElement($xeDrawer), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--body-default'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--content'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({
        $drawer: $xeDrawer
      })) : getFuncText(content))]), rightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--body-right'
      }, vn_getSlotVNs(rightSlot({
        $drawer: $xeDrawer
      }))) : renderEmptyElement($xeDrawer), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(loading, {
        class: 'vxe-drawer--loading',
        modelValue: props.loading
      })]);
    };
    const renderDefaultFooter = () => {
      const {
        slots: propSlots = {},
        showCancelButton,
        showConfirmButton,
        loading
      } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (showCancelButton) {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || getI18n('vxe.button.cancel'),
          onClick: cancelEvent
        }));
      }
      if (showConfirmButton) {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 2,
          ref: refConfirmBtn,
          loading: loading,
          status: 'primary',
          content: props.confirmButtonText || getI18n('vxe.button.confirm'),
          onClick: confirmEvent
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--footer-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--footer-left'
      }, lfSlot ? vn_getSlotVNs(lfSlot({
        $drawer: $xeDrawer
      })) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--footer-right'
      }, rfSlot ? vn_getSlotVNs(rfSlot({
        $drawer: $xeDrawer
      })) : btnVNs)]);
    };
    const renderFooter = () => {
      const {
        slots: propSlots = {}
      } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-drawer--footer'
        }, footerSlot ? vn_getSlotVNs(footerSlot({
          $drawer: $xeDrawer
        })) : [renderDefaultFooter()]);
      }
      return renderEmptyElement($xeDrawer);
    };
    const renderVN = () => {
      const {
        slots: propSlots = {},
        className,
        position,
        loading,
        lockScroll,
        padding,
        lockView,
        mask,
        resize,
        destroyOnClose
      } = props;
      const {
        initialized,
        contentVisible,
        visible
      } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      const dragType = computeDragType.value;
      const btnTransfer = computeBtnTransfer.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-drawer--wrapper', `pos--${position}`, className || '', {
          [`size--${vSize}`]: vSize,
          'is--padding': padding,
          'lock--scroll': lockScroll,
          'lock--view': lockView,
          'is--resize': resize,
          'is--mask': mask,
          'is--visible': contentVisible,
          'is--active': visible,
          'is--loading': loading
        }],
        style: {
          zIndex: reactData.drawerZIndex
        },
        onClick: selfClickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refDrawerBox,
        class: 'vxe-drawer--box',
        onMousedown: boxMousedownEvent
      }, [asideSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--aside'
      }, vn_getSlotVNs(asideSlot({
        $drawer: $xeDrawer
      }))) : renderEmptyElement($xeDrawer), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--container'
      }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [renderHeader(), renderBody(), renderFooter(), resize ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-drawer--resize'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: `${dragType}-resize`,
        type: dragType,
        onMousedown: dragEvent
      })]) : renderEmptyElement($xeDrawer)])])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.width, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, value => {
      if (value) {
        openDrawer();
      } else {
        closeDrawer('model');
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (props.modelValue) {
          openDrawer();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeDrawer, 'keydown', handleGlobalKeydownEvent);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeDrawer, 'keydown');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeDrawer', $xeDrawer);
    $xeDrawer.renderVN = renderVN;
    return $xeDrawer;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/drawer/index.ts





function handleDrawer(options) {
  // ä½¿ç¨å¨æç»ä»¶æ¸²æå¨æå¼¹æ¡
  checkDynamic();
  return new Promise(resolve => {
    if (options && options.id && allActiveDrawers.some(comp => comp.props.id === options.id)) {
      resolve('exist');
    } else {
      const _onHide = options.onHide;
      const drawerOpts = Object.assign(options, {
        key: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId(),
        modelValue: true,
        onHide(params) {
          const drawerList = dynamicStore.drawers;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.drawers = drawerList.filter(item => item.key !== drawerOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.drawers.push(drawerOpts);
    }
  });
}
function getDrawer(id) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(allActiveDrawers, $drawer => $drawer.props.id === id);
}
/**
 * å¨å±å³é­å¨æçæ´»å¨çªå£ï¼åªè½ç¨äºå³é­å¨æçåå»ºçæ´»å¨çªå£ï¼
 * å¦æä¼  id åå³é­æå®ççªå£
 * å¦æä¸ä¼ åå³é­ææçªå£
 */
function closeDrawer(id) {
  const drawers = id ? [getDrawer(id)] : allActiveDrawers;
  const restPromises = [];
  drawers.forEach($drawer => {
    if ($drawer) {
      restPromises.push($drawer.close());
    }
  });
  return Promise.all(restPromises);
}
function openDrawer(options) {
  return handleDrawer(Object.assign({}, options));
}
const DrawerController = {
  get: getDrawer,
  close: closeDrawer,
  open: openDrawer
};
const VxeDrawer = Object.assign(drawer, {
  install: function (app) {
    app.component(drawer.name, drawer);
  }
});
index_esm_VxeUI.drawer = DrawerController;
dynamicApp.use(VxeDrawer);
index_esm_VxeUI.component(drawer);
const Drawer = VxeDrawer;
/* harmony default export */ var packages_drawer = (VxeDrawer);
;// CONCATENATED MODULE: ./packages/empty/src/empty.ts




/* harmony default export */ var empty = (defineVxeComponent({
  name: 'VxeEmpty',
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    status: String,
    content: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeEmpty = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $empty: $xeEmpty
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeEmpty, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const {
        imageUrl,
        imageStyle,
        icon,
        status,
        content
      } = props;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-empty', {
          [`theme--${status}`]: status
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-empty--inner'
      }, [imageUrl ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-empty--img-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
        src: imageUrl,
        style: imageStyle
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-empty--icon-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon || getIcon().EMPTY_DEFAULT
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-empty--content-wrapper'
      }, `${content || getI18n('vxe.empty.defText')}`)])]);
    };
    $xeEmpty.renderVN = renderVN;
    return $xeEmpty;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/empty/index.ts



const VxeEmpty = Object.assign({}, empty, {
  install(app) {
    app.component(empty.name, empty);
  }
});
dynamicApp.use(VxeEmpty);
index_esm_VxeUI.component(empty);
const Empty = VxeEmpty;
/* harmony default export */ var packages_empty = (VxeEmpty);
;// CONCATENATED MODULE: ./packages/form/src/itemInfo.ts



class ItemInfo {
  constructor($xeForm, item) {
    const {
      field,
      itemRender,
      formatter
    } = item;
    if (formatter) {
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(formatter)) {
        const gFormatOpts = formats.get(formatter);
        if (!gFormatOpts || !gFormatOpts.formItemFormatMethod) {
          errLog('vxe.error.notFormats', [`[form] ${formatter}`]);
        }
      } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(formatter)) {
        const gFormatOpts = formats.get(formatter[0]);
        if (!gFormatOpts || !gFormatOpts.formItemFormatMethod) {
          errLog('vxe.error.notFormats', [`[form] ${formatter[0]}`]);
        }
      }
    }
    if (field && itemRender) {
      if (itemRender.startField && `${itemRender.startField}`.indexOf(field) >= 0) {
        errLog('vxe.error.modelConflicts', [`[form] field=${field}`, `item-render.startField=${itemRender.startField}`]);
      }
      if (itemRender.endField && `${itemRender.endField}`.indexOf(field) >= 0) {
        errLog('vxe.error.modelConflicts', [`[form] field=${field}`, `item-render.endField=${itemRender.endField}`]);
      }
    }
    Object.assign(this, {
      id: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('item_'),
      title: item.title,
      field: field,
      span: item.span,
      align: item.align,
      verticalAlign: item.verticalAlign,
      titleBackground: item.titleBackground,
      titleBold: item.titleBold,
      titleAlign: item.titleAlign,
      titleWidth: item.titleWidth,
      titleColon: item.titleColon,
      vertical: item.vertical,
      padding: item.padding,
      titleAsterisk: item.titleAsterisk,
      titlePrefix: item.titlePrefix,
      titleSuffix: item.titleSuffix,
      titleOverflow: item.titleOverflow,
      showTitle: item.showTitle,
      resetValue: item.resetValue,
      visibleMethod: item.visibleMethod,
      visible: item.visible,
      showContent: item.showContent,
      folding: item.folding,
      collapseNode: item.collapseNode,
      className: item.className,
      contentClassName: item.contentClassName,
      contentStyle: item.contentStyle,
      titleClassName: item.titleClassName,
      titleStyle: item.titleStyle,
      itemRender: itemRender,
      rules: item.rules,
      formatter,
      // èªå®ä¹åæ°
      params: item.params,
      // æ¸²æå±æ§
      showError: false,
      showIconMsg: false,
      errRule: null,
      slots: item.slots,
      children: []
    });
  }
  update(name, value) {
    this[name] = value;
  }
}
;// CONCATENATED MODULE: ./packages/form/src/util.ts






function isFormItem(item) {
  return item instanceof ItemInfo;
}
function createItem($xeForm, _vm) {
  return isFormItem(_vm) ? _vm : new ItemInfo($xeForm, _vm);
}
function handleFieldOrItem($xeForm, fieldOrItem) {
  if (fieldOrItem) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrItem) ? $xeForm.getItemByField(fieldOrItem) : fieldOrItem;
  }
  return null;
}
function isHiddenItem($xeForm, formItem) {
  const {
    reactData
  } = $xeForm;
  const {
    collapseAll
  } = reactData;
  const {
    folding,
    visible
  } = formItem;
  return visible === false || folding && collapseAll;
}
function isActiveItem($xeForm, formItem) {
  const $xeGrid = $xeForm.xeGrid;
  let {
    visibleMethod,
    itemRender,
    visible,
    field
  } = formItem;
  if (visible === false) {
    return visible;
  }
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const fiVisibleMethod = compConf ? compConf.formItemVisibleMethod || compConf.itemVisibleMethod : null;
  if (!visibleMethod && fiVisibleMethod) {
    visibleMethod = fiVisibleMethod;
  }
  if (!visibleMethod) {
    return true;
  }
  const formProps = $xeForm.props;
  const {
    data
  } = formProps;
  return visibleMethod({
    data,
    field,
    property: field,
    item: formItem,
    $form: $xeForm,
    $grid: $xeGrid
  });
}
function watchItem(props, formItem) {
  Object.keys(props).forEach(name => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props[name], value => {
      formItem.update(name, value);
    });
  });
}
function assembleItem($xeForm, el, formItem, formGroup) {
  const {
    reactData
  } = $xeForm;
  const formProps = $xeForm.props;
  const {
    customLayout
  } = formProps;
  const {
    staticItems
  } = reactData;
  if (customLayout) {
    if (!staticItems.some(item => item.id === formItem.id)) {
      staticItems.push(formItem);
    }
  } else {
    if (el) {
      const parentElem = el.parentNode;
      const parentItem = formGroup ? formGroup.formItem : null;
      const parentItems = parentItem ? parentItem.children : staticItems;
      if (parentElem) {
        parentItems.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, el), 0, formItem);
        reactData.staticItems = staticItems.slice(0);
      }
    }
  }
}
function destroyItem($xeForm, formItem) {
  const {
    reactData
  } = $xeForm;
  const {
    staticItems
  } = reactData;
  const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(staticItems, item => item.id === formItem.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  reactData.staticItems = staticItems.slice(0);
}
;// CONCATENATED MODULE: ./packages/icon/src/icon.ts




/* harmony default export */ var icon = (defineVxeComponent({
  name: 'VxeIcon',
  props: {
    name: String,
    className: String,
    roll: Boolean,
    status: String,
    size: {
      type: String,
      default: () => getConfig().icon.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const $xeIcon = {
      xID,
      props,
      context
    };
    const clickEvent = evnt => {
      emit('click', createEvent(evnt, {}));
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $icon: $xeIcon
      }, params));
    };
    const iconMethods = {
      dispatchEvent
    };
    const iconPrivateMethods = {};
    Object.assign($xeIcon, iconMethods, iconPrivateMethods);
    const renderVN = () => {
      const {
        name,
        roll,
        status,
        className
      } = props;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-icon', `vxe-icon-${name}`, `${className || ''}`, {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          roll: roll
        }],
        onClick: clickEvent
      });
    };
    $xeIcon.renderVN = renderVN;
    return $xeIcon;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form/src/render.ts










function renderPrefixIcon(titlePrefix) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-form--item-title-tip-prefix'
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(icon, {
    class: titlePrefix.icon || getIcon().FORM_PREFIX,
    status: titlePrefix.iconStatus
  })]);
}
function renderSuffixIcon(titleSuffix) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-form--item-title-tip-suffix'
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(icon, {
    class: titleSuffix.icon || getIcon().FORM_SUFFIX,
    status: titleSuffix.iconStatus
  })]);
}
function getItemClass($xeForm, item, isGroup) {
  const formProps = $xeForm.props;
  const formReactData = $xeForm.reactData;
  const $xeGrid = $xeForm.xeGrid;
  const {
    computeSize,
    computeValidOpts
  } = $xeForm.getComputeMaps();
  const {
    data,
    rules,
    readonly,
    disabled,
    span: allSpan,
    titleBackground: allTitleBackground,
    titleBold: allTitleBold,
    titleColon: allTitleColon,
    titleAsterisk: allTitleAsterisk,
    vertical: allVertical,
    padding: allPadding
  } = formProps;
  const {
    collapseAll
  } = formReactData;
  const {
    folding,
    field,
    itemRender,
    showError,
    className,
    vertical,
    padding,
    children,
    showContent
  } = item;
  const vSize = computeSize.value;
  const validOpts = computeValidOpts.value;
  const {
    showErrorMessage,
    showMessage,
    showErrorIcon
  } = validOpts;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemClassName = compConf ? compConf.formItemClassName || compConf.itemClassName : '';
  const span = item.span || allSpan;
  const itemPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(padding) ? allPadding : padding;
  const itemVertical = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(vertical) ? allVertical : vertical;
  const titleBackground = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleBackground) ? allTitleBackground : item.titleBackground;
  const titleBold = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleBold) ? allTitleBold : item.titleBold;
  const titleColon = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleColon) ? allTitleColon : item.titleColon;
  const titleAsterisk = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
  const params = {
    data,
    disabled,
    readonly,
    field,
    property: field,
    item,
    $form: $xeForm,
    $grid: $xeGrid
  };
  const hasGroup = children && children.length > 0;
  let isRequired = false;
  let isValid = false;
  if (!readonly && rules) {
    const itemRules = rules[field];
    if (itemRules && itemRules.length) {
      isValid = true;
      isRequired = itemRules.some(rule => rule.required);
    }
  }
  return [isGroup || hasGroup ? 'vxe-form--group' : '', 'vxe-form--item', item.id, span ? `vxe-form--item-col_${span} is--span` : '', `${(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showErrorMessage) ? showErrorMessage : showMessage) ? 'show' : 'hide'}--err-msg`, className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(params) : className : '', itemClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemClassName) ? itemClassName(params) : itemClassName : '', {
    [`size--${vSize}`]: vSize,
    'is--colon': titleColon,
    'is--tbg': titleBackground,
    'is--bold': titleBold,
    'is--padding': itemPadding,
    'is--vertical': itemVertical,
    'is--asterisk': titleAsterisk,
    'hide--content': showContent === false,
    'is--valid': isValid,
    'is--required': isRequired,
    'is--hidden': folding && collapseAll,
    'is--active': isActiveItem($xeForm, item),
    'err--icon': showErrorIcon,
    'is--error': showError
  }];
}
function getItemContentClass($xeForm, item, isGroup) {
  const formProps = $xeForm.props;
  const $xeGrid = $xeForm.xeGrid;
  const {
    data,
    readonly,
    disabled,
    align: allAlign,
    verticalAlign: allVerticalAlign
  } = formProps;
  const {
    field,
    itemRender,
    contentClassName,
    children
  } = item;
  const hasGroup = children && children.length > 0;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemContentClassName = compConf ? compConf.formItemContentClassName || compConf.itemContentClassName : '';
  const align = hasGroup ? item.align : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.align) ? allAlign : item.align;
  const verticalAlign = hasGroup ? item.verticalAlign : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.verticalAlign) ? allVerticalAlign : item.verticalAlign;
  const params = {
    data,
    disabled,
    readonly,
    field,
    property: field,
    item,
    $form: $xeForm,
    $grid: $xeGrid
  };
  return [isGroup || hasGroup ? 'vxe-form--group-content vxe-form--item-row' : '', 'vxe-form--item-content', align ? `align--${align}` : '', verticalAlign ? `vertical-align--${verticalAlign}` : '', itemContentClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : '', contentClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentClassName) ? contentClassName(params) : contentClassName : ''];
}
function renderTitle($xeForm, item, isGroup) {
  const formProps = $xeForm.props;
  const $xeGrid = $xeForm.xeGrid;
  const {
    data,
    readonly,
    disabled,
    titleAlign: allTitleAlign,
    titleWidth: allTitleWidth,
    titleOverflow: allTitleOverflow,
    vertical: allVertical
  } = formProps;
  const {
    slots,
    title,
    field,
    itemRender,
    titleOverflow,
    vertical,
    showTitle,
    titleClassName,
    titleStyle,
    titlePrefix,
    titleSuffix,
    children,
    showContent
  } = item;
  const {
    computeTooltipOpts
  } = $xeForm.getComputeMaps();
  const tooltipOpts = computeTooltipOpts.value;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemTitleClassName = compConf ? compConf.formItemTitleClassName || compConf.itemTitleClassName : '';
  const itemTitleStyle = compConf ? compConf.formItemTitleStyle || compConf.itemTitleStyle : null;
  const itemVertical = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(vertical) ? allVertical : vertical;
  const titleAlign = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
  const titleWidth = itemVertical ? null : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
  const itemOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(titleOverflow) ? allTitleOverflow : titleOverflow;
  const ovEllipsis = itemOverflow === 'ellipsis';
  const ovTitle = itemOverflow === 'title';
  const ovTooltip = itemOverflow === true || itemOverflow === 'tooltip';
  const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
  const params = {
    data,
    disabled,
    readonly,
    field,
    property: field,
    item,
    $form: $xeForm,
    $grid: $xeGrid
  };
  const titleSlot = slots ? slots.title : null;
  const prefixSlot = slots ? slots.prefix : null;
  const suffixSlot = slots ? slots.suffix || slots.extra : null;
  const isTitle = showTitle !== false && (title || titleSlot);
  const hasGroup = children && children.length > 0;
  const titVNs = [];
  if (prefixSlot) {
    titVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      key: 'pt',
      class: 'vxe-form--item-title-prefix'
    }, $xeForm.callSlot(prefixSlot, params)));
  }
  if (titlePrefix) {
    titVNs.push(titlePrefix.content || titlePrefix.message ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tooltip, {
      key: 'pm',
      ...tooltipOpts,
      ...titlePrefix,
      content: getFuncText(titlePrefix.content || titlePrefix.message)
    }, {
      default: () => renderPrefixIcon(titlePrefix)
    }) : renderPrefixIcon(titlePrefix));
  }
  const rftTitle = compConf ? compConf.renderFormItemTitle || compConf.renderItemTitle : null;
  titVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    key: 'pl',
    class: 'vxe-form--item-title-label'
  }, titleSlot ? $xeForm.callSlot(titleSlot, params) : rftTitle ? vn_getSlotVNs(rftTitle(itemRender, params)) : getFuncText(item.title)));
  const fixVNs = [];
  if (titleSuffix) {
    fixVNs.push(titleSuffix.content || titleSuffix.message ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tooltip, {
      key: 'sm',
      ...tooltipOpts,
      ...titleSuffix,
      content: getFuncText(titleSuffix.content || titleSuffix.message)
    }, {
      default: () => renderSuffixIcon(titleSuffix)
    }) : renderSuffixIcon(titleSuffix));
  }
  if (suffixSlot) {
    fixVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      key: 'st',
      class: 'vxe-form--item-title-suffix'
    }, $xeForm.callSlot(suffixSlot, params)));
  }
  const ons = ovTooltip ? {
    onMouseenter(evnt) {
      $xeForm.triggerTitleTipEvent(evnt, params);
    },
    onMouseleave: $xeForm.handleTitleTipLeaveEvent
  } : {};
  const itStyle = Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(titleStyle) ? titleStyle(params) : titleStyle);
  if (titleWidth && titleWidth !== 'auto' && showContent !== false) {
    itStyle.width = toCssUnit(titleWidth);
  }
  return isTitle ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: [isGroup || hasGroup ? 'vxe-form--group-title' : '', 'vxe-form--item-title', titleAlign ? `align--${titleAlign}` : '', hasEllipsis ? 'is--ellipsis' : '', itemTitleClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : '', titleClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(titleClassName) ? titleClassName(params) : titleClassName : ''],
    style: itStyle,
    itemid: item.id,
    title: ovTitle ? getFuncText(title) : null,
    ...ons
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: 'vxe-form--item-title-content'
  }, titVNs), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: 'vxe-form--item-title-postfix'
  }, fixVNs)]) : renderEmptyElement($xeForm);
}
function renderItemErrorIcon($xeForm, item) {
  const {
    computeValidOpts
  } = $xeForm.getComputeMaps();
  const validOpts = computeValidOpts.value;
  const {
    showErrorIcon,
    errorIcon
  } = validOpts;
  const {
    errRule,
    showIconMsg
  } = item;
  if (!showErrorIcon) {
    return renderEmptyElement($xeForm);
  }
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    key: 'emi',
    class: ['vxe-form-item--valid-error-icon-wrapper', {
      'is--show': showIconMsg,
      'is--hide': !showIconMsg
    }]
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-form-item--valid-error-icon-btn',
    onClick(evnt) {
      $xeForm.handleValidIconEvent(evnt, {
        item
      });
    }
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
    class: errorIcon || getIcon().FORM_VALID_ERROR_ICON
  })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: 'vxe-form-item--valid-error-icon-msg-tip'
  }, errRule ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: `vxe-form-item--valid-error-icon-msg vxe-form-item--valid-error-icon-theme-${validOpts.theme || 'normal'}`
  }, errRule.content || errRule.message)] : [])]);
}
function renderItemContent($xeForm, item) {
  const formProps = $xeForm.props;
  const formReactData = $xeForm.reactData;
  const formInternalData = $xeForm.internalData;
  const $xeGrid = $xeForm.xeGrid;
  const {
    computeCollapseOpts,
    computeValidOpts
  } = $xeForm.getComputeMaps();
  const {
    itemFormatCache
  } = formInternalData;
  const {
    data,
    readonly,
    disabled
  } = formProps;
  const {
    collapseAll
  } = formReactData;
  const {
    slots,
    field,
    itemRender,
    collapseNode,
    errRule,
    formatter
  } = item;
  const defaultSlot = slots ? slots.default : null;
  const validSlot = slots ? slots.valid : null;
  const collapseOpts = computeCollapseOpts.value;
  const validOpts = computeValidOpts.value;
  const {
    showErrorMessage,
    showMessage
  } = validOpts;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  const params = {
    data,
    disabled,
    readonly,
    field,
    property: field,
    item,
    itemValue,
    $form: $xeForm,
    $grid: $xeGrid
  };
  let contentVNs = [];
  const rftContent = compConf ? compConf.renderFormItemContent || compConf.renderItemContent : null;
  if (defaultSlot) {
    contentVNs = $xeForm.callSlot(defaultSlot, params);
  } else if (rftContent) {
    contentVNs = vn_getSlotVNs(rftContent(itemRender, params));
  } else if (field) {
    let itemLabel = itemValue;
    if (formatter) {
      let formatData;
      if (field) {
        const itemRest = itemFormatCache[field];
        if (itemRest) {
          formatData = itemRest.formatData;
          if (formatData) {
            if (formatData.value === itemValue) {
              return formatData.label;
            }
          } else {
            formatData = itemRest.formatData = {};
          }
        } else {
          itemFormatCache[field] = {
            field
          };
        }
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(formatter)) {
        const gFormatOpts = formats.get(formatter);
        const fiFormatMethod = gFormatOpts ? gFormatOpts.formItemFormatMethod : null;
        itemLabel = fiFormatMethod ? fiFormatMethod(params) : '';
      } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(formatter)) {
        const gFormatOpts = formats.get(formatter[0]);
        const fiFormatMethod = gFormatOpts ? gFormatOpts.formItemFormatMethod : null;
        itemLabel = fiFormatMethod ? fiFormatMethod(params, ...formatter.slice(1)) : '';
      } else {
        itemLabel = formatter(params);
      }
      if (formatData) {
        formatData.value = itemValue;
        formatData.label = itemLabel;
      }
    }
    contentVNs = [eqEmptyValue(itemLabel) ? '' : `${itemLabel}`];
  }
  if (collapseNode) {
    contentVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-form--item-trigger-node',
      onClick: $xeForm.toggleCollapseEvent
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-form--item-trigger-text'
    }, collapseAll ? collapseOpts.unfoldButtonText || getI18n('vxe.form.unfolding') : collapseOpts.foldButtonText || getI18n('vxe.form.folding')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: ['vxe-form--item-trigger-icon', collapseAll ? collapseOpts.foldIcon || getIcon().FORM_FOLDING : collapseOpts.unfoldIcon || getIcon().FORM_UNFOLDING]
    })]));
  }
  if (errRule && (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showErrorMessage) ? showErrorMessage : showMessage)) {
    const validParams = {
      ...params,
      rule: errRule
    };
    contentVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-form-item--valid-error-tip',
      style: errRule.maxWidth ? {
        width: toCssUnit(errRule.maxWidth)
      } : null
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: `vxe-form-item--valid-error-wrapper vxe-form-item--valid-error-theme-${validOpts.theme || 'normal'}`
    }, [validSlot ? $xeForm.callSlot(validSlot, validParams) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-form--item--valid-error-msg'
    }, errRule.content || errRule.message)]])]));
  }
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    key: 'ct',
    class: 'vxe-form--item-inner'
  }, contentVNs);
}
;// CONCATENATED MODULE: ./packages/form/src/form-config-item.ts






const VxeFormConfigItem = defineVxeComponent({
  name: 'VxeFormConfigItem',
  props: {
    itemConfig: Object
  },
  setup(props) {
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', {});
    const xeformiteminfo = {
      itemConfig: props.itemConfig
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeFormItemInfo', xeformiteminfo);
    const renderItem = ($xeForm, item) => {
      const formProps = $xeForm.props;
      const $xeGrid = $xeForm.xeGrid;
      const {
        data,
        readonly,
        disabled
      } = formProps;
      const {
        visible,
        field,
        itemRender,
        contentStyle,
        children,
        showContent
      } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const params = {
        data,
        disabled,
        readonly,
        field,
        property: field,
        item,
        $form: $xeForm,
        $grid: $xeGrid
      };
      const hasGroup = children && children.length > 0;
      if (visible === false) {
        return renderEmptyElement($xeForm);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: item.id,
        itemid: item.id,
        class: getItemClass($xeForm, item),
        style: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [renderTitle($xeForm, item), showContent === false ? renderEmptyElement($xeForm) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: getItemContentClass($xeForm, item),
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentStyle) ? contentStyle(params) : contentStyle)
      }, hasGroup ? children.map(childItem => renderItem($xeForm, childItem)) : [renderItemContent($xeForm, item), renderItemErrorIcon($xeForm, item)])]);
    };
    const renderVN = () => {
      return renderItem($xeForm, props.itemConfig);
    };
    const $xeFormconfigitem = {
      renderVN
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormGroup', null);
    return $xeFormconfigitem;
  },
  render() {
    return this.renderVN();
  }
});
/* harmony default export */ var form_config_item = (VxeFormConfigItem);
;// CONCATENATED MODULE: ./packages/form/render/index.ts





const componentDefaultModelProp = 'modelValue';
/**
 * å·²åºå¼
 * @deprecated
 */
function getOldComponentName(name) {
  return `vxe-${`${name || ''}`.replace('$', '')}`;
}
function getDefaultComponent(renderOpts) {
  const {
    name
  } = renderOpts;
  return getComponent(name) || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(`${name}`);
}
/**
 * å·²åºå¼
 * @deprecated
 */
function getOldComponent({
  name
}) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(getOldComponentName(name));
}
function getNativeAttrs(renderOpts) {
  let {
    name,
    attrs
  } = renderOpts;
  if (name === 'input') {
    attrs = Object.assign({
      type: 'text'
    }, attrs);
  }
  return attrs;
}
function getComponentFormItemProps(renderOpts, params, value, defaultProps) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({}, defaultProps, renderOpts.props, {
    [componentDefaultModelProp]: value
  });
}
/**
 * åçäºä»¶å¤ç
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getNativeElementOns(renderOpts, params, modelFunc, changeFunc) {
  const {
    events
  } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
      ons[getOnName(key)] = function (...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function (...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
/**
 * ç»ä»¶äºä»¶å¤ç
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getComponentOns(renderOpts, params, eFns, eventOns) {
  const {
    events
  } = renderOpts;
  const {
    model: modelFunc,
    change: changeFunc
  } = eFns || {};
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const ons = {};
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
    ons[getOnName(key)] = function (...args) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
        errLog('vxe.error.errFunc', [`[form] ${func}`]);
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function (...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return eventOns ? Object.assign(ons, eventOns) : ons;
}
function getItemOns(renderOpts, params) {
  const {
    $form,
    data,
    field
  } = params;
  return getComponentOns(renderOpts, params, {
    model(value) {
      // å¤ç model å¼ååç»å®
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, field, value);
    },
    change() {
      // å¤ç change äºä»¶ç¸å³é»è¾
      $form.updateStatus(params);
    }
  });
}
function getNativeItemOns(renderOpts, params) {
  const {
    $form,
    data,
    field
  } = params;
  return getNativeElementOns(renderOpts, params, evnt => {
    // å¤ç model å¼ååç»å®
    const itemValue = evnt.target.value;
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, field, itemValue);
  }, () => {
    // å¤ç change äºä»¶ç¸å³é»è¾
    $form.updateStatus(params);
  });
}
function renderNativeOptgroup(renderOpts, params, renderOptionsMethods) {
  const {
    optionGroups,
    optionGroupProps = {}
  } = renderOpts;
  const groupOptions = optionGroupProps.options || 'options';
  const groupLabel = optionGroupProps.label || 'label';
  if (optionGroups) {
    return optionGroups.map((group, gIndex) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('optgroup', {
        key: gIndex,
        label: group[groupLabel]
      }, renderOptionsMethods(group[groupOptions], renderOpts, params));
    });
  }
  return [];
}
/**
 * æ¸²æè¡¨å-é¡¹
 * ç¨äºæ¸²æåççæ ç­¾
 */
function nativeItemRender(renderOpts, params) {
  const {
    data,
    field
  } = params;
  const {
    name
  } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(`${name}`, {
    class: `vxe-default-${name}`,
    ...attrs,
    value: attrs && name === 'input' && (attrs.type === 'submit' || attrs.type === 'reset') ? null : itemValue,
    ...getNativeItemOns(renderOpts, params)
  })];
}
function defaultItemRender(renderOpts, params) {
  const {
    data,
    field
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * å·²åºå¼
 * @deprecated
 */
function oldItemRender(renderOpts, params) {
  const {
    data,
    field
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * å·²åºå¼
 * @deprecated
 */
function oldButtonItemRender(renderOpts, params) {
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-button'), {
    ...getComponentFormItemProps(renderOpts, params, null),
    ...getComponentOns(renderOpts, params)
  })];
}
/**
 * å·²åºå¼
 * @deprecated
 */
function oldButtonsItemRender(renderOpts, params) {
  const {
    children
  } = renderOpts;
  return children ? children.map(childRenderOpts => oldButtonItemRender(childRenderOpts, params)[0]) : [];
}
/**
 * æ¸²æåçç select æ ç­¾
 */
function renderNativeFormOptions(options, renderOpts, params) {
  const {
    data,
    field
  } = params;
  const {
    optionProps = {}
  } = renderOpts;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const disabledProp = optionProps.disabled || 'disabled';
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  if (options) {
    return options.map((item, oIndex) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('option', {
        key: oIndex,
        value: item[valueProp],
        disabled: item[disabledProp],
        /* eslint-disable eqeqeq */
        selected: item[valueProp] == cellValue
      }, item[labelProp]);
    });
  }
  return [];
}
/**
 * æ¸²æè¡¨å-é¡¹
 */
function defaultFormItemRender(renderOpts, params) {
  const {
    data,
    field
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
function formItemRadioAndCheckboxRender(renderOpts, params) {
  const {
    options,
    optionProps
  } = renderOpts;
  const {
    data,
    field
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    options,
    optionProps,
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * å·²åºå¼
 * @deprecated
 */
function oldFormItemRadioAndCheckboxRender(renderOpts, params) {
  const {
    name,
    options,
    optionProps = {}
  } = renderOpts;
  const {
    data,
    field
  } = params;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const disabledProp = optionProps.disabled || 'disabled';
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  const compName = getOldComponentName(name);
  // å¦ææ¯åç»
  if (options) {
    return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(`${compName}-group`), {
      ...getComponentFormItemProps(renderOpts, params, itemValue),
      ...getItemOns(renderOpts, params)
    }, {
      default: () => {
        return options.map((item, index) => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(compName), {
            key: index,
            label: item[valueProp],
            content: item[labelProp],
            disabled: item[disabledProp]
          });
        });
      }
    })];
  }
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(compName), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * è¡¨å - æ¸²æå¨
 */
renderer.mixin({
  input: {
    formItemAutoFocus: 'input',
    renderFormItemContent: nativeItemRender
  },
  textarea: {
    formItemAutoFocus: 'textarea',
    renderFormItemContent: nativeItemRender
  },
  select: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('select', {
        class: 'vxe-default-select',
        ...getNativeAttrs(renderOpts),
        ...getNativeItemOns(renderOpts, params)
      }, renderOpts.optionGroups ? renderNativeOptgroup(renderOpts, params, renderNativeFormOptions) : renderNativeFormOptions(renderOpts.options, renderOpts, params))];
    }
  },
  VxeInput: {
    formItemAutoFocus: 'input',
    renderFormItemContent: defaultItemRender
  },
  VxeNumberInput: {
    formItemAutoFocus: 'input',
    renderFormItemContent: defaultItemRender
  },
  VxePasswordInput: {
    formItemAutoFocus: 'input',
    renderFormItemContent: defaultItemRender
  },
  VxeTextarea: {
    formItemAutoFocus: 'textarea',
    renderFormItemContent: defaultItemRender
  },
  VxeDatePicker: {
    formItemAutoFocus: 'input',
    renderFormItemContent: defaultItemRender
  },
  VxeDateRangePicker: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        startField,
        endField
      } = renderOpts;
      const {
        $form,
        data,
        field
      } = params;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      const seProps = {};
      const seOs = {};
      if (startField && endField) {
        seProps.startValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, startField);
        seProps.endValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, endField);
        seOs['onUpdate:startValue'] = value => {
          if (startField) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, startField, value);
          }
        };
        seOs['onUpdate:endValue'] = value => {
          if (endField) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, endField, value);
          }
        };
      }
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, seProps),
        ...getComponentOns(renderOpts, params, {
          model(value) {
            // å¤ç model å¼ååç»å®
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, field, value);
          },
          change() {
            // å¤ç change äºä»¶ç¸å³é»è¾
            $form.updateStatus(params);
          }
        }, seOs)
      })];
    }
  },
  VxeButton: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeButtonGroup: {
    renderFormItemContent(renderOpts, params) {
      const {
        options
      } = renderOpts;
      const {
        data,
        field
      } = params;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        options,
        ...getComponentFormItemProps(renderOpts, params, itemValue),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeSelect: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          options,
          optionProps,
          optionGroups,
          optionGroupProps
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeTreeSelect: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options,
        optionProps
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          options,
          optionProps
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeTableSelect: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options,
        optionProps
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          options,
          optionProps
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeColorPicker: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          colors: options
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeIconPicker: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          icons: options
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeRadio: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeRadioGroup: {
    renderFormItemContent: formItemRadioAndCheckboxRender
  },
  VxeCheckbox: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeCheckboxGroup: {
    renderFormItemContent: formItemRadioAndCheckboxRender
  },
  VxeSwitch: {
    renderFormItemContent: defaultItemRender
  },
  VxeRate: {
    renderFormItemContent: defaultItemRender
  },
  VxeSlider: {
    renderFormItemContent: defaultItemRender
  },
  VxeImage: {
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        props
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...props,
        src: itemValue,
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeImageGroup: {
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        props
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...props,
        urlList: itemValue,
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeUpload: {
    renderFormItemContent: defaultItemRender
  },
  // ä»¥ä¸å·²åºå¼
  $input: {
    formItemAutoFocus: 'input',
    renderFormItemContent: oldItemRender
  },
  $textarea: {
    formItemAutoFocus: 'textarea',
    renderFormItemContent: oldItemRender
  },
  $button: {
    renderFormItemContent: oldButtonItemRender
  },
  $buttons: {
    renderFormItemContent: oldButtonsItemRender
  },
  $select: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          options,
          optionProps,
          optionGroups,
          optionGroupProps
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  $radio: {
    renderFormItemContent: oldFormItemRadioAndCheckboxRender
  },
  $checkbox: {
    renderFormItemContent: oldFormItemRadioAndCheckboxRender
  },
  $switch: {
    renderFormItemContent: oldItemRender
  }
  // ä»¥ä¸å·²åºå¼
});
;// CONCATENATED MODULE: ./packages/form/src/form.ts














class Rule {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.min,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
}
// å¦æå­å¨ patternï¼å¤æ­æ­£å
function validREValue(pattern, val) {
  if (pattern && !(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return false;
  }
  return true;
}
// å¦æå­å¨ maxï¼å¤æ­æå¤§å¼
function validMaxValue(max, num) {
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(max) && num > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max)) {
    return false;
  }
  return true;
}
// å¦æå­å¨ minï¼å¤æ­æå°å¼
function validMinValue(min, num) {
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(min) && num < external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min)) {
    return false;
  }
  return true;
}
function validRuleValue(rule, val, required) {
  const {
    type,
    min,
    max,
    pattern
  } = rule;
  const isArrType = type === 'array';
  const isNumType = type === 'number';
  const isStrType = type === 'string';
  const strVal = `${val}`;
  if (!validREValue(pattern, strVal)) {
    return false;
  }
  if (isArrType) {
    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(val)) {
      return false;
    }
    if (required) {
      if (!val.length) {
        return false;
      }
    }
    if (!validMinValue(min, val.length)) {
      return false;
    }
    if (!validMaxValue(max, val.length)) {
      return false;
    }
  } else if (isNumType) {
    const numVal = Number(val);
    if (isNaN(numVal)) {
      return false;
    }
    if (!validMinValue(min, numVal)) {
      return false;
    }
    if (!validMaxValue(max, numVal)) {
      return false;
    }
  } else {
    if (isStrType) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val)) {
        return false;
      }
    }
    if (required) {
      if (!strVal) {
        return false;
      }
    }
    if (!validMinValue(min, strVal.length)) {
      return false;
    }
    if (!validMaxValue(max, strVal.length)) {
      return false;
    }
  }
  return true;
}
function checkRuleStatus(rule, val) {
  const {
    required
  } = rule;
  const isEmptyVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(val) ? !val.length : eqEmptyValue(val);
  if (required) {
    if (isEmptyVal) {
      return false;
    }
    if (!validRuleValue(rule, val, required)) {
      return false;
    }
  } else {
    if (!isEmptyVal) {
      if (!validRuleValue(rule, val, required)) {
        return false;
      }
    }
  }
  return true;
}
function createInternalData() {
  return {
    meTimeout: undefined,
    stTimeout: undefined,
    tooltipStore: {
      item: null,
      visible: false
    },
    itemFormatCache: {}
  };
}
/* harmony default export */ var src_form = (defineVxeComponent({
  name: 'VxeForm',
  props: {
    collapseStatus: {
      type: Boolean,
      default: true
    },
    loading: Boolean,
    data: Object,
    size: {
      type: String,
      default: () => getConfig().form.size || getConfig().size
    },
    span: {
      type: [String, Number],
      default: () => getConfig().form.span
    },
    align: {
      type: String,
      default: () => getConfig().form.align
    },
    verticalAlign: {
      type: String,
      default: () => getConfig().form.verticalAlign
    },
    border: {
      type: Boolean,
      default: () => getConfig().form.border
    },
    titleBackground: {
      type: Boolean,
      default: () => getConfig().form.titleBackground
    },
    titleBold: {
      type: Boolean,
      default: () => getConfig().form.titleBold
    },
    titleAlign: {
      type: String,
      default: () => getConfig().form.titleAlign
    },
    titleWidth: {
      type: [String, Number],
      default: () => getConfig().form.titleWidth
    },
    titleColon: {
      type: Boolean,
      default: () => getConfig().form.titleColon
    },
    titleAsterisk: {
      type: Boolean,
      default: () => getConfig().form.titleAsterisk
    },
    titleOverflow: {
      type: [Boolean, String],
      default: () => getConfig().form.titleOverflow
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().form.vertical
    },
    padding: {
      type: Boolean,
      default: () => getConfig().form.padding
    },
    className: [String, Function],
    readonly: Boolean,
    disabled: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: {
      type: Boolean,
      default: () => getConfig().form.preventSubmit
    },
    validConfig: Object,
    tooltipConfig: Object,
    collapseConfig: Object,
    customLayout: {
      type: Boolean,
      default: () => getConfig().form.customLayout
    },
    params: Object
  },
  emits: ['update:collapseStatus', 'collapse', 'toggle-collapse', 'submit', 'submit-invalid', 'reset'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeGrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeGrid', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      collapseAll: props.collapseStatus,
      staticItems: [],
      formItems: [],
      itemWidth: 0
    });
    const internalData = createInternalData();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTooltip = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    let formMethods = {};
    const computeValidOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().form.validConfig, props.validConfig);
    });
    const computeTooltipOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tooltip, getConfig().form.tooltipConfig, props.tooltipConfig);
    });
    const computeCollapseOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().form.collapseConfig, props.collapseConfig);
    });
    const computeAutoItemWidthList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        titleWidth: allTitleWidth,
        vertical: allVertical
      } = props;
      const {
        formItems
      } = reactData;
      const itemList = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(formItems, item => {
        const {
          titleWidth,
          vertical
        } = item;
        if (titleWidth === 'auto') {
          itemList.push(item);
        } else {
          const itemVertical = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(vertical) ? allVertical : vertical;
          const itemTitleWidth = itemVertical ? null : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(titleWidth) ? allTitleWidth : titleWidth;
          if (itemTitleWidth === 'auto' && (!item.children || !item.children.length)) {
            itemList.push(item);
          }
        }
      }, {
        children: 'children'
      });
      return itemList;
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeTooltipOpts,
      computeCollapseOpts,
      computeAutoItemWidthList
    };
    const $xeForm = {
      xID,
      props,
      context,
      reactData,
      internalData,
      xeGrid: $xeGrid,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const loadItem = list => {
      if (list.length) {
        list.forEach(item => {
          if (item.slots) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(item.slots, func => {
              if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
                if (!slots[func]) {
                  errLog('vxe.error.notSlot', [`[form] ${func}`]);
                }
              }
            });
          }
        });
      }
      reactData.staticItems = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(list, item => createItem($xeForm, item), {
        children: 'children'
      });
      internalData.itemFormatCache = {};
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        return recalculate();
      });
    };
    const getItems = () => {
      const itemList = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(reactData.formItems, item => {
        itemList.push(item);
      }, {
        children: 'children'
      });
      return itemList;
    };
    const getItemByField = field => {
      const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(reactData.formItems, item => item.field === field, {
        children: 'children'
      });
      return rest ? rest.item : null;
    };
    const getCollapseStatus = () => {
      return reactData.collapseAll;
    };
    const toggleCollapse = () => {
      const status = !getCollapseStatus();
      reactData.collapseAll = status;
      emit('update:collapseStatus', status);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const toggleCollapseEvent = evnt => {
      const actionRest = toggleCollapse();
      const status = getCollapseStatus();
      formMethods.dispatchEvent('toggle-collapse', {
        status,
        collapse: status,
        data: props.data
      }, evnt);
      formMethods.dispatchEvent('collapse', {
        status,
        collapse: status,
        data: props.data
      }, evnt);
      actionRest.then(() => {
        recalculate().then(() => {
          if ($xeGrid) {
            $xeGrid.recalculate(true);
          }
        });
        if ($xeGrid) {
          $xeGrid.recalculate();
        }
      });
    };
    const clearValidate = fieldOrItem => {
      if (fieldOrItem) {
        let fields = fieldOrItem;
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrItem)) {
          fields = [fieldOrItem];
        }
        fields.forEach(field => {
          if (field) {
            const item = handleFieldOrItem($xeForm, field);
            if (item) {
              item.showError = false;
              item.showIconMsg = false;
            }
          }
        });
      } else {
        getItems().forEach(item => {
          item.showError = false;
          item.showIconMsg = false;
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const getResetValue = (item, data, itemValue) => {
      const {
        field,
        resetValue
      } = item;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(resetValue)) {
        return resetValue({
          field,
          item,
          data,
          $form: $xeForm,
          $grid: $xeGrid
        });
      } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(resetValue)) {
        // é»è®¤
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(itemValue)) {
          return [];
        }
      }
      return resetValue;
    };
    const reset = () => {
      const {
        data
      } = props;
      const itemList = getItems();
      if (data) {
        itemList.forEach(item => {
          const {
            field,
            itemRender
          } = item;
          if (isEnableConf(itemRender)) {
            const {
              name,
              startField,
              endField
            } = itemRender;
            const compConf = renderer.get(name);
            const fiResetMethod = compConf ? compConf.formItemResetMethod || compConf.itemResetMethod : null;
            if (compConf && fiResetMethod) {
              fiResetMethod({
                data,
                field,
                property: field,
                item,
                $form: $xeForm,
                $grid: $xeGrid
              });
            } else if (field) {
              const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, field, getResetValue(item, data, itemValue));
            }
            if (startField && endField) {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, startField, getResetValue(item, data, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, startField)));
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, endField, getResetValue(item, data, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, endField)));
            }
          }
        });
      }
      internalData.itemFormatCache = {};
      clearValidate();
      return recalculate();
    };
    const resetEvent = evnt => {
      evnt.preventDefault();
      reset();
      formMethods.dispatchEvent('reset', {
        data: props.data
      }, evnt);
    };
    const handleFocus = fields => {
      const el = refElem.value;
      if (el) {
        for (let i = 0; i < fields.length; i++) {
          const field = fields[i];
          const item = getItemByField(field);
          if (item && isEnableConf(item.itemRender)) {
            const {
              itemRender
            } = item;
            const compConf = renderer.get(itemRender.name);
            // å®ä½å°ç¬¬ä¸ä¸ª
            if (!i) {
              scrollToView(el.querySelector(`.${item.id}`));
            }
            let inputElem = null;
            const autoFocus = itemRender.autoFocus || itemRender.autofocus || (compConf ? compConf.formItemAutoFocus : null);
            // å¦ææå®äºèç¦ class
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(autoFocus)) {
              inputElem = autoFocus({
                $form: $xeForm,
                $grid: $xeGrid,
                item,
                data: props.data,
                field
              });
            } else {
              if (autoFocus === true) {
                // èªå¨å¹éæ¨¡å¼ï¼ä¼èªå¨å¹éç¬¬ä¸ä¸ªå¯è¾å¥åç´ 
                inputElem = el.querySelector(`.${item.id} input,textarea`);
              } else if (autoFocus) {
                inputElem = el.querySelector(`.${item.id} ${autoFocus}`);
              }
            }
            if (inputElem) {
              inputElem.focus();
              break;
            }
          }
        }
      }
    };
    /**
     * æ ¡éªæ°æ®
     * æè¡¨æ ¼è¡ãåé¡ºåºä¾æ¬¡æ ¡éªï¼åæ­¥æå¼æ­¥ï¼
     * æ ¡éªè§åæ ¹æ®ç´¢å¼é¡ºåºä¾æ¬¡æ ¡éªï¼å¦ææ¯å¼æ­¥åä¼ç­å¾æ ¡éªå®ææä¼ç»§ç»­æ ¡éªä¸ä¸å
     * å¦ææ ¡éªå¤±è´¥åï¼è§¦ååè°æè Promise<(ErrMap æ ¡éªä¸éè¿åçä¿¡æ¯)>
     * å¦ææ¯ä¼ åè°æ¹å¼è¿è¿åä¸ä¸ª (ErrMap æ ¡éªä¸éè¿åçä¿¡æ¯)
     *
     * rule éç½®ï¼
     *  required=Boolean æ¯å¦å¿å¡«
     *  min=Number æå°é¿åº¦
     *  max=Number æå¤§é¿åº¦
     *  validator=Function({ itemValue, rule, rules, data, property }) èªå®ä¹æ ¡éªï¼æ¥æ¶ä¸ä¸ª Promise
     *  trigger=change è§¦åæ¹å¼
     */
    const validItemRules = (validType, fields, val) => {
      const {
        data,
        rules: formRules
      } = props;
      const errorMaps = {};
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fields)) {
        fields = [fields];
      }
      return Promise.all(fields.map(property => {
        const errorRules = [];
        const syncVailds = [];
        if (property && formRules) {
          const rules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(formRules, property);
          if (rules) {
            const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(val) ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property) : val;
            rules.forEach(rule => {
              const {
                trigger,
                validator
              } = rule;
              if (validType === 'all' || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    itemValue,
                    rule,
                    rules,
                    data,
                    field: property,
                    property,
                    $form: $xeForm
                  };
                  let customValid;
                  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(validator)) {
                    const gvItem = validators.get(validator);
                    if (gvItem) {
                      const validatorMethod = gvItem.formItemValidatorMethod || gvItem.itemValidatorMethod;
                      if (validatorMethod) {
                        customValid = validatorMethod(validParams);
                      } else {
                        warnLog('vxe.error.notValidators', [`[form] ${validator}`]);
                      }
                    } else {
                      errLog('vxe.error.notValidators', [`[form] ${validator}`]);
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(customValid)) {
                      errorRules.push(new Rule({
                        type: 'custom',
                        trigger,
                        content: customValid.message,
                        rule: new Rule(rule)
                      }));
                    } else if (customValid.catch) {
                      // å¦æä¸ºå¼æ­¥æ ¡éªï¼æ³¨ï¼å¼æ­¥æ ¡éªæ¯å¹¶åæ åºçï¼
                      syncVailds.push(customValid.catch(e => {
                        errorRules.push(new Rule({
                          type: 'custom',
                          trigger,
                          content: e ? e.message : rule.content || rule.message,
                          rule: new Rule(rule)
                        }));
                      }));
                    }
                  }
                } else {
                  if (!checkRuleStatus(rule, itemValue)) {
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncVailds).then(() => {
          if (errorRules.length) {
            errorMaps[property] = errorRules.map(rule => {
              return {
                $form: $xeForm,
                rule,
                data,
                field: property,
                property
              };
            });
          }
        });
      })).then(() => {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEmpty(errorMaps)) {
          return Promise.reject(errorMaps);
        }
      });
    };
    const beginValidate = (itemList, type, callback) => {
      const {
        data,
        rules: formRules
      } = props;
      const validOpts = computeValidOpts.value;
      const validRest = {};
      const validFields = [];
      const itemValids = [];
      clearTimeout(internalData.meTimeout);
      if (data && formRules) {
        itemList.forEach(item => {
          const {
            field
          } = item;
          if (field && !isHiddenItem($xeForm, item) && isActiveItem($xeForm, item)) {
            itemValids.push(validItemRules(type || 'all', field).then(() => {
              item.errRule = null;
            }).catch(errorMaps => {
              const rest = errorMaps[field];
              if (!validRest[field]) {
                validRest[field] = [];
              }
              validRest[field].push(rest);
              validFields.push(field);
              item.errRule = rest[0].rule;
              return Promise.reject(rest);
            }));
          }
        });
        return Promise.all(itemValids).then(() => {
          if (callback) {
            callback();
          }
        }).catch(() => {
          return new Promise(resolve => {
            internalData.meTimeout = setTimeout(() => {
              itemList.forEach(item => {
                if (item.errRule) {
                  item.showError = true;
                }
              });
            }, 20);
            if (validOpts.autoPos !== false) {
              (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                handleFocus(validFields);
              });
            }
            if (callback) {
              callback(validRest);
              resolve();
            } else {
              resolve(validRest);
            }
          });
        });
      }
      if (callback) {
        callback();
      }
      return Promise.resolve();
    };
    const validate = callback => {
      const {
        readonly
      } = props;
      clearValidate();
      if (readonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
      return beginValidate(getItems(), '', callback).then(params => {
        recalculate();
        return params;
      });
    };
    const validateField = (fieldOrItem, callback) => {
      const {
        readonly
      } = props;
      if (readonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
      let fields = [];
      if (fieldOrItem) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrItem)) {
          fields = fieldOrItem;
        } else {
          fields = [fieldOrItem];
        }
      }
      return beginValidate(fields.map(field => handleFieldOrItem($xeForm, field)), '', callback).then(params => {
        recalculate();
        return params;
      });
    };
    const submitEvent = evnt => {
      const {
        readonly
      } = props;
      evnt.preventDefault();
      if (!props.preventSubmit) {
        clearValidate();
        if (readonly) {
          formMethods.dispatchEvent('submit', {
            data: props.data
          }, evnt);
          recalculate();
          return;
        }
        beginValidate(getItems()).then(errMap => {
          if (errMap) {
            formMethods.dispatchEvent('submit-invalid', {
              data: props.data,
              errMap
            }, evnt);
          } else {
            formMethods.dispatchEvent('submit', {
              data: props.data
            }, evnt);
          }
          recalculate();
        });
      }
    };
    const closeTooltip = () => {
      const {
        tooltipStore
      } = internalData;
      const $tooltip = refTooltip.value;
      if (tooltipStore.visible) {
        Object.assign(tooltipStore, {
          item: null,
          visible: false
        });
        if ($tooltip) {
          $tooltip.close();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const triggerTitleTipEvent = (evnt, params) => {
      const {
        item
      } = params;
      const {
        tooltipStore
      } = internalData;
      const $tooltip = refTooltip.value;
      const overflowElem = evnt.currentTarget.children[0];
      const content = (overflowElem.textContent || '').trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      clearTimeout(internalData.stTimeout);
      if (tooltipStore.item !== item) {
        closeTooltip();
      }
      if (content && isCellOverflow) {
        Object.assign(tooltipStore, {
          item,
          visible: true
        });
        if ($tooltip) {
          $tooltip.open(overflowElem, content);
        }
      }
    };
    const handleTitleTipLeaveEvent = () => {
      const tooltipOpts = computeTooltipOpts.value;
      let $tooltip = refTooltip.value;
      if ($tooltip) {
        $tooltip.setActived(false);
      }
      if (tooltipOpts.enterable) {
        internalData.stTimeout = setTimeout(() => {
          $tooltip = refTooltip.value;
          if ($tooltip && !$tooltip.isActived()) {
            closeTooltip();
          }
        }, tooltipOpts.leaveDelay);
      } else {
        closeTooltip();
      }
    };
    const triggerItemEvent = (evnt, field, itemValue) => {
      if (field) {
        return validItemRules(evnt ? ['blur'].includes(evnt.type) ? 'blur' : 'change' : 'all', field, itemValue).then(() => {
          clearValidate(field);
        }).catch(errorMaps => {
          const rest = errorMaps[field];
          const item = getItemByField(field);
          if (rest && item) {
            item.showError = true;
            item.errRule = rest[0].rule;
          }
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * æ´æ°é¡¹ç¶æ
     * å¦æç»ä»¶å¼ v-model åç change æ¶ï¼è°ç¨æ¹å½æ°ç¨äºæ´æ°æä¸é¡¹ç¼è¾ç¶æ
     * å¦æååæ ¼éç½®äºæ ¡éªè§åï¼åä¼è¿è¡æ ¡éª
     */
    const updateStatus = (scope, itemValue) => {
      const {
        field
      } = scope;
      return triggerItemEvent(new Event('change'), field, itemValue);
    };
    const recalculate = () => {
      const autoItemWidthList = computeAutoItemWidthList.value;
      const el = refElem.value;
      if (el && autoItemWidthList.length) {
        const itemElList = el.querySelectorAll(autoItemWidthList.map(item => `.vxe-form--item-title[itemid="${item.id}"]`).join(','));
        let maxItemWidth = 0;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(itemElList, itemEl => {
          itemEl.style.width = '';
          maxItemWidth = Math.max(maxItemWidth, Math.ceil(itemEl.clientWidth + 2));
        });
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(itemElList, itemEl => {
          itemEl.style.width = `${maxItemWidth}px`;
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleGlobalResizeEvent = () => {
      recalculate();
    };
    formMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $form: $xeForm,
          $grid: $xeGrid
        }, params));
      },
      reset,
      validate,
      validateField,
      clearValidate,
      updateStatus,
      toggleCollapse,
      getItems,
      getItemByField,
      closeTooltip,
      recalculate
    };
    const formPrivateMethods = {
      callSlot,
      triggerItemEvent,
      toggleCollapseEvent,
      triggerTitleTipEvent,
      handleTitleTipLeaveEvent,
      handleValidIconEvent(evnt, params) {
        const {
          item
        } = params;
        item.showIconMsg = !item.showIconMsg;
      }
    };
    Object.assign($xeForm, formMethods, formPrivateMethods);
    const renderVN = () => {
      const {
        loading,
        border,
        className,
        data,
        customLayout
      } = props;
      const {
        formItems
      } = reactData;
      const vSize = computeSize.value;
      const tooltipOpts = computeTooltipOpts.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('form', {
        ref: refElem,
        class: ['vxe-form', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          items: formItems,
          data,
          $form: $xeForm
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--border': border,
          'custom--layout': customLayout,
          'is--loading': loading
        }],
        onSubmit: submitEvent,
        onReset: resetEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form--wrapper vxe-form--item-row'
      }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_config_item, {
          key: index,
          itemConfig: item
        });
      })), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-slots',
        ref: 'hideItem'
      }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),
      /**
       * å è½½ä¸­
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-form--loading',
        modelValue: loading
      }),
      /**
       * å·¥å·æç¤º
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tooltip, {
        ref: refTooltip,
        ...tooltipOpts
      })]);
    };
    const recalcFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.vertical, () => {
      recalcFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.titleWidth, () => {
      recalcFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(recalcFlag, () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        recalculate();
      });
    });
    const staticItemFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems.length, () => {
      staticItemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems, () => {
      staticItemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(staticItemFlag, () => {
      reactData.formItems = reactData.staticItems;
      recalcFlag.value++;
    });
    const itemFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.items, () => {
      itemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(itemFlag, () => {
      loadItem(props.items || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.collapseStatus, value => {
      reactData.collapseAll = !!value;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.readonly, () => {
      clearValidate();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.disabled, () => {
      clearValidate();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (props.customLayout && props.items) {
          errLog('vxe.error.errConflicts', ['[form] custom-layout', 'items']);
        }
      });
      globalEvents.on($xeForm, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeForm, 'resize');
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData, createInternalData());
    });
    if (props.items) {
      loadItem(props.items);
    }
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeFormItemInfo', null);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeForm', $xeForm);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormGroup', null);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormItem', null);
    $xeForm.renderVN = renderVN;
    return $xeForm;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form/index.ts



const VxeForm = Object.assign(src_form, {
  install(app) {
    app.component(src_form.name, src_form);
  }
});
dynamicApp.use(VxeForm);
index_esm_VxeUI.component(src_form);
const Form = VxeForm;
/* harmony default export */ var packages_form = (VxeForm);
;// CONCATENATED MODULE: ./packages/form/src/form-item.ts







const formItemProps = {
  title: String,
  field: String,
  span: {
    type: [String, Number],
    default: null
  },
  align: {
    type: String,
    default: null
  },
  verticalAlign: {
    type: String,
    default: null
  },
  titleBackground: {
    type: Boolean,
    default: null
  },
  titleBold: {
    type: Boolean,
    default: null
  },
  titleAlign: {
    type: String,
    default: null
  },
  titleWidth: {
    type: [String, Number],
    default: null
  },
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  showTitle: {
    type: Boolean,
    default: true
  },
  vertical: {
    type: Boolean,
    default: null
  },
  padding: {
    type: Boolean,
    default: null
  },
  formatter: [String, Function],
  className: [String, Function],
  contentClassName: [String, Function],
  contentStyle: [Object, Function],
  titleClassName: [String, Function],
  titleStyle: [Object, Function],
  titleOverflow: {
    type: [Boolean, String],
    default: null
  },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: {
    default: null
  },
  visibleMethod: Function,
  visible: {
    type: Boolean,
    default: null
  },
  showContent: {
    type: Boolean,
    default: null
  },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object,
  rules: Array,
  params: Object
};
/* harmony default export */ var form_item = (defineVxeComponent({
  name: 'VxeFormItem',
  props: formItemProps,
  setup(props, {
    slots
  }) {
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', {});
    const $xeFormGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormGroup', null);
    const formItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(createItem($xeForm, props));
    formItem.slots = slots;
    const formItemInfo = {
      itemConfig: formItem
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeFormItemInfo', formItemInfo);
    const renderItem = ($xeForm, item) => {
      const formProps = $xeForm.props;
      const $xeGrid = $xeForm.xeGrid;
      const {
        data,
        readonly,
        disabled
      } = formProps;
      const {
        visible,
        field,
        itemRender,
        contentStyle,
        showContent
      } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const params = {
        data,
        disabled,
        readonly,
        field,
        property: field,
        item,
        $form: $xeForm,
        $grid: $xeGrid
      };
      if (visible === false) {
        return renderEmptyElement($xeFormItem);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        key: item.id,
        itemid: item.id,
        class: getItemClass($xeForm, item),
        style: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [renderTitle($xeForm, item), showContent === false ? renderEmptyElement($xeFormItem) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: getItemContentClass($xeForm, item),
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentStyle) ? contentStyle(params) : contentStyle)
      }, [renderItemContent($xeForm, item), renderItemErrorIcon($xeForm, item)])]);
    };
    const renderVN = () => {
      const customLayout = $xeForm ? $xeForm.props.customLayout : false;
      const item = formItem;
      return customLayout ? renderItem($xeForm, item) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    const $xeFormItem = {
      xID,
      formItem,
      renderVN
    };
    watchItem(props, formItem);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      assembleItem($xeForm, elem, formItem, $xeFormGroup);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyItem($xeForm, formItem);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormItem', $xeFormItem);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormGroup', null);
    return $xeFormItem;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form/src/form-group.ts








/* harmony default export */ var form_group = (defineVxeComponent({
  name: 'VxeFormGroup',
  props: formItemProps,
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', {});
    const $xeParentFormGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormGroup', null);
    const formItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(createItem($xeForm, props));
    formItem.slots = slots;
    formItem.children = [];
    const formItemInfo = {
      itemConfig: formItem
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeFormItemInfo', formItemInfo);
    const renderVN = () => {
      const formProps = $xeForm.props;
      const $xeGrid = $xeForm.xeGrid;
      const item = formItem;
      const {
        data,
        readonly,
        disabled
      } = formProps;
      const {
        visible,
        field,
        itemRender,
        contentStyle
      } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const defaultSlot = slots ? slots.default : null;
      const params = {
        data,
        disabled,
        readonly,
        field,
        property: field,
        item,
        $form: $xeForm,
        $grid: $xeGrid
      };
      if (visible === false) {
        return renderEmptyElement($xeFormGroup);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        key: item.id,
        itemid: item.id,
        class: getItemClass($xeForm, item, true),
        style: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [renderTitle($xeForm, item, true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: getItemContentClass($xeForm, item, true),
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentStyle) ? contentStyle(params) : contentStyle)
      }, defaultSlot ? defaultSlot({}) : [])]);
    };
    const $xeFormGroup = {
      xID,
      formItem,
      renderVN
    };
    watchItem(props, formItem);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      assembleItem($xeForm, elem, formItem, $xeParentFormGroup);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyItem($xeForm, formItem);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormGroup', $xeFormGroup);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormItem', null);
    return $xeFormGroup;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-gather/index.ts



const VxeFormGatherComponent = Object.assign({}, form_group, {
  name: 'VxeFormGather'
});
/**
 * å·²åºå¼ï¼è¢« VxeFormGather æ¿æ¢
 * @deprecated
 */
const VxeFormGather = Object.assign(VxeFormGatherComponent, {
  install(app) {
    app.component(VxeFormGatherComponent.name, VxeFormGatherComponent);
  }
});
dynamicApp.use(VxeFormGather);
index_esm_VxeUI.component(VxeFormGatherComponent);
/**
 * å·²åºå¼ï¼è¢« FormGroup æ¿æ¢
 * @deprecated
 */
const FormGather = VxeFormGather;
/* harmony default export */ var form_gather = (VxeFormGather);
;// CONCATENATED MODULE: ./packages/form-group/index.ts



const VxeFormGroup = Object.assign(form_group, {
  install(app) {
    app.component(form_group.name, form_group);
  }
});
dynamicApp.use(VxeFormGroup);
index_esm_VxeUI.component(form_group);
const FormGroup = VxeFormGroup;
/* harmony default export */ var packages_form_group = (VxeFormGroup);
;// CONCATENATED MODULE: ./packages/form-item/index.ts



const VxeFormItem = Object.assign(form_item, {
  install(app) {
    app.component(form_item.name, form_item);
  }
});
dynamicApp.use(VxeFormItem);
index_esm_VxeUI.component(form_item);
const FormItem = VxeFormItem;
/* harmony default export */ var packages_form_item = (VxeFormItem);
;// CONCATENATED MODULE: ./packages/icon/index.ts



const VxeIcon = Object.assign({}, icon, {
  install(app) {
    app.component(icon.name, icon);
  }
});
dynamicApp.use(VxeIcon);
index_esm_VxeUI.component(icon);
const Icon = VxeIcon;
/* harmony default export */ var packages_icon = (VxeIcon);
;// CONCATENATED MODULE: ./packages/icon-picker/src/icon-picker.ts







/* harmony default export */ var icon_picker = (defineVxeComponent({
  name: 'VxeIconPicker',
  props: {
    modelValue: String,
    placeholder: String,
    clearable: Boolean,
    size: {
      type: String,
      default: () => getConfig().iconPicker.size || getConfig().size
    },
    className: [String, Function],
    popupClassName: [String, Function],
    showIconTitle: {
      type: Boolean,
      default: () => getConfig().iconPicker.showIconTitle
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    icons: Array,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'change', 'clear', 'click'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      selectIcon: `${props.modelValue || ''}`,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      // hpTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeIconPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let iconPickerMethods = {};
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().iconPicker.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.base.pleaseSelect');
    });
    const computeIconList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      let {
        icons
      } = props;
      if (!icons || !icons.length) {
        icons = getConfig().iconPicker.icons || [];
      }
      return icons.map(item => {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
          return {
            title: item,
            icon: `vxe-icon-${`${item || ''}`.replace(/^vxe-icon-/, '')}`
          };
        }
        return {
          title: `${item.title || ''}`,
          icon: item.icon || '',
          iconRender: item.iconRender
        };
      });
    });
    const computeIconGroupList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const iconList = computeIconList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(iconList, 4);
    });
    const computeSelectIconItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectIcon
      } = reactData;
      const iconList = computeIconList.value;
      return selectIcon ? iconList.find(item => item.icon === selectIcon) : null;
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          placement
        } = props;
        const {
          panelIndex
        } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const {
            boundingTop,
            boundingLeft,
            visibleHeight,
            visibleWidth
          } = getAbsolutePos(el);
          let panelPlacement = 'bottom';
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === 'top') {
              panelPlacement = 'top';
              top = boundingTop - panelHeight;
            } else if (!placement) {
              // å¦æä¸é¢ä¸å¤æ¾ï¼ååä¸
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = 'top';
                top = boundingTop - panelHeight;
              }
              // å¦æä¸é¢ä¸å¤æ¾ï¼ååä¸ï¼ä¼åï¼
              if (top < marginSize) {
                panelPlacement = 'bottom';
                top = boundingTop + targetHeight;
              }
            }
            // å¦ææº¢åºå³è¾¹
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            // å¦ææº¢åºå·¦è¾¹
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === 'top') {
              panelPlacement = 'top';
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              // å¦æä¸é¢ä¸å¤æ¾ï¼ååä¸
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                // å¦æä¸é¢ä¸å¤æ¾ï¼ååä¸ï¼ä¼åï¼
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = 'top';
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    const showOptionPanel = () => {
      const {
        hpTimeout
      } = internalData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = undefined;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      reactData.selectIcon = selectValue;
      if (selectValue !== props.modelValue) {
        emit('update:modelValue', selectValue);
        dispatchEvent('change', {
          value: selectValue
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const focusEvent = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
      }
    };
    const blurEvent = () => {
      reactData.isActivated = false;
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const togglePanelEvent = evnt => {
      evnt.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const clickEvent = evnt => {
      togglePanelEvent(evnt);
      dispatchEvent('click', {}, evnt);
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable
      } = props;
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
            // changeOptionEvent(evnt, currentValue, currentOption)
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            // let { firstOption, offsetOption } = findOffsetOption(currentValue, isUpArrow)
            // if (!offsetOption && !findVisibleOption(currentValue)) {
            //   offsetOption = firstOption
            // }
            // setCurrentOption(offsetOption)
            // scrollToOption(offsetOption, isDwArrow)
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $iconPicker: $xeIconPicker
      }, params));
    };
    iconPickerMethods = {
      dispatchEvent,
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        if ($input) {
          $input.blur();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    const handleClickIconEvent = (evnt, item) => {
      const value = item.icon;
      changeEvent(evnt, value);
      hideOptionPanel();
    };
    Object.assign($xeIconPicker, iconPickerMethods);
    const renderIconWrapper = () => {
      const {
        showIconTitle
      } = props;
      const iconGroupList = computeIconGroupList.value;
      const isDisabled = computeIsDisabled.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--list-wrapper'
      }, iconGroupList.map(list => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-ico-picker--list'
        }, list.map(item => {
          const {
            iconRender
          } = item;
          const compConf = iconRender ? renderer.get(iconRender.name) : null;
          const oIconMethod = compConf ? compConf.renderIconPickerOptionIcon : null;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-ico-picker--item',
            onClick(evnt) {
              if (!isDisabled) {
                handleClickIconEvent(evnt, item);
              }
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-ico-picker--item-icon'
          }, oIconMethod && iconRender ? vn_getSlotVNs(oIconMethod(iconRender, {
            $iconPicker: $xeIconPicker,
            option: item
          })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: item.icon || ''
          })]), showIconTitle ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-ico-picker--item-title'
          }, `${item.title || ''}`) : renderEmptyElement($xeIconPicker)]);
        }));
      }));
    };
    const renderIconView = () => {
      const {
        selectIcon
      } = reactData;
      const selectIconItem = computeSelectIconItem.value;
      if (selectIconItem) {
        const {
          iconRender
        } = selectIconItem;
        const compConf = iconRender ? renderer.get(iconRender.name) : null;
        const oIconMethod = compConf ? compConf.renderIconPickerOptionIcon : null;
        if (oIconMethod && iconRender) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: 'inc',
            class: 'vxe-ico-picker--icon'
          }, vn_getSlotVNs(oIconMethod(iconRender, {
            $iconPicker: $xeIconPicker,
            option: selectIconItem
          })));
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'ind',
        class: 'vxe-ico-picker--icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: selectIcon
      })]);
    };
    const renderVN = () => {
      const {
        className,
        popupClassName,
        clearable
      } = props;
      const {
        initialized,
        isActivated,
        isAniVisible,
        visiblePanel,
        selectIcon
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-ico-picker--readonly', className]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: selectIcon
        })]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-ico-picker', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $iconPicker: $xeIconPicker
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'show--clear': clearable && !isDisabled && !!selectIcon,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--inner',
        onClick: clickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInput,
        class: 'vxe-ico-picker--input',
        onFocus: focusEvent,
        onBlur: blurEvent
      }), selectIcon ? renderIconView() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--placeholder'
      }, inpPlaceholder), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--suffix'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--clear-icon',
        onClick: clearEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--suffix-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: visiblePanel ? getIcon().ICON_PICKER_OPEN : getIcon().ICON_PICKER_CLOSE
      })])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-ico-picker--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $iconPicker: $xeIconPicker
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': isAniVisible,
          'ani--enter': visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, [initialized && (visiblePanel || isAniVisible) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--panel-wrapper'
      }, [renderIconWrapper()]) : renderEmptyElement($xeIconPicker)])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.selectIcon = `${val || ''}`;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeIconPicker, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeIconPicker, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeIconPicker, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeIconPicker, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeIconPicker, 'mousewheel');
      globalEvents.off($xeIconPicker, 'mousedown');
      globalEvents.off($xeIconPicker, 'keydown');
      globalEvents.off($xeIconPicker, 'blur');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeIconPicker', $xeIconPicker);
    $xeIconPicker.renderVN = renderVN;
    return $xeIconPicker;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/icon-picker/index.ts



const VxeIconPicker = Object.assign(icon_picker, {
  install: function (app) {
    app.component(icon_picker.name, icon_picker);
  }
});
dynamicApp.use(VxeIconPicker);
index_esm_VxeUI.component(icon_picker);
const IconPicker = VxeIconPicker;
/* harmony default export */ var packages_icon_picker = (VxeIconPicker);
;// CONCATENATED MODULE: ./packages/image/src/preview.ts






/* harmony default export */ var preview = (defineVxeComponent({
  name: 'VxeImagePreview',
  props: {
    modelValue: Number,
    urlList: Array,
    urlField: {
      type: String,
      default: () => getConfig().imagePreview.urlField
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().imagePreview.maskClosable
    },
    marginSize: {
      type: String,
      default: () => getConfig().imagePreview.marginSize
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showDownloadButton
    },
    zIndex: Number,
    toolbarConfig: Object,
    beforeDownloadMethod: Function,
    downloadMethod: Function
  },
  emits: ['update:modelValue', 'change', 'download', 'download-fail', 'rotate', 'close'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      activeIndex: props.modelValue || 0,
      offsetPct11: false,
      offsetScale: 0,
      offsetRotate: 0,
      offsetLeft: 0,
      offsetTop: 0
    });
    const computeUrlProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.urlField || 'url';
    });
    const computeMarginSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize || 0) || 16;
    });
    const computeToolbarOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().imagePreview.toolbarConfig, props.toolbarConfig);
    });
    const computeRotateText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        offsetRotate
      } = reactData;
      if (offsetRotate) {
        return `${offsetRotate}Â°`;
      }
      return '0Â°';
    });
    const computeScaleText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        offsetScale
      } = reactData;
      if (offsetScale) {
        return `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil((1 + offsetScale) * 100)}%`;
      }
      return '100%';
    });
    const computeImgList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        urlList
      } = props;
      const urlProp = computeUrlProp.value;
      if (urlList && urlList.length) {
        return urlList.map(item => {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
            return item;
          }
          if (item[urlProp]) {
            return item[urlProp];
          }
          return '';
        });
      }
      return [];
    });
    const computeImgTransform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      let {
        offsetScale,
        offsetRotate,
        offsetLeft,
        offsetTop
      } = reactData;
      const stys = [];
      let targetScale = 1;
      if (offsetScale) {
        targetScale = 1 + offsetScale;
        stys.push(`scale(${targetScale})`);
      }
      if (offsetRotate) {
        stys.push(`rotate(${offsetRotate}deg)`);
      }
      if (offsetLeft || offsetTop) {
        // ç¼©æ¾ä¸ä½ç§»
        offsetLeft /= targetScale;
        offsetTop /= targetScale;
        let targetOffsetLeft = offsetLeft;
        let targetOffsetTop = offsetTop;
        if (offsetRotate) {
          // è½¬åä¸ä½ç§»
          switch (offsetRotate % 360) {
            case 90:
            case -270:
              targetOffsetLeft = offsetTop;
              targetOffsetTop = -offsetLeft;
              break;
            case 180:
            case -180:
              targetOffsetLeft = -offsetLeft;
              targetOffsetTop = -offsetTop;
              break;
            case 270:
            case -90:
              targetOffsetLeft = -offsetTop;
              targetOffsetTop = offsetLeft;
              break;
          }
        }
        stys.push(`translate(${targetOffsetLeft}px, ${targetOffsetTop}px)`);
      }
      return stys.length ? stys.join(' ') : '';
    });
    const computeMaps = {
      computeImgList
    };
    const $xeImagePreview = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $imagePreview: $xeImagePreview
      }, params));
    };
    const imagePreviewMethods = {
      dispatchEvent
    };
    const emitModel = value => {
      reactData.activeIndex = value;
      emit('update:modelValue', value);
    };
    const handleCloseEvent = evnt => {
      dispatchEvent('close', {}, evnt);
    };
    const imagePreviewPrivateMethods = {};
    const resetStyle = () => {
      const elem = refElem.value;
      removeClass(elem, 'is--move');
      Object.assign(reactData, {
        offsetPct11: false,
        offsetScale: 0,
        offsetRotate: 0,
        offsetLeft: 0,
        offsetTop: 0
      });
    };
    const getOffsetZoomStep = () => {
      const {
        offsetScale
      } = reactData;
      let stepNum = 0.02;
      if (offsetScale >= -0.6) {
        stepNum = 0.04;
        if (offsetScale >= -0.4) {
          stepNum = 0.07;
          if (offsetScale >= 0) {
            stepNum = 0.1;
            if (offsetScale >= 3) {
              stepNum = 0.25;
              if (offsetScale >= 8) {
                stepNum = 0.4;
                if (offsetScale >= 16) {
                  stepNum = 0.6;
                  if (offsetScale >= 24) {
                    stepNum = 0.9;
                    if (offsetScale >= 32) {
                      stepNum = 1.3;
                      if (offsetScale >= 39) {
                        stepNum = 1.9;
                        if (offsetScale >= 45) {
                          stepNum = 2.5;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return stepNum;
    };
    const handleZoom = isAdd => {
      const {
        offsetScale
      } = reactData;
      const stepNum = getOffsetZoomStep();
      if (isAdd) {
        reactData.offsetScale = Number(Math.min(49, offsetScale + stepNum).toFixed(2));
      } else {
        reactData.offsetScale = Number(Math.max(-0.9, offsetScale - stepNum).toFixed(2));
      }
    };
    const handleChangeEvent = (evnt, isNext) => {
      let activeIndex = reactData.activeIndex || 0;
      const imgList = computeImgList.value;
      if (isNext) {
        if (activeIndex >= imgList.length - 1) {
          activeIndex = 0;
        } else {
          activeIndex++;
        }
      } else {
        if (activeIndex <= 0) {
          activeIndex = imgList.length - 1;
        } else {
          activeIndex--;
        }
      }
      const imgUrl = imgList[activeIndex || 0];
      reactData.activeIndex = activeIndex;
      resetStyle();
      emitModel(activeIndex);
      dispatchEvent('change', {
        url: imgUrl,
        activeIndex
      }, evnt);
    };
    const handleRotateImgEvent = (evnt, isRight) => {
      const imgList = computeImgList.value;
      const {
        activeIndex
      } = reactData;
      const imgUrl = imgList[activeIndex || 0];
      let offsetRotate = reactData.offsetRotate;
      if (isRight) {
        offsetRotate += 90;
      } else {
        offsetRotate -= 90;
      }
      reactData.offsetRotate = offsetRotate;
      dispatchEvent('rotate', {
        url: imgUrl,
        rotateValue: offsetRotate
      }, evnt);
    };
    const handlePct11 = () => {
      resetStyle();
      reactData.offsetPct11 = true;
    };
    const handlePrintImg = () => {
      const {
        activeIndex
      } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (index_esm_VxeUI.print) {
        index_esm_VxeUI.print({
          align: 'center',
          pageBreaks: [{
            bodyHtml: `<img src="${imgUrl}" style="max-width:100%;max-height:100%;">`
          }]
        });
      }
    };
    const handleDownloadEvent = (evnt, imgUrl) => {
      dispatchEvent('download', {
        url: imgUrl
      }, evnt);
    };
    const handleDefaultDownload = (evnt, imgUrl) => {
      if (index_esm_VxeUI.saveFile) {
        fetch(imgUrl).then(res => {
          return res.blob().then(blob => {
            index_esm_VxeUI.saveFile({
              filename: imgUrl,
              content: blob
            });
            handleDownloadEvent(evnt, imgUrl);
          });
        }).catch(() => {
          if (index_esm_VxeUI.modal) {
            index_esm_VxeUI.modal.message({
              content: getI18n('vxe.error.downErr'),
              status: 'error'
            });
          }
        });
      }
    };
    const handleDownloadImg = evnt => {
      const {
        activeIndex
      } = reactData;
      const toolbarOpts = computeToolbarOpts.value;
      const btnConf = toolbarOpts.download;
      const btnOpts = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(btnConf) ? {} : btnConf ? Object.assign({}, btnConf) : {};
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      const beforeDownloadFn = props.beforeDownloadMethod || btnOpts.beforeDownloadMethod || getConfig().imagePreview.beforeDownloadMethod;
      const downloadFn = props.downloadMethod || btnOpts.downloadMethod || getConfig().imagePreview.downloadMethod;
      Promise.resolve(beforeDownloadFn ? beforeDownloadFn({
        $imagePreview: $xeImagePreview,
        url: imgUrl,
        index: activeIndex || 0
      }) : true).then(status => {
        if (status) {
          if (downloadFn) {
            Promise.resolve(downloadFn({
              $imagePreview: $xeImagePreview,
              url: imgUrl,
              index: activeIndex || 0
            })).then(() => {
              handleDownloadEvent(evnt, imgUrl);
            }).catch(e => e);
          } else {
            handleDefaultDownload(evnt, imgUrl);
          }
        }
      });
    };
    const handleOperationBtn = (evnt, code) => {
      const {
        activeIndex
      } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (imgUrl) {
        switch (code) {
          case 'zoomOut':
            handleZoom(false);
            break;
          case 'zoomIn':
            handleZoom(true);
            break;
          case 'pctFull':
            resetStyle();
            break;
          case 'pct11':
            handlePct11();
            break;
          case 'rotateLeft':
            handleRotateImgEvent(evnt, false);
            break;
          case 'rotateRight':
            handleRotateImgEvent(evnt, true);
            break;
          case 'print':
            handlePrintImg();
            break;
          case 'download':
            handleDownloadImg(evnt);
            break;
        }
      }
    };
    const wheelEvent = evnt => {
      const delta = evnt.deltaY;
      if (delta > 0) {
        evnt.preventDefault();
        handleZoom(false);
      } else if (delta < 0) {
        evnt.preventDefault();
        handleZoom(true);
      }
    };
    const moveEvent = evnt => {
      const {
        offsetTop,
        offsetLeft
      } = reactData;
      const elem = refElem.value;
      evnt.preventDefault();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const startX = evnt.pageX;
      const startY = evnt.pageY;
      const marginSize = computeMarginSize.value;
      document.onmousemove = et => {
        const {
          pageX,
          pageY
        } = et;
        const {
          visibleHeight,
          visibleWidth
        } = getDomNode();
        et.preventDefault();
        addClass(elem, 'is--move');
        // éå¶è¾¹çå¼
        if (pageX > marginSize && pageY > marginSize && pageX < visibleWidth - marginSize && pageY < visibleHeight - marginSize) {
          reactData.offsetLeft = offsetLeft + pageX - startX;
          reactData.offsetTop = offsetTop + pageY - startY;
        }
      };
      document.onmouseup = () => {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        removeClass(elem, 'is--move');
      };
    };
    const handleGlobalKeydownEvent = evnt => {
      const isControlKey = hasControlKey(evnt);
      const hasShiftKey = evnt.shiftKey;
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDownArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
      const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
      const isR = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.R);
      const isP = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.P);
      if (isUpArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop -= 1;
        } else {
          handleZoom(true);
        }
      } else if (isDownArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop += 1;
        } else {
          handleZoom(false);
        }
      } else if (isLeftArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft -= 1;
        } else {
          handleChangeEvent(evnt, false);
        }
      } else if (isRightArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft += 1;
        } else {
          handleChangeEvent(evnt, true);
        }
      } else if (isR && isControlKey) {
        evnt.preventDefault();
        if (hasShiftKey) {
          handleRotateImgEvent(evnt, false);
        } else {
          handleRotateImgEvent(evnt, true);
        }
      } else if (isP && isControlKey) {
        evnt.preventDefault();
        handlePrintImg();
      }
    };
    const handleClickMaskEvent = evnt => {
      if (props.maskClosable) {
        if (evnt.target === evnt.currentTarget) {
          dispatchEvent('close', {}, evnt);
        }
      }
    };
    Object.assign($xeImagePreview, imagePreviewMethods, imagePreviewPrivateMethods);
    const renderImgWrapper = () => {
      const {
        activeIndex
      } = reactData;
      const imgList = computeImgList.value;
      const imgTransform = computeImgTransform.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--img-list',
        onClick: handleClickMaskEvent
      }, imgList.map((url, index) => {
        const isActive = activeIndex === index;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
          class: ['vxe-image-preview--img-item', {
            'is--active': isActive
          }],
          src: url,
          style: isActive ? {
            transform: imgTransform
          } : null,
          onMousedown(evnt) {
            moveEvent(evnt);
          }
        });
      }));
    };
    const renderOperationBtn = (code, icon) => {
      const toolbarOpts = computeToolbarOpts.value;
      const btnConf = toolbarOpts[code];
      const btnOpts = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(btnConf) ? {} : btnConf ? Object.assign({}, btnConf) : {};
      const showBtn = btnConf !== false;
      return showBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-btn',
        title: getI18n(`vxe.imagePreview.operBtn.${code}`),
        onClick(evnt) {
          handleOperationBtn(evnt, code);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: btnOpts.icon || getIcon()[icon]
      })]) : renderEmptyElement($xeImagePreview);
    };
    const renderBtnWrapper = () => {
      const {
        showPrintButton,
        showDownloadButton
      } = props;
      const {
        activeIndex
      } = reactData;
      const imgList = computeImgList.value;
      const rotateText = computeRotateText.value;
      const scaleText = computeScaleText.value;
      const toolbarOpts = computeToolbarOpts.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--close-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--close-btn',
        onClick: handleCloseEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().IMAGE_PREVIEW_CLOSE
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--close-bg'
      })]), imgList.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--previous-btn',
        onClick(evnt) {
          handleChangeEvent(evnt, false);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().IMAGE_PREVIEW_PREVIOUS
      })]) : renderEmptyElement($xeImagePreview), imgList.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--next-btn',
        onClick(evnt) {
          handleChangeEvent(evnt, true);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().IMAGE_PREVIEW_NEXT
      })]) : renderEmptyElement($xeImagePreview), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-info'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-deg'
      }, rotateText), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-pct'
      }, scaleText)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-active-count'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-image-preview--operation-active-current'
      }, `${(activeIndex || 0) + 1}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-image-preview--operation-active-total'
      }, `/${imgList.length}`)]), renderOperationBtn('zoomOut', 'IMAGE_PREVIEW_ZOOM_OUT'), renderOperationBtn('zoomIn', 'IMAGE_PREVIEW_ZOOM_IN'), renderOperationBtn('pctFull', 'IMAGE_PREVIEW_PCT_FULL'), renderOperationBtn('pct11', 'IMAGE_PREVIEW_PCT_1_1'), renderOperationBtn('rotateLeft', 'IMAGE_PREVIEW_ROTATE_LEFT'), renderOperationBtn('rotateRight', 'IMAGE_PREVIEW_ROTATE_RIGHT'), showPrintButton || toolbarOpts.print ? renderOperationBtn('print', 'IMAGE_PREVIEW_PRINT') : renderEmptyElement($xeImagePreview), showDownloadButton || toolbarOpts.download ? renderOperationBtn('download', 'IMAGE_PREVIEW_DOWNLOAD') : renderEmptyElement($xeImagePreview)])]);
    };
    const renderVN = () => {
      const {
        offsetPct11
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-image-preview', {
          'is--pct11': offsetPct11
        }]
      }, [renderImgWrapper(), renderBtnWrapper()]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.activeIndex = val;
      resetStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if (elem) {
        elem.addEventListener('wheel', wheelEvent, {
          passive: false
        });
      }
      globalEvents.on($xeImagePreview, 'keydown', handleGlobalKeydownEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      const elem = refElem.value;
      if (elem) {
        elem.removeEventListener('wheel', wheelEvent);
        removeClass(elem, 'is--move');
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeImagePreview, 'keydown');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeImagePreview', $xeImagePreview);
    $xeImagePreview.renderVN = renderVN;
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/image/src/util.ts




const openPreviewImage = options => {
  if (index_esm_VxeUI.modal) {
    const opts = Object.assign({
      escClosable: true
    }, options);
    const {
      urlList,
      activeIndex,
      zIndex
    } = opts;
    const {
      rotate,
      change
    } = opts.events || {};
    const modalId = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('image-preview');
    index_esm_VxeUI.modal.open({
      id: modalId,
      title: 'é¢è§',
      width: '100%',
      height: '100%',
      showHeader: false,
      showFooter: false,
      padding: false,
      escClosable: opts.escClosable,
      zIndex,
      className: 'vxe-image-preview-popup-wrapper',
      slots: {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(preview, {
            modelValue: activeIndex,
            urlList,
            urlField: opts.urlField,
            marginSize: opts.marginSize,
            maskClosable: opts.maskClosable,
            toolbarConfig: opts.toolbarConfig,
            showPrintButton: opts.showPrintButton,
            showDownloadButton: opts.showDownloadButton,
            beforeDownloadMethod: opts.beforeDownloadMethod,
            downloadMethod: opts.downloadMethod,
            onClose() {
              index_esm_VxeUI.modal.close(modalId);
            },
            onChange(eventParams) {
              if (change) {
                change.call(this, eventParams);
              }
            },
            onRotate(eventParams) {
              if (rotate) {
                rotate.call(this, eventParams);
              }
            }
          });
        }
      }
    });
  }
  return Promise.resolve();
};
;// CONCATENATED MODULE: ./packages/image/src/image.ts






/* harmony default export */ var src_image = (defineVxeComponent({
  name: 'VxeImage',
  props: {
    src: [String, Array],
    alt: [String, Number],
    loading: String,
    title: [String, Number],
    width: [String, Number],
    height: [String, Number],
    circle: Boolean,
    zIndex: Number,
    maskClosable: {
      type: Boolean,
      default: () => getConfig().image.maskClosable
    },
    toolbarConfig: Object,
    showPreview: {
      type: Boolean,
      default: () => getConfig().image.showPreview
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().image.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().image.showDownloadButton
    },
    size: {
      type: String,
      default: () => getConfig().image.size || getConfig().size
    },
    getThumbnailUrlMethod: Function
  },
  emits: ['click', 'change', 'rotate'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeImageGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeImageGroup', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeImgStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        height
      } = props;
      const style = {};
      if (width && height) {
        style.maxWidth = toCssUnit(width);
        style.maxHeight = toCssUnit(height);
      } else {
        if (width) {
          style.width = toCssUnit(width);
        }
        if (height) {
          style.height = toCssUnit(height);
        }
      }
      return style;
    });
    const computeImgList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        src
      } = props;
      if (src) {
        return (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(src) ? src : [src]).map(item => {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
            return {
              url: item,
              alt: ''
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const imgList = computeImgList.value;
      return imgList[0];
    });
    const computeImgUrl = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const imgItem = computeImgItem.value;
      return imgItem ? `${imgItem.url || ''}` : '';
    });
    const computeImgThumbnailUrl = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const getThumbnailUrlFn = props.getThumbnailUrlMethod || getConfig().image.getThumbnailUrlMethod;
      const imgUrl = computeImgUrl.value;
      return getThumbnailUrlFn ? getThumbnailUrlFn({
        url: imgUrl,
        $image: $xeImage
      }) : '';
    });
    const computeMaps = {
      computeSize
    };
    const $xeImage = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const imageMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $image: $xeImage
        }, params));
      }
    };
    const clickEvent = evnt => {
      const {
        showPreview,
        toolbarConfig,
        showPrintButton,
        showDownloadButton,
        maskClosable,
        zIndex
      } = props;
      const imgList = computeImgList.value;
      const imgUrl = computeImgUrl.value;
      if ($xeImageGroup) {
        $xeImageGroup.handleClickImgEvent(evnt, {
          url: imgUrl
        });
      } else {
        if (showPreview && imgUrl) {
          openPreviewImage({
            urlList: imgList,
            toolbarConfig,
            showPrintButton,
            showDownloadButton,
            maskClosable,
            zIndex,
            events: {
              change(eventParams) {
                $xeImage.dispatchEvent('change', eventParams, eventParams.$event);
              },
              rotate(eventParams) {
                $xeImage.dispatchEvent('rotate', eventParams, eventParams.$event);
              }
            }
          });
        }
        $xeImage.dispatchEvent('click', {
          url: imgUrl
        }, evnt);
      }
    };
    const imagePrivateMethods = {};
    Object.assign($xeImage, imageMethods, imagePrivateMethods);
    const renderVN = () => {
      const {
        alt,
        loading,
        circle
      } = props;
      const imgStyle = computeImgStyle.value;
      const imgUrl = computeImgUrl.value;
      const imgThumbnailUrl = computeImgThumbnailUrl.value;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
        ref: refElem,
        class: ['vxe-image', {
          [`size--${vSize}`]: vSize,
          'is--circle': circle
        }],
        src: imgThumbnailUrl || imgUrl,
        alt,
        loading,
        style: imgStyle,
        onClick: clickEvent
      });
    };
    $xeImage.renderVN = renderVN;
    return $xeImage;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/image/index.ts



const VxeImage = Object.assign({}, src_image, {
  install(app) {
    app.component(src_image.name, src_image);
  }
});
dynamicApp.use(VxeImage);
index_esm_VxeUI.component(src_image);
const image_Image = VxeImage;
/* harmony default export */ var packages_image = (VxeImage);
;// CONCATENATED MODULE: ./packages/image/src/group.ts






/* harmony default export */ var src_group = (defineVxeComponent({
  name: 'VxeImageGroup',
  props: {
    urlList: [Array, String],
    showPreview: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPreview
    },
    imageStyle: Object,
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().imageGroup.size || getConfig().size
    },
    toolbarConfig: Object,
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imageGroup.showDownloadButton
    },
    getThumbnailUrlMethod: Function
  },
  emits: ['click', 'change', 'rotate'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const computeImgList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        urlList
      } = props;
      if (urlList) {
        return (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(urlList) ? urlList : [urlList]).map(item => {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
            return {
              url: item,
              alt: ''
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgStyleOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().imageGroup.imageStyle, props.imageStyle);
    });
    const computeGetThumbnailUrlMethod = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.getThumbnailUrlMethod || getConfig().imageGroup.getThumbnailUrlMethod;
    });
    const computeMaps = {
      computeSize
    };
    const $xeImageGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    const imageGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $imageGroup: $xeImageGroup
        }, params));
      }
    };
    const imageGroupPrivateMethods = {
      handleClickImgEvent(evnt, params) {
        const {
          showPreview,
          toolbarConfig,
          showPrintButton,
          showDownloadButton,
          zIndex
        } = props;
        const {
          url
        } = params;
        const imgList = computeImgList.value;
        if (showPreview && url) {
          openPreviewImage({
            activeIndex: Math.max(0, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(imgList, item => item.url === url)),
            urlList: imgList,
            toolbarConfig,
            showPrintButton,
            showDownloadButton,
            zIndex,
            events: {
              change(eventParams) {
                $xeImageGroup.dispatchEvent('change', eventParams, eventParams.$event);
              },
              rotate(eventParams) {
                $xeImageGroup.dispatchEvent('rotate', eventParams, eventParams.$event);
              }
            }
          });
        }
        $xeImageGroup.dispatchEvent('click', {
          url,
          urlList: imgList
        }, evnt);
      }
    };
    Object.assign($xeImageGroup, imageGroupMethods, imageGroupPrivateMethods);
    const renderVN = () => {
      const imgList = computeImgList.value;
      const vSize = computeSize.value;
      const imgStyleOpts = computeImgStyleOpts.value;
      const getThumbnailUrlMethod = computeGetThumbnailUrlMethod.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-image-group', {
          [`size--${vSize}`]: vSize
        }]
      }, imgList ? imgList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_image, {
          key: index,
          src: item.url,
          alt: item.alt,
          width: imgStyleOpts.width,
          height: imgStyleOpts.height,
          getThumbnailUrlMethod
        });
      }) : []);
    };
    $xeImageGroup.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeImageGroup', $xeImageGroup);
    return $xeImageGroup;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/image-group/index.ts



const VxeImageGroup = Object.assign({}, src_group, {
  install(app) {
    app.component(src_group.name, src_group);
  }
});
dynamicApp.use(VxeImageGroup);
index_esm_VxeUI.component(src_group);
const ImageGroup = VxeImageGroup;
/* harmony default export */ var image_group = (VxeImageGroup);
;// CONCATENATED MODULE: ./packages/image-preview/index.ts




const VxeImagePreview = Object.assign(preview, {
  install(app) {
    app.component(preview.name, preview);
  }
});
index_esm_VxeUI.previewImage = openPreviewImage;
dynamicApp.use(VxeImagePreview);
index_esm_VxeUI.component(preview);
const ImagePreview = VxeImagePreview;
/* harmony default export */ var image_preview = (VxeImagePreview);
;// CONCATENATED MODULE: ./packages/input/index.ts



const VxeInput = Object.assign(input, {
  install(app) {
    app.component(input.name, input);
  }
});
dynamicApp.use(VxeInput);
index_esm_VxeUI.component(input);
const Input = VxeInput;
/* harmony default export */ var packages_input = (VxeInput);
;// CONCATENATED MODULE: ./packages/layout-aside/src/layout-aside.ts






/* harmony default export */ var layout_aside = (defineVxeComponent({
  name: 'VxeLayoutAside',
  props: {
    width: [String, Number],
    collapsed: Boolean,
    collapseWidth: [String, Number],
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutAside.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeWrapperWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        collapsed,
        collapseWidth
      } = props;
      if (collapsed) {
        if (collapseWidth) {
          return toCssUnit(collapseWidth);
        }
      } else {
        if (width) {
          return toCssUnit(width);
        }
      }
      return '';
    });
    const computeMaps = {
      computeSize
    };
    const $xeLayoutAside = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $layoutAside: $xeLayoutAside
      }, params));
    };
    const layoutAsideMethods = {
      dispatchEvent
    };
    const layoutAsidePrivateMethods = {};
    Object.assign($xeLayoutAside, layoutAsideMethods, layoutAsidePrivateMethods);
    const renderVN = () => {
      const {
        width,
        collapsed,
        loading,
        padding
      } = props;
      const wrapperWidth = computeWrapperWidth.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('aside', {
        ref: refElem,
        class: ['vxe-layout-aside', {
          [`size--${vSize}`]: vSize,
          'is--padding': padding,
          'is--default-width': !width,
          'is--collapse': collapsed,
          'is--loading': loading
        }],
        style: wrapperWidth ? {
          width: wrapperWidth
        } : null
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-layout-aside--inner'
      }, defaultSlot ? defaultSlot({}) : []),
      /**
       * å è½½ä¸­
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-list-view--loading',
        modelValue: loading
      })]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeLayoutAside', $xeLayoutAside);
    $xeLayoutAside.renderVN = renderVN;
    return $xeLayoutAside;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-aside/index.ts



const VxeLayoutAside = Object.assign({}, layout_aside, {
  install(app) {
    app.component(layout_aside.name, layout_aside);
  }
});
dynamicApp.use(VxeLayoutAside);
index_esm_VxeUI.component(layout_aside);
const LayoutAside = VxeLayoutAside;
/* harmony default export */ var packages_layout_aside = (VxeLayoutAside);
;// CONCATENATED MODULE: ./packages/layout-body/src/layout-body.ts





/* harmony default export */ var layout_body = (defineVxeComponent({
  name: 'VxeLayoutBody',
  props: {
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutBody.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeLayoutBody = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $layoutBody: $xeLayoutBody
      }, params));
    };
    const layoutBodyMethods = {
      dispatchEvent
    };
    const layoutBodyPrivateMethods = {};
    Object.assign($xeLayoutBody, layoutBodyMethods, layoutBodyPrivateMethods);
    const renderVN = () => {
      const {
        loading,
        padding
      } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-layout-body', {
          [`size--${vSize}`]: vSize,
          'is--loading': loading,
          'is--padding': padding
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-layout-body--inner'
      }, defaultSlot ? defaultSlot({}) : []),
      /**
       * å è½½ä¸­
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-list-view--loading',
        modelValue: loading
      })]);
    };
    $xeLayoutBody.renderVN = renderVN;
    return $xeLayoutBody;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-body/index.ts



const VxeLayoutBody = Object.assign({}, layout_body, {
  install(app) {
    app.component(layout_body.name, layout_body);
  }
});
dynamicApp.use(VxeLayoutBody);
index_esm_VxeUI.component(layout_body);
const LayoutBody = VxeLayoutBody;
/* harmony default export */ var packages_layout_body = (VxeLayoutBody);
;// CONCATENATED MODULE: ./packages/layout-container/src/layout-container.ts




/* harmony default export */ var layout_container = (defineVxeComponent({
  name: 'VxeLayoutContainer',
  props: {
    vertical: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutContainer.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeLayoutContainer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $layoutContainer: $xeLayoutContainer
      }, params));
    };
    const layoutContainerMethods = {
      dispatchEvent
    };
    const layoutContainerPrivateMethods = {};
    Object.assign($xeLayoutContainer, layoutContainerMethods, layoutContainerPrivateMethods);
    const renderVN = () => {
      const {
        vertical
      } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-layout-container', {
          [`size--${vSize}`]: vSize,
          'is--vertical': vertical
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutContainer.renderVN = renderVN;
    return $xeLayoutContainer;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-container/index.ts



const VxeLayoutContainer = Object.assign({}, layout_container, {
  install(app) {
    app.component(layout_container.name, layout_container);
  }
});
dynamicApp.use(VxeLayoutContainer);
index_esm_VxeUI.component(layout_container);
const LayoutContainer = VxeLayoutContainer;
/* harmony default export */ var packages_layout_container = (VxeLayoutContainer);
;// CONCATENATED MODULE: ./packages/layout-footer/src/layout-footer.ts




/* harmony default export */ var layout_footer = (defineVxeComponent({
  name: 'VxeLayoutFooter',
  props: {
    fixed: Boolean,
    align: String
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutFooter = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $layoutFooter: $xeLayoutFooter
      }, params));
    };
    const layoutFooterMethods = {
      dispatchEvent
    };
    const layoutFooterPrivateMethods = {};
    Object.assign($xeLayoutFooter, layoutFooterMethods, layoutFooterPrivateMethods);
    const renderVN = () => {
      const {
        fixed,
        align
      } = props;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('footer', {
        ref: refElem,
        class: ['vxe-layout-footer', align ? `align--${align}` : '', {
          'is--fixed': fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutFooter.renderVN = renderVN;
    return $xeLayoutFooter;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-footer/index.ts



const VxeLayoutFooter = Object.assign({}, layout_footer, {
  install(app) {
    app.component(layout_footer.name, layout_footer);
  }
});
dynamicApp.use(VxeLayoutFooter);
index_esm_VxeUI.component(layout_footer);
const LayoutFooter = VxeLayoutFooter;
/* harmony default export */ var packages_layout_footer = (VxeLayoutFooter);
;// CONCATENATED MODULE: ./packages/layout-header/src/layout-header.ts




/* harmony default export */ var layout_header = (defineVxeComponent({
  name: 'VxeLayoutHeader',
  props: {
    fixed: Boolean
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutHeader = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $layoutHeader: $xeLayoutHeader
      }, params));
    };
    const layoutHeaderMethods = {
      dispatchEvent
    };
    const layoutHeaderPrivateMethods = {};
    Object.assign($xeLayoutHeader, layoutHeaderMethods, layoutHeaderPrivateMethods);
    const renderVN = () => {
      const {
        fixed
      } = props;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('header', {
        ref: refElem,
        class: ['vxe-layout-header', {
          'is--fixed': fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutHeader.renderVN = renderVN;
    return $xeLayoutHeader;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-header/index.ts



const VxeLayoutHeader = Object.assign({}, layout_header, {
  install(app) {
    app.component(layout_header.name, layout_header);
  }
});
dynamicApp.use(VxeLayoutHeader);
index_esm_VxeUI.component(layout_header);
const LayoutHeader = VxeLayoutHeader;
/* harmony default export */ var packages_layout_header = (VxeLayoutHeader);
;// CONCATENATED MODULE: ./packages/link/src/link.ts





/* harmony default export */ var src_link = (defineVxeComponent({
  name: 'VxeLink',
  props: {
    href: String,
    target: String,
    status: String,
    title: [String, Number],
    disabled: Boolean,
    icon: String,
    routerLink: Object,
    underline: {
      type: Boolean,
      default: () => getConfig().link.underline
    },
    /**
     * æéç 
     */
    permissionCode: [String, Number],
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().link.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLink = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $link: $xeLink
      }, params));
    };
    const linkMethods = {
      dispatchEvent
    };
    const linkPrivateMethods = {};
    const clickEvent = evnt => {
      const {
        disabled
      } = props;
      if (!disabled) {
        dispatchEvent('click', {}, evnt);
      }
    };
    Object.assign($xeLink, linkMethods, linkPrivateMethods);
    const renderContent = () => {
      const {
        icon,
        content
      } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      const textContent = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content);
      return [iconSlot || icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-link--icon'
      }, iconSlot ? vn_getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon
      })]) : renderEmptyElement($xeLink), defaultSlot || textContent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-link--content'
      }, defaultSlot ? defaultSlot({}) : textContent) : renderEmptyElement($xeLink)];
    };
    const renderVN = () => {
      const {
        status,
        target,
        href,
        title,
        underline,
        disabled,
        routerLink
      } = props;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeLink);
      }
      if (routerLink && !disabled) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
          class: ['vxe-link', {
            [`size--${vSize}`]: vSize,
            [`theme--${status}`]: status,
            'is--disabled': disabled,
            'is--underline': underline
          }],
          title,
          target,
          to: disabled ? null : routerLink,
          onClick: clickEvent
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
        ref: refElem,
        class: ['vxe-link', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--disabled': disabled,
          'is--underline': underline
        }],
        href: disabled ? null : href,
        target,
        title,
        onClick: clickEvent
      }, renderContent());
    };
    $xeLink.renderVN = renderVN;
    return $xeLink;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/link/index.ts



const VxeLink = Object.assign({}, src_link, {
  install(app) {
    app.component(src_link.name, src_link);
  }
});
dynamicApp.use(VxeLink);
index_esm_VxeUI.component(src_link);
const Link = VxeLink;
/* harmony default export */ var packages_link = (VxeLink);
;// CONCATENATED MODULE: ./packages/list/src/list.ts






function list_createInternalData() {
  return {
    resizeObserver: undefined,
    fullData: [],
    lastScrollLeft: 0,
    lastScrollTop: 0,
    scrollYStore: {
      startIndex: 0,
      endIndex: 0,
      visibleSize: 0,
      offsetSize: 0,
      rowHeight: 0
    }
  };
}
/* harmony default export */ var list = (defineVxeComponent({
  name: 'VxeList',
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: {
      type: String,
      default: () => getConfig().list.size || getConfig().size
    },
    autoResize: {
      type: Boolean,
      default: () => getConfig().list.autoResize
    },
    syncResize: [Boolean, String, Number],
    virtualYConfig: Object,
    scrollY: Object
  },
  emits: ['scroll'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const browseObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      scrollYLoad: false,
      bodyHeight: 0,
      customHeight: 0,
      customMaxHeight: 0,
      parentHeight: 0,
      topSpaceHeight: 0,
      items: []
    });
    const internalData = list_createInternalData();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeList = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeSYOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().list.virtualYConfig || getConfig().list.scrollY, props.virtualYConfig || props.scrollY);
    });
    const computeStyles = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        height,
        maxHeight
      } = props;
      const {
        customHeight,
        customMaxHeight
      } = reactData;
      const style = {};
      if (height) {
        style.height = `${customHeight}px`;
      } else if (maxHeight) {
        style.height = 'auto';
        style.maxHeight = `${customMaxHeight}px`;
      }
      return style;
    });
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $list: $xeList
      }, params));
    };
    const calcTableHeight = key => {
      const {
        parentHeight
      } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === '100%' || val === 'auto') {
          num = parentHeight;
        } else {
          if (isScale(val)) {
            num = Math.floor((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val);
          }
          num = Math.max(40, num);
        }
      }
      return num;
    };
    const updateHeight = () => {
      reactData.customHeight = calcTableHeight('height');
      reactData.customMaxHeight = calcTableHeight('maxHeight');
    };
    const updateYSpace = () => {
      const {
        scrollYLoad
      } = reactData;
      const {
        scrollYStore,
        fullData
      } = internalData;
      reactData.bodyHeight = scrollYLoad ? fullData.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const {
        scrollYLoad
      } = reactData;
      const {
        fullData,
        scrollYStore
      } = internalData;
      reactData.items = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          scrollYLoad
        } = reactData;
        const {
          scrollYStore
        } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const sYOpts = computeSYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(12, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        // è®¡ç® Y é»è¾
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, Math.ceil(scrollBodyElem.clientHeight / rowHeight));
          const offsetYSize = sYOpts.oSize ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(sYOpts.oSize) : browseObj.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    /**
     * æ¸é¤æ»å¨æ¡
     */
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * å¦æææ»å¨æ¡ï¼åæ»å¨å°å¯¹åºçä½ç½®
     */
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollLeft) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
          scrollTop = scrollLeft.top;
          scrollLeft = scrollLeft.left;
        }
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
        scrollBodyElem.scrollLeft = scrollLeft;
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollTop)) {
        scrollBodyElem.scrollTop = scrollTop;
      }
      if (reactData.scrollYLoad) {
        return new Promise(resolve => {
          setTimeout(() => {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              resolve();
            });
          }, 50);
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * å·æ°æ»å¨æ¡
     */
    const refreshScroll = () => {
      const {
        lastScrollLeft,
        lastScrollTop
      } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    /**
     * éæ°è®¡ç®åè¡¨
     */
    const recalculate = () => {
      const el = refElem.value;
      if (el) {
        const parentEl = el.parentElement;
        reactData.parentHeight = parentEl ? parentEl.clientHeight : 0;
        updateHeight();
        if (el.clientWidth && el.clientHeight) {
          return computeScrollLoad();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const loadYData = evnt => {
      const {
        scrollYStore
      } = internalData;
      const {
        startIndex,
        endIndex,
        visibleSize,
        offsetSize,
        rowHeight
      } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = evnt => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      dispatchEvent('scroll', {
        scrollLeft,
        scrollTop,
        isX,
        isY
      }, evnt);
    };
    /**
     * å è½½æ°æ®
     * @param {Array} datas æ°æ®
     */
    const loadData = datas => {
      const {
        scrollYStore
      } = internalData;
      const sYOpts = computeSYOpts.value;
      const fullData = datas || [];
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      internalData.fullData = fullData;
      // å¦ægtä¸º0ï¼åæ»æ¯å¯ç¨
      reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
      handleData();
      return computeScrollLoad().then(() => {
        refreshScroll();
      });
    };
    const listMethods = {
      dispatchEvent,
      loadData,
      /**
       * éæ°å è½½æ°æ®
       * @param {Array} datas æ°æ®
       */
      reloadData(datas) {
        clearScroll();
        return loadData(datas);
      },
      recalculate,
      scrollTo,
      refreshScroll,
      clearScroll
    };
    Object.assign($xeList, listMethods);
    const renderVN = () => {
      const {
        className,
        loading
      } = props;
      const {
        bodyHeight,
        topSpaceHeight,
        items
      } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-list', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $list: $xeList
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--loading': loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualWrapper,
        class: 'vxe-list--virtual-wrapper',
        style: styles,
        onScroll: scrollEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list--y-space',
        style: {
          height: bodyHeight ? `${bodyHeight}px` : ''
        }
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualBody,
        class: 'vxe-list--body',
        style: {
          marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ''
        }
      }, defaultSlot ? defaultSlot({
        items,
        $list: $xeList
      }) : [])]),
      /**
       * å è½½ä¸­
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-list--loading',
        modelValue: loading
      })]);
    };
    const dataFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(dataFlag, () => {
      loadData(props.data || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, () => {
      recalculate();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.maxHeight, () => {
      recalculate();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.syncResize, value => {
      if (value) {
        recalculate();
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => setTimeout(() => recalculate()));
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onActivated)(() => {
      recalculate().then(() => refreshScroll());
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      loadData(props.data || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      recalculate();
      if (props.autoResize) {
        const el = refElem.value;
        const resizeObserver = globalResize.create(() => recalculate());
        resizeObserver.observe(el);
        if (el) {
          resizeObserver.observe(el.parentElement);
        }
        internalData.resizeObserver = resizeObserver;
      }
      globalEvents.on($xeList, 'resize', recalculate);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      const {
        resizeObserver
      } = internalData;
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeList, 'resize');
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData, list_createInternalData());
    });
    $xeList.renderVN = renderVN;
    return $xeList;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/list/index.ts



const VxeList = Object.assign(list, {
  install(app) {
    app.component(list.name, list);
  }
});
dynamicApp.use(VxeList);
index_esm_VxeUI.component(list);
const List = VxeList;
/* harmony default export */ var packages_list = (VxeList);
;// CONCATENATED MODULE: ./packages/menu/src/menu.ts








/* harmony default export */ var menu = (defineVxeComponent({
  name: 'VxeMenu',
  props: {
    modelValue: [String, Number],
    expandAll: Boolean,
    accordion: {
      type: Boolean,
      default: () => getConfig().menu.accordion
    },
    collapsed: {
      type: Boolean,
      default: null
    },
    collapseFixed: Boolean,
    loading: Boolean,
    options: {
      type: Array,
      default: () => []
    },
    size: {
      type: String,
      default: () => getConfig().menu.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'click'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeLayoutAside = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeLayoutAside', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refCollapseElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: !!props.collapsed,
      isEnterCollapse: false,
      collapseStyle: {},
      collapseZindex: 0,
      activeName: props.modelValue,
      menuList: [],
      itemHeight: 1
    });
    const refMaps = {
      refElem
    };
    const computeIsCollapsed = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        collapsed
      } = props;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(collapsed)) {
        return collapsed;
      }
      if ($xeLayoutAside) {
        return !!$xeLayoutAside.props.collapsed;
      }
      return false;
    });
    const computeCollapseWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      let collapseWidth = '';
      if ($xeLayoutAside) {
        collapseWidth = $xeLayoutAside.props.collapseWidth || '';
      }
      return collapseWidth;
    });
    const computeCollapseEnterWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      let width = '';
      if ($xeLayoutAside) {
        width = $xeLayoutAside.props.width || '';
      }
      return width;
    });
    const computeMaps = {
      computeSize
    };
    const $xeMenu = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getMenuTitle = item => {
      return `${item.title || item.name}`;
    };
    const updateZindex = () => {
      if (reactData.collapseZindex < getLastZIndex()) {
        reactData.collapseZindex = nextZIndex();
      }
    };
    const updateActiveMenu = isDefExpand => {
      const {
        activeName
      } = reactData;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(reactData.menuList, (item, index, items, path, parent, nodes) => {
        if (item.itemKey === activeName) {
          nodes.forEach(obj => {
            obj.isActive = true;
            if (isDefExpand) {
              obj.isExpand = true;
            }
          });
          item.isExactActive = true;
        } else {
          item.isExactActive = false;
          item.isActive = false;
        }
      }, {
        children: 'childList'
      });
    };
    const updateMenuConfig = () => {
      const {
        options,
        expandAll
      } = props;
      reactData.menuList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(options, (item, index, items, path, parent) => {
        const objItem = {
          ...item,
          parentKey: parent ? parent.name || path.slice(0, path.length - 1).join(',') : '',
          level: path.length,
          itemKey: item.name || path.join(','),
          isExactActive: false,
          isActive: false,
          isExpand: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(item.expanded) ? item.expanded : !!expandAll,
          hasChild: item.children && item.children.length > 0
        };
        return objItem;
      }, {
        children: 'children',
        mapChildren: 'childList'
      });
    };
    const updateCollapseStyle = () => {
      const {
        collapseFixed
      } = props;
      if (collapseFixed) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const {
            isEnterCollapse
          } = reactData;
          const isCollapsed = computeIsCollapsed.value;
          const collapseEnterWidth = computeCollapseEnterWidth.value;
          const collapseWidth = computeCollapseWidth.value;
          const el = refElem.value;
          if (el) {
            const clientRect = el.getBoundingClientRect();
            const parentNode = el.parentNode;
            reactData.collapseStyle = isCollapsed ? {
              top: toCssUnit(clientRect.top),
              left: toCssUnit(clientRect.left),
              height: toCssUnit(parentNode.clientHeight),
              width: isEnterCollapse ? collapseEnterWidth ? toCssUnit(collapseEnterWidth) : '' : collapseWidth ? toCssUnit(collapseWidth) : '',
              zIndex: reactData.collapseZindex
            } : {};
          }
        });
      }
    };
    const handleCollapseMenu = () => {
      const {
        collapseFixed
      } = props;
      if (collapseFixed) {
        const {
          initialized
        } = reactData;
        const isCollapsed = computeIsCollapsed.value;
        if (isCollapsed) {
          if (!initialized) {
            reactData.initialized = true;
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              const collapseEl = refCollapseElem.value;
              if (collapseEl) {
                document.body.appendChild(collapseEl);
              }
            });
          }
        }
        reactData.isEnterCollapse = false;
        updateZindex();
        updateCollapseStyle();
      }
    };
    const handleClickIconCollapse = (evnt, item, itemList) => {
      const {
        accordion
      } = props;
      const {
        hasChild,
        isExpand
      } = item;
      if (hasChild) {
        evnt.stopPropagation();
        evnt.preventDefault();
        if (accordion) {
          itemList.forEach(obj => {
            if (obj !== item) {
              obj.isExpand = false;
            }
          });
        }
        item.isExpand = !isExpand;
      }
    };
    const emitModel = value => {
      reactData.activeName = value;
      emit('update:modelValue', value);
    };
    const handleClickMenu = (evnt, item, itemList) => {
      const {
        itemKey,
        routerLink,
        hasChild
      } = item;
      if (routerLink) {
        emitModel(itemKey);
        handleMenuMouseleave();
      } else {
        if (hasChild) {
          handleClickIconCollapse(evnt, item, itemList);
        } else {
          emitModel(itemKey);
          handleMenuMouseleave();
        }
      }
      dispatchEvent('click', {
        menu: item
      }, evnt);
    };
    const handleMenuMouseenter = () => {
      const {
        collapseStyle
      } = reactData;
      const collapseEnterWidth = computeCollapseEnterWidth.value;
      reactData.collapseStyle = Object.assign({}, collapseStyle, {
        width: collapseEnterWidth ? toCssUnit(collapseEnterWidth) : ''
      });
      reactData.isEnterCollapse = true;
    };
    const handleMenuMouseover = () => {
      const {
        isEnterCollapse
      } = reactData;
      if (!isEnterCollapse) {
        handleMenuMouseenter();
      }
    };
    const handleMenuMouseleave = () => {
      const {
        collapseStyle
      } = reactData;
      const el = refElem.value;
      reactData.collapseStyle = Object.assign({}, collapseStyle, {
        width: el ? toCssUnit(el.offsetWidth) : ''
      });
      reactData.isEnterCollapse = false;
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $menu: $xeMenu
      }, params));
    };
    const menuMethods = {
      dispatchEvent
    };
    const menuPrivateMethods = {};
    Object.assign($xeMenu, menuMethods, menuPrivateMethods);
    const renderMenuTitle = (item, itemList) => {
      const {
        icon,
        isExpand,
        hasChild
      } = item;
      const itemSlots = item.slots || {};
      const optionSlot = itemSlots.default || slots.option;
      const titleSlot = itemSlots.title || slots.optionTitle || slots['option-title'];
      const iconSlot = itemSlots.icon || slots.optionIcon || slots['option-icon'];
      const title = getMenuTitle(item);
      const isCollapsed = computeIsCollapsed.value;
      const params = {
        option: item,
        collapsed: isCollapsed
      };
      return [optionSlot ? renderEmptyElement($xeMenu) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-link-icon'
      }, iconSlot ? callSlot(iconSlot, params) : icon ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon
      })] : []), optionSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-custom-title'
      }, callSlot(optionSlot, params)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-link-title',
        title
      }, titleSlot ? callSlot(titleSlot, params) : title), hasChild ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-link-collapse',
        onClick(evnt) {
          handleClickIconCollapse(evnt, item, itemList);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: isExpand ? getIcon().MENU_ITEM_EXPAND_OPEN : getIcon().MENU_ITEM_EXPAND_CLOSE
      })]) : renderEmptyElement($xeMenu)];
    };
    const renderDefaultChildren = (item, itemList) => {
      const {
        itemKey,
        level,
        hasChild,
        isActive,
        isExactActive,
        isExpand,
        routerLink,
        childList
      } = item;
      const {
        isEnterCollapse
      } = reactData;
      const isCollapsed = computeIsCollapsed.value;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return renderEmptyElement($xeMenu);
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: itemKey,
        class: ['vxe-menu--item-wrapper', `vxe-menu--item-level${level}`, {
          'is--exact-active': isExactActive,
          'is--active': isActive,
          'is--expand': (!isCollapsed || isEnterCollapse) && isExpand
        }]
      }, [routerLink ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
        class: 'vxe-menu--item-link',
        to: routerLink,
        onClick(evnt) {
          handleClickMenu(evnt, item, itemList);
        }
      }, {
        default: () => renderMenuTitle(item, itemList)
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-link',
        onClick(evnt) {
          handleClickMenu(evnt, item, itemList);
        }
      }, renderMenuTitle(item, itemList)), hasChild ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-group'
      }, childList.map(child => renderDefaultChildren(child, childList))) : renderEmptyElement($xeMenu)]);
    };
    const renderCollapseChildren = (item, itemList) => {
      const {
        itemKey,
        level,
        hasChild,
        isActive,
        isExactActive,
        routerLink,
        childList
      } = item;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return renderEmptyElement($xeMenu);
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: itemKey,
        class: ['vxe-menu--item-wrapper', `vxe-menu--item-level${level}`, {
          'is--exact-active': isExactActive,
          'is--active': isActive
        }]
      }, [routerLink ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
        class: 'vxe-menu--item-link',
        to: routerLink,
        onClick(evnt) {
          handleClickMenu(evnt, item, itemList);
        }
      }, {
        default: () => renderMenuTitle(item, itemList)
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-link',
        onClick(evnt) {
          handleClickMenu(evnt, item, itemList);
        }
      }, renderMenuTitle(item, itemList)), hasChild ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-group'
      }, childList.map(child => renderDefaultChildren(child, childList))) : renderEmptyElement($xeMenu)]);
    };
    const renderVN = () => {
      const {
        loading,
        collapseFixed
      } = props;
      const {
        initialized,
        menuList,
        collapseStyle,
        isEnterCollapse
      } = reactData;
      const vSize = computeSize.value;
      const isCollapsed = computeIsCollapsed.value;
      let ons = {};
      if (collapseFixed) {
        ons = {
          onMouseenter: handleMenuMouseenter,
          onMouseover: handleMenuMouseover,
          onMouseleave: handleMenuMouseleave
        };
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-menu', {
          [`size--${vSize}`]: vSize,
          'is--collapsed': isCollapsed,
          'is--loading': loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-list'
      }, menuList.map(child => isCollapsed ? renderCollapseChildren(child, menuList) : renderDefaultChildren(child, menuList))), initialized ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refCollapseElem,
        class: ['vxe-menu--collapse-wrapper', {
          [`size--${vSize}`]: vSize,
          'is--collapsed': isCollapsed,
          'is--enter': isEnterCollapse,
          'is--loading': loading
        }],
        style: collapseStyle,
        ...ons
      }, [isCollapsed ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-list'
      }, menuList.map(child => renderDefaultChildren(child, menuList))) : renderEmptyElement($xeMenu)]) : renderEmptyElement($xeMenu),
      /**
       * å è½½ä¸­
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-list-view--loading',
        modelValue: loading
      })]);
    };
    const optFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options ? props.options.length : -1, () => {
      optFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      optFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(optFlag, () => {
      updateMenuConfig();
      updateActiveMenu(true);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.activeName = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.activeName, () => {
      updateActiveMenu(true);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeIsCollapsed, () => {
      handleCollapseMenu();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeMenu, 'resize', updateCollapseStyle);
      updateCollapseStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      globalEvents.off($xeMenu, 'resize');
      const collapseEl = refCollapseElem.value;
      if (collapseEl) {
        const parentNode = collapseEl.parentNode;
        if (parentNode) {
          parentNode.removeChild(collapseEl);
        }
      }
    });
    updateMenuConfig();
    updateActiveMenu(true);
    $xeMenu.renderVN = renderVN;
    return $xeMenu;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/menu/index.ts



const VxeMenu = Object.assign({}, menu, {
  install(app) {
    app.component(menu.name, menu);
  }
});
dynamicApp.use(VxeMenu);
index_esm_VxeUI.component(menu);
const Menu = VxeMenu;
/* harmony default export */ var packages_menu = (VxeMenu);
;// CONCATENATED MODULE: ./packages/modal/src/modal.ts











const allActiveModals = [];
const msgQueue = [];
const notifyQueue = [];
const lockScrollAttrKey = 'data-vxe-lock-scroll';
const lockScrollCssWidthKey = '--vxe-ui-modal-lock-scroll-view-width';
/* harmony default export */ var modal = (defineVxeComponent({
  name: 'VxeModal',
  props: {
    modelValue: Boolean,
    id: String,
    type: {
      type: String,
      default: 'modal'
    },
    loading: {
      type: Boolean,
      default: null
    },
    status: String,
    iconStatus: String,
    className: String,
    top: {
      type: [Number, String],
      default: () => getConfig().modal.top
    },
    position: [String, Object],
    title: String,
    duration: {
      type: [Number, String],
      default: () => getConfig().modal.duration
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => getConfig().modal.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().modal.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => getConfig().modal.confirmButtonText
    },
    lockView: {
      type: Boolean,
      default: () => getConfig().modal.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => getConfig().modal.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().modal.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => getConfig().modal.escClosable
    },
    cancelClosable: {
      type: Boolean,
      default: () => getConfig().modal.cancelClosable
    },
    confirmClosable: {
      type: Boolean,
      default: () => getConfig().modal.confirmClosable
    },
    resize: Boolean,
    showHeader: {
      type: Boolean,
      default: () => getConfig().modal.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => getConfig().modal.showFooter
    },
    showZoom: Boolean,
    zoomConfig: Object,
    showMaximize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMaximize)
    },
    showMinimize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMinimize)
    },
    showClose: {
      type: Boolean,
      default: () => getConfig().modal.showClose
    },
    dblclickZoom: {
      type: Boolean,
      default: () => getConfig().modal.dblclickZoom
    },
    width: [Number, String],
    height: [Number, String],
    minWidth: {
      type: [Number, String],
      default: () => getConfig().modal.minWidth
    },
    minHeight: {
      type: [Number, String],
      default: () => getConfig().modal.minHeight
    },
    zIndex: Number,
    marginSize: {
      type: [Number, String],
      default: () => getConfig().modal.marginSize
    },
    fullscreen: Boolean,
    draggable: {
      type: Boolean,
      default: () => getConfig().modal.draggable
    },
    remember: {
      type: Boolean,
      default: () => getConfig().modal.remember
    },
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().modal.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().modal.showTitleOverflow
    },
    transfer: {
      type: Boolean,
      default: () => getConfig().modal.transfer
    },
    storage: {
      type: Boolean,
      default: () => getConfig().modal.storage
    },
    storageKey: {
      type: String,
      default: () => getConfig().modal.storageKey
    },
    padding: {
      type: Boolean,
      default: () => getConfig().modal.padding
    },
    size: {
      type: String,
      default: () => getConfig().modal.size || getConfig().size
    },
    beforeHideMethod: Function,
    slots: Object,
    /**
     * å·²åºå¼
     * @deprecated
     */
    message: [Number, String],
    /**
     * å·²åºå¼
     * @deprecated
     */
    animat: {
      type: Boolean,
      default: () => getConfig().modal.animat
    }
  },
  emits: ['update:modelValue', 'show', 'hide', 'before-hide', 'close', 'confirm', 'cancel', 'zoom', 'resize', 'move'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeParentModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      visible: false,
      contentVisible: false,
      modalTop: 0,
      modalZindex: 0,
      prevZoomStatus: '',
      zoomStatus: '',
      revertLocat: null,
      prevLocat: null,
      firstOpen: true,
      resizeFlag: 1
    });
    const internalData = {
      msgTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refModalBox = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refConfirmBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refCancelBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().modal.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeParentModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeIsMsg = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.type === 'message' || props.type === 'notification';
    });
    const computeIsMinimizeStatus = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return reactData.zoomStatus === 'minimize';
    });
    const computeIsMaximizeStatus = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return reactData.zoomStatus === 'maximize';
    });
    const computeZoomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().modal.zoomConfig, props.zoomConfig);
    });
    const computeMaps = {
      computeSize,
      computeZoomOpts
    };
    const $xeModal = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let modalMethods = {};
    const getBox = () => {
      const boxElem = refModalBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const {
        width,
        height
      } = props;
      const boxElem = getBox();
      if (boxElem) {
        boxElem.style.width = width ? toCssUnit(width) : '';
        boxElem.style.height = height ? toCssUnit(height) : '';
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      const {
        modalZindex
      } = reactData;
      if (zIndex) {
        reactData.modalZindex = zIndex;
      } else {
        const isMsg = computeIsMsg.value;
        if (isMsg) {
          if (modalZindex < getSubLastZIndex()) {
            reactData.modalZindex = nextSubZIndex();
          }
        } else {
          if (modalZindex < getLastZIndex()) {
            reactData.modalZindex = nextZIndex();
          }
        }
      }
    };
    const updatePosition = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          position
        } = props;
        const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
        const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
        const isPosCenter = position === 'center';
        const {
          top,
          left
        } = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(position) ? {
          top: position,
          left: position
        } : Object.assign({}, position);
        const topCenter = isPosCenter || top === 'center';
        const leftCenter = isPosCenter || left === 'center';
        let posTop = '';
        let posLeft = '';
        if (left && !leftCenter) {
          posLeft = isNaN(left) ? left : `${left}px`;
        } else {
          posLeft = `${Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2)}px`;
        }
        if (top && !topCenter) {
          posTop = isNaN(top) ? top : `${top}px`;
        } else {
          posTop = `${Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2)}px`;
        }
        boxElem.style.top = posTop;
        boxElem.style.left = posLeft;
      });
    };
    const updateStyle = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          type
        } = props;
        const queueList = type === 'notification' ? notifyQueue : msgQueue;
        let offsetTop = 0;
        queueList.forEach(comp => {
          const boxElem = comp.getBox();
          if (boxElem) {
            offsetTop += external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(comp.props.top);
            comp.reactData.modalTop = offsetTop;
            offsetTop += boxElem.clientHeight;
          }
        });
      });
    };
    const removeMsgQueue = () => {
      const {
        type
      } = props;
      const queueList = type === 'notification' ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) > -1) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(queueList, comp => comp === $xeModal);
      }
      updateStyle();
    };
    const closeModal = type => {
      const {
        remember
      } = props;
      const {
        visible
      } = reactData;
      const isMsg = computeIsMsg.value;
      const beforeHideFn = props.beforeHideMethod || getConfig().modal.beforeHideMethod;
      const params = {
        type
      };
      if (visible) {
        Promise.resolve(beforeHideFn ? beforeHideFn(params) : null).then(rest => {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(rest)) {
            if (isMsg) {
              removeMsgQueue();
            }
            reactData.contentVisible = false;
            if (!remember) {
              handleRevert();
            }
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(allActiveModals, item => item === $xeModal);
            dispatchEvent('before-hide', params, null);
            setTimeout(() => {
              reactData.visible = false;
              emitModel(false);
              dispatchEvent('hide', params, null);
            }, 200);
            removeBodyLockScroll();
          }
        }).catch(e => e);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const closeEvent = evnt => {
      const type = 'close';
      dispatchEvent(type, {
        type
      }, evnt);
      closeModal(type);
    };
    const confirmEvent = evnt => {
      const {
        confirmClosable
      } = props;
      const type = 'confirm';
      dispatchEvent(type, {
        type
      }, evnt);
      if (confirmClosable) {
        closeModal(type);
      }
    };
    const cancelEvent = evnt => {
      const {
        cancelClosable
      } = props;
      const type = 'cancel';
      dispatchEvent(type, {
        type
      }, evnt);
      if (cancelClosable) {
        closeModal(type);
      }
    };
    const getStorageMap = key => {
      const version = getConfig().version;
      const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringJSON(localStorage.getItem(key) || '');
      return rest && rest._v === version ? rest : {
        _v: version
      };
    };
    const hasPosStorage = () => {
      const {
        id,
        storage,
        storageKey
      } = props;
      return !!(id && storage && getStorageMap(storageKey)[id]);
    };
    const restorePosStorage = () => {
      const {
        id,
        storage,
        storageKey
      } = props;
      if (id && storage) {
        const posStorage = getStorageMap(storageKey)[id];
        if (posStorage) {
          const boxElem = getBox();
          const [left, top, width, height, zoomLeft, zoomTop, zoomWidth, zoomHeight] = posStorage.split(',');
          if (boxElem) {
            if (left) {
              boxElem.style.left = `${left}px`;
            }
            if (top) {
              boxElem.style.top = `${top}px`;
            }
            if (width) {
              boxElem.style.width = `${width}px`;
            }
            if (height) {
              boxElem.style.height = `${height}px`;
            }
          }
          if (zoomLeft && zoomTop) {
            reactData.revertLocat = {
              left: zoomLeft,
              top: zoomTop,
              width: zoomWidth,
              height: zoomHeight
            };
          }
        }
      }
    };
    const addMsgQueue = () => {
      const {
        type
      } = props;
      const queueList = type === 'notification' ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) === -1) {
        queueList.push($xeModal);
      }
      updateStyle();
    };
    const savePosStorage = () => {
      const {
        id,
        storage,
        storageKey
      } = props;
      const {
        zoomStatus,
        revertLocat
      } = reactData;
      if (zoomStatus) {
        return;
      }
      if (id && storage) {
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const posStorageMap = getStorageMap(storageKey);
        posStorageMap[id] = [boxElem.style.left, boxElem.style.top, boxElem.clientWidth, boxElem.clientHeight].concat(revertLocat ? [revertLocat.left, revertLocat.top, revertLocat.width, revertLocat.height] : []).map(val => val ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val) : '').join(',');
        localStorage.setItem(storageKey, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toJSONString(posStorageMap));
      }
    };
    const handleMinimize = () => {
      const zoomOpts = computeZoomOpts.value;
      const {
        minimizeLayout,
        minimizeMaxSize,
        minimizeHorizontalOffset,
        minimizeVerticalOffset,
        minimizeOffsetMethod
      } = zoomOpts;
      const isHorizontalLayout = minimizeLayout === 'horizontal';
      const prevZoomStatus = reactData.zoomStatus;
      const hlMList = [];
      const vlMList = [];
      allActiveModals.forEach(item => {
        if (item.xID !== $xeModal.xID && item.props.type === 'modal' && item.reactData.zoomStatus === 'minimize') {
          const itemZoomOpts = item.getComputeMaps().computeZoomOpts.value;
          if (itemZoomOpts.minimizeLayout === 'horizontal') {
            hlMList.push(item);
          } else {
            vlMList.push(item);
          }
        }
      });
      const mList = isHorizontalLayout ? hlMList : vlMList;
      // å¦æéç½®æå°åæå¤§æ°é
      if (minimizeMaxSize && mList.length >= minimizeMaxSize) {
        if (index_esm_VxeUI.modal) {
          index_esm_VxeUI.modal.message({
            status: 'error',
            content: getI18n('vxe.modal.miniMaxSize', [minimizeMaxSize])
          });
        }
        return Promise.resolve({
          status: false
        });
      }
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = 'minimize';
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const boxElem = getBox();
        if (!boxElem) {
          return {
            status: false
          };
        }
        const headerEl = refHeaderElem.value;
        if (!headerEl) {
          return {
            status: false
          };
        }
        const {
          visibleHeight
        } = getDomNode();
        // å¦æå½åå¤äºå¤åç¶æ
        if (!prevZoomStatus) {
          reactData.revertLocat = {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft,
            width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
            height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
          };
        }
        const targetModal = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default())[isHorizontalLayout ? 'max' : 'min'](mList, $modal => {
          const boxElem = $modal.getBox();
          return boxElem ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(boxElem.style[isHorizontalLayout ? 'left' : 'top']) : 0;
        });
        let targetTop = visibleHeight - headerEl.offsetHeight - 16;
        let targetLeft = 16;
        if (targetModal) {
          const minBoxElem = targetModal.getBox();
          if (minBoxElem) {
            const boxLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(minBoxElem.style.left);
            const boxTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(minBoxElem.style.top);
            let offsetObj = {};
            if (isHorizontalLayout) {
              offsetObj = Object.assign({}, minimizeHorizontalOffset);
            } else {
              offsetObj = Object.assign({}, minimizeVerticalOffset);
            }
            targetLeft = boxLeft + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetObj.left);
            targetTop = boxTop + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetObj.top);
            if (minimizeOffsetMethod) {
              offsetObj = minimizeOffsetMethod({
                $modal: $xeModal,
                left: targetLeft,
                top: targetTop
              });
              targetLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetObj.left);
              targetTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetObj.top);
            }
          }
        }
        Object.assign(boxElem.style, {
          top: `${targetTop}px`,
          left: `${targetLeft}px`,
          width: '200px',
          height: `${headerEl.offsetHeight}px`
        });
        savePosStorage();
        return {
          status: true
        };
      });
    };
    const handleMaximize = () => {
      const prevZoomStatus = reactData.zoomStatus;
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = 'maximize';
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const boxElem = getBox();
        if (boxElem) {
          // å¦æå½åå¤äºå¤åç¶æ
          if (!prevZoomStatus) {
            const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
            const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
            const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
            reactData.revertLocat = {
              top: Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2),
              left: Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2),
              width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
              height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
            };
          }
          Object.assign(boxElem.style, {
            top: '0',
            left: '0',
            width: '100%',
            height: '100%'
          });
        }
        savePosStorage();
        return {
          status: true
        };
      });
    };
    const handleMsgAutoClose = () => {
      const {
        duration
      } = props;
      if (duration !== -1) {
        internalData.msgTimeout = setTimeout(() => closeModal('close'), external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(duration));
      }
    };
    const removeBodyLockScroll = () => {
      const htmlElem = document.documentElement;
      const lockData = htmlElem.getAttribute(lockScrollAttrKey);
      if (lockData) {
        const lockList = lockData.split(',').filter(key => key !== xID);
        if (lockList.length) {
          htmlElem.setAttribute(lockScrollAttrKey, lockList.join(','));
        } else {
          htmlElem.removeAttribute(lockScrollAttrKey);
          htmlElem.style.removeProperty(lockScrollCssWidthKey);
        }
      }
    };
    const addBodyLockScroll = () => {
      const {
        lockScroll
      } = props;
      const isMsg = computeIsMsg.value;
      if (lockScroll && !isMsg) {
        const htmlElem = document.documentElement;
        const clientWidth = document.body.clientWidth;
        const lockData = htmlElem.getAttribute(lockScrollAttrKey);
        const lockList = lockData ? lockData.split(',') : [];
        if (!lockList.includes(xID)) {
          lockList.push(xID);
          htmlElem.setAttribute(lockScrollAttrKey, lockList.join(','));
        }
        htmlElem.style.setProperty(lockScrollCssWidthKey, `${clientWidth}px`);
      }
    };
    const openModal = () => {
      const {
        remember,
        showFooter
      } = props;
      const {
        initialized,
        visible
      } = reactData;
      const isMsg = computeIsMsg.value;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        addBodyLockScroll();
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveModals.push($xeModal);
        setTimeout(() => {
          reactData.contentVisible = true;
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = '';
            const params = {
              type
            };
            emitModel(true);
            dispatchEvent('show', params, null);
          });
        }, 10);
        if (isMsg) {
          addMsgQueue();
          handleMsgAutoClose();
        } else {
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            const {
              fullscreen
            } = props;
            const {
              firstOpen
            } = reactData;
            if (firstOpen) {
              reactData.firstOpen = false;
              if (hasPosStorage()) {
                restorePosStorage();
              } else {
                if (fullscreen) {
                  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => handleMaximize());
                } else {
                  recalculate();
                  updatePosition().then(() => {
                    setTimeout(() => updatePosition(), 20);
                  });
                }
              }
            } else {
              if (!remember) {
                recalculate();
                updatePosition().then(() => {
                  setTimeout(() => updatePosition(), 20);
                });
              }
            }
          });
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const selfClickEvent = evnt => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = 'mask';
        closeModal(type);
      }
    };
    const selfMouseoverEvent = () => {
      const {
        msgTimeout
      } = internalData;
      if (!msgTimeout) {
        return;
      }
      const isMsg = computeIsMsg.value;
      if (isMsg) {
        clearTimeout(msgTimeout);
        internalData.msgTimeout = undefined;
      }
    };
    const selfMouseoutEvent = () => {
      const {
        msgTimeout
      } = internalData;
      if (!msgTimeout) {
        const isMsg = computeIsMsg.value;
        if (isMsg) {
          handleMsgAutoClose();
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastModal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().max(allActiveModals, item => item.reactData.modalZindex);
        // å¤ä¸ªæ¶ï¼åªå³ææä¸å±ççªå£
        if (lastModal) {
          setTimeout(() => {
            if (lastModal === $xeModal && lastModal.props.escClosable) {
              const type = 'exit';
              dispatchEvent('close', {
                type
              }, evnt);
              closeModal(type);
            }
          }, 10);
        }
      }
    };
    const isMinimized = () => {
      return reactData.zoomStatus === 'minimize';
    };
    const isMaximized = () => {
      return reactData.zoomStatus === 'maximize';
    };
    const handleRevert = () => {
      reactData.prevZoomStatus = reactData.zoomStatus;
      reactData.zoomStatus = '';
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          revertLocat
        } = reactData;
        if (revertLocat) {
          const boxElem = getBox();
          reactData.revertLocat = null;
          if (boxElem) {
            Object.assign(boxElem.style, {
              top: `${revertLocat.top}px`,
              left: `${revertLocat.left}px`,
              width: `${revertLocat.width}px`,
              height: `${revertLocat.height}px`
            });
          }
          savePosStorage();
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
            return {
              status: true
            };
          });
        }
        return {
          status: false
        };
      });
    };
    const handleZoom = type => {
      const {
        zoomStatus
      } = reactData;
      return new Promise(resolve => {
        if (type) {
          if (type === 'maximize') {
            resolve(handleMaximize());
            return;
          }
          if (type === 'minimize') {
            resolve(handleMinimize());
            return;
          }
          resolve(handleRevert());
          return;
        }
        resolve(zoomStatus ? handleRevert() : handleMaximize());
      }).then(() => {
        return reactData.zoomStatus || 'revert';
      });
    };
    const toggleZoomMinEvent = evnt => {
      const {
        zoomStatus,
        prevZoomStatus
      } = reactData;
      return handleZoom(zoomStatus === 'minimize' ? prevZoomStatus || 'revert' : 'minimize').then(type => {
        const params = {
          type
        };
        dispatchEvent('zoom', params, evnt);
      });
    };
    const toggleZoomMaxEvent = evnt => {
      return handleZoom().then(type => {
        const params = {
          type
        };
        dispatchEvent('zoom', params, evnt);
      });
    };
    const getPosition = () => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          return {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft
          };
        }
      }
      return null;
    };
    const setPosition = (top, left) => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(top)) {
            boxElem.style.top = `${top}px`;
          }
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(left)) {
            boxElem.style.left = `${left}px`;
          }
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const boxMousedownEvent = () => {
      const {
        modalZindex
      } = reactData;
      if (allActiveModals.some(comp => comp.reactData.visible && comp.reactData.modalZindex > modalZindex)) {
        updateZindex();
      }
    };
    const mousedownEvent = evnt => {
      const {
        storage
      } = props;
      const {
        zoomStatus
      } = reactData;
      const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
      const boxElem = getBox();
      if (!boxElem) {
        return;
      }
      if (zoomStatus !== 'maximize' && evnt.button === 0 && !getEventTargetNode(evnt, boxElem, 'trigger--btn').flag) {
        evnt.preventDefault();
        const disX = evnt.clientX - boxElem.offsetLeft;
        const disY = evnt.clientY - boxElem.offsetTop;
        const {
          visibleHeight,
          visibleWidth
        } = getDomNode();
        document.onmousemove = evnt => {
          evnt.preventDefault();
          const offsetWidth = boxElem.offsetWidth;
          const offsetHeight = boxElem.offsetHeight;
          const minX = marginSize;
          const maxX = visibleWidth - offsetWidth - marginSize - 1;
          const minY = marginSize;
          const maxY = visibleHeight - offsetHeight - marginSize - 1;
          let left = evnt.clientX - disX;
          let top = evnt.clientY - disY;
          if (left > maxX) {
            left = maxX;
          }
          if (left < minX) {
            left = minX;
          }
          if (top > maxY) {
            top = maxY;
          }
          if (top < minY) {
            top = minY;
          }
          boxElem.style.left = `${left}px`;
          boxElem.style.top = `${top}px`;
          boxElem.className = boxElem.className.replace(/\s?is--drag/, '') + ' is--drag';
          dispatchEvent('move', {
            type: 'move'
          }, evnt);
          reactData.resizeFlag++;
        };
        document.onmouseup = () => {
          document.onmousemove = null;
          document.onmouseup = null;
          if (storage) {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              savePosStorage();
            });
          }
          reactData.resizeFlag++;
          setTimeout(() => {
            boxElem.className = boxElem.className.replace(/\s?is--drag/, '');
          }, 50);
        };
      }
    };
    const dragEvent = evnt => {
      evnt.preventDefault();
      const {
        storage
      } = props;
      const {
        visibleHeight,
        visibleWidth
      } = getDomNode();
      const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
      const targetElem = evnt.target;
      const type = targetElem.getAttribute('type');
      const minWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.minWidth);
      const minHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.minHeight);
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = {
        type: 'resize'
      };
      document.onmousemove = evnt => {
        evnt.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case 'wl':
            dragLeft = disX - evnt.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            break;
          case 'swst':
            dragLeft = disX - evnt.clientX;
            dragTop = disY - evnt.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case 'swlb':
            dragLeft = disX - evnt.clientX;
            dragTop = evnt.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case 'st':
            dragTop = disY - evnt.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case 'wr':
            dragLeft = evnt.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case 'sest':
            dragLeft = evnt.clientX - disX;
            dragTop = disY - evnt.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case 'selb':
            dragLeft = evnt.clientX - disX;
            dragTop = evnt.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case 'sb':
            dragTop = evnt.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, '') + ' is--drag';
        if (storage) {
          savePosStorage();
        }
        dispatchEvent('resize', params, evnt);
      };
      document.onmouseup = () => {
        reactData.revertLocat = null;
        document.onmousemove = null;
        document.onmouseup = null;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, '');
        }, 50);
      };
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $modal: $xeModal
      }, params));
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    modalMethods = {
      dispatchEvent,
      open: openModal,
      close() {
        return closeModal('close');
      },
      getBox,
      getPosition,
      setPosition,
      isMinimized,
      isMaximized,
      zoom() {
        return handleZoom();
      },
      minimize() {
        if (!reactData.visible) {
          return Promise.resolve({
            status: false
          });
        }
        return handleMinimize();
      },
      maximize() {
        if (!reactData.visible) {
          return Promise.resolve({
            status: false
          });
        }
        return handleMaximize();
      },
      revert() {
        if (!reactData.visible) {
          return Promise.resolve({
            status: false
          });
        }
        return handleRevert();
      }
    };
    Object.assign($xeModal, modalMethods);
    const renderTitles = () => {
      const {
        slots: propSlots = {},
        showClose,
        showZoom,
        showMaximize,
        showMinimize,
        title
      } = props;
      const {
        zoomStatus
      } = reactData;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const isMaximizeStatus = computeIsMaximizeStatus.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--header-title'
      }, titleSlot ? vn_getSlotVNs(titleSlot({
        $modal: $xeModal,
        minimized: isMinimizeStatus,
        maximized: isMaximizeStatus
      })) : title ? getFuncText(title) : getI18n('vxe.alert.title')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--header-right'
      }, [cornerSlot && !isMinimizeStatus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--corner-wrapper'
      }, vn_getSlotVNs(cornerSlot({
        $modal: $xeModal
      }))) : renderEmptyElement($xeModal), (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showMinimize) ? showMinimize : showZoom) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-modal--zoom-btn', 'trigger--btn'],
        title: getI18n(`vxe.modal.zoom${zoomStatus === 'minimize' ? 'Out' : 'Min'}`),
        onClick: toggleZoomMinEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: zoomStatus === 'minimize' ? getIcon().MODAL_ZOOM_REVERT : getIcon().MODAL_ZOOM_MIN
      })]) : renderEmptyElement($xeModal), (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showMaximize) ? showMaximize : showZoom) && zoomStatus !== 'minimize' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-modal--zoom-btn', 'trigger--btn'],
        title: getI18n(`vxe.modal.zoom${zoomStatus === 'maximize' ? 'Out' : 'In'}`),
        onClick: toggleZoomMaxEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: zoomStatus === 'maximize' ? getIcon().MODAL_ZOOM_OUT : getIcon().MODAL_ZOOM_IN
      })]) : renderEmptyElement($xeModal), showClose ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-modal--close-btn', 'trigger--btn'],
        title: getI18n('vxe.modal.close'),
        onClick: closeEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().MODAL_CLOSE
      })]) : renderEmptyElement($xeModal)])];
    };
    const renderHeader = () => {
      const {
        slots: propSlots = {},
        showZoom,
        showMaximize,
        draggable
      } = props;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        const headerOns = {};
        if (draggable) {
          headerOns.onMousedown = mousedownEvent;
        }
        if ((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showMaximize) ? showMaximize : showZoom) && props.dblclickZoom && props.type === 'modal') {
          headerOns.onDblclick = toggleZoomMaxEvent;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refHeaderElem,
          class: ['vxe-modal--header', {
            'is--ellipsis': props.showTitleOverflow
          }],
          ...headerOns
        }, headerSlot ? vn_getSlotVNs(headerSlot({
          $modal: $xeModal
        })) : renderTitles());
      }
      return renderEmptyElement($xeModal);
    };
    const renderBody = () => {
      const {
        slots: propSlots = {},
        status,
        message,
        iconStatus
      } = props;
      const content = props.content || message;
      const isMsg = computeIsMsg.value;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      const contVNs = [];
      if (!isMsg && (status || iconStatus)) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-modal--status-wrapper'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-modal--status-icon', iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
        })]));
      }
      contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--content'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({
        $modal: $xeModal
      })) : getFuncText(content)));
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--body'
      }, [leftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--body-left'
      }, vn_getSlotVNs(leftSlot({
        $modal: $xeModal
      }))) : renderEmptyElement($xeModal), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--body-default'
      }, contVNs), rightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--body-right'
      }, vn_getSlotVNs(rightSlot({
        $modal: $xeModal
      }))) : renderEmptyElement($xeModal), isMsg ? renderEmptyElement($xeModal) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(loading, {
        class: 'vxe-modal--loading',
        modelValue: props.loading
      })]);
    };
    const renderDefaultFooter = () => {
      const {
        slots: propSlots = {},
        showCancelButton,
        showConfirmButton,
        type,
        loading
      } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showCancelButton) ? showCancelButton : type === 'confirm') {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || getI18n('vxe.button.cancel'),
          onClick: cancelEvent
        }));
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showConfirmButton) ? showConfirmButton : type === 'confirm' || type === 'alert') {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 2,
          ref: refConfirmBtn,
          loading: loading,
          status: 'primary',
          content: props.confirmButtonText || getI18n('vxe.button.confirm'),
          onClick: confirmEvent
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--footer-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--footer-left'
      }, lfSlot ? vn_getSlotVNs(lfSlot({
        $modal: $xeModal
      })) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--footer-right'
      }, rfSlot ? vn_getSlotVNs(rfSlot({
        $modal: $xeModal
      })) : btnVNs)]);
    };
    const renderFooter = () => {
      const {
        slots: propSlots = {}
      } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-modal--footer'
        }, footerSlot ? vn_getSlotVNs(footerSlot({
          $modal: $xeModal
        })) : [renderDefaultFooter()]);
      }
      return renderEmptyElement($xeModal);
    };
    const renderVN = () => {
      const {
        slots: propSlots = {},
        className,
        type,
        animat,
        draggable,
        iconStatus,
        position,
        loading,
        destroyOnClose,
        status,
        lockScroll,
        padding,
        lockView,
        mask,
        resize
      } = props;
      const {
        initialized,
        modalTop,
        contentVisible,
        visible,
        zoomStatus
      } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      const isMsg = computeIsMsg.value;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const btnTransfer = computeBtnTransfer.value;
      const ons = {};
      if (isMsg) {
        ons.onMouseover = selfMouseoverEvent;
        ons.onMouseout = selfMouseoutEvent;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-modal--wrapper', `type--${type}`, `zoom--${zoomStatus || 'revert'}`, className || '', position ? `pos--${position}` : '', {
          [`size--${vSize}`]: vSize,
          [`status--${status}`]: status,
          'is--padding': padding,
          'is--animat': animat,
          'lock--scroll': lockScroll,
          'lock--view': lockView,
          'is--draggable': draggable,
          'is--resize': resize,
          'is--mask': mask,
          'is--visible': contentVisible,
          'is--active': visible,
          'is--loading': loading
        }],
        style: {
          zIndex: reactData.modalZindex,
          top: modalTop ? `${modalTop}px` : null
        },
        onClick: selfClickEvent,
        ...ons
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refModalBox,
        class: 'vxe-modal--box',
        onMousedown: boxMousedownEvent
      }, [(isMsg || asideSlot) && !isMinimizeStatus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--aside'
      }, asideSlot ? vn_getSlotVNs(asideSlot({
        $modal: $xeModal
      })) : [status || iconStatus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--status-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-modal--status-icon', iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
      })]) : renderEmptyElement($xeModal)]) : renderEmptyElement($xeModal), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--container'
      }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [renderHeader(), renderBody(), renderFooter(), !isMsg && resize ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-modal--resize'
      }, ['wl', 'wr', 'swst', 'sest', 'st', 'swlb', 'selb', 'sb'].map(type => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: `${type}-resize`,
          type: type,
          onMousedown: dragEvent
        });
      })) : renderEmptyElement($xeModal)])])])]);
    };
    $xeModal.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.width, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, value => {
      if (value) {
        openModal();
      } else {
        closeModal('model');
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if (props.type === 'modal' && props.showFooter && !(props.showConfirmButton || props.showCancelButton || slots.footer)) {
        warnLog('vxe.modal.footPropErr');
      }
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (props.storage && !props.id) {
          errLog('vxe.error.reqProp', ['[modal] id']);
        }
        if (props.modelValue) {
          openModal();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeModal, 'keydown', handleGlobalKeydownEvent);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeModal, 'keydown');
      removeMsgQueue();
      removeBodyLockScroll();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeModal', $xeModal);
    return $xeModal;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/modal/index.ts





function handleModal(options) {
  // ä½¿ç¨å¨æç»ä»¶æ¸²æå¨æå¼¹æ¡
  checkDynamic();
  return new Promise(resolve => {
    const opts = Object.assign({}, options);
    if (opts.id && allActiveModals.some(comp => comp.props.id === opts.id)) {
      resolve('exist');
    } else {
      const _onHide = opts.onHide;
      const modalOpts = Object.assign(opts, {
        key: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId(),
        modelValue: true,
        onHide(params) {
          const modalList = dynamicStore.modals;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.modals = modalList.filter(item => item.key !== modalOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.modals.push(modalOpts);
    }
  });
}
function getModal(id) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(allActiveModals, $modal => $modal.props.id === id);
}
/**
 * å¨å±å³é­å¨æçæ´»å¨çªå£ï¼åªè½ç¨äºå³é­å¨æçåå»ºçæ´»å¨çªå£ï¼
 * å¦æä¼  id åå³é­æå®ççªå£
 * å¦æä¸ä¼ åå³é­ææçªå£
 */
function closeModal(id) {
  const modals = id ? [getModal(id)] : allActiveModals;
  const restPromises = [];
  modals.forEach($modal => {
    if ($modal) {
      restPromises.push($modal.close());
    }
  });
  return Promise.all(restPromises);
}
function handleOpen(defOpts, content, title, options) {
  let opts;
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(content)) {
    opts = content;
  } else {
    opts = {
      content: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content),
      title
    };
  }
  return handleModal({
    ...defOpts,
    ...options,
    ...opts
  });
}
function openModal(options) {
  return handleOpen({
    type: 'modal'
  }, options);
}
function openAlert(content, title, options) {
  return handleOpen({
    type: 'alert',
    lockScroll: true,
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openConfirm(content, title, options) {
  return handleOpen({
    type: 'confirm',
    status: 'question',
    lockScroll: true,
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openMessage(content, options) {
  return handleOpen({
    type: 'message',
    mask: false,
    lockView: false,
    lockScroll: false,
    showHeader: false
  }, content, '', options);
}
function openNotification(content, title, options) {
  return handleOpen({
    type: 'notification',
    mask: false,
    lockView: false,
    lockScroll: false,
    showHeader: true,
    draggable: false,
    position: 'top-right',
    width: 320
  }, content, title, options);
}
const ModalController = {
  get: getModal,
  close: closeModal,
  open: openModal,
  alert: openAlert,
  confirm: openConfirm,
  message: openMessage,
  notification: openNotification
};
const VxeModal = Object.assign(modal, {
  install: function (app) {
    app.component(modal.name, modal);
  }
});
index_esm_VxeUI.modal = ModalController;
dynamicApp.use(VxeModal);
index_esm_VxeUI.component(modal);
const Modal = VxeModal;
/* harmony default export */ var packages_modal = (VxeModal);
;// CONCATENATED MODULE: ./packages/notice-bar/src/notice-bar.ts





/* harmony default export */ var notice_bar = (defineVxeComponent({
  name: 'VxeNoticeBar',
  props: {
    duration: [String, Number],
    direction: {
      type: String,
      default: () => getConfig().noticeBar.direction
    },
    speed: {
      type: String,
      default: () => getConfig().noticeBar.speed
    },
    content: String,
    vertical: Boolean,
    loop: {
      type: Boolean
    },
    size: {
      type: String,
      default: () => getConfig().noticeBar.size || getConfig().size
    }
  },
  emits: ['start', 'end'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeTabs = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTabs', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refContentElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      animationStatus: false,
      animationDuration: 0
    });
    const refMaps = {
      refElem
    };
    const computeNoticeText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        content
      } = props;
      return `${content || ''}`;
    });
    const computeTabsResizeFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeTabs ? $xeTabs.reactData.resizeFlag : null;
    });
    const computeMaps = {};
    const $xeNoticeBar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $noticeBar: $xeNoticeBar
      }, params));
    };
    const noticeBarMethods = {
      dispatchEvent
    };
    const noticeBarPrivateMethods = {};
    const updateAnimationStyle = () => {
      const {
        speed
      } = props;
      const contEl = refContentElem.value;
      if (contEl) {
        let sRate = 46;
        if (speed === 'fast') {
          sRate = 118;
        } else if (speed === 'slow') {
          sRate = 18;
        }
        reactData.animationDuration = Math.ceil(contEl.scrollWidth / sRate);
      }
    };
    const animationStartEvent = evnt => {
      reactData.animationStatus = true;
      dispatchEvent('start', {
        status: true
      }, evnt);
    };
    const animationEndEvent = evnt => {
      reactData.animationStatus = false;
      dispatchEvent('end', {
        status: false
      }, evnt);
    };
    Object.assign($xeNoticeBar, noticeBarMethods, noticeBarPrivateMethods);
    const renderVN = () => {
      const {
        vertical,
        duration,
        direction,
        loop
      } = props;
      const {
        animationDuration,
        animationStatus
      } = reactData;
      const vSize = computeSize.value;
      const noticeText = computeNoticeText.value;
      const defaultSlot = slots.default;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-notice-bar', `is--${vertical ? 'vertical' : 'horizontal'}`, `dir--${direction || 'left'}`, {
          [`size--${vSize}`]: vSize,
          'is--loop': loop
        }]
      }, [prefixSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-notice-bar--prefix'
      }, prefixSlot({})) : renderEmptyElement($xeNoticeBar), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-notice-bar--content'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refContentElem,
        class: 'vxe-notice-bar--inner'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-notice-bar--wrapper', `is--${animationStatus ? 'progress' : 'end'}`],
        style: {
          animationDuration: duration ? toCssUnit(duration, 's') : `${animationDuration}s`
        },
        onAnimationstart: animationStartEvent,
        onAnimationend: animationEndEvent
      }, defaultSlot ? defaultSlot({}) : noticeText)])]), suffixSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-notice-bar--suffix'
      }, suffixSlot({})) : renderEmptyElement($xeNoticeBar)]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeTabsResizeFlag, () => {
      updateAnimationStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeNoticeBar, 'resize', updateAnimationStyle);
      updateAnimationStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      globalEvents.off($xeNoticeBar, 'resize');
    });
    $xeNoticeBar.renderVN = renderVN;
    return $xeNoticeBar;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/notice-bar/index.ts



const VxeNoticeBar = Object.assign({}, notice_bar, {
  install(app) {
    app.component(notice_bar.name, notice_bar);
  }
});
dynamicApp.use(VxeNoticeBar);
index_esm_VxeUI.component(notice_bar);
const NoticeBar = VxeNoticeBar;
/* harmony default export */ var packages_notice_bar = (VxeNoticeBar);
;// CONCATENATED MODULE: ./packages/number-input/index.ts



const VxeNumberInput = Object.assign({}, number_input, {
  install(app) {
    app.component(number_input.name, number_input);
  }
});
dynamicApp.use(VxeNumberInput);
index_esm_VxeUI.component(number_input);
const NumberInput = VxeNumberInput;
/* harmony default export */ var packages_number_input = (VxeNumberInput);
;// CONCATENATED MODULE: ./packages/select/src/option-info.ts

class OptionInfo {
  constructor($xeselect, _vm) {
    Object.assign(this, {
      id: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('option_'),
      value: _vm.value,
      label: _vm.label,
      visible: _vm.visible,
      className: _vm.className,
      disabled: _vm.disabled
    });
  }
  update(name, value) {
    this[name] = value;
  }
}
;// CONCATENATED MODULE: ./packages/select/src/util.ts



function isOption(option) {
  return option instanceof OptionInfo;
}
function createOption($xeSelect, _vm) {
  return isOption(_vm) ? _vm : new OptionInfo($xeSelect, _vm);
}
function watchOption(props, option) {
  Object.keys(props).forEach(name => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props[name], value => {
      option.update(name, value);
    });
  });
}
function assembleOption($xeSelect, el, option, $xeOptgroup) {
  const {
    reactData
  } = $xeSelect;
  const {
    staticOptions
  } = reactData;
  const parentElem = el.parentNode;
  const parentOption = $xeOptgroup ? $xeOptgroup.optionConfig : null;
  const parentCols = parentOption ? parentOption.options : staticOptions;
  if (parentElem && parentCols) {
    parentCols.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, el), 0, option);
    reactData.staticOptions = staticOptions.slice(0);
  }
}
function destroyOption($xeSelect, option) {
  const {
    reactData
  } = $xeSelect;
  const {
    staticOptions
  } = reactData;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticOptions, item => item.id === option.id, {
    children: 'options'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticOptions = staticOptions.slice(0);
}
;// CONCATENATED MODULE: ./packages/select/src/optgroup.ts



/* harmony default export */ var optgroup = (defineVxeComponent({
  name: 'VxeOptgroup',
  props: {
    label: {
      type: [String, Number, Boolean],
      default: ''
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(props, {
    slots
  }) {
    const elem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeSelect = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeSelect', {});
    const optionConfig = createOption($xeSelect, props);
    const $xeOptgroup = {
      optionConfig
    };
    optionConfig.options = [];
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeOptgroup', $xeOptgroup);
    watchOption(props, optionConfig);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const el = elem.value;
      assembleOption($xeSelect, el, optionConfig);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyOption($xeSelect, optionConfig);
    });
    return () => {
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: elem
      }, defaultSlot ? defaultSlot({}) : []);
    };
  }
}));
;// CONCATENATED MODULE: ./packages/optgroup/index.ts



const VxeOptgroup = Object.assign(optgroup, {
  install: function (app) {
    app.component(optgroup.name, optgroup);
  }
});
dynamicApp.use(VxeOptgroup);
index_esm_VxeUI.component(optgroup);
const Optgroup = VxeOptgroup;
/* harmony default export */ var packages_optgroup = (VxeOptgroup);
;// CONCATENATED MODULE: ./packages/select/src/option.ts



/* harmony default export */ var src_option = (defineVxeComponent({
  name: 'VxeOption',
  props: {
    value: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: ''
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(props, {
    slots
  }) {
    const elem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeSelect = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeSelect', {});
    const $xeOptgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeOptgroup', null);
    const optionConfig = createOption($xeSelect, props);
    optionConfig.slots = slots;
    watchOption(props, optionConfig);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const el = elem.value;
      assembleOption($xeSelect, el, optionConfig, $xeOptgroup);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyOption($xeSelect, optionConfig);
    });
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: elem
      });
    };
  }
}));
;// CONCATENATED MODULE: ./packages/option/index.ts



const VxeOption = Object.assign(src_option, {
  install: function (app) {
    app.component(src_option.name, src_option);
  }
});
dynamicApp.use(VxeOption);
index_esm_VxeUI.component(src_option);
const Option = VxeOption;
/* harmony default export */ var packages_option = (VxeOption);
;// CONCATENATED MODULE: ./packages/select/src/select.ts










function isOptionVisible(option) {
  return option.visible !== false;
}
function getOptUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('opt_');
}
function select_createInternalData() {
  return {
    synchData: [],
    fullData: [],
    afterVisibleList: [],
    optAddMaps: {},
    optGroupKeyMaps: {},
    optFullValMaps: {},
    remoteValMaps: {},
    lastScrollLeft: 0,
    lastScrollTop: 0,
    scrollYStore: {
      startIndex: 0,
      endIndex: 0,
      visibleSize: 0,
      offsetSize: 0,
      rowHeight: 0
    },
    lastScrollTime: 0,
    hpTimeout: undefined
  };
}
/* harmony default export */ var src_select = (defineVxeComponent({
  name: 'VxeSelect',
  props: {
    modelValue: [String, Number, Boolean, Array],
    defaultConfig: Object,
    clearable: Boolean,
    placeholder: String,
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    multiCharOverflow: {
      type: [Number, String],
      default: () => getConfig().select.multiCharOverflow
    },
    prefixIcon: String,
    allowCreate: {
      type: Boolean,
      default: () => getConfig().select.allowCreate
    },
    placement: String,
    lazyOptions: Array,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    popupClassName: [String, Function],
    max: {
      type: [String, Number],
      default: null
    },
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    remoteConfig: Object,
    emptyText: String,
    showTotalButoon: {
      type: Boolean,
      default: () => getConfig().select.showTotalButoon
    },
    showCheckedButoon: {
      type: Boolean,
      default: () => getConfig().select.showCheckedButoon
    },
    showClearButton: {
      type: Boolean,
      default: () => getConfig().select.showClearButton
    },
    transfer: {
      type: Boolean,
      default: null
    },
    virtualYConfig: Object,
    scrollY: Object,
    /**
     * å·²åºå¼ï¼è¢« remote-config.queryMethod æ¿æ¢
     * @deprecated
     */
    remoteMethod: Function,
    /**
     * å·²åºå¼ï¼è¢« option-config.keyField æ¿æ¢
     * @deprecated
     */
    optionId: {
      type: String,
      default: () => getConfig().select.optionId
    },
    /**
     * å·²åºå¼ï¼è¢« option-config.useKey æ¿æ¢
     * @deprecated
     */
    optionKey: Boolean
  },
  emits: ['update:modelValue', 'change', 'all-change', 'clear', 'blur', 'focus', 'click', 'scroll', 'visible-change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInpSearch = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      scrollYLoad: false,
      bodyHeight: 0,
      topSpaceHeight: 0,
      optList: [],
      staticOptions: [],
      reactFlag: 0,
      currentOption: null,
      searchValue: '',
      searchLoading: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = select_createInternalData();
    const refMaps = {
      refElem
    };
    const $xeSelect = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.base.pleaseSelect');
    });
    const computeDefaultOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.defaultConfig);
    });
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeGroupPropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.optionGroupProps);
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeGroupLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.label || 'label';
    });
    const computeGroupOptionsField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.options || 'options';
    });
    const computeIsMaximize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const selectVals = computeSelectVals.value;
      return checkMaxLimit(selectVals);
    });
    const computeVirtualYOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().select.virtualYConfig || getConfig().select.scrollY, props.virtualYConfig || props.scrollY);
    });
    const computeRemoteOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().select.remoteConfig, props.remoteConfig);
    });
    const computeOptionOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().select.optionConfig, props.optionConfig);
    });
    const computeMultiMaxCharNum = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.multiCharOverflow);
    });
    const computeSelectVals = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        multiple
      } = props;
      let vals = [];
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue)) {
        vals = modelValue;
      } else {
        if (multiple) {
          if (!eqEmptyValue(modelValue)) {
            vals = `${modelValue}`.indexOf(',') > -1 ? `${modelValue}`.split(',') : [modelValue];
          }
        } else {
          vals = modelValue === null || modelValue === undefined ? [] : [modelValue];
        }
      }
      return vals;
    });
    const computeFullLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        remote
      } = props;
      const {
        reactFlag
      } = reactData;
      const selectVals = computeSelectVals.value;
      if (remote && reactFlag) {
        return selectVals.map(val => getRemoteSelectLabel(val)).join(', ');
      }
      return selectVals.map(val => getSelectLabel(val)).join(', ');
    });
    const computeSelectLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        remote,
        multiple
      } = props;
      const {
        reactFlag
      } = reactData;
      const multiMaxCharNum = computeMultiMaxCharNum.value;
      const selectVals = computeSelectVals.value;
      if (remote && reactFlag) {
        return selectVals.map(val => getRemoteSelectLabel(val)).join(', ');
      }
      const labels = selectVals.map(val => getSelectLabel(val));
      if (multiple && multiMaxCharNum > 0 && labels.length > multiMaxCharNum) {
        return `${labels.slice(0, multiMaxCharNum)}...`;
      }
      return labels.join(', ');
    });
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $select: $xeSelect
      }, params));
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const getOptKey = () => {
      const optionOpts = computeOptionOpts.value;
      return optionOpts.keyField || props.optionId || '_X_OPTION_KEY';
    };
    const getOptId = option => {
      const optid = option[getOptKey()];
      return optid ? encodeURIComponent(optid) : '';
    };
    const checkMaxLimit = selectVals => {
      const {
        multiple,
        max
      } = props;
      if (multiple && max) {
        return selectVals.length >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    };
    const getRemoteSelectLabel = value => {
      const {
        lazyOptions
      } = props;
      const {
        remoteValMaps,
        optFullValMaps
      } = internalData;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const remoteItem = remoteValMaps[value] || optFullValMaps[value];
      const item = remoteItem ? remoteItem.item : null;
      if (item) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(item[labelField]);
      }
      if (lazyOptions) {
        const lazyItem = lazyOptions.find(item => item[valueField] === value);
        if (lazyItem) {
          return lazyItem[labelField];
        }
      }
      return value;
    };
    const getSelectLabel = value => {
      const {
        lazyOptions
      } = props;
      const {
        optFullValMaps
      } = internalData;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const cacheItem = reactData.reactFlag ? optFullValMaps[value] : null;
      if (cacheItem) {
        return cacheItem.item[labelField];
      }
      if (lazyOptions) {
        const lazyItem = lazyOptions.find(item => item[valueField] === value);
        if (lazyItem) {
          return lazyItem[labelField];
        }
      }
      return value;
    };
    const cacheItemMap = datas => {
      const groupOptionsField = computeGroupOptionsField.value;
      const valueField = computeValueField.value;
      const key = getOptKey();
      const groupKeyMaps = {};
      const fullKeyMaps = {};
      const list = [];
      const handleOptItem = item => {
        list.push(item);
        let optid = getOptId(item);
        if (!optid) {
          optid = getOptUniqueId();
          item[key] = optid;
        }
        fullKeyMaps[item[valueField]] = {
          key: optid,
          item,
          _index: -1
        };
      };
      datas.forEach(group => {
        handleOptItem(group);
        if (group[groupOptionsField]) {
          groupKeyMaps[group[key]] = group;
          group[groupOptionsField].forEach(handleOptItem);
        }
      });
      internalData.fullData = list;
      internalData.optGroupKeyMaps = groupKeyMaps;
      internalData.optFullValMaps = fullKeyMaps;
      reactData.reactFlag++;
      handleOption();
    };
    /**
     * å¤çéé¡¹ï¼å½éé¡¹è¢«å¨ææ¾ç¤º/éèæ¶å¯è½ä¼ç¨å°
     */
    const handleOption = () => {
      const {
        modelValue,
        filterable,
        filterMethod
      } = props;
      const {
        searchValue
      } = reactData;
      const {
        fullData,
        optFullValMaps
      } = internalData;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const searchStr = `${searchValue || ''}`.toLowerCase();
      let avList = [];
      if (filterable && filterMethod) {
        avList = fullData.filter(option => isOptionVisible(option) && filterMethod({
          $select: $xeSelect,
          group: null,
          option,
          searchValue,
          value: modelValue
        }));
      } else if (filterable) {
        avList = fullData.filter(option => isOptionVisible(option) && (!searchStr || `${option[labelField] || option[valueField]}`.toLowerCase().indexOf(searchStr) > -1));
      } else {
        avList = fullData.filter(isOptionVisible);
      }
      avList.forEach((item, index) => {
        const cacheItem = optFullValMaps[item[valueField]];
        if (cacheItem) {
          cacheItem._index = index;
        }
      });
      internalData.afterVisibleList = avList;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const setCurrentOption = option => {
      if (option) {
        reactData.currentOption = option;
      }
    };
    const updateZIndex = () => {
      const {
        zIndex
      } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refElem.value;
      const panelElem = refOptionPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const handleScrollSelect = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          isAniVisible,
          visiblePanel
        } = reactData;
        const {
          optFullValMaps
        } = internalData;
        const selectVals = computeSelectVals.value;
        if (selectVals.length && isAniVisible && visiblePanel) {
          const cacheItem = reactData.reactFlag ? optFullValMaps[`${selectVals[0]}`] : null;
          if (cacheItem) {
            handleScrollToOption(cacheItem.item);
          }
        }
      });
    };
    const showOptionPanel = () => {
      const {
        loading,
        filterable,
        remote
      } = props;
      const {
        fullData,
        hpTimeout
      } = internalData;
      const isDisabled = computeIsDisabled.value;
      const remoteOpts = computeRemoteOpts.value;
      if (!loading && !isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = undefined;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (filterable) {
          if (remote && remoteOpts.enabled && remoteOpts.autoLoad && !fullData.length) {
            handleSearchEvent();
          } else {
            handleOption();
            updateYData();
          }
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
          handleFocusSearch();
          recalculate().then(() => {
            handleScrollSelect();
            refreshScroll();
          });
        }, 10);
        setTimeout(() => {
          recalculate().then(() => refreshScroll());
        }, 100);
        updateZIndex();
        updatePlacement();
        dispatchEvent('visible-change', {
          visible: true
        }, null);
      }
    };
    const hideOptionPanel = () => {
      reactData.searchValue = '';
      reactData.searchLoading = false;
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
      dispatchEvent('visible-change', {
        visible: false
      }, null);
    };
    const changeEvent = (evnt, selectValue, option) => {
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        dispatchEvent('change', {
          value: selectValue,
          option
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      internalData.remoteValMaps = {};
      changeEvent(evnt, selectValue, null);
      dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const clearEvent = params => {
      const {
        $event
      } = params;
      clearValueEvent($event, null);
      hideOptionPanel();
    };
    const allCheckedPanelEvent = params => {
      const {
        $event
      } = params;
      const {
        multiple,
        max
      } = props;
      const {
        optList
      } = reactData;
      const valueField = computeValueField.value;
      if (multiple) {
        const selectVals = computeSelectVals.value;
        const currVlas = selectVals.slice(0);
        for (let i = 0; i < optList.length; i++) {
          const option = optList[i];
          const selectValue = option[valueField];
          // æ£æµæ¯å¦è¶è¿æå¤§å¯éæ°é
          if (checkMaxLimit(currVlas)) {
            if (index_esm_VxeUI) {
              index_esm_VxeUI.modal.message({
                content: getI18n('vxe.select.overSizeErr', [max]),
                status: 'warning'
              });
            }
            break;
          }
          if (!currVlas.some(val => val === selectValue)) {
            currVlas.push(selectValue);
          }
        }
        changeEvent($event, currVlas, optList[0]);
        dispatchEvent('all-change', {
          value: currVlas
        }, $event);
      }
    };
    const clearCheckedPanelEvent = params => {
      const {
        $event
      } = params;
      clearValueEvent($event, null);
      hideOptionPanel();
    };
    const changeOptionEvent = (evnt, option) => {
      const {
        multiple
      } = props;
      const {
        remoteValMaps
      } = internalData;
      const valueField = computeValueField.value;
      const selectValue = option[valueField];
      const remoteItem = remoteValMaps[selectValue];
      if (!reactData.visiblePanel) {
        return;
      }
      if (remoteItem) {
        remoteItem.item = option;
      } else {
        remoteValMaps[selectValue] = {
          key: getOptId(option),
          item: option,
          _index: -1
        };
      }
      if (multiple) {
        let multipleValue = [];
        const selectVals = computeSelectVals.value;
        const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(selectVals, val => val === selectValue);
        if (index === -1) {
          multipleValue = selectVals.concat([selectValue]);
        } else {
          multipleValue = selectVals.filter(val => val !== selectValue);
        }
        changeEvent(evnt, multipleValue, option);
      } else {
        changeEvent(evnt, selectValue, option);
        hideOptionPanel();
      }
      reactData.reactFlag++;
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const validOffsetOption = option => {
      const isDisabled = option.disabled;
      const optid = getOptId(option);
      if (!isDisabled && !hasOptGroupById(optid)) {
        return true;
      }
      return false;
    };
    const findOffsetOption = (option, isDwArrow) => {
      const {
        allowCreate
      } = props;
      const {
        optList
      } = reactData;
      const {
        optFullValMaps,
        optAddMaps,
        afterVisibleList
      } = internalData;
      const valueField = computeValueField.value;
      let fullList = afterVisibleList;
      let offsetAddIndex = 0;
      if (allowCreate && optList.length) {
        const firstItem = optList[0];
        const optid = getOptId(firstItem);
        if (optAddMaps[optid]) {
          offsetAddIndex = 1;
          fullList = [optAddMaps[optid]].concat(fullList);
        }
      }
      if (!option) {
        if (isDwArrow) {
          for (let i = 0; i < fullList.length; i++) {
            const item = fullList[i];
            if (validOffsetOption(item)) {
              return item;
            }
          }
        } else {
          for (let len = fullList.length - 1; len >= 0; len--) {
            const item = fullList[len];
            if (validOffsetOption(item)) {
              return item;
            }
          }
        }
      }
      let avIndex = 0;
      const cacheItem = option ? optFullValMaps[option[valueField]] : null;
      if (cacheItem) {
        avIndex = cacheItem._index + offsetAddIndex;
      }
      if (avIndex > -1) {
        if (isDwArrow) {
          for (let i = avIndex + 1; i <= fullList.length - 1; i++) {
            const item = fullList[i];
            if (validOffsetOption(item)) {
              return item;
            }
          }
        } else {
          if (avIndex > 0) {
            for (let len = avIndex - 1; len >= 0; len--) {
              const item = fullList[len];
              if (validOffsetOption(item)) {
                return item;
              }
            }
          }
        }
      }
      return null;
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable
      } = props;
      const {
        visiblePanel,
        currentOption
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            if (currentOption) {
              evnt.preventDefault();
              evnt.stopPropagation();
              changeOptionEvent(evnt, currentOption);
            }
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            let offsetOption = findOffsetOption(currentOption, isDwArrow);
            // å¦æä¸å¹éï¼é»è®¤ææ¥è¿ä¸ä¸ª
            if (!offsetOption) {
              offsetOption = findOffsetOption(null, isDwArrow);
            }
            if (offsetOption) {
              setCurrentOption(offsetOption);
              handleScrollToOption(offsetOption, isDwArrow);
            }
          }
        } else if ((isUpArrow || isDwArrow || isEnter) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const handleFocusSearch = () => {
      if (props.filterable) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    const focusEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 500);
        }
      }
      dispatchEvent('focus', {}, evnt);
    };
    const clickEvent = evnt => {
      togglePanelEvent(evnt);
      dispatchEvent('click', {
        triggerButton: false,
        visible: reactData.visiblePanel
      }, evnt);
    };
    const blurEvent = evnt => {
      reactData.isActivated = false;
      dispatchEvent('blur', {}, evnt);
    };
    const suffixClickEvent = evnt => {
      togglePanelEvent(evnt);
      dispatchEvent('click', {
        triggerButton: true,
        visible: reactData.visiblePanel
      }, evnt);
    };
    const modelSearchEvent = value => {
      reactData.searchValue = value;
    };
    const focusSearchEvent = () => {
      reactData.isActivated = true;
    };
    const handleSearchEvent = () => {
      const {
        modelValue,
        remote,
        remoteMethod
      } = props;
      const {
        searchValue
      } = reactData;
      const remoteOpts = computeRemoteOpts.value;
      const queryMethod = remoteOpts.queryMethod || remoteMethod;
      if (remote && queryMethod && remoteOpts.enabled) {
        reactData.searchLoading = true;
        Promise.resolve(queryMethod({
          $select: $xeSelect,
          searchValue,
          value: modelValue
        })).then(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).catch(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).finally(() => {
          reactData.searchLoading = false;
          handleOption();
          updateYData();
        });
      } else {
        handleOption();
        updateYData();
      }
    };
    const triggerSearchEvent = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().debounce(handleSearchEvent, 350, {
      trailing: true
    });
    const togglePanelEvent = params => {
      const {
        $event
      } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const checkOptionDisabled = (isSelected, option) => {
      if (option.disabled) {
        return true;
      }
      const isMaximize = computeIsMaximize.value;
      if (isMaximize && !isSelected) {
        return true;
      }
      return false;
    };
    const updateYSpace = () => {
      const {
        scrollYLoad
      } = reactData;
      const {
        scrollYStore,
        afterVisibleList
      } = internalData;
      reactData.bodyHeight = scrollYLoad ? afterVisibleList.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const {
        filterable,
        allowCreate
      } = props;
      const {
        scrollYLoad,
        searchValue
      } = reactData;
      const {
        optAddMaps,
        scrollYStore,
        afterVisibleList
      } = internalData;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const restList = scrollYLoad ? afterVisibleList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : afterVisibleList.slice(0);
      if (filterable && allowCreate && searchValue) {
        if (!restList.some(option => option[labelField] === searchValue)) {
          const addItem = optAddMaps[searchValue] || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
            [getOptKey()]: searchValue,
            [labelField]: searchValue,
            [valueField]: searchValue
          });
          optAddMaps[searchValue] = addItem;
          restList.unshift(addItem);
        }
      }
      reactData.optList = restList;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          scrollYLoad
        } = reactData;
        const {
          scrollYStore
        } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const virtualYOpts = computeVirtualYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        // è®¡ç® Y é»è¾
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, scrollBodyElem ? Math.ceil(scrollBodyElem.clientHeight / rowHeight) : 0);
          const offsetYSize = Math.max(0, Math.min(2, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualYOpts.oSize)));
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    const handleScrollToOption = (option, isDwArrow) => {
      const {
        scrollYLoad
      } = reactData;
      const {
        optFullValMaps,
        scrollYStore
      } = internalData;
      const valueField = computeValueField.value;
      const cacheItem = optFullValMaps[option[valueField]];
      if (cacheItem) {
        const optid = cacheItem.key;
        const avIndex = cacheItem._index;
        if (avIndex > -1) {
          const optWrapperElem = refVirtualWrapper.value;
          const panelElem = refOptionPanel.value;
          if (!panelElem) {
            return;
          }
          const optElem = panelElem.querySelector(`[optid='${optid}']`);
          if (optWrapperElem) {
            if (optElem) {
              const wrapperHeight = optWrapperElem.offsetHeight;
              const offsetPadding = 1;
              if (isDwArrow) {
                if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
                } else if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
                }
              } else {
                if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
                } else if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
                }
              }
            } else if (scrollYLoad) {
              if (isDwArrow) {
                optWrapperElem.scrollTop = avIndex * scrollYStore.rowHeight - optWrapperElem.clientHeight + scrollYStore.rowHeight;
              } else {
                optWrapperElem.scrollTop = avIndex * scrollYStore.rowHeight;
              }
            }
          }
        }
      }
    };
    /**
     * å¦æææ»å¨æ¡ï¼åæ»å¨å°å¯¹åºçä½ç½®
     * @param {Number} scrollLeft å·¦è·ç¦»
     * @param {Number} scrollTop ä¸è·ç¦»
     */
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
          scrollBodyElem.scrollLeft = scrollLeft;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollTop)) {
          scrollBodyElem.scrollTop = scrollTop;
        }
      }
      if (reactData.scrollYLoad) {
        return new Promise(resolve => {
          setTimeout(() => {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              resolve();
            });
          }, 50);
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * å·æ°æ»å¨æ¡
     */
    const refreshScroll = () => {
      const {
        lastScrollLeft,
        lastScrollTop
      } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    /**
     * éæ°è®¡ç®åè¡¨
     */
    const recalculate = () => {
      const el = refElem.value;
      if (el && el.clientWidth && el.clientHeight) {
        return computeScrollLoad();
      }
      return Promise.resolve();
    };
    const loadYData = evnt => {
      const {
        scrollYStore
      } = internalData;
      const {
        startIndex,
        endIndex,
        visibleSize,
        offsetSize,
        rowHeight
      } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    // æ»å¨ãæå¨è¿ç¨ä¸­ä¸éè¦è§¦å
    const isVMScrollProcess = () => {
      const delayHover = 250;
      const {
        lastScrollTime
      } = internalData;
      return !!(lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const scrollEvent = evnt => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      internalData.lastScrollTime = Date.now();
      dispatchEvent('scroll', {
        scrollLeft,
        scrollTop,
        isX,
        isY
      }, evnt);
    };
    /**
     * å è½½æ°æ®
     * @param {Array} datas æ°æ®
     */
    const loadData = datas => {
      cacheItemMap(datas || []);
      const {
        isLoaded,
        fullData,
        scrollYStore
      } = internalData;
      const defaultOpts = computeDefaultOpts.value;
      const virtualYOpts = computeVirtualYOpts.value;
      const valueField = computeValueField.value;
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      internalData.synchData = datas || [];
      // å¦ægtä¸º0ï¼åæ»æ¯å¯ç¨
      reactData.scrollYLoad = !!virtualYOpts.enabled && virtualYOpts.gt > -1 && (virtualYOpts.gt === 0 || virtualYOpts.gt <= fullData.length);
      handleData();
      if (!isLoaded) {
        const {
          selectMode
        } = defaultOpts;
        if (datas.length > 0 && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(props.modelValue)) {
          if (selectMode === 'first' || selectMode === 'last') {
            const selectItem = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default())[selectMode](datas);
            if (selectItem) {
              (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(props.modelValue)) {
                  emitModel(selectItem[valueField]);
                }
              });
            }
          }
          internalData.isLoaded = true;
        }
      }
      return computeScrollLoad().then(() => {
        refreshScroll();
      });
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
        scrollBodyElem.scrollLeft = 0;
      }
      internalData.lastScrollTop = 0;
      internalData.lastScrollLeft = 0;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const hasOptGroupById = optid => {
      const {
        optGroupKeyMaps
      } = internalData;
      return !!optGroupKeyMaps[optid];
    };
    const selectMethods = {
      dispatchEvent,
      loadData,
      reloadData(datas) {
        internalData.isLoaded = false;
        clearScroll();
        return loadData(datas);
      },
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      refreshOption() {
        handleOption();
        updateYData();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      focus() {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
        reactData.isActivated = true;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      recalculate,
      clearScroll
    };
    Object.assign($xeSelect, selectMethods);
    const renderOption = list => {
      const {
        allowCreate,
        optionKey
      } = props;
      const {
        currentOption
      } = reactData;
      const {
        optAddMaps
      } = internalData;
      const optionOpts = computeOptionOpts.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const groupLabelField = computeGroupLabelField.value;
      const selectVals = computeSelectVals.value;
      const {
        useKey,
        height
      } = optionOpts;
      const optionSlot = slots.option;
      return list.map((option, cIndex) => {
        const {
          slots,
          className
        } = option;
        const optid = getOptId(option);
        const optionValue = option[valueField];
        const isOptGroup = hasOptGroupById(optid);
        const isAdd = !!(allowCreate && optAddMaps[optid]);
        const isSelected = !isAdd && selectVals.indexOf(optionValue) > -1;
        const isVisible = isAdd || !isOptGroup || isOptionVisible(option);
        const isDisabled = !isAdd && checkOptionDisabled(isSelected, option);
        const defaultSlot = slots ? slots.default : null;
        const optParams = {
          option,
          group: isOptGroup ? option : null,
          $select: $xeSelect
        };
        let optLabel = '';
        let optVNs = [];
        if (optionSlot) {
          optVNs = callSlot(optionSlot, optParams);
        } else if (defaultSlot) {
          optVNs = callSlot(defaultSlot, optParams);
        } else {
          optLabel = getFuncText(option[isOptGroup ? groupLabelField : labelField] || optionValue);
          optVNs = optLabel;
        }
        return isVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: useKey || optionKey ? optid : cIndex,
          class: ['vxe-select-option', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(optParams) : className : '', {
            'vxe-select-optgroup': isOptGroup,
            'is--disabled': isDisabled,
            'is--selected': isSelected,
            'is--add': isAdd,
            'is--hover': currentOption && getOptId(currentOption) === optid
          }],
          optid: optid,
          title: optLabel || null,
          style: height ? {
            height: toCssUnit(height)
          } : undefined,
          onMousedown: evnt => {
            const isLeftBtn = evnt.button === 0;
            if (isLeftBtn) {
              evnt.stopPropagation();
            }
          },
          onClick: evnt => {
            if (!isDisabled && !isOptGroup) {
              changeOptionEvent(evnt, option);
            }
          },
          onMouseenter: () => {
            if (!isDisabled && !isOptGroup && !isVMScrollProcess()) {
              setCurrentOption(option);
            }
          }
        }, allowCreate ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          key: 1,
          class: 'vxe-select-option--label'
        }, optVNs), isAdd ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          key: 2,
          class: 'vxe-select-option--add-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().SELECT_ADD_OPTION
        })]) : renderEmptyElement($xeSelect)] : optVNs) : renderEmptyElement($xeSelect);
      });
    };
    const renderOpts = () => {
      const {
        optList,
        searchLoading
      } = reactData;
      if (searchLoading) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-select--search-loading'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-select--search-icon', getIcon().SELECT_LOADED]
        }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-select--search-text'
        }, getI18n('vxe.select.loadingText'))])];
      }
      if (optList.length) {
        return renderOption(optList);
      }
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--empty-placeholder'
      }, props.emptyText || getI18n('vxe.select.emptyText'))];
    };
    const renderVN = () => {
      const {
        className,
        popupClassName,
        multiple,
        loading,
        filterable,
        showTotalButoon,
        showCheckedButoon,
        showClearButton
      } = props;
      const {
        initialized,
        isActivated,
        isAniVisible,
        optList,
        visiblePanel,
        bodyHeight,
        topSpaceHeight
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const fullLabel = computeFullLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-select--readonly', className]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-select-slots',
          ref: 'hideOption'
        }, defaultSlot ? defaultSlot({}) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-select-label',
          title: fullLabel
        }, selectLabel)]);
      }
      const selectVals = computeSelectVals.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-select', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $select: $xeSelect
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--filter': filterable,
          'is--loading': loading,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select-slots',
        ref: 'hideOption'
      }, defaultSlot ? defaultSlot({}) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInput,
        clearable: props.clearable,
        placeholder: inpPlaceholder,
        readonly: true,
        disabled: isDisabled,
        type: 'text',
        prefixIcon: props.prefixIcon,
        suffixIcon: loading ? getIcon().SELECT_LOADED : visiblePanel ? getIcon().SELECT_OPEN : getIcon().SELECT_CLOSE,
        autoFocus: false,
        title: fullLabel,
        modelValue: selectLabel,
        onClear: clearEvent,
        onClick: clickEvent,
        onFocus: focusEvent,
        onBlur: blurEvent,
        onSuffixClick: suffixClickEvent
      }, prefixSlot ? {
        prefix: () => prefixSlot({})
      } : {}), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-select--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $select: $xeSelect
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': !loading && isAniVisible,
          'ani--enter': !loading && visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, initialized && (visiblePanel || isAniVisible) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-wrapper'
      }, [filterable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-search'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInpSearch,
        class: 'vxe-select-search--input',
        modelValue: reactData.searchValue,
        type: 'text',
        clearable: true,
        disabled: false,
        readonly: false,
        placeholder: getI18n('vxe.select.search'),
        prefixIcon: getIcon().INPUT_SEARCH,
        'onUpdate:modelValue': modelSearchEvent,
        onFocus: focusSearchEvent,
        onChange: triggerSearchEvent,
        onSearch: triggerSearchEvent
      })]) : renderEmptyElement($xeSelect), showTotalButoon || showCheckedButoon && multiple || showClearButton || headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-header'
      }, headerSlot ? callSlot(headerSlot, {}) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--header-button'
      }, [showTotalButoon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--header-total'
      }, getI18n('vxe.select.total', [selectVals.length, optList.length])) : renderEmptyElement($xeSelect), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--header-btns'
      }, [showCheckedButoon && multiple ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.select.allChecked'),
        mode: 'text',
        onClick: allCheckedPanelEvent
      }) : renderEmptyElement($xeSelect), showClearButton ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.select.clear'),
        mode: 'text',
        onClick: clearCheckedPanelEvent
      }) : renderEmptyElement($xeSelect)])])]) : renderEmptyElement($xeSelect), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualWrapper,
        class: 'vxe-select-option--wrapper',
        onScroll: scrollEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--y-space',
        style: {
          height: bodyHeight ? `${bodyHeight}px` : ''
        }
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualBody,
        class: 'vxe-select--body',
        style: {
          transform: `translateY(${topSpaceHeight}px)`
        }
      }, renderOpts())])]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-footer'
      }, callSlot(footerSlot, {})) : renderEmptyElement($xeSelect)])] : [])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticOptions, val => {
      loadData(val);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, val => {
      loadData(val || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.optionGroups, val => {
      loadData(val || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          options,
          optionGroups
        } = props;
        if (optionGroups) {
          loadData(optionGroups);
        } else if (options) {
          loadData(options);
        }
      });
      globalEvents.on($xeSelect, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeSelect, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeSelect, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeSelect, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xeSelect, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeSelect, 'mousewheel');
      globalEvents.off($xeSelect, 'mousedown');
      globalEvents.off($xeSelect, 'keydown');
      globalEvents.off($xeSelect, 'blur');
      globalEvents.off($xeSelect, 'resize');
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData, select_createInternalData());
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeSelect', $xeSelect);
    $xeSelect.renderVN = renderVN;
    return $xeSelect;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/pager/src/pager.ts








/* harmony default export */ var pager = (defineVxeComponent({
  name: 'VxePager',
  props: {
    size: {
      type: String,
      default: () => getConfig().pager.size || getConfig().size
    },
    // èªå®ä¹å¸å±
    layouts: {
      type: Array,
      default: () => getConfig().pager.layouts || ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
    },
    // å½åé¡µ
    currentPage: {
      type: Number,
      default: 1
    },
    // å è½½ä¸­
    loading: Boolean,
    // æ¯é¡µå¤§å°
    pageSize: {
      type: Number,
      default: () => getConfig().pager.pageSize || 10
    },
    // æ»æ¡æ°
    total: {
      type: Number,
      default: 0
    },
    // æ¾ç¤ºé¡µç æé®çæ°é
    pagerCount: {
      type: Number,
      default: () => getConfig().pager.pagerCount || 7
    },
    // æ¯é¡µå¤§å°éé¡¹åè¡¨
    pageSizes: {
      type: Array,
      default: () => getConfig().pager.pageSizes || [10, 15, 20, 50, 100]
    },
    // åå¯¹é½æ¹å¼
    align: {
      type: String,
      default: () => getConfig().pager.align
    },
    // å¸¦è¾¹æ¡
    border: {
      type: Boolean,
      default: () => getConfig().pager.border
    },
    // å¸¦èæ¯é¢è²
    background: {
      type: Boolean,
      default: () => getConfig().pager.background
    },
    // éå¥çæ ·å¼
    perfect: {
      type: Boolean,
      default: () => getConfig().pager.perfect
    },
    // å½åªæä¸é¡µæ¶éè
    autoHidden: {
      type: Boolean,
      default: () => getConfig().pager.autoHidden
    },
    transfer: {
      type: Boolean,
      default: () => getConfig().pager.transfer
    },
    className: [String, Function],
    pageSizePlacement: {
      type: String,
      default: () => getConfig().pager.pageSizePlacement
    },
    // èªå®ä¹å¾æ 
    iconPrevPage: String,
    iconJumpPrev: String,
    iconJumpNext: String,
    iconNextPage: String,
    iconJumpMore: String,
    iconHomePage: String,
    iconEndPage: String
  },
  emits: ['update:pageSize', 'update:currentPage', 'page-change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const $xeGrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeGrid', null);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inpCurrPage: props.currentPage
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const computePageCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getPageCount(props.total, props.pageSize);
    });
    const computeNumList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        pagerCount
      } = props;
      const pageCount = computePageCount.value;
      const len = pageCount > pagerCount ? pagerCount - 2 : pagerCount;
      const rest = [];
      for (let index = 0; index < len; index++) {
        rest.push(index);
      }
      return rest;
    });
    const computeOffsetNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Math.floor((props.pagerCount - 2) / 2);
    });
    const computeSizeList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.pageSizes.map(item => {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(item)) {
          return {
            value: item,
            label: `${getI18n('vxe.pager.pagesize', [item])}`
          };
        }
        return {
          value: '',
          label: '',
          ...item
        };
      });
    });
    const $xePager = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $pager: $xePager
      }, params));
    };
    const getPageCount = (total, size) => {
      return Math.max(Math.ceil(total / size), 1);
    };
    const handleJumpPageEvent = (evnt, currentPage) => {
      emit('update:currentPage', currentPage);
      if (evnt && currentPage !== props.currentPage) {
        dispatchEvent('page-change', {
          type: 'current',
          pageSize: props.pageSize,
          currentPage
        }, evnt);
      }
    };
    const handleChangeCurrentPage = (currentPage, evnt) => {
      emit('update:currentPage', currentPage);
      if (evnt && currentPage !== props.currentPage) {
        dispatchEvent('page-change', {
          type: 'current',
          pageSize: props.pageSize,
          currentPage
        }, evnt);
      }
    };
    const triggerJumpEvent = params => {
      const {
        $event
      } = params;
      const inputElem = $event.target;
      const inpValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(inputElem.value);
      const pageCount = computePageCount.value;
      const current = inpValue <= 0 ? 1 : inpValue >= pageCount ? pageCount : inpValue;
      const currPage = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(current);
      inputElem.value = currPage;
      reactData.inpCurrPage = currPage;
      handleChangeCurrentPage(current, $event);
    };
    const handleHomePage = evnt => {
      const {
        currentPage
      } = props;
      if (currentPage > 1) {
        handleChangeCurrentPage(1, evnt);
      }
    };
    const handleEndPage = evnt => {
      const {
        currentPage
      } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        handleChangeCurrentPage(pageCount, evnt);
      }
    };
    const handlePrevPage = evnt => {
      const {
        currentPage
      } = props;
      const pageCount = computePageCount.value;
      if (currentPage > 1) {
        handleChangeCurrentPage(Math.min(pageCount, Math.max(currentPage - 1, 1)), evnt);
      }
    };
    const handleNextPage = evnt => {
      const {
        currentPage
      } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        handleChangeCurrentPage(Math.min(pageCount, currentPage + 1), evnt);
      }
    };
    const handlePrevJump = evnt => {
      const numList = computeNumList.value;
      handleChangeCurrentPage(Math.max(props.currentPage - numList.length, 1), evnt);
    };
    const handleNextJump = evnt => {
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      handleChangeCurrentPage(Math.min(props.currentPage + numList.length, pageCount), evnt);
    };
    const pageSizeEvent = params => {
      const {
        value,
        $event
      } = params;
      const pageSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(value);
      const pageCount = getPageCount(props.total, pageSize);
      let currentPage = props.currentPage;
      if (currentPage > pageCount) {
        currentPage = pageCount;
        emit('update:currentPage', pageCount);
      }
      emit('update:pageSize', pageSize);
      if ($event) {
        dispatchEvent('page-change', {
          type: 'size',
          pageSize,
          currentPage
        }, $event);
      }
    };
    const jumpKeydownEvent = params => {
      const {
        $event
      } = params;
      if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ENTER)) {
        triggerJumpEvent(params);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_UP)) {
        $event.preventDefault();
        handleNextPage($event);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_DOWN)) {
        $event.preventDefault();
        handlePrevPage($event);
      }
    };
    // ç¬¬ä¸é¡µ
    const renderHomePage = () => {
      const {
        currentPage,
        total
      } = props;
      const homeSlot = slots.home;
      const pageCount = computePageCount.value;
      if (homeSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-home-btn'
        }, homeSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--home-btn', {
          'is--disabled': currentPage <= 1
        }],
        type: 'button',
        title: getI18n('vxe.pager.homePageTitle'),
        onClick: handleHomePage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconHomePage || getIcon().PAGER_HOME]
      })]);
    };
    // ä¸ä¸é¡µ
    const renderPrevPage = () => {
      const {
        currentPage,
        total
      } = props;
      const prevPageSlot = slots.prevPage || slots['prev-page'];
      const pageCount = computePageCount.value;
      if (prevPageSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-prev-btn'
        }, prevPageSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--prev-btn', {
          'is--disabled': currentPage <= 1
        }],
        type: 'button',
        title: getI18n('vxe.pager.prevPageTitle'),
        onClick: handlePrevPage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconPrevPage || getIcon().PAGER_PREV_PAGE]
      })]);
    };
    // åä¸ç¿»é¡µ
    const renderPrevJump = tagName => {
      const {
        currentPage,
        total
      } = props;
      const prevJumpSlot = slots.prevJump || slots['prev-jump'];
      const pageCount = computePageCount.value;
      if (prevJumpSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-jump-prev'
        }, prevJumpSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tagName || 'button', {
        class: ['vxe-pager--jump-prev', {
          'is--fixed': !tagName,
          'is--disabled': currentPage <= 1
        }],
        type: 'button',
        title: getI18n('vxe.pager.prevJumpTitle'),
        onClick: handlePrevJump
      }, [tagName ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-more-icon', props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
      }) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-icon', props.iconJumpPrev || getIcon().PAGER_JUMP_PREV]
      })]);
    };
    // åä¸ç¿»é¡µ
    const renderNextJump = tagName => {
      const {
        currentPage,
        total
      } = props;
      const nextJumpSlot = slots.nextJump || slots['next-jump'];
      const pageCount = computePageCount.value;
      if (nextJumpSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-jump-next'
        }, nextJumpSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tagName || 'button', {
        class: ['vxe-pager--jump-next', {
          'is--fixed': !tagName,
          'is--disabled': currentPage >= pageCount
        }],
        type: 'button',
        title: getI18n('vxe.pager.nextJumpTitle'),
        onClick: handleNextJump
      }, [tagName ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-more-icon', props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
      }) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-icon', props.iconJumpNext || getIcon().PAGER_JUMP_NEXT]
      })]);
    };
    // ä¸ä¸é¡µ
    const renderNextPage = () => {
      const {
        currentPage,
        total
      } = props;
      const nextPageSlot = slots.nextPage || slots['next-page'];
      const pageCount = computePageCount.value;
      if (nextPageSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-next-btn'
        }, nextPageSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--next-btn', {
          'is--disabled': currentPage >= pageCount
        }],
        type: 'button',
        title: getI18n('vxe.pager.nextPageTitle'),
        onClick: handleNextPage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconNextPage || getIcon().PAGER_NEXT_PAGE]
      })]);
    };
    // æåä¸é¡µ
    const renderEndPage = () => {
      const {
        currentPage,
        total
      } = props;
      const endSlot = slots.end;
      const pageCount = computePageCount.value;
      if (endSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-end-btn'
        }, endSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--end-btn', {
          'is--disabled': currentPage >= pageCount
        }],
        type: 'button',
        title: getI18n('vxe.pager.endPageTitle'),
        onClick: handleEndPage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconEndPage || getIcon().PAGER_END]
      })]);
    };
    // é¡µæ°
    const renderNumber = showJump => {
      const {
        currentPage,
        total,
        pagerCount
      } = props;
      const numberSlot = showJump ? slots.numberJump || slots['number-jump'] : slots.number;
      const nums = [];
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      const offsetNumber = computeOffsetNumber.value;
      const isOv = pageCount > pagerCount;
      const isLt = isOv && currentPage > offsetNumber + 1;
      const isGt = isOv && currentPage < pageCount - offsetNumber;
      const restList = [];
      let startNumber = 1;
      if (isOv) {
        if (currentPage >= pageCount - offsetNumber) {
          startNumber = Math.max(pageCount - numList.length + 1, 1);
        } else {
          startNumber = Math.max(currentPage - offsetNumber, 1);
        }
      }
      if (showJump && isLt) {
        restList.push(1);
        nums.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
          class: 'vxe-pager--num-btn',
          type: 'button',
          onClick: evnt => handleJumpPageEvent(evnt, 1)
        }, '1'), renderPrevJump('span'));
      }
      numList.forEach((item, index) => {
        const number = startNumber + index;
        if (number <= pageCount) {
          restList.push(number);
          nums.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
            key: number,
            class: ['vxe-pager--num-btn', {
              'is--active': currentPage === number
            }],
            type: 'button',
            onClick: evnt => handleJumpPageEvent(evnt, number)
          }, `${number}`));
        }
      });
      if (showJump && isGt) {
        restList.push(pageCount);
        nums.push(renderNextJump('button'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
          class: 'vxe-pager--num-btn',
          type: 'button',
          onClick: evnt => handleJumpPageEvent(evnt, pageCount)
        }, pageCount));
      }
      if (numberSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-btn-wrapper'
        }, numberSlot({
          $pager: $xePager,
          total,
          numList: restList,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--btn-wrapper'
      }, nums);
    };
    // jumpNumber
    const renderJumpNumber = () => {
      return renderNumber(true);
    };
    // sizes
    const renderSizes = () => {
      const {
        total,
        currentPage,
        pageSize,
        pageSizePlacement,
        transfer
      } = props;
      const sizesSlot = slots.sizes;
      const sizeList = computeSizeList.value;
      const pageCount = computePageCount.value;
      if (sizesSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-sizes'
        }, sizesSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount,
          pageSize,
          options: sizeList
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_select, {
        class: 'vxe-pager--sizes',
        modelValue: pageSize,
        placement: pageSizePlacement,
        transfer: transfer,
        options: sizeList,
        onChange: pageSizeEvent
      });
    };
    // Jump
    const renderJump = isFull => {
      const {
        total
      } = props;
      const {
        inpCurrPage
      } = reactData;
      const jumpSlot = isFull ? slots.fullJump || slots['full-jump'] : slots.jump;
      const pageCount = computePageCount.value;
      if (jumpSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-jump'
        }, jumpSlot({
          $pager: $xePager,
          total,
          currentPage: inpCurrPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--jump'
      }, [isFull ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--goto-text'
      }, getI18n('vxe.pager.goto')) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(number_input, {
        class: 'vxe-pager--goto',
        modelValue: reactData.inpCurrPage,
        placeholder: getI18n('vxe.pager.gotoTitle'),
        align: 'center',
        type: 'integer',
        max: pageCount,
        min: 1,
        controls: false,
        onKeydown: jumpKeydownEvent,
        onBlur: triggerJumpEvent,
        'onUpdate:modelValue'(val) {
          reactData.inpCurrPage = val;
        }
      }), isFull ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--classifier-text'
      }, getI18n('vxe.pager.pageClassifier')) : null]);
    };
    // FullJump
    const renderFullJump = () => {
      return renderJump(true);
    };
    // PageCount
    const renderPageCount = () => {
      const {
        currentPage,
        total
      } = props;
      const pageCountSlot = slots.pageCount || slots['page-count'];
      const pageCount = computePageCount.value;
      if (pageCountSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-count'
        }, pageCountSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--count'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--separator'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', pageCount)]);
    };
    // total
    const renderTotal = () => {
      const {
        currentPage,
        total
      } = props;
      const totalSlot = slots.total;
      const pageCount = computePageCount.value;
      if (totalSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-total'
        }, totalSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--total'
      }, getI18n('vxe.pager.total', [total]));
    };
    const pagerMethods = {
      dispatchEvent,
      setPageSize(num) {
        pageSizeEvent({
          value: num
        });
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setPageSizeByEvent(evnt, num) {
        pageSizeEvent({
          value: num,
          $event: evnt
        });
      },
      homePage() {
        handleHomePage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      homePageByEvent(evnt) {
        handleHomePage(evnt);
      },
      endPage() {
        handleEndPage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      endPageByEvent(evnt) {
        handleEndPage(evnt);
      },
      prevPage() {
        handlePrevPage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      prevPageByEvent(evnt) {
        handlePrevPage(evnt);
      },
      nextPage() {
        handleNextPage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      nextPageByEvent(evnt) {
        handleNextPage(evnt);
      },
      prevJump() {
        handlePrevJump();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      prevJumpByEvent(evnt) {
        handlePrevJump(evnt);
      },
      nextJump() {
        handleNextJump();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      nextJumpByEvent(evnt) {
        handleNextJump(evnt);
      },
      setCurrentPage(currentPage) {
        const current = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(currentPage) || 1;
        reactData.inpCurrPage = current;
        handleChangeCurrentPage(current);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setCurrentPageByEvent(evnt, currentPage) {
        const current = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(currentPage) || 1;
        reactData.inpCurrPage = current;
        handleChangeCurrentPage(current, evnt);
      },
      /**
       * å·²åºå¼ï¼è¢« setCurrentPage æ¿æ¢
       * @deprecated
       */
      jumpPage(currentPage) {
        warnLog('vxe.error.delFunc', ['[pager] jumpPage', 'setCurrentPage']);
        return $xePager.setCurrentPage(currentPage);
      }
    };
    const pagerPrivateMethods = {
      handlePrevPage,
      handleNextPage,
      handlePrevJump,
      handleNextJump
    };
    Object.assign($xePager, pagerMethods, pagerPrivateMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.currentPage, value => {
      reactData.inpCurrPage = value;
    });
    const renderVN = () => {
      const {
        align,
        layouts,
        className
      } = props;
      const childNodes = [];
      const vSize = computeSize.value;
      const pageCount = computePageCount.value;
      if (slots.left) {
        childNodes.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--left-wrapper'
        }, slots.left({
          $grid: $xeGrid
        })));
      }
      layouts.forEach(name => {
        let renderFn;
        switch (name) {
          case 'Home':
            renderFn = renderHomePage;
            break;
          case 'PrevJump':
            renderFn = renderPrevJump;
            break;
          case 'PrevPage':
            renderFn = renderPrevPage;
            break;
          case 'Number':
            renderFn = renderNumber;
            break;
          case 'JumpNumber':
            renderFn = renderJumpNumber;
            break;
          case 'NextPage':
            renderFn = renderNextPage;
            break;
          case 'NextJump':
            renderFn = renderNextJump;
            break;
          case 'End':
            renderFn = renderEndPage;
            break;
          case 'Sizes':
            renderFn = renderSizes;
            break;
          case 'FullJump':
            renderFn = renderFullJump;
            break;
          case 'Jump':
            renderFn = renderJump;
            break;
          case 'PageCount':
            renderFn = renderPageCount;
            break;
          case 'Total':
            renderFn = renderTotal;
            break;
        }
        if (renderFn) {
          childNodes.push(renderFn());
        } else {
          errLog('vxe.error.notProp', [`[pager] layouts -> ${name}`]);
        }
      });
      if (slots.right) {
        childNodes.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--right-wrapper'
        }, slots.right({
          $grid: $xeGrid
        })));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-pager', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $pager: $xePager
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          [`align--${align}`]: align,
          'is--border': props.border,
          'is--background': props.background,
          'is--perfect': props.perfect,
          'is--hidden': props.autoHidden && pageCount === 1,
          'is--loading': props.loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pager--wrapper'
      }, childNodes)]);
    };
    $xePager.renderVN = renderVN;
    return $xePager;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/pager/index.ts



const VxePager = Object.assign(pager, {
  install: function (app) {
    app.component(pager.name, pager);
  }
});
dynamicApp.use(VxePager);
index_esm_VxeUI.component(pager);
const Pager = VxePager;
/* harmony default export */ var packages_pager = (VxePager);
;// CONCATENATED MODULE: ./packages/password-input/src/password-input.ts






/* harmony default export */ var password_input = (defineVxeComponent({
  name: 'VxePasswordInput',
  props: {
    modelValue: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    clearable: {
      type: Boolean,
      default: () => getConfig().passwordInput.clearable
    },
    readonly: Boolean,
    disabled: Boolean,
    maxLength: [String, Number],
    placeholder: String,
    autoComplete: {
      type: String,
      default: 'off'
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().passwordInput.size || getConfig().size
    },
    prefixIcon: String,
    suffixIcon: String,
    controls: {
      type: Boolean,
      default: () => getConfig().passwordInput.controls
    },
    // å·²åºå¼
    autocomplete: String
  },
  emits: ['update:modelValue', 'input', 'change', 'click', 'focus', 'blur', 'clear', 'lazy-change', 'toggle-visible', 'prefix-click', 'suffix-click'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      showPwd: false,
      isActivated: false,
      inputValue: props.modelValue
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xePasswordInput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let passwordInputMethods = {};
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.clearable;
    });
    const computeInpReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      return readonly;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().passwordInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.base.pleaseInput');
    });
    const computeInputType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        showPwd
      } = reactData;
      if (showPwd) {
        return 'text';
      }
      return 'password';
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        immediate
      } = props;
      return immediate;
    });
    const triggerEvent = evnt => {
      const {
        inputValue
      } = reactData;
      passwordInputMethods.dispatchEvent(evnt.type, {
        value: inputValue
      }, evnt);
    };
    const emitInputEvent = (value, evnt) => {
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (inpImmediate) {
        handleChange(value, evnt);
      } else {
        passwordInputMethods.dispatchEvent('input', {
          value
        }, evnt);
      }
    };
    const inputEvent = evnt => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit('update:modelValue', value);
      passwordInputMethods.dispatchEvent('input', {
        value
      }, evnt);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        passwordInputMethods.dispatchEvent('change', {
          value
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const changeEvent = evnt => {
      triggerEvent(evnt);
      $xePasswordInput.dispatchEvent('lazy-change', {
        value: reactData.inputValue
      }, evnt);
      // èªå¨æ´æ°æ ¡éªç¶æ
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, reactData.inputValue);
      }
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      triggerEvent(evnt);
    };
    const blurEvent = evnt => {
      const {
        inputValue
      } = reactData;
      const value = inputValue;
      $xePasswordInput.dispatchEvent('blur', {
        value
      }, evnt);
      // èªå¨æ´æ°æ ¡éªç¶æ
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const passwordToggleEvent = evnt => {
      const {
        readonly,
        disabled
      } = props;
      const {
        showPwd
      } = reactData;
      if (!disabled && !readonly) {
        reactData.showPwd = !showPwd;
      }
      $xePasswordInput.dispatchEvent('toggle-visible', {
        visible: reactData.showPwd
      }, evnt);
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      handleChange('', evnt);
      $xePasswordInput.dispatchEvent('clear', {
        value
      }, evnt);
      $xePasswordInput.dispatchEvent('lazy-change', {
        value: reactData.inputValue
      }, evnt);
    };
    const clickSuffixEvent = evnt => {
      const {
        disabled
      } = props;
      if (!disabled) {
        const {
          inputValue
        } = reactData;
        $xePasswordInput.dispatchEvent('suffix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const clickPrefixEvent = evnt => {
      const {
        disabled
      } = props;
      if (!disabled) {
        const {
          inputValue
        } = reactData;
        $xePasswordInput.dispatchEvent('prefix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const renderPasswordIcon = () => {
      const {
        showPwd
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-password-input--control-icon',
        onClick: passwordToggleEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-password-input--password-icon', showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
      })]);
    };
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-password-input--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-password-input--prefix-icon'
      }, prefixSlot ? vn_getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : null;
    };
    const renderSuffixIcon = () => {
      const {
        disabled,
        suffixIcon,
        controls
      } = props;
      const {
        inputValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isClearable = computeIsClearable.value;
      return isClearable || controls || suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-password-input--suffix', {
          'is--clear': isClearable && !disabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-password-input--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : renderEmptyElement($xePasswordInput), controls ? renderPasswordIcon() : renderEmptyElement($xePasswordInput), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-password-input--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? vn_getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : renderEmptyElement($xePasswordInput)]) : null;
    };
    passwordInputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $passwordInput: $xePasswordInput
        }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xePasswordInput, passwordInputMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
    });
    const renderVN = () => {
      const {
        className,
        name,
        disabled,
        readonly,
        autocomplete,
        autoComplete,
        maxLength
      } = props;
      const {
        inputValue,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const inpReadonly = computeInpReadonly.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon();
      const suffix = renderSuffixIcon();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-password-input', className, {
          [`size--${vSize}`]: vSize,
          'is--prefix': !!prefix,
          'is--suffix': !!suffix,
          'is--readonly': readonly,
          'is--disabled': disabled,
          'is--active': isActivated,
          'show--clear': isClearable && !disabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }],
        spellcheck: false
      }, [prefix || renderEmptyElement($xePasswordInput), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-password-input--wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-password-input--inner',
        value: inputValue,
        name,
        type: inputType,
        placeholder: inpPlaceholder,
        readonly: inpReadonly,
        disabled,
        autocomplete: autocomplete || autoComplete,
        maxlength: maxLength,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), suffix || renderEmptyElement($xePasswordInput)]);
    };
    $xePasswordInput.renderVN = renderVN;
    return $xePasswordInput;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/password-input/index.ts



const VxePasswordInput = Object.assign({}, password_input, {
  install(app) {
    app.component(password_input.name, password_input);
  }
});
dynamicApp.use(VxePasswordInput);
index_esm_VxeUI.component(password_input);
const PasswordInput = VxePasswordInput;
/* harmony default export */ var packages_password_input = (VxePasswordInput);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.delete.js
var web_url_search_params_delete = __webpack_require__(4603);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.has.js
var web_url_search_params_has = __webpack_require__(7566);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.size.js
var web_url_search_params_size = __webpack_require__(8721);
;// CONCATENATED MODULE: ./packages/print/src/util.ts





const browseObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
// æå°
let printFrame;
// é»è®¤å¯¼åºææå°ç HTML æ ·å¼
const defaultHtmlStyle = 'body{padding:0;font-family:"Microsoft YaHei",å¾®è½¯éé»,"MicrosoftJhengHei",åæç»é»,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function trimHtml(html) {
  return `${html}`.replace(/(<!---->)/, '');
}
function createPrintFrame() {
  const frame = document.createElement('iframe');
  frame.className = 'vxe-table--print-frame';
  return frame;
}
function appendPrintFrame() {
  if (!printFrame.parentNode) {
    document.body.appendChild(printFrame);
  }
}
function afterPrintEvent() {
  requestAnimationFrame(removeFrame);
}
function removeFrame() {
  if (printFrame) {
    if (printFrame.parentNode) {
      try {
        printFrame.contentDocument.write('');
      } catch (e) {}
      printFrame.parentNode.removeChild(printFrame);
    }
    printFrame = null;
  }
}
function getExportBlobByString(str, type) {
  return new Blob([str], {
    type: `text/${type};charset=utf-8;`
  });
}
const defaultPrintMargin = 50;
const defaultFontColor = '#000000';
function parsePageStyle(val) {
  const styOpts = Object.assign({}, val);
  const headStyOpts = Object.assign({}, styOpts.header);
  const titStyOpts = Object.assign({}, styOpts.title);
  const footStyOpts = Object.assign({}, styOpts.footer);
  const pnStyOpts = Object.assign({}, styOpts.pageNumber);
  let mVal = defaultPrintMargin;
  let marginTop = mVal;
  let marginBottom = mVal;
  let marginLeft = mVal;
  let marginRight = mVal;
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(styOpts.margin) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(styOpts.margin)) {
    mVal = styOpts.margin;
    marginTop = mVal;
    marginBottom = mVal;
    marginLeft = mVal;
    marginRight = mVal;
  }
  return {
    marginTop: toCssUnit(styOpts.marginTop || marginTop),
    marginBottom: toCssUnit(styOpts.marginBottom || marginBottom),
    marginLeft: toCssUnit(styOpts.marginLeft || marginLeft),
    marginRight: toCssUnit(styOpts.marginRight || marginRight),
    fontSize: toCssUnit(styOpts.fontSize),
    color: styOpts.color,
    textAlign: styOpts.textAlign,
    header: {
      height: toCssUnit(headStyOpts.height),
      textAlign: headStyOpts.textAlign
    },
    title: {
      color: titStyOpts.color,
      fontSize: toCssUnit(titStyOpts.fontSize),
      textAlign: titStyOpts.textAlign
    },
    footer: {
      height: toCssUnit(footStyOpts.height),
      textAlign: footStyOpts.textAlign
    },
    pageNumber: {
      color: pnStyOpts.color,
      fontSize: toCssUnit(pnStyOpts.fontSize),
      textAlign: pnStyOpts.textAlign
    }
  };
}
function createHtmlPage(opts, printHtml) {
  const {
    pageStyle,
    customStyle
  } = opts;
  const pageStyObj = parsePageStyle(pageStyle);
  const headStyOpts = pageStyObj.header;
  const titStyOpts = pageStyObj.title;
  const footStyOpts = pageStyObj.header;
  const pnStyOpts = pageStyObj.pageNumber;
  const isPbMode = opts._pageBreaks || opts.pageBreaks && opts.pageBreaks.length;
  return ['<!DOCTYPE html><html>', '<head>', '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">', `<title>${opts.title || ''}</title>`, `<style media="print">@page{size:auto;${isPbMode ? 'margin: 0mm;' : ''}}</style>`, `<style>body{font-size:${pageStyObj.fontSize || '14px'};color:${pageStyObj.color || defaultFontColor};text-align:${pageStyObj.textAlign || 'left'};}</style>`, '<style>', '.vxe-print-slots{display:none;}', '.vxe-print-page-break.align--center{text-align:center;}', '.vxe-print-page-break.align--left{text-align:left;}', '.vxe-print-page-break.align--right{text-align:right;}', '.vxe-print-page-break{break-before:always;page-break-before:always;display:flex;flex-direction:column;height:100vh;overflow:hidden;}', '.vxe-print-page-break--body{display:flex;flex-direction:row;flex-grow:1;overflow:hidden;}', '.vxe-print-page-break--left,.vxe-print-page-break--right{flex-shrink:0;height:100%;}', `.vxe-print-page-break--left{width:${pageStyObj.marginLeft};}`, `.vxe-print-page-break--right{width:${pageStyObj.marginRight};}`, '.vxe-print-page-break--header,.vxe-print-page-break--footer{display:flex;justify-content:center;flex-direction:column;flex-shrink:0;width:100%;}', `.vxe-print-page-break--header{height:${headStyOpts.height || pageStyObj.marginTop};padding:0 ${pageStyObj.marginLeft} 0 ${pageStyObj.marginRight};text-align:${headStyOpts.textAlign || 'left'};}`, `.vxe-print-page-break--header-title{font-size:${titStyOpts.fontSize || '1.6em'};color:${titStyOpts.color || defaultFontColor};text-align:${opts.headerAlign || pnStyOpts.textAlign || 'center'};}`, `.vxe-print-page-break--footer{height:${footStyOpts.height || pageStyObj.marginBottom};padding:0 ${pageStyObj.marginLeft} 0 ${pageStyObj.marginRight};text-align:${footStyOpts.textAlign || 'left'};}`, '.vxe-print-page-break--content{flex-grow:1;overflow:hidden;}', `.vxe-print-page-break--footer-page-number{font-size:${pnStyOpts.fontSize || '1.2em'};color:${pnStyOpts.color || defaultFontColor};text-align:${opts.footerAlign || pnStyOpts.textAlign || 'center'};}`, '</style>', '<style>.vxe-table{white-space:pre;}</style>', `<style>${defaultHtmlStyle}</style>`, isPbMode ? '<style>body{margin:0;}</style>' : '', customStyle ? `<style>${customStyle}</style>` : '', '</head>', '<body>', `${printHtml}`, '</body>', '</html>'].join('');
}
function handlePrint(opts, printHtml = '') {
  const {
    beforeMethod
  } = opts;
  if (beforeMethod) {
    printHtml = beforeMethod({
      content: printHtml,
      html: printHtml,
      options: opts
    }) || '';
  }
  printHtml = createHtmlPage(opts, printHtml);
  const blob = getExportBlobByString(printHtml, 'html');
  return new Promise(resolve => {
    if (browseObj.msie) {
      removeFrame();
      printFrame = createPrintFrame();
      appendPrintFrame();
      const contentDocument = printFrame.contentDocument;
      if (contentDocument) {
        contentDocument.write(printHtml);
        contentDocument.execCommand('print');
      }
      setTimeout(() => {
        resolve({
          status: true
        });
      }, 300);
    } else {
      if (!printFrame) {
        printFrame = createPrintFrame();
        printFrame.onload = evnt => {
          const frameEl = evnt.target;
          if (frameEl.src) {
            try {
              const contentWindow = frameEl.contentWindow;
              if (contentWindow) {
                contentWindow.onafterprint = afterPrintEvent;
                contentWindow.print();
              }
            } catch (e) {}
          }
          resolve({
            status: true
          });
        };
        printFrame.onerror = () => {
          resolve({
            status: false
          });
        };
      }
      appendPrintFrame();
      printFrame.src = URL.createObjectURL(blob);
    }
  });
}
function createPageBreak(opts) {
  const {
    title,
    showPageNumber,
    align,
    headerAlign,
    footerAlign,
    showAllPageTitle
  } = opts;
  const pageBreaks = opts.pageBreaks || [];
  const pageCount = pageBreaks.length;
  return pageBreaks.map((item, index) => {
    const bodyHtml = item.bodyHtml;
    const headerHtml = item.headerHtml || opts.headerHtml;
    const footerHtml = item.footerHtml || opts.footerHtml;
    const leftHtml = item.leftHtml || opts.leftHtml;
    const rightHtml = item.rightHtml || opts.rightHtml;
    const currentPage = index + 1;
    const params = {
      currentPage,
      pageCount
    };
    return [`<div class="${['vxe-print-page-break', align ? `align--${align}` : ''].join(' ')}">`, `<div class="${['vxe-print-page-break--header', headerAlign ? `align--${headerAlign}` : ''].join(' ')}">`, headerHtml ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerHtml) ? headerHtml(params) : headerHtml || ''}` : title && (showAllPageTitle || !index) ? `<div class="vxe-print-page-break--header-title">${title || ''}</div>` : '', '</div>', '<div class="vxe-print-page-break--body">', `<div class="vxe-print-page-break--left">${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(leftHtml) ? leftHtml(params) : leftHtml || ''}</div>`, `<div class="vxe-print-page-break--content">${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ''}</div>`, `<div class="vxe-print-page-break--right">${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rightHtml) ? rightHtml(params) : rightHtml || ''}</div>`, '</div>', `<div class="${['vxe-print-page-break--footer', footerAlign ? `align--${footerAlign}` : ''].join(' ')}">`, footerHtml ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerHtml) ? footerHtml(params) : footerHtml || ''}` : showPageNumber ? `<div class="vxe-print-page-break--footer-page-number">${currentPage}/${pageCount}</div>` : '', '</div>', '</div>'].join('');
  }).join('');
}
const printHtml = options => {
  const opts = Object.assign({
    _pageBreaks: false,
    customLayout: true
  }, options);
  if (opts.sheetName) {
    opts.title = opts.title || opts.sheetName;
  }
  if (opts.style) {
    opts.customStyle = opts.customStyle || opts.style;
  }
  if (opts.beforePrintMethod) {
    opts.beforeMethod = opts.beforeMethod || opts.beforePrintMethod;
  }
  if (opts.pageBreaks && opts.pageBreaks.length) {
    return handlePrint(opts, createPageBreak(opts));
  }
  const printHtml = opts.html || opts.content;
  return handlePrint(opts, printHtml);
};
function assemblePageBreak($xePageBreak, elem, pageBreakConfig) {
  const staticPageBreaks = $xePageBreak.reactData.staticPageBreaks;
  const parentElem = elem.parentNode;
  if (parentElem && staticPageBreaks) {
    staticPageBreaks.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, pageBreakConfig);
    $xePageBreak.reactData.staticPageBreaks = staticPageBreaks.slice(0);
  }
}
function destroyPageBreak($xePageBreak, pageBreakConfig) {
  $xePageBreak.reactData.staticPageBreaks = $xePageBreak.reactData.staticPageBreaks.filter(item => item.id !== pageBreakConfig.id);
}
;// CONCATENATED MODULE: ./packages/print/src/page-break.ts





/* harmony default export */ var page_break = (defineVxeComponent({
  name: 'VxePrintPageBreak',
  props: {},
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xePrint = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xePrint', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const pageBreakConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      slots
    });
    const $xePrintPageBreak = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $print: $xePrint
      }, params));
    };
    const printPageBreakMethods = {
      dispatchEvent
    };
    const printPageBreakPrivateMethods = {};
    Object.assign($xePrintPageBreak, printPageBreakMethods, printPageBreakPrivateMethods);
    if (!$xePrint) {
      $xePrintPageBreak.renderVN = () => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      };
      return $xePrintPageBreak;
    }
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if ($xePrint && elem) {
        assemblePageBreak($xePrint, elem, pageBreakConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xePrint) {
        destroyPageBreak($xePrint, pageBreakConfig);
      }
    });
    $xePrintPageBreak.renderVN = renderVN;
    return $xePrintPageBreak;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/print-page-break/index.ts



const VxePrintPageBreak = Object.assign({}, page_break, {
  install(app) {
    app.component(page_break.name, page_break);
  }
});
dynamicApp.use(VxePrintPageBreak);
index_esm_VxeUI.component(page_break);
const PrintPageBreak = VxePrintPageBreak;
/* harmony default export */ var print_page_break = (VxePrintPageBreak);
;// CONCATENATED MODULE: ./packages/print/src/print.ts






/* harmony default export */ var print = (defineVxeComponent({
  name: 'VxePrint',
  props: {
    align: {
      type: String,
      default: () => getConfig().print.align
    },
    title: String,
    headerAlign: {
      type: String,
      default: () => getConfig().print.headerAlign
    },
    footerAlign: {
      type: String,
      default: () => getConfig().print.footerAlign
    },
    showPageNumber: {
      type: Boolean,
      default: () => getConfig().print.showPageNumber
    },
    customLayout: Boolean,
    pageBreaks: Array,
    content: String,
    html: String,
    headerHtml: String,
    footerHtml: String,
    leftHtml: String,
    rightHtml: String,
    showAllPageTitle: {
      type: Boolean,
      default: () => getConfig().print.showAllPageTitle
    },
    pageStyle: {
      type: Object,
      default: () => getConfig().print.pageStyle
    },
    customStyle: {
      type: String,
      default: () => getConfig().print.customStyle
    },
    beforeMethod: Function
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      staticPageBreaks: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xePrint = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $print: $xePrint
      }, params));
    };
    const printMethods = {
      dispatchEvent,
      print() {
        const elem = refElem.value;
        return printHtml(Object.assign({}, props, {
          _pageBreaks: !!reactData.staticPageBreaks.length,
          html: trimHtml(elem ? elem.outerHTML : '') || props.html || props.content || ''
        }));
      }
    };
    const printPrivateMethods = {};
    Object.assign($xePrint, printMethods, printPrivateMethods);
    const renderPageConfigLayouts = () => {
      const {
        title,
        showPageNumber,
        showAllPageTitle,
        align,
        headerAlign,
        footerAlign
      } = props;
      const pageBreaks = props.pageBreaks || [];
      const pageCount = pageBreaks.length;
      return pageBreaks.map((item, index) => {
        const bodyHtml = item.bodyHtml;
        const headerHtml = item.headerHtml || props.headerHtml;
        const footerHtml = item.footerHtml || props.footerHtml;
        const leftHtml = item.leftHtml || props.leftHtml;
        const rightHtml = item.rightHtml || props.rightHtml;
        const currentPage = index + 1;
        const params = {
          currentPage,
          pageCount
        };
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break', align ? `align--${align}` : '']
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break--header', headerAlign ? `align--${headerAlign}` : '']
        }, headerHtml ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerHtml) ? headerHtml(params) : headerHtml || ''}` : [title && (showAllPageTitle || !index) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--header-title'
        }, `${title || ''}`) : renderEmptyElement($xePrint)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--body'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--left'
        }, `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(leftHtml) ? leftHtml(params) : leftHtml || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--content'
        }, `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--right'
        }, `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rightHtml) ? rightHtml(params) : rightHtml || ''}`)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break--footer', footerAlign ? `align--${footerAlign}` : '']
        }, footerHtml ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerHtml) ? footerHtml(params) : footerHtml || ''}` : [showPageNumber ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--footer-page-number'
        }, `${currentPage}/${pageCount}`) : renderEmptyElement($xePrint)])]);
      });
    };
    const renderPageStaticLayouts = () => {
      const {
        title,
        showPageNumber,
        showAllPageTitle,
        align,
        headerAlign,
        footerAlign
      } = props;
      const {
        staticPageBreaks
      } = reactData;
      const pageCount = staticPageBreaks.length;
      return staticPageBreaks.map((item, index) => {
        const itemSlots = item.slots || {};
        const currentPage = index + 1;
        const defaultSlot = itemSlots.default;
        const headerSlot = itemSlots.header || slots.header;
        const footerSlot = itemSlots.footer || slots.footer;
        const leftSlot = itemSlots.left || slots.left;
        const rightSlot = itemSlots.right || slots.right;
        const params = {
          currentPage,
          pageCount
        };
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break', align ? `align--${align}` : '']
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break--header', headerAlign ? `align--${headerAlign}` : '']
        }, headerSlot ? vn_getSlotVNs(headerSlot(params)) : [title && (showAllPageTitle || !index) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--header-title'
        }, `${title || ''}`) : renderEmptyElement($xePrint)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--body'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--left'
        }, leftSlot ? vn_getSlotVNs(leftSlot(params)) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--content'
        }, defaultSlot ? vn_getSlotVNs(defaultSlot(params)) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--right'
        }, rightSlot ? vn_getSlotVNs(rightSlot(params)) : [])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break--footer', footerAlign ? `align--${footerAlign}` : '']
        }, footerSlot ? vn_getSlotVNs(footerSlot(params)) : [showPageNumber ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--footer-page-number'
        }, `${currentPage}/${pageCount}`) : renderEmptyElement($xePrint)])]);
      });
    };
    const renderVN = () => {
      const {
        customLayout
      } = props;
      const {
        staticPageBreaks
      } = reactData;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-print']
      }, customLayout ? defaultSlot ? vn_getSlotVNs(defaultSlot({})) : [] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'slot',
        class: 'vxe-print-slots'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({})) : [])].concat(staticPageBreaks.length ? renderPageStaticLayouts() : renderPageConfigLayouts()));
    };
    $xePrint.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xePrint', $xePrint);
    return $xePrint;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/print/index.ts




const VxePrint = Object.assign({}, print, {
  install(app) {
    app.component(print.name, print);
  }
});
dynamicApp.use(VxePrint);
index_esm_VxeUI.component(print);
index_esm_VxeUI.print = printHtml;
const Print = VxePrint;
/* harmony default export */ var packages_print = (VxePrint);
;// CONCATENATED MODULE: ./packages/pulldown/src/pulldown.ts






/* harmony default export */ var pulldown = (defineVxeComponent({
  name: 'VxePulldown',
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    trigger: {
      type: String,
      default: getConfig().pulldown.trigger
    },
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().pulldown.size || getConfig().size
    },
    options: Array,
    className: {
      type: [String, Function],
      default: getConfig().pulldown.className
    },
    popupClassName: [String, Function],
    showPopupShadow: Boolean,
    destroyOnClose: {
      type: Boolean,
      default: getConfig().pulldown.destroyOnClose
    },
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'click', 'option-click', 'show-panel', 'hide-panel', 'visible-change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      hpTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPulldownContent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPulldownPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().pulldown.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const refMaps = {
      refElem
    };
    const $xePulldown = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let pulldownMethods = {};
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const isPanelVisible = () => {
      return reactData.visiblePanel;
    };
    /**
     * æå¨æ´æ°ä½ç½®
     */
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refPulldownContent.value;
      const panelElem = refPulldownPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    /**
     * æ¾ç¤ºä¸æé¢æ¿
     */
    const showPanel = () => {
      if (!reactData.initialized) {
        reactData.initialized = true;
      }
      return new Promise(resolve => {
        if (!props.disabled) {
          if (internalData.hpTimeout) {
            clearTimeout(internalData.hpTimeout);
          }
          reactData.isActivated = true;
          reactData.isAniVisible = true;
          setTimeout(() => {
            reactData.visiblePanel = true;
            emit('update:modelValue', true);
            updatePlacement();
            setTimeout(() => {
              resolve(updatePlacement());
            }, 40);
          }, 10);
          updateZindex();
          dispatchEvent('visible-change', {
            visible: true
          }, null);
        } else {
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            resolve();
          });
        }
      });
    };
    /**
     * éèä¸æé¢æ¿
     */
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      dispatchEvent('visible-change', {
        visible: false
      }, null);
      emit('update:modelValue', false);
      return new Promise(resolve => {
        if (reactData.isAniVisible) {
          internalData.hpTimeout = setTimeout(() => {
            reactData.isAniVisible = false;
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              resolve();
            });
          }, 350);
        } else {
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            resolve();
          });
        }
      });
    };
    /**
     * åæ¢ä¸æé¢æ¿
     */
    const togglePanel = () => {
      if (reactData.visiblePanel) {
        return hideOptionPanel();
      }
      return showPanel();
    };
    const handleOptionEvent = (evnt, option) => {
      if (!option.disabled) {
        if (reactData.visiblePanel) {
          hideOptionPanel();
          dispatchEvent('hide-panel', {}, evnt);
        }
        dispatchEvent('option-click', {
          option
        }, evnt);
      }
    };
    const clickTargetEvent = evnt => {
      const {
        trigger
      } = props;
      if (trigger === 'click') {
        if (reactData.visiblePanel) {
          hideOptionPanel();
          dispatchEvent('hide-panel', {}, evnt);
        } else {
          showPanel();
          dispatchEvent('show-panel', {}, evnt);
        }
      }
      dispatchEvent('click', {
        $pulldown: $xePulldown
      }, evnt);
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        disabled
      } = props;
      const {
        visiblePanel
      } = reactData;
      const panelElem = refPulldownPanel.value;
      if (!disabled) {
        if (visiblePanel) {
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
            dispatchEvent('hide-panel', {}, evnt);
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        disabled
      } = props;
      const {
        visiblePanel
      } = reactData;
      const el = refElem.value;
      const panelElem = refPulldownPanel.value;
      if (!disabled) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
          dispatchEvent('hide-panel', {}, evnt);
        }
      }
    };
    const handleGlobalBlurEvent = evnt => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
        dispatchEvent('hide-panel', {}, evnt);
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $pulldown: $xePulldown
      }, params));
    };
    pulldownMethods = {
      dispatchEvent,
      isPanelVisible,
      togglePanel,
      showPanel,
      hidePanel: hideOptionPanel
    };
    Object.assign($xePulldown, pulldownMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, value => {
      reactData.isActivated = !!value;
      if (value) {
        showPanel();
      } else {
        hideOptionPanel();
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      if (props.modelValue) {
        showPanel();
      }
      globalEvents.on($xePulldown, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xePulldown, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xePulldown, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xePulldown, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xePulldown, 'mousewheel');
      globalEvents.off($xePulldown, 'mousedown');
      globalEvents.off($xePulldown, 'blur');
      globalEvents.off($xePulldown, 'resize');
    });
    const renderDefaultPanel = options => {
      const optionSlot = slots.option;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-list'
      }, options ? options.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-pulldown--panel-item',
          onClick(evnt) {
            handleOptionEvent(evnt, item);
          }
        }, optionSlot ? optionSlot({
          $pulldown: $xePulldown,
          option: item
        }) : `${item.label || ''}`);
      }) : []);
    };
    const renderVN = () => {
      const {
        className,
        options,
        popupClassName,
        showPopupShadow,
        destroyOnClose,
        disabled
      } = props;
      const {
        initialized,
        isActivated,
        isAniVisible,
        visiblePanel,
        panelStyle,
        panelPlacement
      } = reactData;
      const btnTransfer = computeBtnTransfer.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const dropdownSlot = slots.dropdown;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-pulldown', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $pulldown: $xePulldown
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--visible': visiblePanel,
          'is--disabled': disabled,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refPulldownContent,
        class: 'vxe-pulldown--content',
        onClick: clickTargetEvent
      }, defaultSlot ? defaultSlot({
        $pulldown: $xePulldown
      }) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refPulldownPanel,
        class: ['vxe-table--ignore-clear vxe-pulldown--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $pulldown: $xePulldown
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': isAniVisible,
          'ani--enter': visiblePanel
        }],
        placement: panelPlacement,
        style: panelStyle
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-pulldown--panel-wrapper', {
          'is--shadow': showPopupShadow
        }]
      }, initialized && (destroyOnClose ? visiblePanel || isAniVisible : true) ? [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-header'
      }, headerSlot({
        $pulldown: $xePulldown
      })) : renderEmptyElement($xePulldown), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-body'
      }, dropdownSlot ? dropdownSlot({
        $pulldown: $xePulldown
      }) : [renderDefaultPanel(options)]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-footer'
      }, footerSlot({
        $pulldown: $xePulldown
      })) : renderEmptyElement($xePulldown)] : [])])])]);
    };
    $xePulldown.renderVN = renderVN;
    return $xePulldown;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/pulldown/index.ts



const VxePulldown = Object.assign(pulldown, {
  install: function (app) {
    app.component(pulldown.name, pulldown);
  }
});
dynamicApp.use(VxePulldown);
index_esm_VxeUI.component(pulldown);
const Pulldown = VxePulldown;
/* harmony default export */ var packages_pulldown = (VxePulldown);
;// CONCATENATED MODULE: ./packages/radio/src/radio.ts





/* harmony default export */ var src_radio = (defineVxeComponent({
  name: 'VxeRadio',
  props: {
    modelValue: [String, Number, Boolean],
    checkedValue: {
      type: [String, Number, Boolean],
      default: undefined
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    name: String,
    strict: {
      type: Boolean,
      default: () => getConfig().radio.strict
    },
    size: {
      type: String,
      default: () => getConfig().radio.size || getConfig().size
    },
    /**
     * å·²åºå¼ï¼è¢« checkedValue æ¿æ¢
     */
    label: {
      type: [String, Number, Boolean],
      default: null
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const $xeRadioGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeRadioGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const $xeRadio = {
      xID,
      props,
      context,
      reactData
    };
    const {
      computeSize
    } = useSize(props);
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const {
            computeIsDisabled
          } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled.value;
        }
      }
      return disabled;
    });
    const computeName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : props.name;
    });
    const computeStrict = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        label,
        checkedValue
      } = props;
      const radioValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(checkedValue) ? label : checkedValue;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === radioValue : props.modelValue === radioValue;
    });
    const handleValue = (checkedValue, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({
          label: checkedValue,
          checkedValue
        }, evnt);
      } else {
        emit('update:modelValue', checkedValue);
        dispatchEvent('change', {
          value: checkedValue,
          label: checkedValue,
          checkedValue
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, checkedValue);
        }
      }
    };
    const changeEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          label,
          checkedValue
        } = props;
        const radioValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(checkedValue) ? label : checkedValue;
        handleValue(radioValue, evnt);
      }
    };
    const clickEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        const {
          label,
          checkedValue
        } = props;
        const radioValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(checkedValue) ? label : checkedValue;
        if (radioValue === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $radio: $xeRadio
      }, params));
    };
    const radioMethods = {
      dispatchEvent
    };
    const radioPrivateMethods = {};
    Object.assign($xeRadio, radioMethods, radioPrivateMethods);
    const renderVN = () => {
      const {
        label,
        checkedValue
      } = props;
      const radioValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(checkedValue) ? label : checkedValue;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        key: radioValue,
        class: ['vxe-radio vxe-radio--default', {
          [`size--${vSize}`]: vSize,
          'is--checked': isChecked,
          'is--disabled': isDisabled
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-radio--input',
        type: 'radio',
        name,
        checked: isChecked,
        disabled: isDisabled,
        onChange: changeEvent,
        onClick: clickEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-radio--icon', isChecked ? getIcon().RADIO_CHECKED : isDisabled ? getIcon().RADIO_DISABLED_UNCHECKED : getIcon().RADIO_UNCHECKED]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-radio--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    $xeRadio.renderVN = renderVN;
    return $xeRadio;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/radio/index.ts



const VxeRadio = Object.assign(src_radio, {
  install: function (app) {
    app.component(src_radio.name, src_radio);
  }
});
dynamicApp.use(VxeRadio);
index_esm_VxeUI.component(src_radio);
const Radio = VxeRadio;
/* harmony default export */ var packages_radio = (VxeRadio);
;// CONCATENATED MODULE: ./packages/radio/src/button.ts





/* harmony default export */ var radio_src_button = (defineVxeComponent({
  name: 'VxeRadioButton',
  props: {
    modelValue: [String, Number, Boolean],
    checkedValue: {
      type: [String, Number, Boolean],
      default: undefined
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    strict: {
      type: Boolean,
      default: () => getConfig().radioButton.strict
    },
    size: {
      type: String,
      default: () => getConfig().radioButton.size || getConfig().size
    },
    /**
     * å·²åºå¼ï¼è¢« checkedValue æ¿æ¢
     */
    label: {
      type: [String, Number, Boolean],
      default: null
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const $xeRadioGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeRadioGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const {
      computeSize
    } = useSize(props);
    const $xeRadioButton = {
      xID,
      props,
      context,
      reactData
    };
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const {
            computeIsDisabled
          } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled.value;
        }
      }
      return disabled;
    });
    const computeName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : null;
    });
    const computeStrict = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        label,
        checkedValue
      } = props;
      const radioValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(checkedValue) ? label : checkedValue;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === radioValue : props.modelValue === radioValue;
    });
    const radioButtonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $radioButton: $xeRadioButton
        }, params));
      }
    };
    const radioButtonPrivateMethods = {};
    Object.assign($xeRadioButton, radioButtonMethods, radioButtonPrivateMethods);
    const handleValue = (checkedValue, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({
          label: checkedValue,
          checkedValue
        }, evnt);
      } else {
        emit('update:modelValue', checkedValue);
        radioButtonMethods.dispatchEvent('change', {
          value: checkedValue,
          label: checkedValue
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, checkedValue);
        }
      }
    };
    const changeEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          label,
          checkedValue
        } = props;
        const radioValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(checkedValue) ? label : checkedValue;
        handleValue(radioValue, evnt);
      }
    };
    const clickEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        const {
          label,
          checkedValue
        } = props;
        const radioValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(checkedValue) ? label : checkedValue;
        if (radioValue === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const renderVN = () => {
      const {
        label,
        checkedValue
      } = props;
      const radioValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(checkedValue) ? label : checkedValue;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        key: radioValue,
        class: ['vxe-radio vxe-radio--button', {
          [`size--${vSize}`]: vSize,
          'is--disabled': isDisabled
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-radio--input',
        type: 'radio',
        name,
        checked: isChecked,
        disabled: isDisabled,
        onChange: changeEvent,
        onClick: clickEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-radio--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    $xeRadioButton.renderVN = renderVN;
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/radio-button/index.ts



const VxeRadioButton = Object.assign(radio_src_button, {
  install: function (app) {
    app.component(radio_src_button.name, radio_src_button);
  }
});
dynamicApp.use(VxeRadioButton);
index_esm_VxeUI.component(radio_src_button);
const RadioButton = VxeRadioButton;
/* harmony default export */ var radio_button = (VxeRadioButton);
;// CONCATENATED MODULE: ./packages/radio/src/group.ts






/* harmony default export */ var radio_src_group = (defineVxeComponent({
  name: 'VxeRadioGroup',
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    type: String,
    options: Array,
    optionProps: Object,
    strict: {
      type: Boolean,
      default: () => getConfig().radioGroup.strict
    },
    size: {
      type: String,
      default: () => getConfig().radioGroup.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMaps = {
      computeIsDisabled
    };
    const $xeRadioGroup = {
      xID,
      props,
      context,
      reactData,
      name: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('xe_group_'),
      getComputeMaps: () => computeMaps
    };
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeDisabledField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || 'disabled';
    });
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $radioGroup: $xeRadioGroup
      }, params));
    };
    const radioGroupMethods = {
      dispatchEvent
    };
    const radioGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const value = params.checkedValue;
        emit('update:modelValue', value);
        dispatchEvent('change', {
          value,
          label: value,
          checkedValue: value
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    Object.assign($xeRadioGroup, radioGroupMethods, radioGroupPrivateMethods);
    const renderVN = () => {
      const {
        options,
        type
      } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      const btnComp = type === 'button' ? radio_src_button : src_radio;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-radio-group', {
          [`size--${vSize}`]: vSize
        }]
      }, defaultSlot ? defaultSlot({}) : options ? options.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(btnComp, {
          key: item[valueField],
          checkedValue: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeRadioGroup', $xeRadioGroup);
    $xeRadioGroup.renderVN = renderVN;
    return $xeRadioGroup;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/radio-group/index.ts



const VxeRadioGroup = Object.assign(radio_src_group, {
  install: function (app) {
    app.component(radio_src_group.name, radio_src_group);
  }
});
dynamicApp.use(VxeRadioGroup);
index_esm_VxeUI.component(radio_src_group);
const RadioGroup = VxeRadioGroup;
/* harmony default export */ var radio_group = (VxeRadioGroup);
;// CONCATENATED MODULE: ./packages/rate/src/rate.ts




/* harmony default export */ var rate = (defineVxeComponent({
  name: 'VxeRate',
  props: {
    modelValue: [Number, String],
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().rate.size || getConfig().size
    },
    status: String
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      activeValue: null
    });
    const refMaps = {
      refElem
    };
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return readonly;
    });
    const computeNumVal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue
      } = props;
      const {
        activeValue
      } = reactData;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(activeValue === null ? modelValue : activeValue);
    });
    const computeItemList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return [1, 2, 3, 4, 5].map(num => {
        return {
          value: num,
          label: num
        };
      });
    });
    const computeMaps = {};
    const $xeRate = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $rate: $xeRate
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const mouseenterEvent = (evnt, item) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const value = item.value;
        reactData.activeValue = value;
      }
    };
    const mouseleaveEvent = () => {
      reactData.activeValue = null;
    };
    const clickEvent = (evnt, item) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const value = item.value;
        emitModel(value);
        dispatchEvent('change', {
          value
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    Object.assign($xeRate, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const {
        status
      } = props;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const itemList = computeItemList.value;
      const vSize = computeSize.value;
      const numVal = computeNumVal.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-rate', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--disabled': isDisabled,
          'is--readonly': isReadonly
        }]
      }, itemList.map(item => {
        const isChecked = numVal >= item.value;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-rte--item', {
            'is--checked': isChecked
          }],
          onMouseenter(evnt) {
            if (!(isDisabled || isReadonly)) {
              mouseenterEvent(evnt, item);
            }
          },
          onMouseleave: mouseleaveEvent,
          onClick(evnt) {
            if (!(isDisabled || isReadonly)) {
              clickEvent(evnt, item);
            }
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: isChecked ? getIcon().RATE_CHECKED : getIcon().RATE_UNCHECKED
        })]);
      }));
    };
    $xeRate.renderVN = renderVN;
    return $xeRate;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/rate/index.ts



const VxeRate = Object.assign({}, rate, {
  install(app) {
    app.component(rate.name, rate);
  }
});
dynamicApp.use(VxeRate);
index_esm_VxeUI.component(rate);
const Rate = VxeRate;
/* harmony default export */ var packages_rate = (VxeRate);
;// CONCATENATED MODULE: ./packages/result/src/result.ts




/* harmony default export */ var result = (defineVxeComponent({
  name: 'VxeResult',
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    type: [String, Number],
    status: [String, Number],
    title: [String, Number],
    content: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeResult = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $result: $xeResult
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeResult, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const {
        imageUrl,
        imageStyle,
        icon,
        title,
        type,
        content
      } = props;
      const status = props.status || type;
      const slotExtra = slots.extra;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: 'refElem',
        class: ['vxe-result', {
          [`theme--${status}`]: status
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-result--inner'
      }, [imageUrl ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-result--img-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
        src: imageUrl,
        style: imageStyle
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-result--icon-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: [icon, type ? getIcon()[`RESULT_${type}`.toLocaleUpperCase()] : '']
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-result--title-wrapper'
      }, `${title || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-result--content-wrapper'
      }, `${content || ''}`), slotExtra ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-result--extra-wrapper'
      }, slotExtra({})) : renderEmptyElement($xeResult)])]);
    };
    $xeResult.renderVN = renderVN;
    return $xeResult;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/result/index.ts



const VxeResult = Object.assign({}, result, {
  install(app) {
    app.component(result.name, result);
  }
});
dynamicApp.use(VxeResult);
index_esm_VxeUI.component(result);
const Result = VxeResult;
/* harmony default export */ var packages_result = (VxeResult);
;// CONCATENATED MODULE: ./packages/row/src/row.ts





/* harmony default export */ var row = (defineVxeComponent({
  name: 'VxeRow',
  props: {
    gutter: [Number, String, Array],
    wrap: {
      type: Boolean,
      default: () => getConfig().row.wrap
    },
    vertical: Boolean,
    size: {
      type: String,
      default: () => getConfig().row.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeRowStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        gutter,
        vertical
      } = props;
      const style = {};
      if (gutter) {
        let [lrGutter, tbGutter] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(gutter) ? gutter : [gutter];
        if (vertical) {
          tbGutter = lrGutter;
          lrGutter = '';
        }
        if (lrGutter) {
          const offsetSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(lrGutter) ? toCssUnit(-(lrGutter / 2)) : `calc(${toCssUnit(lrGutter)} / 2 * -1)`;
          style.marginLeft = offsetSize;
          style.marginRight = offsetSize;
        }
        if (tbGutter) {
          const offsetSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(tbGutter) ? toCssUnit(-(tbGutter / 2)) : `calc(${toCssUnit(tbGutter)} / 2 * -1)`;
          style.marginTop = offsetSize;
          style.marginBottom = offsetSize;
        }
      }
      return style;
    });
    const computeMaps = {};
    const $xeRow = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = evnt => {
      dispatchEvent('click', {}, evnt);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $row: $xeRow
      }, params));
    };
    const rowMethods = {
      dispatchEvent
    };
    const rowPrivateMethods = {};
    Object.assign($xeRow, rowMethods, rowPrivateMethods);
    const renderVN = () => {
      const {
        vertical,
        wrap
      } = props;
      const rowStyle = computeRowStyle.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-row', {
          'is--vertical': vertical,
          'is--wrap': wrap
        }],
        style: rowStyle,
        onClick: clickEvent
      }, defaultSlot ? defaultSlot({}) : []);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeRow', $xeRow);
    $xeRow.renderVN = renderVN;
    return $xeRow;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/row/index.ts



const VxeRow = Object.assign({}, row, {
  install(app) {
    app.component(row.name, row);
  }
});
dynamicApp.use(VxeRow);
index_esm_VxeUI.component(row);
const Row = VxeRow;
/* harmony default export */ var packages_row = (VxeRow);
;// CONCATENATED MODULE: ./packages/select/index.ts



const VxeSelect = Object.assign(src_select, {
  install: function (app) {
    app.component(src_select.name, src_select);
  }
});
dynamicApp.use(VxeSelect);
index_esm_VxeUI.component(src_select);
const Select = VxeSelect;
/* harmony default export */ var packages_select = (VxeSelect);
;// CONCATENATED MODULE: ./packages/splitter/src/splitter.ts









/* harmony default export */ var splitter = (defineVxeComponent({
  name: 'VxeSplitter',
  props: {
    width: [Number, String],
    height: [Number, String],
    vertical: {
      type: Boolean,
      default: () => getConfig().splitter.vertical
    },
    border: {
      type: Boolean,
      default: () => getConfig().splitter.border
    },
    padding: {
      type: Boolean,
      default: () => getConfig().splitter.padding
    },
    resize: {
      type: Boolean,
      default: () => getConfig().splitter.resize
    },
    items: Array,
    itemConfig: Object,
    barConfig: Object,
    resizeConfig: Object,
    actionConfig: Object,
    size: {
      type: String,
      default: () => getConfig().splitter.size || getConfig().size
    }
  },
  emits: ['action-dblclick', 'action-click', 'toggle-expand', 'resize-start', 'resize-drag', 'resize-end'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBarInfoElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refResizableSplitterTip = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      staticItems: [],
      itemList: [],
      barWidth: 0,
      barHeight: 0
    });
    const internalData = {
      wrapperWidth: 0,
      wrapperHeight: 0
    };
    const computeItemOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().splitter.itemConfig, props.itemConfig);
    });
    const computeBarOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().splitter.barConfig, props.barConfig);
    });
    const computeResizeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().splitter.resizeConfig, props.resizeConfig);
    });
    const computeActionOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().splitter.actionConfig, props.actionConfig);
    });
    const computeVisibleItems = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return reactData.itemList.filter(item => item.isExpand);
    });
    const computeAutoItems = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        vertical
      } = props;
      const autoItems = [];
      let heightCount = 0;
      let widthCount = 0;
      reactData.itemList.forEach(vertical ? item => {
        const {
          renderHeight,
          resizeHeight,
          foldHeight,
          isExpand,
          height
        } = item;
        const itemHeight = isExpand ? foldHeight || resizeHeight || renderHeight : 0;
        if (!height) {
          autoItems.push(item);
        }
        heightCount += itemHeight;
      } : item => {
        const {
          renderWidth,
          resizeWidth,
          foldWidth,
          isExpand,
          width
        } = item;
        const itemWidth = isExpand ? foldWidth || resizeWidth || renderWidth : 0;
        if (!width) {
          autoItems.push(item);
        }
        widthCount += itemWidth;
      });
      return {
        autoItems,
        heightCount,
        heightRatio: heightCount / 100,
        widthCount,
        widthRatio: widthCount / 100
      };
    });
    const computeBarStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const barOpts = computeBarOpts.value;
      const {
        width,
        height
      } = barOpts;
      const stys = {};
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (width) {
        stys.width = toCssUnit(width);
      }
      return stys;
    });
    const computeMaps = {
      computeItemOpts,
      computeBarOpts,
      computeActionOpts
    };
    const refMaps = {
      refElem
    };
    const $xeSplitter = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $splitter: $xeSplitter
      }, params));
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const getActionIcon = (prevItem, nextItem, isNext) => {
      const {
        vertical
      } = props;
      const topIcon = 'SPLIT_TOP_ACTION';
      const bottomIcon = 'SPLIT_BOTTOM_ACTION';
      const leftIcon = 'SPLIT_LEFT_ACTION';
      const rightIcon = 'SPLIT_RIGHT_ACTION';
      let iconName = '';
      if (vertical) {
        if (isNext) {
          iconName = nextItem.isExpand ? bottomIcon : topIcon;
        } else {
          iconName = prevItem.isExpand ? topIcon : bottomIcon;
        }
      } else {
        if (isNext) {
          iconName = nextItem.isExpand ? rightIcon : leftIcon;
        } else {
          iconName = prevItem.isExpand ? leftIcon : rightIcon;
        }
      }
      if (iconName) {
        return getIcon()[iconName];
      }
      return '';
    };
    const reset = () => {
      const {
        itemList
      } = reactData;
      itemList.forEach(item => {
        item.isExpand = true;
        item.foldHeight = 0;
        item.foldWidth = 0;
        item.resizeHeight = 0;
        item.resizeWidth = 0;
      });
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleLoadItem = (list, isReset) => {
      const {
        staticItems
      } = reactData;
      const actionOpts = computeActionOpts.value;
      const {
        showPrevButton,
        showNextButton
      } = actionOpts;
      const itemDef = {
        isExpand: true,
        renderWidth: 0,
        resizeWidth: 0,
        foldWidth: 0,
        renderHeight: 0,
        resizeHeight: 0,
        foldHeight: 0
      };
      reactData.itemList = list.map(item => {
        if (item.showAction) {
          warnLog('vxe.error.removeProp', ['[splitter] show-action']);
        }
        if (item.slots) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(item.slots, func => {
            if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
              if (!slots[func]) {
                errLog('vxe.error.notSlot', [`[splitter] ${func}`]);
              }
            }
          });
        }
        return Object.assign({}, isReset ? null : itemDef, item, isReset ? itemDef : null, {
          id: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId()
        });
      });
      if (staticItems.length) {
        errLog('vxe.error.errConflicts', ['<vxe-splitter-panel ...>', 'items']);
      }
      if ((showPrevButton || showNextButton) && reactData.itemList.length > 2) {
        errLog('vxe.error.errConflicts', ['action-config.showPrevButton | action-config.showNextButton', 'Only supports 2 item']);
      }
      return recalculate();
    };
    const loadItem = list => {
      return handleLoadItem(list || [], false);
    };
    const reloadItem = list => {
      return handleLoadItem(list || [], true);
    };
    const handleItemByName = name => {
      const {
        itemList
      } = reactData;
      let index = -1;
      let currItem = null;
      let prevItem = null;
      let nextItem = null;
      for (let i = 0; i < itemList.length; i++) {
        const item = itemList[i];
        if (item.name === name) {
          index = i;
          currItem = item;
          prevItem = itemList[i - 1] || null;
          nextItem = itemList[i + 1] || null;
          break;
        }
      }
      return {
        index,
        currItem,
        prevItem,
        nextItem
      };
    };
    const setItemExpand = (name, expanded) => {
      const restItem = handleItemByName(name);
      if (restItem) {
        const {
          currItem,
          prevItem,
          nextItem
        } = restItem;
        if (currItem) {
          if (expanded ? !currItem.isExpand : currItem.isExpand) {
            if (nextItem) {
              if (nextItem.isExpand) {
                handleItemActionEvent(null, currItem, nextItem, false);
              }
            } else if (prevItem) {
              if (prevItem.isExpand) {
                handleItemActionEvent(null, prevItem, currItem, true);
              }
            }
          }
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const toggleItemExpand = name => {
      const restItem = handleItemByName(name);
      if (restItem) {
        const {
          currItem
        } = restItem;
        if (currItem) {
          return setItemExpand(name, !currItem.isExpand);
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const getItemExpand = name => {
      const restItem = handleItemByName(name);
      if (restItem) {
        const {
          currItem
        } = restItem;
        if (currItem) {
          return currItem.isExpand;
        }
      }
      return false;
    };
    const recalculate = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          vertical
        } = props;
        const {
          itemList
        } = reactData;
        const el = refElem.value;
        const barInfoElem = refBarInfoElem.value;
        if (!el) {
          return;
        }
        const wWidth = el.clientWidth;
        const wHeight = el.clientHeight;
        if (!wWidth || !wHeight) {
          return;
        }
        if (barInfoElem) {
          reactData.barWidth = barInfoElem.offsetWidth;
          reactData.barHeight = barInfoElem.offsetHeight;
        }
        const contentWidth = wWidth - (vertical ? 0 : reactData.barWidth * (itemList.length - 1));
        const contentHeight = wHeight - (vertical ? reactData.barHeight * (itemList.length - 1) : 0);
        const itemOpts = computeItemOpts.value;
        const allMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(itemOpts.minWidth);
        const allMinHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(itemOpts.minHeight);
        const residueItems = [];
        if (vertical) {
          let countHeight = 0;
          itemList.forEach(item => {
            const {
              height
            } = item;
            let itemHeight = 0;
            if (height) {
              if (isScale(height)) {
                itemHeight = contentHeight * external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(height) / 100;
              } else {
                itemHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(height);
              }
              item.renderHeight = itemHeight;
            } else {
              residueItems.push(item);
            }
            countHeight += itemHeight;
          });
          if (residueItems.length) {
            const reMeanHeight = (contentHeight - countHeight) / residueItems.length;
            residueItems.forEach(item => {
              item.renderHeight = Math.max(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getGlobalDefaultConfig(item.minHeight, allMinHeight)), reMeanHeight);
            });
          }
        } else {
          let countWidth = 0;
          itemList.forEach(item => {
            const {
              width
            } = item;
            let itemWidth = 0;
            if (width) {
              if (isScale(width)) {
                itemWidth = contentWidth * external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(width) / 100;
              } else {
                itemWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(width);
              }
              item.renderWidth = itemWidth;
            } else {
              residueItems.push(item);
            }
            countWidth += itemWidth;
          });
          if (residueItems.length) {
            const reMeanWidth = (contentWidth - countWidth) / residueItems.length;
            residueItems.forEach(item => {
              item.renderWidth = Math.max(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getGlobalDefaultConfig(item.minWidth, allMinWidth)), reMeanWidth);
            });
          }
        }
        internalData.wrapperWidth = contentWidth;
        internalData.wrapperHeight = contentHeight;
      });
    };
    const dragEvent = evnt => {
      const {
        resize,
        vertical
      } = props;
      const {
        itemList
      } = reactData;
      if (!resize) {
        return;
      }
      evnt.preventDefault();
      const barEl = evnt.currentTarget;
      const handleEl = barEl.parentElement;
      const el = refElem.value;
      if (!el) {
        return;
      }
      const prevEl = handleEl.previousElementSibling;
      const nextEl = handleEl.nextElementSibling;
      if (!prevEl || !nextEl) {
        return;
      }
      const prevId = prevEl.getAttribute('itemid');
      const nextId = nextEl.getAttribute('itemid');
      const prevItem = itemList.find(item => item.id === prevId);
      const nextItem = itemList.find(item => item.id === nextId);
      if (!prevItem || !nextItem) {
        return;
      }
      const containerRect = el.getBoundingClientRect();
      const barRect = barEl.getBoundingClientRect();
      const rsSplitterLineEl = refResizableSplitterTip.value;
      const rsSplitterTipEl = rsSplitterLineEl ? rsSplitterLineEl.children[0] : null;
      const itemOpts = computeItemOpts.value;
      const resizeOpts = computeResizeOpts.value;
      const {
        immediate
      } = resizeOpts;
      const allMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(itemOpts.minWidth);
      const allMinHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(itemOpts.minHeight);
      const barOffsetX = Math.ceil(barRect.width - (evnt.clientX - barRect.left));
      const barOffsetY = Math.ceil(evnt.clientY - barRect.top);
      const prevWidth = prevEl.offsetWidth;
      const nextWidth = nextEl.offsetWidth;
      const prevMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(prevItem ? getGlobalDefaultConfig(prevItem.minWidth, allMinWidth) : allMinWidth);
      const nextMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(nextItem ? getGlobalDefaultConfig(nextItem.minWidth, allMinWidth) : allMinWidth);
      const minOffsetLeft = prevEl.offsetLeft + prevMinWidth - barOffsetX;
      const maxOffsetLeft = nextEl.offsetLeft + nextEl.offsetWidth - nextMinWidth - barOffsetX;
      const startOffsetLeft = evnt.clientX - containerRect.left;
      let targetOffsetWidth = -1;
      let prevResizeWidth = 0;
      let nextResizeWidth = 0;
      let offsetLeft = startOffsetLeft;
      const prevHeight = prevEl.offsetHeight;
      const nextHeight = nextEl.offsetHeight;
      const prevMinHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(prevItem ? getGlobalDefaultConfig(prevItem.minHeight, allMinHeight) : allMinHeight);
      const nextMinHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(nextItem ? getGlobalDefaultConfig(nextItem.minHeight, allMinHeight) : allMinHeight);
      const minOffsetTop = prevEl.offsetTop + prevMinHeight + barOffsetY;
      const maxOffsetTop = nextEl.offsetTop + nextEl.offsetHeight - nextMinHeight + barOffsetY;
      const startOffsetTop = evnt.clientY - containerRect.top;
      let targetOffsetHeight = -1;
      let prevResizeHeight = 0;
      let nextResizeHeight = 0;
      let offsetTop = startOffsetTop;
      const handleReStyle = evnt => {
        if (!rsSplitterLineEl) {
          return;
        }
        const rsNumPrevEl = rsSplitterTipEl ? rsSplitterTipEl.children[0] : null;
        const rsNumNextEl = rsSplitterTipEl ? rsSplitterTipEl.children[1] : null;
        if (vertical) {
          let tipWidth = 0;
          if (rsNumPrevEl) {
            if (targetOffsetHeight < 0) {
              rsNumPrevEl.style.display = 'none';
            } else {
              rsNumPrevEl.textContent = `${Math.floor(prevResizeHeight)}px`;
              rsNumPrevEl.style.display = 'block';
              tipWidth = rsNumPrevEl.offsetWidth;
            }
          }
          if (rsNumNextEl) {
            if (targetOffsetHeight < 0) {
              rsNumNextEl.textContent = `${Math.floor(nextResizeHeight)}px`;
              rsNumNextEl.style.display = 'block';
              tipWidth = rsNumNextEl.offsetWidth;
            } else {
              rsNumNextEl.style.display = 'none';
            }
          }
          let rsLeft = Math.max(1, evnt.clientX - containerRect.left - tipWidth / 2);
          if (rsLeft > containerRect.width - tipWidth - 1) {
            rsLeft = containerRect.width - tipWidth - 1;
          }
          rsSplitterLineEl.style.left = '0';
          rsSplitterLineEl.style.top = `${offsetTop}px`;
          if (rsSplitterTipEl) {
            rsSplitterTipEl.style.left = `${rsLeft}px`;
          }
        } else {
          let tipHeight = 0;
          if (rsNumPrevEl) {
            if (targetOffsetWidth < 0) {
              rsNumPrevEl.style.display = 'none';
            } else {
              rsNumPrevEl.textContent = `${Math.floor(prevResizeWidth)}px`;
              rsNumPrevEl.style.display = 'block';
              tipHeight = rsNumPrevEl.offsetHeight;
            }
          }
          if (rsNumNextEl) {
            if (targetOffsetWidth < 0) {
              rsNumNextEl.textContent = `${Math.floor(nextResizeWidth)}px`;
              rsNumNextEl.style.display = 'block';
              tipHeight = rsNumNextEl.offsetHeight;
            } else {
              rsNumNextEl.style.display = 'none';
            }
          }
          let rsTop = Math.max(1, evnt.clientY - containerRect.top - tipHeight / 2);
          if (rsTop > containerRect.height - tipHeight - 1) {
            rsTop = containerRect.height - tipHeight - 1;
          }
          rsSplitterLineEl.style.top = '0';
          rsSplitterLineEl.style.left = `${offsetLeft}px`;
          if (rsSplitterTipEl) {
            rsSplitterTipEl.style.top = `${rsTop}px`;
          }
        }
      };
      const handleUpdate = () => {
        if (vertical) {
          prevItem.resizeHeight = prevResizeHeight;
          nextItem.resizeHeight = nextResizeHeight;
        } else {
          prevItem.resizeWidth = prevResizeWidth;
          nextItem.resizeWidth = nextResizeWidth;
        }
      };
      const handleDrag = evnt => {
        if (vertical) {
          offsetTop = evnt.clientY - containerRect.top;
          if (offsetTop < minOffsetTop) {
            offsetTop = minOffsetTop;
          }
          if (offsetTop > maxOffsetTop) {
            offsetTop = maxOffsetTop;
          }
          targetOffsetHeight = offsetTop - startOffsetTop;
          prevResizeHeight = prevHeight + targetOffsetHeight;
          nextResizeHeight = nextHeight - targetOffsetHeight;
        } else {
          offsetLeft = evnt.clientX - containerRect.left;
          if (offsetLeft < minOffsetLeft) {
            offsetLeft = minOffsetLeft;
          }
          if (offsetLeft > maxOffsetLeft) {
            offsetLeft = maxOffsetLeft;
          }
          targetOffsetWidth = offsetLeft - startOffsetLeft;
          prevResizeWidth = prevWidth + targetOffsetWidth;
          nextResizeWidth = nextWidth - targetOffsetWidth;
        }
        if (immediate) {
          if (vertical) {
            prevEl.style.height = toCssUnit(prevResizeHeight);
            nextEl.style.height = toCssUnit(nextResizeHeight);
          } else {
            prevEl.style.width = toCssUnit(prevResizeWidth);
            nextEl.style.width = toCssUnit(nextResizeWidth);
          }
        }
        if (rsSplitterLineEl) {
          handleReStyle(evnt);
        }
        dispatchEvent('resize-drag', {
          prevItem,
          nextItem,
          offsetHeight: targetOffsetHeight,
          offsetWidth: targetOffsetWidth
        }, evnt);
      };
      document.onmousemove = evnt => {
        evnt.preventDefault();
        handleDrag(evnt);
      };
      document.onmouseup = evnt => {
        document.onmousemove = null;
        document.onmouseup = null;
        if (rsSplitterLineEl) {
          rsSplitterLineEl.style.display = '';
        }
        handleUpdate();
        removeClass(el, 'is--drag');
        dispatchEvent('resize-end', {
          prevItem,
          nextItem,
          offsetHeight: targetOffsetHeight,
          offsetWidth: targetOffsetWidth
        }, evnt);
        recalculate();
      };
      if (rsSplitterLineEl) {
        rsSplitterLineEl.style.display = 'block';
        handleReStyle(evnt);
      }
      handleDrag(evnt);
      addClass(el, 'is--drag');
      dispatchEvent('resize-start', {
        prevItem,
        nextItem
      }, evnt);
    };
    const handleItemActionEvent = (evnt, prevItem, nextItem, isNext) => {
      const {
        vertical
      } = props;
      let expanded = false;
      let item = prevItem;
      if (isNext) {
        item = nextItem;
        expanded = !nextItem.isExpand;
        nextItem.isExpand = expanded;
      } else {
        expanded = !prevItem.isExpand;
        prevItem.isExpand = expanded;
      }
      if (vertical) {
        if (prevItem.isExpand && nextItem.isExpand) {
          prevItem.foldHeight = 0;
          nextItem.foldHeight = 0;
        } else if (prevItem.isExpand) {
          nextItem.foldHeight = 0;
          prevItem.foldHeight = (prevItem.resizeHeight || prevItem.renderHeight) + (nextItem.resizeHeight || nextItem.renderHeight);
        } else {
          prevItem.foldHeight = 0;
          nextItem.foldHeight = (prevItem.resizeHeight || prevItem.renderHeight) + (nextItem.resizeHeight || nextItem.renderHeight);
        }
      } else {
        if (prevItem.isExpand && nextItem.isExpand) {
          prevItem.foldWidth = 0;
          nextItem.foldWidth = 0;
        } else if (prevItem.isExpand) {
          nextItem.foldWidth = 0;
          prevItem.foldWidth = (prevItem.resizeWidth || prevItem.renderWidth) + (nextItem.resizeWidth || nextItem.renderWidth);
        } else {
          prevItem.foldWidth = 0;
          nextItem.foldWidth = (prevItem.resizeWidth || prevItem.renderWidth) + (nextItem.resizeWidth || nextItem.renderWidth);
        }
      }
      if (evnt) {
        dispatchEvent('toggle-expand', {
          prevItem,
          nextItem,
          expanded,
          item
        }, evnt);
      }
      recalculate();
    };
    const handlePrevActionDblclickEvent = evnt => {
      const {
        itemList
      } = reactData;
      const actionOpts = computeActionOpts.value;
      const btnEl = evnt.currentTarget;
      const btnWrapperEl = btnEl.parentElement;
      const handleEl = btnWrapperEl.parentElement;
      const prevEl = handleEl.previousElementSibling;
      const prevId = prevEl.getAttribute('itemid');
      const prevItem = itemList.find(item => item.id === prevId);
      const nextEl = handleEl.nextElementSibling;
      const nextId = nextEl.getAttribute('itemid');
      const nextItem = itemList.find(item => item.id === nextId);
      if (actionOpts.trigger === 'dblclick') {
        if (prevItem && nextItem && nextItem.isExpand) {
          handleItemActionEvent(evnt, prevItem, nextItem, false);
        }
      }
      dispatchEvent('action-dblclick', {
        prevItem,
        nextItem
      }, evnt);
    };
    const handlePrevActionClickEvent = evnt => {
      const {
        itemList
      } = reactData;
      const actionOpts = computeActionOpts.value;
      const btnEl = evnt.currentTarget;
      const btnWrapperEl = btnEl.parentElement;
      const handleEl = btnWrapperEl.parentElement;
      const prevEl = handleEl.previousElementSibling;
      const prevId = prevEl.getAttribute('itemid');
      const prevItem = itemList.find(item => item.id === prevId);
      const nextEl = handleEl.nextElementSibling;
      const nextId = nextEl.getAttribute('itemid');
      const nextItem = itemList.find(item => item.id === nextId);
      if (actionOpts.trigger !== 'dblclick') {
        if (prevItem && nextItem && nextItem.isExpand) {
          handleItemActionEvent(evnt, prevItem, nextItem, false);
        }
      }
      dispatchEvent('action-click', {
        prevItem,
        nextItem
      }, evnt);
    };
    const handleNextActionDblclickEvent = evnt => {
      const {
        itemList
      } = reactData;
      const actionOpts = computeActionOpts.value;
      const btnEl = evnt.currentTarget;
      const btnWrapperEl = btnEl.parentElement;
      const handleEl = btnWrapperEl.parentElement;
      const prevEl = handleEl.previousElementSibling;
      const prevId = prevEl.getAttribute('itemid');
      const prevItem = itemList.find(item => item.id === prevId);
      const nextEl = handleEl.nextElementSibling;
      const nextId = nextEl.getAttribute('itemid');
      const nextItem = itemList.find(item => item.id === nextId);
      if (actionOpts.trigger === 'dblclick') {
        if (prevItem && nextItem && prevItem.isExpand) {
          handleItemActionEvent(evnt, prevItem, nextItem, true);
        }
      }
      dispatchEvent('action-dblclick', {
        prevItem,
        nextItem
      }, evnt);
    };
    const handleNextActionClickEvent = evnt => {
      const {
        itemList
      } = reactData;
      const actionOpts = computeActionOpts.value;
      const btnEl = evnt.currentTarget;
      const btnWrapperEl = btnEl.parentElement;
      const handleEl = btnWrapperEl.parentElement;
      const prevEl = handleEl.previousElementSibling;
      const prevId = prevEl.getAttribute('itemid');
      const prevItem = itemList.find(item => item.id === prevId);
      const nextEl = handleEl.nextElementSibling;
      const nextId = nextEl.getAttribute('itemid');
      const nextItem = itemList.find(item => item.id === nextId);
      if (actionOpts.trigger !== 'dblclick') {
        if (prevItem && nextItem && prevItem.isExpand) {
          handleItemActionEvent(evnt, prevItem, nextItem, true);
        }
      }
      dispatchEvent('action-click', {
        prevItem,
        nextItem
      }, evnt);
    };
    const handleGlobalResizeEvent = () => {
      recalculate();
    };
    const splitterMethods = {
      dispatchEvent,
      setItemExpand,
      toggleItemExpand,
      getItemExpand,
      recalculate,
      reset,
      loadItem,
      reloadItem
    };
    const splitterPrivateMethods = {};
    Object.assign($xeSplitter, splitterMethods, splitterPrivateMethods);
    const renderHandleBar = (prevItem, nextItem) => {
      const {
        border,
        resize,
        vertical
      } = props;
      const {
        itemList
      } = reactData;
      const barStyle = computeBarStyle.value;
      const actionOpts = computeActionOpts.value;
      const {
        direction
      } = actionOpts;
      const showPrevButton = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(actionOpts.showPrevButton) ? actionOpts.showPrevButton : itemList.some(item => item.showAction);
      const showNextButton = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(actionOpts.showNextButton) ? actionOpts.showNextButton : direction === 'next' && itemList.some(item => item.showAction);
      const resizeOpts = computeResizeOpts.value;
      const {
        immediate
      } = resizeOpts;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-splitter-panel-handle', vertical ? 'is--vertical' : 'is--horizontal', immediate ? 'is-resize--immediate' : 'is-resize--lazy', {
          'is--resize': resize,
          'is--border': border
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-splitter-panel-handle-bar',
        style: barStyle,
        onMousedown: dragEvent
      }), itemList.length === 2 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-splitter-panel-action-btn-wrapper'
      }, [showPrevButton && nextItem.isExpand ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-splitter-panel-action-btn',
        onDblclick: handlePrevActionDblclickEvent,
        onClick: handlePrevActionClickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getActionIcon(prevItem, nextItem, false)
      })]) : renderEmptyElement($xeSplitter), showNextButton && prevItem.isExpand ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-splitter-panel-action-btn',
        onDblclick: handleNextActionDblclickEvent,
        onClick: handleNextActionClickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getActionIcon(prevItem, nextItem, true)
      })]) : renderEmptyElement($xeSplitter)]) : renderEmptyElement($xeSplitter)]);
    };
    const renderItems = () => {
      const {
        border,
        padding,
        resize,
        vertical
      } = props;
      const {
        itemList
      } = reactData;
      const vSize = computeSize.value;
      const resizeOpts = computeResizeOpts.value;
      const {
        immediate
      } = resizeOpts;
      const visibleItems = computeVisibleItems.value;
      const {
        autoItems
      } = computeAutoItems.value;
      const itemVNs = [];
      itemList.forEach((prevItem, index) => {
        const {
          id,
          name,
          slots,
          renderHeight,
          resizeHeight,
          foldHeight,
          renderWidth,
          resizeWidth,
          foldWidth,
          isExpand
        } = prevItem;
        const nextItem = itemList[index + 1];
        const defaultSlot = slots ? slots.default : null;
        const stys = {};
        let itemWidth = isExpand ? foldWidth || resizeWidth || renderWidth : 0;
        let itemHeight = isExpand ? foldHeight || resizeHeight || renderHeight : 0;
        // è³å°å­å¨ä¸ä¸ªèªéåº
        if (autoItems.length === 1) {
          if (vertical) {
            if (!prevItem.height) {
              itemHeight = 0;
            }
          } else {
            if (!prevItem.width) {
              itemWidth = 0;
            }
          }
        }
        let isFill = true;
        if (vertical) {
          if (itemHeight && visibleItems.length > 1) {
            isFill = false;
            stys.height = toCssUnit(itemHeight);
          }
        } else {
          if (itemWidth && visibleItems.length > 1) {
            isFill = false;
            stys.width = toCssUnit(itemWidth);
          }
        }
        itemVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          itemid: id,
          class: ['vxe-splitter-panel', vertical ? 'is--vertical' : 'is--horizontal', immediate ? 'is-resize--immediate' : 'is-resize--lazy', {
            [`size--${vSize}`]: vSize,
            'is--resize': resize,
            'is--padding': padding,
            'is--border': border,
            'is--height': itemHeight,
            'is--width': itemWidth,
            'is--visible': isExpand,
            'is--hidden': !isExpand,
            'is--fill': isExpand && isFill
          }],
          style: stys
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          itemid: id,
          class: 'vxe-splitter-panel--wrapper'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-splitter-panel--inner'
        }, defaultSlot ? callSlot(defaultSlot, {
          name,
          isExpand
        }) : [])])]));
        if (nextItem) {
          itemVNs.push(renderHandleBar(prevItem, nextItem));
        }
      });
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-splitter-wrapper'
      }, itemVNs);
    };
    const renderVN = () => {
      const {
        vertical,
        width,
        height
      } = props;
      const vSize = computeSize.value;
      const resizeOpts = computeResizeOpts.value;
      const {
        immediate,
        showTip
      } = resizeOpts;
      const defaultSlot = slots.default;
      const stys = {};
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (width) {
        stys.width = toCssUnit(width);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-splitter', vertical ? 'is--vertical' : 'is--horizontal', immediate ? 'is-resize--immediate' : 'is-resize--lazy', {
          [`size--${vSize}`]: vSize
        }],
        style: stys
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-splitter-slots'
      }, defaultSlot ? defaultSlot({}) : []), renderItems(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refResizableSplitterTip,
        class: ['vxe-splitter--resizable-splitter-tip', vertical ? 'is--vertical' : 'is--horizontal', immediate ? 'is-resize--immediate' : 'is-resize--lazy']
      }, showTip ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-splitter--resizable-splitter-tip-number'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-splitter--resizable-splitter-number-prev'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-splitter--resizable-splitter-number-next'
      })])] : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-splitter--render-vars'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refBarInfoElem,
        class: 'vxe-splitter--handle-bar-info'
      })])]);
    };
    const itemFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.items, () => {
      itemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(itemFlag, () => {
      loadItem(props.items || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems, val => {
      const actionOpts = computeActionOpts.value;
      const {
        showPrevButton,
        showNextButton
      } = actionOpts;
      if (props.items && props.items.length) {
        errLog('vxe.error.errConflicts', ['<vxe-splitter-panel ...>', 'items']);
      }
      reactData.itemList = val || [];
      if ((showPrevButton || showNextButton) && reactData.itemList.length > 2) {
        errLog('vxe.error.modelConflicts', ['[splitter] action-config.showPrevButton | action-config.showNextButton', '<vxe-splitter-panel ...> Only supports 2 panel']);
      }
      reactData.itemList.forEach(item => {
        if (item.showAction) {
          warnLog('vxe.error.removeProp', ['[splitter] showAction']);
        }
      });
      recalculate();
    });
    let resizeObserver;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        recalculate();
      });
      const el = refElem.value;
      if (el) {
        resizeObserver = globalResize.create(() => {
          recalculate();
        });
        resizeObserver.observe(el);
      }
      const actionOpts = computeActionOpts.value;
      if (actionOpts.direction) {
        errLog('vxe.error.delProp', ['[splitter] action-config.direction', 'action-config.showPrevButton | action-config.showNextButton']);
      }
      globalEvents.on($xeSplitter, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeSplitter, 'resize');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onActivated)(() => {
      recalculate();
    });
    if (props.items) {
      loadItem(props.items);
    }
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeSplitter', $xeSplitter);
    $xeSplitter.renderVN = renderVN;
    return $xeSplitter;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/splitter/index.ts



const VxeSplitter = Object.assign({}, splitter, {
  install(app) {
    app.component(splitter.name, splitter);
  }
});
dynamicApp.use(VxeSplitter);
index_esm_VxeUI.component(splitter);
const Splitter = VxeSplitter;
/* harmony default export */ var packages_splitter = (VxeSplitter);
;// CONCATENATED MODULE: ./packages/splitter/src/util.ts

function assembleSplitterItem($xeSplitter, elem, paneConfig) {
  const staticItems = $xeSplitter.reactData.staticItems;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticItems.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, paneConfig);
    $xeSplitter.reactData.staticItems = staticItems.slice(0);
  }
}
function destroySplitterItem($xeSplitter, paneConfig) {
  const staticItems = $xeSplitter.reactData.staticItems;
  const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(staticItems, item => item.id === paneConfig.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  $xeSplitter.reactData.staticItems = staticItems.slice(0);
}
;// CONCATENATED MODULE: ./packages/splitter/src/splitter-panel.ts





/* harmony default export */ var splitter_panel = (defineVxeComponent({
  name: 'VxeSplitterPanel',
  props: {
    name: [Number, String],
    width: [Number, String],
    height: [Number, String],
    minWidth: {
      type: [Number, String],
      default: () => null
    },
    minHeight: {
      type: [Number, String],
      default: () => null
    },
    // å·²åºå¼
    showAction: Boolean
  },
  emits: [],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeSplitter = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeSplitter', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const paneConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      name: props.name,
      width: props.width,
      height: props.height,
      minWidth: props.minWidth,
      minHeight: props.minHeight,
      showAction: props.showAction,
      isExpand: true,
      renderWidth: 0,
      resizeWidth: 0,
      foldWidth: 0,
      renderHeight: 0,
      resizeHeight: 0,
      foldHeight: 0,
      slots: slots
    });
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const internalData = {};
    const computeMaps = {};
    const refMaps = {
      refElem
    };
    const $xeSplitterItem = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $splitterPanel: $xeSplitterItem
      }, params));
    };
    const splitterPanelMethods = {
      dispatchEvent
    };
    const splitterPanelPrivateMethods = {};
    Object.assign($xeSplitterItem, splitterPanelMethods, splitterPanelPrivateMethods);
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.name, val => {
      paneConfig.name = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.width, val => {
      paneConfig.width = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, val => {
      paneConfig.height = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.minWidth, val => {
      paneConfig.minWidth = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.minHeight, val => {
      paneConfig.minHeight = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.showAction, val => {
      paneConfig.showAction = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if ($xeSplitter && elem) {
        assembleSplitterItem($xeSplitter, elem, paneConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xeSplitter) {
        destroySplitterItem($xeSplitter, paneConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeSplitterItem', $xeSplitterItem);
    $xeSplitterItem.renderVN = renderVN;
    return $xeSplitterItem;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/splitter-panel/index.ts



const VxeSplitterPanel = Object.assign({}, splitter_panel, {
  install(app) {
    app.component(splitter_panel.name, splitter_panel);
  }
});
dynamicApp.use(VxeSplitterPanel);
index_esm_VxeUI.component(splitter_panel);
const SplitterPanel = VxeSplitterPanel;
/* harmony default export */ var packages_splitter_panel = (VxeSplitterPanel);
;// CONCATENATED MODULE: ./packages/split/index.ts



const VxeSplit = Object.assign({}, splitter, {
  install(app) {
    app.component('VxeSplit', splitter);
  }
});
dynamicApp.use(VxeSplit);
index_esm_VxeUI.component(splitter);
const Split = VxeSplit;
/* harmony default export */ var split = (VxeSplit);
;// CONCATENATED MODULE: ./packages/split-pane/index.ts



const VxeSplitPane = Object.assign({}, splitter_panel, {
  install(app) {
    app.component('VxeSplitPane', splitter_panel);
    app.component('VxeSplitItem', splitter_panel);
  }
});
dynamicApp.use(VxeSplitPane);
index_esm_VxeUI.component(splitter_panel);
const SplitPane = VxeSplitPane;
/* harmony default export */ var split_pane = (VxeSplitPane);
;// CONCATENATED MODULE: ./packages/slider/src/slider.ts




/* harmony default export */ var slider = (defineVxeComponent({
  name: 'VxeSlider',
  props: {
    modelValue: [String, Number, Array],
    vertical: Boolean,
    max: {
      type: [String, Number],
      default: () => getConfig().slider.max
    },
    min: {
      type: [String, Number],
      default: () => getConfig().slider.min
    },
    step: {
      type: [String, Number],
      default: () => getConfig().slider.step
    },
    size: {
      type: String,
      default: () => getConfig().slider.size || getConfig().size
    },
    range: {
      type: Boolean,
      default: () => getConfig().slider.range
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'change', 'track-dragstart', 'track-dragover', 'track-dragend'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBarElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTrackElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refStartBtnElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refEndBtnElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      startValue: 0,
      endValue: 0
    });
    const refMaps = {
      refElem
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMaxNum = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.max || 0);
    });
    const computeMinNum = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.min || 0);
    });
    const computeMaps = {};
    const $xeSlider = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $slider: $xeSlider
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const getStartPercent = startValue => {
      const {
        range
      } = props;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      return range ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor((startValue - minNum) / external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(maxNum - minNum) * 100) : 0;
    };
    const getEndPercent = (startValue, endValue) => {
      const {
        range
      } = props;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor((endValue - (range ? startValue : 0) - minNum) / external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(maxNum - minNum) * 100);
    };
    const updateModel = () => {
      const {
        modelValue
      } = props;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue)) {
        const [sVal, eVal] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(modelValue, true).sort();
        reactData.startValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(sVal || 0));
        reactData.endValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(eVal || 0));
      } else {
        reactData.startValue = 0;
        reactData.endValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(modelValue || 0));
      }
    };
    const updateBarStyle = () => {
      const {
        startValue,
        endValue
      } = reactData;
      const trackElem = refTrackElem.value;
      const startBtnElem = refStartBtnElem.value;
      const endBtnElem = refEndBtnElem.value;
      let startPercent = 0;
      let endPercent = 0;
      if (startValue > endValue) {
        startPercent = getStartPercent(endValue);
        endPercent = getEndPercent(endValue, startValue);
      } else {
        startPercent = getStartPercent(startValue);
        endPercent = getEndPercent(startValue, endValue);
      }
      if (trackElem) {
        trackElem.style.left = `${startPercent}%`;
        trackElem.style.width = `${endPercent}%`;
      }
      if (startBtnElem) {
        startBtnElem.style.left = `${startPercent}%`;
      }
      if (endBtnElem) {
        endBtnElem.style.left = `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(startPercent + endPercent)}%`;
      }
    };
    const changeEvent = evnt => {
      const {
        range
      } = props;
      const {
        startValue,
        endValue
      } = reactData;
      const value = range ? [startValue, endValue].sort() : endValue;
      emitModel(value);
      dispatchEvent('change', {
        value
      }, evnt);
      // èªå¨æ´æ°æ ¡éªç¶æ
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const handleMousedownEvent = (evnt, isEnd) => {
      const formReadonly = computeFormReadonly.value;
      const isDisabled = computeIsDisabled.value;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      if (!(formReadonly || isDisabled)) {
        evnt.preventDefault();
        document.onmousemove = evnt => {
          evnt.preventDefault();
          const el = refElem.value;
          const barElem = refBarElem.value;
          if (el && barElem) {
            const barRect = barElem.getBoundingClientRect();
            const trackWidth = (evnt.clientX - barRect.left) / barRect.width;
            if (isEnd) {
              reactData.endValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(Math.max(minNum, Math.min(maxNum, trackWidth * (maxNum - minNum) + minNum)));
            } else {
              reactData.startValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(Math.max(minNum, Math.min(maxNum, trackWidth * (maxNum - minNum))));
            }
            dispatchEvent('track-dragover', {
              startValue: reactData.startValue,
              endValue: reactData.endValue
            }, evnt);
          }
          updateBarStyle();
        };
        document.onmouseup = evnt => {
          document.onmousemove = null;
          document.onmouseup = null;
          dispatchEvent('track-dragend', {
            startValue: reactData.startValue,
            endValue: reactData.endValue
          }, evnt);
          changeEvent(evnt);
          updateBarStyle();
        };
        dispatchEvent('track-dragstart', {
          startValue: reactData.startValue,
          endValue: reactData.endValue
        }, evnt);
      }
    };
    const handleStartMousedownEvent = evnt => {
      const endBtnElem = refEndBtnElem.value;
      const startBtnElem = evnt.currentTarget;
      handleMousedownEvent(evnt, endBtnElem ? endBtnElem.offsetLeft < startBtnElem.offsetLeft : false);
    };
    const handleEndMousedownEvent = evnt => {
      const startBtnElem = refStartBtnElem.value;
      const endBtnElem = evnt.currentTarget;
      handleMousedownEvent(evnt, startBtnElem ? endBtnElem.offsetLeft > startBtnElem.offsetLeft : true);
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeSlider, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const {
        vertical,
        range
      } = props;
      const vSize = computeSize.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabled = computeIsDisabled.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-slider', {
          [`size--${vSize}`]: vSize,
          'is--vertical': vertical,
          'is--readonly': formReadonly,
          'is--disabled': isDisabled
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-slider--inner'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refBarElem,
        class: 'vxe-slider--bar-wrapper'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refTrackElem,
        class: 'vxe-slider--bar-track'
      }), formReadonly || !range ? renderEmptyElement($xeSlider) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refStartBtnElem,
        class: 'vxe-slider--bar-btn vxe-slider--start-btn',
        onMousedown: handleStartMousedownEvent
      }), formReadonly ? renderEmptyElement($xeSlider) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refEndBtnElem,
        class: 'vxe-slider--bar-btn vxe-slider--end-btn',
        onMousedown: handleEndMousedownEvent
      })])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      updateModel();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      updateBarStyle();
    });
    updateModel();
    $xeSlider.renderVN = renderVN;
    return $xeSlider;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/slider/index.ts



const VxeSlider = Object.assign({}, slider, {
  install(app) {
    app.component(slider.name, slider);
  }
});
dynamicApp.use(VxeSlider);
index_esm_VxeUI.component(slider);
const Slider = VxeSlider;
/* harmony default export */ var packages_slider = (VxeSlider);
;// CONCATENATED MODULE: ./packages/steps/src/steps.ts




/* harmony default export */ var steps = (defineVxeComponent({
  name: 'VxeSteps',
  props: {},
  emits: [],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeSteps = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $steps: $xeSteps
      }, params));
    };
    const stepsMethods = {
      dispatchEvent
    };
    const stepsPrivateMethods = {};
    Object.assign($xeSteps, stepsMethods, stepsPrivateMethods);
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: 'vxe-steps'
      }, []);
    };
    $xeSteps.renderVN = renderVN;
    return $xeSteps;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/steps/index.ts



const VxeSteps = Object.assign({}, steps, {
  install(app) {
    app.component(steps.name, steps);
  }
});
dynamicApp.use(VxeSteps);
index_esm_VxeUI.component(steps);
const Steps = VxeSteps;
/* harmony default export */ var packages_steps = (VxeSteps);
;// CONCATENATED MODULE: ./packages/switch/src/switch.ts





/* harmony default export */ var src_switch = (defineVxeComponent({
  name: 'VxeSwitch',
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().switch.size || getConfig().size
    },
    openLabel: String,
    closeLabel: String,
    openValue: {
      type: [String, Number, Boolean],
      default: true
    },
    closeValue: {
      type: [String, Number, Boolean],
      default: false
    },
    openIcon: String,
    closeIcon: String,
    openActiveIcon: String,
    closeActiveIcon: String
  },
  emits: ['update:modelValue', 'change', 'focus', 'blur'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isActivated: false,
      hasAnimat: false,
      offsetLeft: 0
    });
    const internalData = {};
    const $xeSwitch = {
      xID,
      props,
      context,
      reactData,
      internalData
    };
    const refButton = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    let switchMethods = {};
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return readonly;
    });
    const computeOnShowLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getFuncText(props.openLabel);
    });
    const computeOffShowLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getFuncText(props.closeLabel);
    });
    const computeIsChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.modelValue === props.openValue;
    });
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const clickEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const isChecked = computeIsChecked.value;
        clearTimeout(internalData.atTimeout);
        const value = isChecked ? props.closeValue : props.openValue;
        reactData.hasAnimat = true;
        emitModel(value);
        switchMethods.dispatchEvent('change', {
          value
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
        internalData.atTimeout = setTimeout(() => {
          reactData.hasAnimat = false;
          internalData.atTimeout = undefined;
        }, 400);
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $switch: $xeSwitch
      }, params));
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      switchMethods.dispatchEvent('focus', {
        value: props.modelValue
      }, evnt);
    };
    const blurEvent = evnt => {
      reactData.isActivated = false;
      switchMethods.dispatchEvent('blur', {
        value: props.modelValue
      }, evnt);
    };
    switchMethods = {
      dispatchEvent,
      focus() {
        const btnElem = refButton.value;
        reactData.isActivated = true;
        if (btnElem) {
          btnElem.focus();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.blur();
        }
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xeSwitch, switchMethods);
    const renderVN = () => {
      const {
        openIcon,
        closeIcon,
        openActiveIcon,
        closeActiveIcon
      } = props;
      const vSize = computeSize.value;
      const isChecked = computeIsChecked.value;
      const onShowLabel = computeOnShowLabel.value;
      const offShowLabel = computeOffShowLabel.value;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-switch', isChecked ? 'is--on' : 'is--off', {
          [`size--${vSize}`]: vSize,
          'is--disabled': isDisabled,
          'is--readonly': isReadonly,
          'is--animat': reactData.hasAnimat
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        ref: refButton,
        class: 'vxe-switch--button',
        type: 'button',
        disabled: isDisabled || isReadonly,
        onClick: clickEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-switch--label vxe-switch--label-on'
      }, [openIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-switch--label-icon', openIcon]
      }) : renderEmptyElement($xeSwitch), onShowLabel]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-switch--label vxe-switch--label-off'
      }, [closeIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-switch--label-icon', closeIcon]
      }) : renderEmptyElement($xeSwitch), offShowLabel]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-switch--icon']
      }, openActiveIcon || closeActiveIcon ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: isChecked ? openActiveIcon : closeActiveIcon
      })] : [])])]);
    };
    $xeSwitch.renderVN = renderVN;
    return $xeSwitch;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/switch/index.ts



const VxeSwitch = Object.assign(src_switch, {
  install: function (app) {
    app.component(src_switch.name, src_switch);
  }
});
dynamicApp.use(VxeSwitch);
index_esm_VxeUI.component(src_switch);
const Switch = VxeSwitch;
/* harmony default export */ var packages_switch = (VxeSwitch);
;// CONCATENATED MODULE: ./packages/tabs/src/util.ts

function assembleTabItem($xeTabs, elem, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticTabs.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, tabConfig);
    $xeTabs.reactData.staticTabs = staticTabs.slice(0);
  }
}
function destroyTabItem($xeTabs, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticTabs, item => item.id === tabConfig.id, {
    children: 'children'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeTabs.reactData.staticTabs = staticTabs.slice(0);
}
;// CONCATENATED MODULE: ./packages/tabs/src/tab-pane.ts





/* harmony default export */ var tab_pane = (defineVxeComponent({
  name: 'VxeTabPane',
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeTabs = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTabs', null);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const tabConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      titleWidth: props.titleWidth,
      titleAlign: props.titleAlign,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots: slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTabPane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tabPane: $xeTabPane
      }, params));
    };
    const tabPaneMethods = {
      dispatchEvent
    };
    const tabPanePrivateMethods = {};
    Object.assign($xeTabPane, tabPaneMethods, tabPanePrivateMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.title, val => {
      tabConfig.title = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.name, val => {
      tabConfig.name = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.icon, val => {
      tabConfig.icon = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.permissionCode, val => {
      tabConfig.permissionCode = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if ($xeTabs && elem) {
        assembleTabItem($xeTabs, elem, tabConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xeTabs) {
        destroyTabItem($xeTabs, tabConfig);
      }
    });
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      }, []);
    };
    $xeTabPane.renderVN = renderVN;
    return $xeTabPane;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tab-pane/index.ts



const VxeTabPane = Object.assign({}, tab_pane, {
  install(app) {
    app.component(tab_pane.name, tab_pane);
  }
});
dynamicApp.use(VxeTabPane);
index_esm_VxeUI.component(tab_pane);
const TabPane = VxeTabPane;
/* harmony default export */ var packages_tab_pane = (VxeTabPane);
;// CONCATENATED MODULE: ./packages/table-select/src/table-select.ts










function getRowUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('row_');
}
function table_select_createInternalData() {
  return {
    // hpTimeout: undefined,
    // vpTimeout: undefined,
    fullRowMaps: {}
  };
}
/* harmony default export */ var table_select = (defineVxeComponent({
  name: 'VxeTableSelect',
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(getConfig().tableSelect.placeholder) ? getI18n('vxe.base.pleaseSelect') : getConfig().tableSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    className: [String, Function],
    prefixIcon: String,
    placement: String,
    columns: Array,
    options: Array,
    optionProps: Object,
    lazyOptions: Array,
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().tableSelect.size || getConfig().size
    },
    popupConfig: Object,
    gridConfig: Object,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'change', 'clear', 'blur', 'focus', 'click', 'form-submit', 'form-reset', 'form-collapse', 'page-change'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const VxeTableGridComponent = index_esm_VxeUI.getComponent('vxe-grid');
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refGridWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refGrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      tableColumns: [],
      fullOptionList: [],
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = table_select_createInternalData();
    const refMaps = {
      refElem
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.optionProps || {};
    });
    const computeRowOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const gridOpts = computeGridOpts.value;
      return Object.assign({}, gridOpts.rowConfig, {
        isCurrent: true
      });
    });
    const computeRowKeyField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const rowOpts = computeRowOpts.value;
      return rowOpts.keyField || '_X_ROW_KEY';
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computePopupOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tableSelect.popupConfig, props.popupConfig);
    });
    const computeGridOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tableSelect.gridConfig, props.gridConfig, {
        data: undefined
      });
    });
    const computeSelectGridOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const gridOpts = computeGridOpts.value;
      const {
        pagerConfig,
        proxyConfig
      } = gridOpts;
      if (proxyConfig) {
        const proxyAjax = proxyConfig.ajax;
        if (proxyAjax && proxyAjax.query) {
          const newProxyConfig = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(proxyConfig, true);
          const ajaxMethods = proxyAjax.query;
          if (ajaxMethods) {
            const resConfigs = proxyConfig.response || proxyConfig.props || {};
            Object.assign(newProxyConfig.ajax, {
              query(params, ...args) {
                return Promise.resolve(ajaxMethods(params, ...args)).then(rest => {
                  let tableData = [];
                  if (pagerConfig) {
                    const resultProp = resConfigs.result;
                    tableData = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(resultProp) ? resultProp({
                      data: rest,
                      $table: null,
                      $grid: null,
                      $gantt: null
                    }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, resultProp || 'result')) || [];
                  } else {
                    const listProp = resConfigs.list;
                    tableData = (listProp ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(listProp) ? listProp({
                      data: rest,
                      $table: null,
                      $grid: null,
                      $gantt: null
                    }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, listProp) : rest) || [];
                  }
                  cacheDataMap(tableData || []);
                  return rest;
                });
              }
            });
          }
          return Object.assign({}, gridOpts, {
            proxyConfig: newProxyConfig
          });
        }
      }
      return gridOpts;
    });
    const computeSelectLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        lazyOptions
      } = props;
      const {
        fullOptionList
      } = reactData;
      const {
        fullRowMaps
      } = internalData;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      if (!fullOptionList) {
        return '';
      }
      return (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue]).map(val => {
        const cacheItem = fullRowMaps[val];
        if (cacheItem) {
          return cacheItem.item[labelField];
        }
        if (lazyOptions) {
          const lazyItem = lazyOptions.find(item => item[valueField] === val);
          if (lazyItem) {
            return lazyItem[labelField];
          }
        }
        return val;
      }).join(', ');
    });
    const computePopupWrapperStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const popupOpts = computePopupOpts.value;
      const {
        height,
        width
      } = popupOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeTableSelect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const gridEventKeys = ['form-submit', 'form-reset', 'form-collapse', 'page-change'];
    const gridEvents = {};
    gridEventKeys.forEach(name => {
      gridEvents[getOnName(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().camelCase(name))] = params => {
        dispatchEvent(name, params, params.$event);
      };
    });
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tableSelect: $xeTableSelect
      }, params));
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const tableSelectMethods = {
      dispatchEvent
    };
    const tableSelectPrivateMethods = {};
    const getRowid = option => {
      const nodeKeyField = computeRowKeyField.value;
      const rowid = option[nodeKeyField];
      return rowid ? encodeURIComponent(rowid) : '';
    };
    const getRowsByValue = modelValue => {
      const {
        fullRowMaps
      } = internalData;
      const rows = [];
      const vals = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(modelValue) ? [] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue];
      vals.forEach(val => {
        const cacheItem = fullRowMaps[val];
        if (cacheItem) {
          rows.push(cacheItem.item);
        }
      });
      return rows;
    };
    const updateModel = modelValue => {
      const {
        multiple
      } = props;
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const $grid = refGrid.value;
        if ($grid) {
          const selectList = getRowsByValue(modelValue);
          if (selectList.length) {
            if (multiple) {
              $grid.setCheckboxRow(selectList, true);
            } else {
              $grid.setRadioRow(selectList[0]);
            }
          }
        }
      });
    };
    const loadTableColumn = columns => {
      if (!columns || !columns.length) {
        return;
      }
      const {
        multiple
      } = props;
      const tableCols = [];
      let hasRadioCol = false;
      let hasCheckboxCol = false;
      columns.forEach(column => {
        if (!hasRadioCol && column.type === 'radio') {
          hasRadioCol = true;
        } else if (!hasCheckboxCol && column.type === 'checkbox') {
          hasCheckboxCol = true;
        }
        tableCols.push(column);
      });
      if (multiple) {
        if (!hasCheckboxCol) {
          tableCols.unshift({
            type: 'checkbox',
            width: 70
          });
        }
      } else {
        if (!hasRadioCol) {
          tableCols.unshift({
            type: 'radio',
            width: 70
          });
        }
      }
      reactData.tableColumns = tableCols;
    };
    const cacheDataMap = dataList => {
      const {
        options
      } = props;
      const rowKeyField = computeRowKeyField.value;
      const valueField = computeValueField.value;
      const gridOpts = computeGridOpts.value;
      const {
        treeConfig,
        pagerConfig
      } = gridOpts;
      const rowMaps = {};
      const keyMaps = {};
      if (treeConfig) {
        // x
      } else {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(dataList || options || [], (item, index, items) => {
          let rowid = getRowid(item);
          if (!rowid) {
            rowid = getRowUniqueId();
          }
          if (keyMaps[rowid]) {
            errLog('vxe.error.repeatKey', [`[table-select] ${rowKeyField}`, rowid]);
          }
          keyMaps[rowid] = true;
          const value = item[valueField];
          if (rowMaps[value]) {
            errLog('vxe.error.repeatKey', [`[table-select] ${valueField}`, value]);
          }
          rowMaps[value] = {
            item,
            index,
            items,
            parent: null,
            nodes: []
          };
        });
      }
      reactData.fullOptionList = dataList || options || [];
      internalData.fullRowMaps = pagerConfig ? Object.assign({}, internalData.fullRowMaps, rowMaps) : rowMaps;
      updateModel(props.modelValue);
    };
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refElem.value;
      const panelElem = refOptionPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const showOptionPanel = () => {
      const {
        loading
      } = props;
      const isDisabled = computeIsDisabled.value;
      if (!loading && !isDisabled) {
        if (internalData.vpTimeout) {
          clearTimeout(internalData.vpTimeout);
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        internalData.vpTimeout = setTimeout(() => {
          reactData.visiblePanel = true;
          updateModel(props.modelValue);
          internalData.vpTimeout = undefined;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      if (internalData.vpTimeout) {
        clearTimeout(internalData.vpTimeout);
      }
      if (internalData.hpTimeout) {
        clearTimeout(internalData.hpTimeout);
      }
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
        internalData.hpTimeout = undefined;
      }, 350);
    };
    const changeEvent = (evnt, selectValue, row) => {
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        dispatchEvent('change', {
          value: selectValue,
          row,
          option: row
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue, null);
      dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const focusEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent('focus', {}, evnt);
    };
    const clickEvent = evnt => {
      togglePanelEvent(evnt);
      dispatchEvent('click', {}, evnt);
    };
    const blurEvent = evnt => {
      reactData.isActivated = false;
      dispatchEvent('blur', {}, evnt);
    };
    const togglePanelEvent = params => {
      const {
        $event
      } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const radioChangeEvent = params => {
      const {
        $event,
        row
      } = params;
      const valueField = computeValueField.value;
      const value = row[valueField];
      changeEvent($event, value, row);
      hideOptionPanel();
    };
    const checkboxChangeEvent = params => {
      const {
        $grid,
        $event,
        row
      } = params;
      const valueField = computeValueField.value;
      if ($grid) {
        const checkboxRecords = $grid.getCheckboxRecords();
        const value = checkboxRecords.map(row => {
          return row[valueField];
        });
        changeEvent($event, value, row);
      }
    };
    const checkboxAllEvent = params => {
      checkboxChangeEvent(params);
    };
    Object.assign($xeTableSelect, tableSelectMethods, tableSelectPrivateMethods);
    const renderVN = () => {
      const {
        className,
        options,
        loading
      } = props;
      const {
        initialized,
        isActivated,
        isAniVisible,
        visiblePanel,
        tableColumns
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const popupOpts = computePopupOpts.value;
      const {
        className: popupClassName
      } = popupOpts;
      const selectGridOpts = computeSelectGridOpts.value;
      const rowOpts = computeRowOpts.value;
      const popupWrapperStyle = computePopupWrapperStyle.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-table-select--readonly', className]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-table-select-label'
        }, selectLabel)]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table-select', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $tableSelect: $xeTableSelect
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--loading': loading,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInput,
        clearable: props.clearable,
        placeholder: loading ? getI18n('vxe.select.loadingText') : props.placeholder,
        readonly: true,
        disabled: isDisabled,
        type: 'text',
        prefixIcon: props.prefixIcon,
        suffixIcon: loading ? getIcon().TABLE_SELECT_LOADED : visiblePanel ? getIcon().TABLE_SELECT_OPEN : getIcon().TABLE_SELECT_CLOSE,
        modelValue: loading ? '' : selectLabel,
        onClear: clearEvent,
        onClick: clickEvent,
        onFocus: focusEvent,
        onBlur: blurEvent,
        onSuffixClick: togglePanelEvent
      }, prefixSlot ? {
        prefix: () => prefixSlot({})
      } : {}), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-table-select--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $tableSelect: $xeTableSelect
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': !loading && isAniVisible,
          'ani--enter': !loading && visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, initialized ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-select--panel-wrapper'
      }, [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-select--panel-header'
      }, headerSlot({})) : renderEmptyElement($xeTableSelect), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-select--panel-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refGridWrapper,
        class: 'vxe-table-select-grid--wrapper',
        style: popupWrapperStyle
      }, [VxeTableGridComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeTableGridComponent, {
        ...selectGridOpts,
        ...gridEvents,
        class: 'vxe-table-select--grid',
        ref: refGrid,
        rowConfig: rowOpts,
        data: options,
        columns: tableColumns.length ? tableColumns : selectGridOpts.columns,
        height: '100%',
        autoResize: true,
        onRadioChange: radioChangeEvent,
        onCheckboxChange: checkboxChangeEvent,
        onCheckboxAll: checkboxAllEvent
      }, Object.assign({}, slots, {
        header: undefined,
        footer: undefined,
        prefixSlot: undefined
      })) : renderEmptyElement($xeTableSelect)])]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-select--panel-footer'
      }, footerSlot({})) : renderEmptyElement($xeTableSelect)])] : [])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      cacheDataMap();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.columns, val => {
      loadTableColumn(val);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      updateModel(val);
    });
    loadTableColumn(props.columns);
    cacheDataMap();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const {
        gridConfig
      } = props;
      if (gridConfig && gridConfig.proxyConfig) {
        if (gridConfig.proxyConfig.autoLoad !== false) {
          reactData.initialized = true;
        }
      }
      globalEvents.on($xeTableSelect, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeTableSelect, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeTableSelect, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xeTableSelect, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeTableSelect, 'mousewheel');
      globalEvents.off($xeTableSelect, 'mousedown');
      globalEvents.off($xeTableSelect, 'blur');
      globalEvents.off($xeTableSelect, 'resize');
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData, table_select_createInternalData());
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      if (!VxeTableGridComponent) {
        errLog('vxe.error.reqComp', ['[table-select] vxe-grid']);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeTableSelect', $xeTableSelect);
    $xeTableSelect.renderVN = renderVN;
    return $xeTableSelect;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/table-select/index.ts



const VxeTableSelect = Object.assign({}, table_select, {
  install(app) {
    app.component(table_select.name, table_select);
  }
});
dynamicApp.use(VxeTableSelect);
index_esm_VxeUI.component(table_select);
const TableSelect = VxeTableSelect;
/* harmony default export */ var packages_table_select = (VxeTableSelect);
;// CONCATENATED MODULE: ./packages/tabs/src/tabs.ts










const scrollbarOffsetSize = 20;
/* harmony default export */ var tabs = (defineVxeComponent({
  name: 'VxeTabs',
  props: {
    modelValue: [String, Number, Boolean],
    options: Array,
    width: [String, Number],
    height: [String, Number],
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().tabs.destroyOnClose
    },
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    type: {
      type: String,
      default: () => getConfig().tabs.type
    },
    position: {
      type: String,
      default: () => getConfig().tabs.position
    },
    showClose: Boolean,
    showBody: {
      type: Boolean,
      default: true
    },
    padding: {
      type: Boolean,
      default: () => getConfig().tabs.padding
    },
    trigger: String,
    beforeChangeMethod: Function,
    closeConfig: Object,
    refreshConfig: Object,
    size: {
      type: String,
      default: () => getConfig().tabs.size || getConfig().size
    },
    // å·²åºå¼
    beforeCloseMethod: Function
  },
  emits: ['update:modelValue', 'change', 'tab-change', 'tab-change-fail', 'tab-close', 'tab-close-fail', 'tab-click', 'tab-load'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeParentTabs = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTabs', null);
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeadWrapperElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeadPrevElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeadNextElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      staticTabs: [],
      activeName: null,
      initNames: [],
      lintLeft: 0,
      lintTop: 0,
      lintWidth: 0,
      lintHeight: 0,
      scrollbarWidth: 0,
      scrollbarHeight: 0,
      isTabOver: false,
      resizeFlag: 1,
      cacheTabMaps: {}
    });
    const internalData = {
      slTimeout: undefined
    };
    const refMaps = {
      refElem
    };
    const computeTabType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type || 'default';
    });
    const computeTabPosition = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        position
      } = props;
      return position || 'top';
    });
    const computeLrPosition = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const tabPosition = computeTabPosition.value;
      return tabPosition === 'left' || tabPosition === 'right';
    });
    const computeLineStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        lintLeft,
        lintTop,
        lintWidth,
        lintHeight
      } = reactData;
      const lrPosition = computeLrPosition.value;
      return lrPosition ? {
        top: `${lintTop}px`,
        height: `${lintHeight}px`
      } : {
        left: `${lintLeft}px`,
        width: `${lintWidth}px`
      };
    });
    const computeWrapperStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        height
      } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeCloseOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tabs.closeConfig, props.closeConfig);
    });
    const computeRefreshOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tabs.refreshConfig, props.refreshConfig);
    });
    const computeTabOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        options
      } = props;
      return (options || []).filter(item => handleFilterTab(item));
    });
    const computeTabStaticOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        staticTabs
      } = reactData;
      return staticTabs.filter(item => handleFilterTab(item));
    });
    const computeParentTabsResizeFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeParentTabs ? $xeParentTabs.reactData.resizeFlag : null;
    });
    const computeMaps = {};
    const $xeTabs = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleFilterTab = item => {
      const {
        permissionCode
      } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const checkScrolling = () => {
      const lrPosition = computeLrPosition.value;
      const headerWrapperEl = refHeadWrapperElem.value;
      const headPrevEl = refHeadPrevElem.value;
      const headNextEl = refHeadNextElem.value;
      if (headerWrapperEl) {
        const {
          scrollLeft,
          scrollTop,
          clientWidth,
          clientHeight,
          scrollWidth,
          scrollHeight
        } = headerWrapperEl;
        if (headPrevEl) {
          if ((lrPosition ? scrollTop : scrollLeft) > 0) {
            addClass(headPrevEl, 'scrolling--middle');
          } else {
            removeClass(headPrevEl, 'scrolling--middle');
          }
        }
        if (headNextEl) {
          if (lrPosition ? clientHeight < scrollHeight - Math.ceil(scrollTop) : clientWidth < scrollWidth - Math.ceil(scrollLeft)) {
            addClass(headNextEl, 'scrolling--middle');
          } else {
            removeClass(headNextEl, 'scrolling--middle');
          }
        }
      }
    };
    const updateTabStyle = () => {
      const handleStyle = () => {
        const {
          activeName
        } = reactData;
        const tabType = computeTabType.value;
        const tabOptions = computeTabOptions.value;
        const tabStaticOptions = computeTabStaticOptions.value;
        const headerWrapperEl = refHeadWrapperElem.value;
        const lrPosition = computeLrPosition.value;
        let lintWidth = 0;
        let lintHeight = 0;
        let lintLeft = 0;
        let lintTop = 0;
        let sBarWidth = 0;
        let sBarHeight = 0;
        let isOver = false;
        if (headerWrapperEl) {
          const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, item => item.name === activeName);
          const {
            children,
            offsetWidth,
            scrollWidth,
            offsetHeight,
            scrollHeight,
            clientWidth,
            clientHeight
          } = headerWrapperEl;
          sBarWidth = offsetWidth - clientWidth;
          sBarHeight = offsetHeight - clientHeight;
          if (lrPosition) {
            isOver = scrollHeight !== clientHeight;
            if (index > -1) {
              const tabEl = children[index];
              if (tabEl) {
                const tabHeight = tabEl.clientHeight;
                const tabWidth = tabEl.clientWidth;
                if (tabType === 'card') {
                  lintWidth = tabWidth;
                  lintHeight = tabHeight;
                  lintTop = tabEl.offsetTop;
                } else if (tabType === 'border-card') {
                  lintWidth = tabWidth;
                  lintHeight = tabHeight;
                  lintTop = tabEl.offsetTop - 1;
                } else {
                  lintHeight = Math.max(4, Math.floor(tabHeight * 0.6));
                  lintTop = tabEl.offsetTop + Math.floor((tabHeight - lintHeight) / 2);
                }
              }
            }
          } else {
            isOver = scrollWidth !== clientWidth;
            if (index > -1) {
              const tabEl = children[index];
              if (tabEl) {
                const tabWidth = tabEl.clientWidth;
                if (tabType === 'card') {
                  lintWidth = tabWidth + 1;
                  lintLeft = tabEl.offsetLeft;
                } else if (tabType === 'border-card') {
                  lintWidth = tabWidth;
                  lintLeft = tabEl.offsetLeft - 1;
                } else {
                  lintWidth = Math.max(4, Math.floor(tabWidth * 0.6));
                  lintLeft = tabEl.offsetLeft + Math.floor((tabWidth - lintWidth) / 2);
                }
              }
            }
          }
        }
        reactData.scrollbarWidth = sBarWidth;
        reactData.scrollbarHeight = sBarHeight;
        reactData.lintLeft = lintLeft;
        reactData.lintTop = lintTop;
        reactData.lintWidth = lintWidth;
        reactData.lintHeight = lintHeight;
        reactData.isTabOver = isOver;
        checkScrolling();
      };
      handleStyle();
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(handleStyle);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tabs: $xeTabs
      }, params));
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const addInitName = (name, evnt) => {
      const {
        initNames
      } = reactData;
      if (name && !initNames.includes(name)) {
        dispatchEvent('tab-load', {
          name
        }, evnt);
        initNames.push(name);
        return true;
      }
      return false;
    };
    const initDefaultName = list => {
      let activeName = null;
      const nameMaps = {};
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach(item => {
          const {
            name,
            preload
          } = item || {};
          if (name) {
            nameMaps[`${name}`] = {
              loading: false
            };
            if (activeName === name) {
              validVal = true;
            }
            if (preload) {
              addInitName(name, null);
            }
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          addInitName(activeName, null);
          emitModel(activeName);
        }
      }
      reactData.activeName = activeName;
      reactData.cacheTabMaps = nameMaps;
    };
    const clickEvent = (evnt, item) => {
      const {
        trigger
      } = props;
      const beforeMethod = props.beforeChangeMethod || getConfig().tabs.beforeChangeMethod;
      const {
        activeName
      } = reactData;
      const {
        name
      } = item;
      const value = name;
      dispatchEvent('tab-click', {
        name
      }, evnt);
      if (trigger === 'manual') {
        return;
      }
      if (name !== activeName) {
        Promise.resolve(!beforeMethod || beforeMethod({
          $tabs: $xeTabs,
          name,
          oldName: activeName,
          newName: name,
          option: item
        })).then(status => {
          if (status) {
            reactData.activeName = name;
            emitModel(value);
            addInitName(name, evnt);
            dispatchEvent('change', {
              value,
              name,
              oldName: activeName,
              newName: name,
              option: item
            }, evnt);
            dispatchEvent('tab-change', {
              value,
              name,
              oldName: activeName,
              newName: name,
              option: item
            }, evnt);
          } else {
            dispatchEvent('tab-change-fail', {
              value,
              name,
              oldName: activeName,
              newName: name,
              option: item
            }, evnt);
          }
        }).catch(() => {
          dispatchEvent('tab-change-fail', {
            value,
            name,
            oldName: activeName,
            newName: name,
            option: item
          }, evnt);
        });
      }
    };
    const handleRefreshTabEvent = (evnt, item) => {
      evnt.stopPropagation();
      const {
        activeName,
        cacheTabMaps
      } = reactData;
      const {
        name
      } = item;
      const refreshOpts = computeRefreshOpts.value;
      const {
        queryMethod
      } = refreshOpts;
      const cacheItem = name ? cacheTabMaps[`${name}`] : null;
      if (cacheItem) {
        if (queryMethod) {
          if (cacheItem.loading) {
            return;
          }
          cacheItem.loading = true;
          Promise.resolve(queryMethod({
            $tabs: $xeTabs,
            value: activeName,
            name,
            option: item
          })).finally(() => {
            cacheItem.loading = false;
          });
        } else {
          errLog('vxe.error.notFunc', ['refresh-config.queryMethod']);
        }
      }
    };
    const handleCloseTabEvent = (evnt, item, index, list) => {
      evnt.stopPropagation();
      const {
        activeName
      } = reactData;
      const closeOpts = computeCloseOpts.value;
      const beforeMethod = closeOpts.beforeMethod || props.beforeCloseMethod || getConfig().tabs.beforeCloseMethod;
      const {
        name
      } = item;
      const value = activeName;
      let nextName = value;
      if (activeName === name) {
        const nextItem = index < list.length - 1 ? list[index + 1] : list[index - 1];
        nextName = nextItem ? nextItem.name : null;
      }
      Promise.resolve(!beforeMethod || beforeMethod({
        $tabs: $xeTabs,
        value,
        name,
        nextName,
        option: item
      })).then(status => {
        if (status) {
          dispatchEvent('tab-close', {
            value,
            name,
            nextName
          }, evnt);
        } else {
          dispatchEvent('tab-close-fail', {
            value,
            name,
            nextName
          }, evnt);
        }
      }).catch(() => {
        dispatchEvent('tab-close-fail', {
          value,
          name,
          nextName
        }, evnt);
      });
    };
    const startScrollAnimation = (offsetPos, offsetSize) => {
      const {
        slTimeout
      } = internalData;
      const lrPosition = computeLrPosition.value;
      let offsetLeft = lrPosition ? 0 : offsetSize;
      let offsetTop = lrPosition ? offsetSize : 0;
      let scrollCount = 6;
      let delayNum = 35;
      if (slTimeout) {
        clearTimeout(slTimeout);
        internalData.slTimeout = undefined;
      }
      const scrollAnimate = () => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (scrollCount > 0) {
          scrollCount--;
          if (headerWrapperEl) {
            const {
              clientWidth,
              clientHeight,
              scrollWidth,
              scrollHeight,
              scrollLeft,
              scrollTop
            } = headerWrapperEl;
            if (lrPosition) {
              offsetTop = Math.floor(offsetTop / 2);
              if (offsetPos > 0) {
                if (clientHeight + scrollTop < scrollHeight) {
                  headerWrapperEl.scrollTop += offsetTop;
                  delayNum -= 4;
                  internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
                }
              } else {
                if (scrollTop > 0) {
                  headerWrapperEl.scrollTop -= offsetTop;
                  delayNum -= 4;
                  internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
                }
              }
            } else {
              offsetLeft = Math.floor(offsetLeft / 2);
              if (offsetPos > 0) {
                if (clientWidth + scrollLeft < scrollWidth) {
                  headerWrapperEl.scrollLeft += offsetLeft;
                  delayNum -= 4;
                  internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
                }
              } else {
                if (scrollLeft > 0) {
                  headerWrapperEl.scrollLeft -= offsetLeft;
                  delayNum -= 4;
                  internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
                }
              }
            }
            updateTabStyle();
          }
        }
      };
      scrollAnimate();
    };
    const handleScrollToLeft = offsetPos => {
      const lrPosition = computeLrPosition.value;
      const headerWrapperEl = refHeadWrapperElem.value;
      if (headerWrapperEl) {
        const {
          clientWidth,
          clientHeight
        } = headerWrapperEl;
        const offsetSize = Math.floor((lrPosition ? clientHeight : clientWidth) * 0.75);
        startScrollAnimation(offsetPos, offsetSize);
      }
    };
    const scrollLeftEvent = () => {
      handleScrollToLeft(-1);
    };
    const scrollRightEvent = () => {
      handleScrollToLeft(1);
    };
    const scrollToTab = name => {
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const lrPosition = computeLrPosition.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (headerWrapperEl) {
          const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, item => item.name === name);
          if (index > -1) {
            const {
              scrollLeft,
              scrollTop,
              clientWidth,
              clientHeight,
              children
            } = headerWrapperEl;
            const tabEl = children[index];
            if (tabEl) {
              if (lrPosition) {
                const tabOffsetTop = tabEl.offsetTop;
                const tabClientHeight = tabEl.clientHeight;
                // å¦æé¡¶é¨è¢«æ¡
                const overSize = tabOffsetTop + tabClientHeight - (scrollTop + clientHeight);
                if (overSize > 0) {
                  headerWrapperEl.scrollTop += overSize;
                }
                // å¦æåºé¨è¢«æ¡ï¼ä¼å
                if (tabOffsetTop < scrollTop) {
                  headerWrapperEl.scrollTop = tabOffsetTop;
                }
              } else {
                const tabOffsetLeft = tabEl.offsetLeft;
                const tabClientWidth = tabEl.clientWidth;
                // å¦æå³ä¾§è¢«æ¡
                const overSize = tabOffsetLeft + tabClientWidth - (scrollLeft + clientWidth);
                if (overSize > 0) {
                  headerWrapperEl.scrollLeft += overSize;
                }
                // å¦æå·¦ä¾§è¢«æ¡ï¼ä¼å
                if (tabOffsetLeft < scrollLeft) {
                  headerWrapperEl.scrollLeft = tabOffsetLeft;
                }
              }
            }
          }
          updateTabStyle();
        }
      });
    };
    const handlePrevNext = isNext => {
      const {
        activeName
      } = reactData;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const list = tabStaticOptions.length ? tabStaticOptions : tabOptions;
      const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(list, item => item.name === activeName);
      if (index > -1) {
        let item = null;
        if (isNext) {
          if (index < list.length - 1) {
            item = list[index + 1];
          }
        } else {
          if (index > 0) {
            item = list[index - 1];
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emitModel(value);
          addInitName(name, null);
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const tabsMethods = {
      dispatchEvent,
      scrollToTab,
      prev() {
        return handlePrevNext(false);
      },
      next() {
        return handlePrevNext(true);
      },
      prevTab() {
        warnLog('vxe.error.delFunc', ['[tabs] prevTab', 'prev']);
        return tabsMethods.prev();
      },
      nextTab() {
        warnLog('vxe.error.delFunc', ['[tabs] nextTab', 'next']);
        return tabsMethods.next();
      }
    };
    const tabsPrivateMethods = {};
    Object.assign($xeTabs, tabsMethods, tabsPrivateMethods);
    const renderTabHeader = tabList => {
      const {
        titleWidth: allTitleWidth,
        titleAlign: allTitleAlign,
        showClose,
        closeConfig,
        refreshConfig
      } = props;
      const {
        activeName,
        scrollbarWidth,
        scrollbarHeight,
        isTabOver,
        cacheTabMaps
      } = reactData;
      const tabType = computeTabType.value;
      const tabPosition = computeTabPosition.value;
      const lrPosition = computeLrPosition.value;
      const lineStyle = computeLineStyle.value;
      const tabPrefixSlot = slots.tabPrefix || slots['tab-prefix'] || slots.prefix;
      const tabSuffixSlot = slots.tabSuffix || slots['tab-suffix'] || slots.suffix || slots.extra;
      const closeOpts = computeCloseOpts.value;
      const closeVisibleMethod = closeOpts.visibleMethod;
      const refreshOpts = computeRefreshOpts.value;
      const refreshVisibleMethod = refreshOpts.visibleMethod;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'th',
        class: ['vxe-tabs-header', `type--${tabType}`, `pos--${tabPosition}`]
      }, [tabPrefixSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-tabs-header--prefix', `type--${tabType}`, `pos--${tabPosition}`]
      }, callSlot(tabPrefixSlot, {
        name: activeName
      })) : renderEmptyElement($xeTabs), isTabOver ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeadPrevElem,
        class: ['vxe-tabs-header--bar vxe-tabs-header--prev-bar', `type--${tabType}`, `pos--${tabPosition}`],
        onClick: scrollLeftEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: lrPosition ? getIcon().TABS_TAB_BUTTON_TOP : getIcon().TABS_TAB_BUTTON_LEFT
      })]) : renderEmptyElement($xeTabs), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-tabs-header--wrapper', `type--${tabType}`, `pos--${tabPosition}`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeadWrapperElem,
        class: 'vxe-tabs-header--item-wrapper',
        style: lrPosition ? {
          marginRight: `-${scrollbarWidth + scrollbarOffsetSize}px`,
          paddingRight: `${scrollbarOffsetSize}px`
        } : {
          marginBottom: `-${scrollbarHeight + scrollbarOffsetSize}px`,
          paddingBottom: `${scrollbarOffsetSize}px`
        },
        onScroll: checkScrolling
      }, tabList.map((item, index) => {
        const {
          title,
          titleWidth,
          titleAlign,
          icon,
          name
        } = item;
        const itemSlots = item.slots || {};
        const titleSlot = itemSlots.title || itemSlots.tab;
        const titlePrefixSlot = itemSlots.titlePrefix || itemSlots['title-prefix'];
        const titleSuffixSlot = itemSlots.titleSuffix || itemSlots['title-suffix'];
        const itemWidth = titleWidth || allTitleWidth;
        const itemAlign = titleAlign || allTitleAlign;
        const params = {
          $tabs: $xeTabs,
          value: activeName,
          name,
          option: item
        };
        const isActive = activeName === name;
        const cacheItem = name ? cacheTabMaps[`${name}`] : null;
        const isLoading = cacheItem ? cacheItem.loading : false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: `${name}`,
          class: ['vxe-tabs-header--item', `type--${tabType}`, `pos--${tabPosition}`, itemAlign ? `align--${itemAlign}` : '', {
            'is--active': isActive
          }],
          style: itemWidth ? {
            width: toCssUnit(itemWidth)
          } : undefined,
          onClick(evnt) {
            clickEvent(evnt, item);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tabs-header--item-inner'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tabs-header--item-content'
        }, [icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-tabs-header--item-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: icon
        })]) : renderEmptyElement($xeTabs), titlePrefixSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-tabs-header--item-prefix'
        }, callSlot(titlePrefixSlot, {
          name,
          title
        })) : renderEmptyElement($xeTabs), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-tabs-header--item-name'
        }, titleSlot ? callSlot(titleSlot, {
          name,
          title
        }) : `${title}`), titleSuffixSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-tabs-header--item-suffix'
        }, callSlot(titleSuffixSlot, {
          name,
          title
        })) : renderEmptyElement($xeTabs)]), (isEnableConf(refreshConfig) || refreshOpts.enabled) && (refreshVisibleMethod ? refreshVisibleMethod(params) : true) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-tabs-header--refresh-btn', {
            'is--active': isActive,
            'is--loading': isLoading,
            'is--disabled': isLoading
          }],
          onClick(evnt) {
            handleRefreshTabEvent(evnt, item);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: isLoading ? getIcon().TABS_TAB_REFRESH_LOADING : getIcon().TABS_TAB_REFRESH
        })]) : renderEmptyElement($xeTabs), (showClose || isEnableConf(closeConfig) || closeOpts.enabled) && (!closeVisibleMethod || closeVisibleMethod(params)) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-tabs-header--close-btn', {
            'is--active': isActive
          }],
          onClick(evnt) {
            handleCloseTabEvent(evnt, item, index, tabList);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().TABS_TAB_CLOSE
        })]) : renderEmptyElement($xeTabs)])]);
      }).concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        key: 'line',
        class: ['vxe-tabs-header--active-line', `type--${tabType}`, `pos--${tabPosition}`],
        style: lineStyle
      })]))]), isTabOver ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeadNextElem,
        class: ['vxe-tabs-header--bar vxe-tabs-header--next-bar', `type--${tabType}`, `pos--${tabPosition}`],
        onClick: scrollRightEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: lrPosition ? getIcon().TABS_TAB_BUTTON_BOTTOM : getIcon().TABS_TAB_BUTTON_RIGHT
      })]) : renderEmptyElement($xeTabs), tabSuffixSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-tabs-header--suffix', `type--${tabType}`, `pos--${tabPosition}`]
      }, callSlot(tabSuffixSlot, {
        name: activeName
      })) : renderEmptyElement($xeTabs)]);
    };
    const renderTabPane = item => {
      const {
        initNames,
        activeName
      } = reactData;
      const {
        name,
        slots
      } = item;
      const defaultSlot = slots ? slots.default : null;
      return name && initNames.includes(name) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: `${name}`,
        class: ['vxe-tabs-pane--item', {
          'is--visible': activeName === name
        }]
      }, defaultSlot ? callSlot(defaultSlot, {
        name
      }) : []) : renderEmptyElement($xeTabs);
    };
    const renderTabContent = tabList => {
      const {
        destroyOnClose
      } = props;
      const {
        activeName
      } = reactData;
      if (destroyOnClose) {
        const activeTab = tabList.find(item => item.name === activeName);
        return [activeTab ? renderTabPane(activeTab) : renderEmptyElement($xeTabs)];
      }
      return tabList.map(item => renderTabPane(item));
    };
    const rendetTabBody = tabList => {
      const {
        height,
        padding,
        showBody
      } = props;
      const {
        activeName,
        cacheTabMaps
      } = reactData;
      const vSize = computeSize.value;
      const tabType = computeTabType.value;
      const tabPosition = computeTabPosition.value;
      const refreshOpts = computeRefreshOpts.value;
      const {
        showLoading
      } = refreshOpts;
      const headerpSlot = slots.header;
      const footerSlot = slots.footer;
      if (!showBody) {
        return renderEmptyElement($xeTabs);
      }
      const cacheItem = activeName ? cacheTabMaps[`${activeName}`] : null;
      const isLoading = cacheItem ? cacheItem.loading : false;
      const defParams = {
        name: activeName
      };
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'tb',
        class: ['vxe-tabs-pane--wrapper', `type--${tabType}`, `pos--${tabPosition}`, {
          'is--content': showBody
        }]
      }, [headerpSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tabs-pane--header'
      }, callSlot(headerpSlot, defParams)) : renderEmptyElement($xeTabs), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-tabs-pane--body', `type--${tabType}`, `pos--${tabPosition}`, {
          [`size--${vSize}`]: vSize,
          'is--padding': padding,
          'is--height': height
        }]
      }, renderTabContent(tabList)), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tabs-pane--footer'
      }, callSlot(footerSlot, defParams)) : renderEmptyElement($xeTabs), showLoading && isLoading ? renderEmptyElement($xeTabs) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-tabs--loading',
        modelValue: isLoading
      })]);
    };
    const renderVN = () => {
      const {
        height,
        padding,
        trigger
      } = props;
      const {
        activeName
      } = reactData;
      const vSize = computeSize.value;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const tabType = computeTabType.value;
      const tabPosition = computeTabPosition.value;
      const wrapperStyle = computeWrapperStyle.value;
      const defaultSlot = slots.default;
      const tabList = defaultSlot ? tabStaticOptions : tabOptions;
      const vns = [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'ts',
        class: 'vxe-tabs-slots'
      }, defaultSlot ? defaultSlot({
        name: activeName
      }) : [])];
      if (tabPosition === 'right' || tabPosition === 'bottom') {
        vns.push(rendetTabBody(tabList), renderTabHeader(tabList));
      } else {
        vns.push(renderTabHeader(tabList), rendetTabBody(tabList));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tabs', `pos--${tabPosition}`, `vxe-tabs--${tabType}`, `trigger--${trigger === 'manual' ? 'trigger' : 'default'}`, {
          [`size--${vSize}`]: vSize,
          'is--padding': padding,
          'is--height': height
        }],
        style: wrapperStyle
      }, vns);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.position, () => {
      reactData.resizeFlag++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      addInitName(val, null);
      reactData.activeName = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.activeName, val => {
      scrollToTab(val);
    });
    const optsFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(optsFlag, () => {
      initDefaultName(props.options);
      reactData.resizeFlag++;
    });
    const stFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticTabs ? reactData.staticTabs.length : -1, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticTabs, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(stFlag, () => {
      initDefaultName(reactData.staticTabs);
      reactData.resizeFlag++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeParentTabsResizeFlag, () => {
      reactData.resizeFlag++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.resizeFlag, () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        updateTabStyle();
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      updateTabStyle();
      globalEvents.on($xeTabs, 'resize', updateTabStyle);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeTabs, 'resize');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeTabs', $xeTabs);
    addInitName(props.modelValue, null);
    initDefaultName(reactData.staticTabs.length ? reactData.staticTabs : props.options);
    $xeTabs.renderVN = renderVN;
    return $xeTabs;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tabs/index.ts



const VxeTabs = Object.assign({}, tabs, {
  install(app) {
    app.component(tabs.name, tabs);
  }
});
dynamicApp.use(VxeTabs);
index_esm_VxeUI.component(tabs);
const Tabs = VxeTabs;
/* harmony default export */ var packages_tabs = (VxeTabs);
;// CONCATENATED MODULE: ./packages/tag/src/tag.ts




/* harmony default export */ var tag = (defineVxeComponent({
  name: 'VxeTag',
  props: {
    border: {
      type: Boolean,
      default: () => getConfig().tag.border
    },
    visible: {
      type: Boolean,
      default: null
    },
    status: String,
    title: [String, Number],
    icon: String,
    closeIcon: {
      type: String,
      default: () => getConfig().tag.closeIcon
    },
    content: [String, Number],
    round: Boolean,
    closable: {
      type: Boolean,
      default: () => getConfig().tag.closable
    },
    color: String,
    loading: Boolean,
    size: {
      type: String,
      default: () => getConfig().tag.size || getConfig().size
    }
  },
  emits: ['click', 'dblclick', 'close', 'update:visible'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      showTag: props.visible !== false
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTag = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tag: $xeTag
      }, params));
    };
    const tagMethods = {
      dispatchEvent
    };
    const tagPrivateMethods = {};
    const updateVisible = () => {
      reactData.showTag = props.visible !== false;
    };
    const clickEvent = evnt => {
      const {
        loading
      } = props;
      if (!loading) {
        dispatchEvent('click', {}, evnt);
      }
    };
    const dblclickEvent = evnt => {
      const {
        loading
      } = props;
      if (!loading) {
        dispatchEvent('dblclick', {}, evnt);
      }
    };
    const closeEvent = evnt => {
      const {
        loading
      } = props;
      if (!loading) {
        const visible = !reactData.showTag;
        reactData.showTag = visible;
        emit('update:visible', visible);
        dispatchEvent('close', {
          visible
        }, evnt);
      }
    };
    Object.assign($xeTag, tagMethods, tagPrivateMethods);
    const renderContent = () => {
      const {
        icon,
        content,
        closable,
        closeIcon,
        loading
      } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      const closeIconSlot = slots.closeIcon || slots['close-icon'];
      return [iconSlot || icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-tag--icon'
      }, iconSlot ? iconSlot({}) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon
      })]) : renderEmptyElement($xeTag), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-tag--content'
      }, defaultSlot ? defaultSlot({}) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content)), loading || closable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: loading ? 'vxe-tag--loading' : 'vxe-tag--close',
        onClick: closeEvent
      }, !loading && closeIconSlot ? closeIconSlot({}) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: loading ? getIcon().TAG_LOADING : closeIcon || getIcon().TAG_CLOSE
      })]) : renderEmptyElement($xeTag)];
    };
    const renderVN = () => {
      const {
        status,
        color,
        title,
        round,
        border,
        loading
      } = props;
      const {
        showTag
      } = reactData;
      const vSize = computeSize.value;
      if (!showTag) {
        return renderEmptyElement($xeTag);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        ref: refElem,
        class: ['vxe-tag', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status && !color,
          [`color--${color}`]: color && !status,
          'is--round': round,
          'is--border': border,
          'is--loading': loading
        }],
        title,
        onClick: clickEvent,
        onDblclick: dblclickEvent
      }, renderContent());
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.visible, () => {
      updateVisible();
    });
    updateVisible();
    $xeTag.renderVN = renderVN;
    return $xeTag;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tag/index.ts



const VxeTag = Object.assign({}, tag, {
  install(app) {
    app.component(tag.name, tag);
  }
});
dynamicApp.use(VxeTag);
index_esm_VxeUI.component(tag);
const Tag = VxeTag;
/* harmony default export */ var packages_tag = (VxeTag);
;// CONCATENATED MODULE: ./packages/text-ellipsis/src/text-ellipsis.ts




/* harmony default export */ var text_ellipsis = (defineVxeComponent({
  name: 'VxeTextEllipsis',
  props: {
    href: String,
    target: String,
    content: [String, Number],
    lineClamp: [String, Number],
    status: String,
    title: [String, Number],
    loading: Boolean,
    offsetLength: [String, Number],
    routerLink: Object,
    underline: {
      type: Boolean,
      default: () => getConfig().textEllipsis.underline
    },
    /**
     * æéç 
     */
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().textEllipsis.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const realityElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      resizeObserver: null,
      visibleLen: 0
    });
    const refMaps = {
      refElem
    };
    const computeTextLineClamp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.lineClamp);
    });
    const computeTextContent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.content);
    });
    const computeTextOffsetLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.offsetLength ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.offsetLength) : 0;
    });
    const computeVisibleContent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        visibleLen
      } = reactData;
      const textLineClamp = computeTextLineClamp.value;
      const textContent = computeTextContent.value;
      const textOffsetLength = computeTextOffsetLength.value;
      if (textLineClamp > 1) {
        if (textContent.length > visibleLen) {
          return `${textContent.slice(0, Math.max(1, visibleLen - 3 + textOffsetLength))}...`;
        }
        return textContent;
      }
      return textContent;
    });
    const computeMaps = {};
    const $xeTextEllipsis = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $textEllipsis: $xeTextEllipsis
      }, params));
    };
    const calculateFont = targetWidth => {
      const el = refElem.value;
      const ryEl = realityElem.value;
      if (el && ryEl) {
        let fontSize = 12;
        try {
          fontSize = Math.max(10, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getComputedStyle(ryEl).fontSize));
        } catch (e) {}
        const textContent = computeTextContent.value;
        let currIndex = Math.floor(targetWidth / fontSize);
        let currStr = textContent.slice(0, currIndex);
        ryEl.textContent = currStr;
        reactData.visibleLen = currStr.length;
        let maxCount = 0;
        while (targetWidth > ryEl.clientWidth && maxCount < 30) {
          maxCount++;
          const offsetIndex = Math.floor((targetWidth - ryEl.clientWidth) / fontSize);
          if (offsetIndex) {
            currIndex += offsetIndex;
            currStr = textContent.slice(0, currIndex);
            ryEl.textContent = currStr;
            reactData.visibleLen = currStr.length;
          } else {
            break;
          }
        }
        ryEl.textContent = '';
        ryEl.style.display = '';
        ryEl.style.position = '';
        ryEl.style.top = '';
        ryEl.style.left = '';
      }
    };
    const updateStyle = () => {
      const el = refElem.value;
      const ryEl = realityElem.value;
      const textContent = computeTextContent.value;
      const textLineClamp = computeTextLineClamp.value;
      if (el && ryEl) {
        const cWidth = el.clientWidth;
        ryEl.style.display = 'block';
        ryEl.style.position = 'absolute';
        ryEl.style.top = '-3000px';
        ryEl.style.left = '-3000px';
        ryEl.textContent = textContent;
        const sWidth = ryEl.offsetWidth;
        const targetWidth = Math.floor(cWidth * textLineClamp);
        if (targetWidth > sWidth) {
          reactData.visibleLen = textContent.length;
        } else {
          calculateFont(targetWidth);
        }
      } else {
        reactData.visibleLen = textContent.length;
      }
    };
    const textEllipsisMethods = {
      dispatchEvent
    };
    const clickEvent = () => {
      emit('click', {});
    };
    const initObserver = () => {
      const {
        resizeObserver
      } = reactData;
      const textLineClamp = computeTextLineClamp.value;
      if (!resizeObserver) {
        const el = refElem.value;
        if (el && textLineClamp > 1) {
          if (window.ResizeObserver) {
            const observerObj = new window.ResizeObserver(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().throttle(() => {
              updateStyle();
            }, 300, {
              leading: true,
              trailing: true
            }));
            observerObj.observe(el);
            reactData.resizeObserver = observerObj;
          }
        }
      }
    };
    const textEllipsisPrivateMethods = {};
    Object.assign($xeTextEllipsis, textEllipsisMethods, textEllipsisPrivateMethods);
    const renderContent = () => {
      const {
        routerLink,
        href,
        target,
        title
      } = props;
      const visibleContent = computeVisibleContent.value;
      if (routerLink) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
          class: 'vxe-text-ellipsis--link',
          title,
          target,
          to: routerLink
        }, {
          default() {
            return renderContent();
          }
        });
      }
      if (href) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
          class: 'vxe-text-ellipsis--link',
          href,
          target,
          title
        }, visibleContent);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-text-ellipsis--content'
      }, visibleContent);
    };
    const renderVN = () => {
      const {
        loading,
        status,
        title,
        underline
      } = props;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      const textLineClamp = computeTextLineClamp.value;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeTextEllipsis);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-text-ellipsis', textLineClamp > 1 ? 'is--multi' : 'is--single', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--underline': underline,
          'is--loading': loading
        }],
        title,
        onClick: clickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        ref: realityElem,
        class: 'vxe-text-ellipsis--reality'
      }), renderContent()]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.content, () => {
      updateStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.lineClamp, () => {
      initObserver();
      updateStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      initObserver();
      updateStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      const {
        resizeObserver
      } = reactData;
      const el = refElem.value;
      const ryEl = realityElem.value;
      if (ryEl) {
        ryEl.textContent = '';
      }
      if (resizeObserver) {
        if (el) {
          resizeObserver.unobserve(el);
        }
        resizeObserver.disconnect();
        reactData.resizeObserver = null;
      }
    });
    $xeTextEllipsis.renderVN = renderVN;
    return $xeTextEllipsis;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/text-ellipsis/index.ts



const VxeTextEllipsis = Object.assign({}, text_ellipsis, {
  install(app) {
    app.component(text_ellipsis.name, text_ellipsis);
  }
});
dynamicApp.use(VxeTextEllipsis);
index_esm_VxeUI.component(text_ellipsis);
const TextEllipsis = VxeTextEllipsis;
/* harmony default export */ var packages_text_ellipsis = (VxeTextEllipsis);
;// CONCATENATED MODULE: ./packages/text/index.ts



const VxeText = Object.assign({}, src_text, {
  install(app) {
    app.component(src_text.name, src_text);
  }
});
dynamicApp.use(VxeText);
index_esm_VxeUI.component(src_text);
const Text = VxeText;
/* harmony default export */ var packages_text = (VxeText);
;// CONCATENATED MODULE: ./packages/textarea/src/textarea.ts





let autoTxtElem;
/* harmony default export */ var src_textarea = (defineVxeComponent({
  name: 'VxeTextarea',
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    readonly: {
      type: Boolean,
      default: null
    },
    editable: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    rows: {
      type: [String, Number],
      default: null
    },
    cols: {
      type: [String, Number],
      default: null
    },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: {
      type: String,
      default: () => getConfig().textarea.resize
    },
    size: {
      type: String,
      default: () => getConfig().textarea.size || getConfig().size
    },
    // å·²åºå¼
    maxlength: [String, Number]
  },
  emits: ['update:modelValue', 'input', 'keydown', 'keyup', 'click', 'change', 'focus', 'blur', 'lazy-change'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inputValue: props.modelValue
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTextarea = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refTextarea
    };
    const $xeTextarea = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let textareaMethods = {};
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInputReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        editable
      } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || !editable;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().textarea.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.base.pleaseInput');
    });
    const computeInpMaxLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        maxLength,
        maxlength
      } = props;
      return maxLength || maxlength;
    });
    const computeInputCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getSize(reactData.inputValue);
    });
    const computeIsCountError = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpMaxLength);
    });
    const computeSizeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        minRows: 1,
        maxRows: 10
      }, getConfig().textarea.autosize, props.autosize);
    });
    const updateAutoTxt = () => {
      const {
        size,
        autosize
      } = props;
      const {
        inputValue
      } = reactData;
      if (autosize) {
        if (!autoTxtElem) {
          autoTxtElem = document.createElement('div');
        }
        if (!autoTxtElem.parentNode) {
          document.body.appendChild(autoTxtElem);
        }
        const textElem = refTextarea.value;
        if (!textElem) {
          return;
        }
        const textStyle = getComputedStyle(textElem);
        autoTxtElem.className = ['vxe-textarea--autosize', size ? `size--${size}` : ''].join(' ');
        autoTxtElem.style.width = `${textElem.clientWidth}px`;
        autoTxtElem.style.padding = textStyle.padding;
        autoTxtElem.innerText = ('' + (inputValue || 'ã')).replace(/\n$/, '\nã');
      }
    };
    const handleResize = () => {
      if (props.autosize) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const sizeOpts = computeSizeOpts.value;
          const {
            minRows,
            maxRows
          } = sizeOpts;
          const textElem = refTextarea.value;
          if (!textElem) {
            return;
          }
          const sizeHeight = autoTxtElem.clientHeight;
          const textStyle = getComputedStyle(textElem);
          const lineHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.lineHeight);
          const paddingTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.paddingTop);
          const paddingBottom = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.paddingBottom);
          const borderTopWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.borderTopWidth);
          const borderBottomWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.borderBottomWidth);
          const intervalHeight = paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
          const rowNum = (sizeHeight - intervalHeight) / lineHeight;
          const textRows = rowNum && /[0-9]/.test('' + rowNum) ? rowNum : Math.floor(rowNum) + 1;
          let vaildRows = textRows;
          if (textRows < minRows) {
            vaildRows = minRows;
          } else if (textRows > maxRows) {
            vaildRows = maxRows;
          }
          textElem.style.height = `${vaildRows * lineHeight + intervalHeight}px`;
        });
      }
    };
    const triggerEvent = evnt => {
      const value = reactData.inputValue;
      $xeTextarea.dispatchEvent(evnt.type, {
        value
      }, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit('update:modelValue', value);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        textareaMethods.dispatchEvent('change', {
          value
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = evnt => {
      const {
        immediate
      } = props;
      const textElem = evnt.target;
      const value = textElem.value;
      reactData.inputValue = value;
      if (immediate) {
        handleChange(value, evnt);
      }
      $xeTextarea.dispatchEvent('input', {
        value
      }, evnt);
      handleResize();
    };
    const changeEvent = evnt => {
      const {
        immediate
      } = props;
      if (immediate) {
        triggerEvent(evnt);
      } else {
        handleChange(reactData.inputValue, evnt);
      }
      $xeTextarea.dispatchEvent('lazy-change', {
        value: reactData.inputValue
      }, evnt);
    };
    const blurEvent = evnt => {
      const {
        immediate
      } = props;
      const {
        inputValue
      } = reactData;
      if (!immediate) {
        handleChange(inputValue, evnt);
      }
      $xeTextarea.dispatchEvent('blur', {
        value: inputValue
      }, evnt);
    };
    textareaMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $textarea: $xeTextarea
        }, params));
      },
      focus() {
        const textElem = refTextarea.value;
        textElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const textElem = refTextarea.value;
        textElem.blur();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xeTextarea, textareaMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
      updateAutoTxt();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeSizeOpts, () => {
      updateAutoTxt();
      handleResize();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      const {
        autosize
      } = props;
      if (autosize) {
        updateAutoTxt();
        handleResize();
      }
    });
    const renderVN = () => {
      const {
        className,
        resize,
        autosize,
        showWordCount,
        countMethod,
        rows,
        cols
      } = props;
      const {
        inputValue
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const inpMaxLength = computeInpMaxLength.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-textarea--readonly', className]
        }, inputValue);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-textarea', className, {
          [`size--${vSize}`]: vSize,
          'is--autosize': autosize,
          'is--count': showWordCount,
          'is--disabled': isDisabled,
          'is--rows': !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(rows),
          'is--cols': !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cols)
        }],
        spellcheck: false
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('textarea', {
        ref: refTextarea,
        class: 'vxe-textarea--inner',
        value: inputValue,
        name: props.name,
        placeholder: inpPlaceholder,
        maxlength: inpMaxLength,
        readonly: inputReadonly,
        disabled: isDisabled,
        rows,
        cols,
        style: resize ? {
          resize
        } : null,
        onInput: inputEvent,
        onChange: changeEvent,
        onKeydown: triggerEvent,
        onKeyup: triggerEvent,
        onClick: triggerEvent,
        onFocus: triggerEvent,
        onBlur: blurEvent
      }), showWordCount ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-textarea--count', {
          'is--error': isCountError
        }]
      }, countMethod ? `${countMethod({
        value: inputValue
      })}` : `${inputCount}${inpMaxLength ? `/${inpMaxLength}` : ''}`) : null]);
    };
    $xeTextarea.renderVN = renderVN;
    return $xeTextarea;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/textarea/index.ts



const VxeTextarea = Object.assign(src_textarea, {
  install: function (app) {
    app.component(src_textarea.name, src_textarea);
  }
});
dynamicApp.use(VxeTextarea);
index_esm_VxeUI.component(src_textarea);
const Textarea = VxeTextarea;
/* harmony default export */ var packages_textarea = (VxeTextarea);
;// CONCATENATED MODULE: ./packages/tip/src/tip.ts





/* harmony default export */ var tip = (defineVxeComponent({
  name: 'VxeTip',
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().tip.title
    },
    content: [String, Number],
    status: String,
    icon: {
      type: String,
      default: () => getConfig().tip.icon
    },
    /**
     * æéç 
     */
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().tip.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tip: $xeTip
      }, params));
    };
    const tipMethods = {
      dispatchEvent
    };
    const tipPrivateMethods = {};
    Object.assign($xeTip, tipMethods, tipPrivateMethods);
    const renderVN = () => {
      const {
        status,
        content,
        icon,
        title
      } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeTip);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tip', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'has--title': !!(titleSlot || title)
        }]
      }, [iconSlot || icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tip--icon'
      }, iconSlot ? vn_getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon
      })]) : renderEmptyElement($xeTip), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tip--body'
      }, [titleSlot || title ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tip--title'
      }, titleSlot ? vn_getSlotVNs(titleSlot({})) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(title)) : renderEmptyElement($xeTip), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tip--content'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({})) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content))])]);
    };
    $xeTip.renderVN = renderVN;
    return $xeTip;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tip/index.ts



const VxeTip = Object.assign({}, tip, {
  install(app) {
    app.component(tip.name, tip);
    app.component('VxeTipsComponent', tip);
  }
});
dynamicApp.use(VxeTip);
index_esm_VxeUI.component(tip);
const Tips = VxeTip;
const Tip = VxeTip;
/* harmony default export */ var packages_tip = (VxeTip);
;// CONCATENATED MODULE: ./packages/tooltip/index.ts



const VxeTooltip = Object.assign({}, tooltip, {
  install(app) {
    app.component(tooltip.name, tooltip);
  }
});
dynamicApp.use(VxeTooltip);
index_esm_VxeUI.component(tooltip);
const Tooltip = VxeTooltip;
/* harmony default export */ var packages_tooltip = (VxeTooltip);
;// CONCATENATED MODULE: ./packages/tree/src/util.ts

function enNodeValue(nodeid) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(nodeid) ? '' : encodeURIComponent(`${nodeid}`);
}
function deNodeValue(nodeid) {
  return nodeid ? decodeURIComponent(`${nodeid}`) : nodeid;
}
function countTreeExpand($xeTree, prevNode) {
  let count = 1;
  if (!prevNode) {
    return count;
  }
  const props = $xeTree.props;
  const {
    transform
  } = props;
  const reactData = $xeTree.reactData;
  const {
    updateExpandedFlag
  } = reactData;
  const internalData = $xeTree.internalData;
  const {
    treeExpandedMaps
  } = internalData;
  const {
    computeChildrenField,
    computeMapChildrenField
  } = $xeTree.getComputeMaps();
  const childrenField = computeChildrenField.value;
  const mapChildrenField = computeMapChildrenField.value;
  const nodeChildren = prevNode[transform ? mapChildrenField : childrenField];
  if (nodeChildren && updateExpandedFlag && treeExpandedMaps[$xeTree.getNodeId(prevNode)]) {
    for (let index = 0; index < nodeChildren.length; index++) {
      count += countTreeExpand($xeTree, nodeChildren[index]);
    }
  }
  return count;
}
function calcTreeLine($xeTree, node, prevNode) {
  const internalData = $xeTree.internalData;
  const {
    scrollYStore
  } = internalData;
  const {
    rowHeight
  } = scrollYStore;
  let expandSize = 1;
  if (prevNode) {
    expandSize = countTreeExpand($xeTree, prevNode);
  }
  return (rowHeight || 28) * expandSize - (prevNode ? 1 : 12);
}
;// CONCATENATED MODULE: ./packages/tree/src/tree.ts










/**
 * çæèç¹çå¯ä¸ä¸»é®
 */
function getNodeUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('node_');
}
function tree_createInternalData() {
  return {
    // initialized: false,
    // lastFilterValue: '',
    treeFullData: [],
    afterTreeList: [],
    afterVisibleList: [],
    nodeMaps: {},
    selectCheckboxMaps: {},
    indeterminateRowMaps: {},
    treeExpandedMaps: {},
    treeExpandLazyLoadedMaps: {},
    lastScrollLeft: 0,
    lastScrollTop: 0,
    scrollYStore: {
      startIndex: 0,
      endIndex: 0,
      visibleSize: 0,
      offsetSize: 0,
      rowHeight: 0
    },
    lastScrollTime: 0
    // hpTimeout: undefined
  };
}
/* harmony default export */ var tree = (defineVxeComponent({
  name: 'VxeTree',
  props: {
    data: Array,
    autoResize: {
      type: Boolean,
      default: () => getConfig().tree.autoResize
    },
    height: [String, Number],
    maxHeight: {
      type: [String, Number],
      default: () => getConfig().tree.maxHeight
    },
    minHeight: {
      type: [String, Number],
      default: () => getConfig().tree.minHeight
    },
    loading: Boolean,
    loadingConfig: Object,
    accordion: {
      type: Boolean,
      default: () => getConfig().tree.accordion
    },
    childrenField: {
      type: String,
      default: () => getConfig().tree.childrenField
    },
    valueField: {
      type: String,
      default: () => getConfig().tree.valueField
    },
    keyField: {
      type: String,
      default: () => getConfig().tree.keyField
    },
    parentField: {
      type: String,
      default: () => getConfig().tree.parentField
    },
    titleField: {
      type: String,
      default: () => getConfig().tree.titleField
    },
    hasChildField: {
      type: String,
      default: () => getConfig().tree.hasChildField
    },
    mapChildrenField: {
      type: String,
      default: () => getConfig().tree.mapChildrenField
    },
    transform: Boolean,
    // å·²åºå¼
    isCurrent: Boolean,
    // å·²åºå¼
    isHover: Boolean,
    expandAll: Boolean,
    expandNodeKeys: Array,
    showLine: {
      type: Boolean,
      default: () => getConfig().tree.showLine
    },
    trigger: String,
    indent: {
      type: Number,
      default: () => getConfig().tree.indent
    },
    showRadio: {
      type: Boolean,
      default: () => getConfig().tree.showRadio
    },
    checkNodeKey: {
      type: [String, Number],
      default: () => getConfig().tree.checkNodeKey
    },
    radioConfig: Object,
    showCheckbox: {
      type: Boolean,
      default: () => getConfig().tree.showCheckbox
    },
    checkNodeKeys: {
      type: Array,
      default: () => getConfig().tree.checkNodeKeys
    },
    checkboxConfig: Object,
    nodeConfig: Object,
    lazy: Boolean,
    toggleMethod: Function,
    loadMethod: Function,
    showIcon: {
      type: Boolean,
      default: true
    },
    iconOpen: {
      type: String,
      default: () => getConfig().tree.iconOpen
    },
    iconClose: {
      type: String,
      default: () => getConfig().tree.iconClose
    },
    iconLoaded: {
      type: String,
      default: () => getConfig().tree.iconLoaded
    },
    filterValue: [String, Number],
    filterConfig: Object,
    size: {
      type: String,
      default: () => getConfig().tree.size || getConfig().size
    },
    virtualYConfig: Object
  },
  emits: ['update:modelValue', 'update:checkNodeKey', 'update:checkNodeKeys', 'node-click', 'node-dblclick', 'current-change', 'radio-change', 'checkbox-change', 'load-success', 'load-error', 'scroll'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderWrapperElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterWrapperElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      parentHeight: 0,
      customHeight: 0,
      customMinHeight: 0,
      customMaxHeight: 0,
      currentNode: null,
      scrollYLoad: false,
      bodyHeight: 0,
      topSpaceHeight: 0,
      selectRadioKey: enNodeValue(props.checkNodeKey),
      treeList: [],
      updateExpandedFlag: 1,
      updateCheckboxFlag: 1
    });
    const internalData = tree_createInternalData();
    const refMaps = {
      refElem
    };
    const computeTitleField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.titleField || 'title';
    });
    const computeKeyField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.keyField || 'id';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const keyField = computeKeyField.value;
      return props.valueField || keyField;
    });
    const computeParentField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.parentField || 'parentId';
    });
    const computeChildrenField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.childrenField || 'children';
    });
    const computeMapChildrenField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.mapChildrenField || 'mapChildren';
    });
    const computeHasChildField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.hasChildField || 'hasChild';
    });
    const computeVirtualYOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tree.virtualYConfig, props.virtualYConfig);
    });
    const computeIsRowCurrent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const nodeOpts = computeNodeOpts.value;
      const {
        isCurrent
      } = nodeOpts;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(isCurrent)) {
        return isCurrent;
      }
      return props.isCurrent;
    });
    const computeIsRowHover = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const nodeOpts = computeNodeOpts.value;
      const {
        isHover
      } = nodeOpts;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(isHover)) {
        return isHover;
      }
      return props.isHover;
    });
    const computeRadioOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        showIcon: true
      }, getConfig().tree.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        showIcon: true
      }, getConfig().tree.checkboxConfig, props.checkboxConfig);
    });
    const computeNodeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tree.nodeConfig, props.nodeConfig);
    });
    const computeLoadingOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tree.loadingConfig, props.loadingConfig);
    });
    const computeTreeStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        customHeight,
        customMinHeight,
        customMaxHeight
      } = reactData;
      const stys = {};
      if (customHeight) {
        stys.height = toCssUnit(customHeight);
      }
      if (customMinHeight) {
        stys.minHeight = toCssUnit(customMinHeight);
      }
      if (customMaxHeight) {
        stys.maxHeight = toCssUnit(customMaxHeight);
      }
      return stys;
    });
    const computeFilterOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tree.filterConfig, props.filterConfig);
    });
    const computeMaps = {
      computeChildrenField,
      computeMapChildrenField,
      computeRadioOpts,
      computeCheckboxOpts,
      computeNodeOpts
    };
    const $xeTree = {
      xID,
      props,
      context,
      internalData,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getNodeId = node => {
      const valueField = computeValueField.value;
      const nodeKey = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, valueField);
      return enNodeValue(nodeKey);
    };
    const isExpandByNode = node => {
      const {
        updateExpandedFlag
      } = reactData;
      const {
        treeExpandedMaps
      } = internalData;
      const nodeid = getNodeId(node);
      return !!(updateExpandedFlag && treeExpandedMaps[nodeid]);
    };
    const isCheckedByRadioNodeId = nodeid => {
      const {
        selectRadioKey
      } = reactData;
      return selectRadioKey === nodeid;
    };
    const isCheckedByRadioNode = node => {
      return isCheckedByRadioNodeId(getNodeId(node));
    };
    const isCheckedByCheckboxNodeId = nodeid => {
      const {
        updateCheckboxFlag
      } = reactData;
      const {
        selectCheckboxMaps
      } = internalData;
      return !!(updateCheckboxFlag && selectCheckboxMaps[nodeid]);
    };
    const isCheckedByCheckboxNode = node => {
      return isCheckedByCheckboxNodeId(getNodeId(node));
    };
    const isIndeterminateByCheckboxNodeid = nodeid => {
      const {
        updateCheckboxFlag
      } = reactData;
      const {
        indeterminateRowMaps
      } = internalData;
      return !!(updateCheckboxFlag && indeterminateRowMaps[nodeid]);
    };
    const isIndeterminateByCheckboxNode = node => {
      return isIndeterminateByCheckboxNodeid(getNodeId(node));
    };
    const emitCheckboxMode = value => {
      emit('update:checkNodeKeys', value);
    };
    const emitRadioMode = value => {
      emit('update:checkNodeKey', value);
    };
    const handleSetCheckboxByNodeId = (nodeKeys, checked) => {
      const {
        nodeMaps
      } = internalData;
      if (nodeKeys) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodeKeys)) {
          nodeKeys = [nodeKeys];
        }
        const nodeList = [];
        nodeKeys.forEach(nodeKey => {
          const nodeid = enNodeValue(nodeKey);
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            nodeList.push(nodeItem.item);
          }
        });
        handleCheckedCheckboxNode(nodeList, checked);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleCheckedCheckboxNode = (nodeList, checked) => {
      const {
        transform
      } = props;
      const {
        selectCheckboxMaps
      } = internalData;
      const mapChildrenField = computeMapChildrenField.value;
      const childrenField = computeChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        checkStrictly
      } = checkboxOpts;
      const handleSelect = node => {
        const nodeid = getNodeId(node);
        if (checked) {
          if (!selectCheckboxMaps[nodeid]) {
            selectCheckboxMaps[nodeid] = node;
          }
        } else {
          if (selectCheckboxMaps[nodeid]) {
            delete selectCheckboxMaps[nodeid];
          }
        }
      };
      if (checkStrictly) {
        nodeList.forEach(handleSelect);
      } else {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(nodeList, handleSelect, {
          children: transform ? mapChildrenField : childrenField
        });
      }
      reactData.updateCheckboxFlag++;
      updateCheckboxStatus();
    };
    const updateCheckboxChecked = nodeKeys => {
      internalData.selectCheckboxMaps = {};
      handleSetCheckboxByNodeId(nodeKeys, true);
    };
    const handleSetExpand = (nodeid, expanded, expandedMaps) => {
      if (expanded) {
        if (!expandedMaps[nodeid]) {
          expandedMaps[nodeid] = true;
        }
      } else {
        if (expandedMaps[nodeid]) {
          delete expandedMaps[nodeid];
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tree: $xeTree
      }, params));
    };
    const getParentElem = () => {
      const el = refElem.value;
      return el ? el.parentElement : null;
    };
    const calcTableHeight = key => {
      const {
        parentHeight
      } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === '100%' || val === 'auto') {
          num = parentHeight;
        } else {
          if (isScale(val)) {
            num = Math.floor((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val);
          }
          num = Math.max(40, num);
        }
      }
      return num;
    };
    const updateHeight = () => {
      reactData.customHeight = calcTableHeight('height');
      reactData.customMinHeight = calcTableHeight('minHeight');
      reactData.customMaxHeight = calcTableHeight('maxHeight');
      // å¦æå¯ç¨èææ»å¨ï¼é»è®¤é«åº¦
      if (reactData.scrollYLoad && !(reactData.customHeight || reactData.customMinHeight)) {
        reactData.customHeight = 300;
      }
    };
    const createNode = records => {
      const valueField = computeValueField.value;
      return Promise.resolve(records.map(obj => {
        const item = {
          ...obj
        };
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item, valueField, nodeid);
        }
        return item;
      }));
    };
    const cacheNodeMap = () => {
      const {
        treeFullData
      } = internalData;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const keyMaps = {};
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(treeFullData, (item, index, items, path, parent, nodes) => {
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item, valueField, nodeid);
        }
        keyMaps[nodeid] = {
          item,
          index,
          items,
          parent,
          nodes,
          level: nodes.length,
          treeIndex: index,
          lineCount: 0,
          treeLoaded: false
        };
      }, {
        children: childrenField
      });
      internalData.nodeMaps = keyMaps;
    };
    const updateAfterDataIndex = () => {
      const {
        transform
      } = props;
      const {
        afterTreeList,
        nodeMaps
      } = internalData;
      const childrenField = computeChildrenField.value;
      const mapChildrenField = computeMapChildrenField.value;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeList, (item, index, items) => {
        const nodeid = getNodeId(item);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          nodeItem.items = items;
          nodeItem.treeIndex = index;
        } else {
          const rest = {
            item,
            index,
            items,
            parent,
            nodes: [],
            level: 0,
            treeIndex: index,
            lineCount: 0,
            treeLoaded: false
          };
          nodeMaps[nodeid] = rest;
        }
      }, {
        children: transform ? mapChildrenField : childrenField
      });
    };
    const updateAfterFullData = () => {
      const {
        transform,
        filterValue
      } = props;
      const {
        treeFullData,
        lastFilterValue
      } = internalData;
      const titleField = computeTitleField.value;
      const childrenField = computeChildrenField.value;
      const mapChildrenField = computeMapChildrenField.value;
      const filterOpts = computeFilterOpts.value;
      const {
        autoExpandAll,
        beforeFilterMethod,
        filterMethod,
        afterFilterMethod
      } = filterOpts;
      let fullList = treeFullData;
      let treeList = fullList;
      let filterStr = '';
      if (filterValue || filterValue === 0) {
        filterStr = `${filterValue}`;
        const handleSearch = filterMethod ? item => {
          return filterMethod({
            $tree: $xeTree,
            node: item,
            filterValue: filterStr
          });
        } : item => {
          return String(item[titleField]).toLowerCase().indexOf(filterStr) > -1;
        };
        const bafParams = {
          $tree: $xeTree,
          filterValue: filterStr
        };
        if (beforeFilterMethod) {
          beforeFilterMethod(bafParams);
        }
        if (transform) {
          treeList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(treeFullData, handleSearch, {
            original: true,
            isEvery: true,
            children: childrenField,
            mapChildren: mapChildrenField
          });
          fullList = treeList;
        } else {
          fullList = treeFullData.filter(handleSearch);
        }
        internalData.lastFilterValue = filterStr;
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          // ç­éæ¶èªå¨å±å¼
          if (autoExpandAll) {
            $xeTree.setAllExpandNode(true).then(() => {
              if (afterFilterMethod) {
                afterFilterMethod(bafParams);
              }
            });
          } else {
            if (afterFilterMethod) {
              afterFilterMethod(bafParams);
            }
          }
        });
      } else {
        if (transform) {
          treeList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(treeFullData, () => true, {
            original: true,
            isEvery: true,
            children: childrenField,
            mapChildren: mapChildrenField
          });
          fullList = treeList;
          if (lastFilterValue) {
            const bafParams = {
              $tree: $xeTree,
              filterValue: filterStr
            };
            if (beforeFilterMethod) {
              beforeFilterMethod(bafParams);
            }
            // åæ¶ç­éæ¶èªå¨æ¶èµ·
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              if (autoExpandAll) {
                $xeTree.clearAllExpandNode().then(() => {
                  if (afterFilterMethod) {
                    afterFilterMethod(bafParams);
                  }
                });
              } else {
                if (afterFilterMethod) {
                  afterFilterMethod(bafParams);
                }
              }
            });
          }
        }
        internalData.lastFilterValue = '';
      }
      internalData.afterVisibleList = fullList;
      internalData.afterTreeList = treeList;
      updateAfterDataIndex();
    };
    /**
     * å¦æä¸ºèææ ãåå°æ ç»ææå¹³
     */
    const handleTreeToList = () => {
      const {
        transform
      } = props;
      const {
        afterTreeList,
        treeExpandedMaps
      } = internalData;
      const mapChildrenField = computeMapChildrenField.value;
      const expandMaps = {};
      if (transform) {
        const fullData = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeList, (item, index, items, path, parentRow) => {
          const nodeid = getNodeId(item);
          const parentNodeid = getNodeId(parentRow);
          if (!parentRow || expandMaps[parentNodeid] && treeExpandedMaps[parentNodeid]) {
            expandMaps[nodeid] = 1;
            fullData.push(item);
          }
        }, {
          children: mapChildrenField
        });
        updateScrollYStatus(fullData);
        internalData.afterVisibleList = fullData;
        return fullData;
      }
      return internalData.afterVisibleList;
    };
    const handleData = force => {
      const {
        scrollYLoad
      } = reactData;
      const {
        scrollYStore
      } = internalData;
      let fullList = internalData.afterVisibleList;
      if (force) {
        // æ´æ°æ°æ®ï¼å¤çç­éåæåº
        updateAfterFullData();
        // å¦æä¸ºèææ ï¼å°æ ç»ææå¹³
        fullList = handleTreeToList();
      }
      const treeList = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);
      reactData.treeList = treeList;
    };
    const triggerSearchEvent = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().debounce(() => handleData(true), 350, {
      trailing: true
    });
    const loadData = list => {
      const {
        expandAll,
        expandNodeKeys,
        transform
      } = props;
      const {
        initialized,
        scrollYStore
      } = internalData;
      const keyField = computeKeyField.value;
      const parentField = computeParentField.value;
      const childrenField = computeChildrenField.value;
      const fullData = transform ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(list, {
        key: keyField,
        parentKey: parentField,
        mapChildren: childrenField
      }) : list ? list.slice(0) : [];
      internalData.treeFullData = fullData;
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      const sYLoad = updateScrollYStatus(fullData);
      cacheNodeMap();
      handleData(true);
      if (sYLoad) {
        if (!(props.height || props.maxHeight)) {
          errLog('vxe.error.reqProp', ['[tree] height | max-height | virtual-y-config.enabled=false']);
        }
      }
      return computeScrollLoad().then(() => {
        if (!initialized) {
          if (list && list.length) {
            internalData.initialized = true;
            if (expandAll) {
              $xeTree.setAllExpandNode(true);
            } else if (expandNodeKeys && expandNodeKeys.length) {
              $xeTree.setExpandByNodeId(expandNodeKeys, true);
            }
            handleSetCheckboxByNodeId(props.checkNodeKeys || [], true);
          }
        }
        updateHeight();
        refreshScroll();
      });
    };
    const updateScrollYStatus = fullData => {
      const {
        transform
      } = props;
      const virtualYOpts = computeVirtualYOpts.value;
      const allList = fullData || internalData.treeFullData;
      // å¦ægtä¸º0ï¼åæ»æ¯å¯ç¨
      const scrollYLoad = !!transform && !!virtualYOpts.enabled && virtualYOpts.gt > -1 && (virtualYOpts.gt === 0 || virtualYOpts.gt < allList.length);
      reactData.scrollYLoad = scrollYLoad;
      return scrollYLoad;
    };
    const updateYSpace = () => {
      const {
        scrollYLoad
      } = reactData;
      const {
        scrollYStore,
        afterVisibleList
      } = internalData;
      reactData.bodyHeight = scrollYLoad ? afterVisibleList.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          scrollYLoad
        } = reactData;
        const {
          scrollYStore
        } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const virtualYOpts = computeVirtualYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        // è®¡ç® Y é»è¾
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, scrollBodyElem ? Math.ceil(scrollBodyElem.clientHeight / rowHeight) : 0);
          const offsetYSize = Math.max(0, Math.min(2, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualYOpts.oSize)));
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    /**
     * å¦æææ»å¨æ¡ï¼åæ»å¨å°å¯¹åºçä½ç½®
     */
    const handleScrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollLeft) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
          scrollTop = scrollLeft.top;
          scrollLeft = scrollLeft.left;
        }
      }
      if (scrollBodyElem) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
          scrollBodyElem.scrollLeft = scrollLeft;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollTop)) {
          scrollBodyElem.scrollTop = scrollTop;
        }
      }
      if (reactData.scrollYLoad) {
        return new Promise(resolve => {
          setTimeout(() => {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              resolve();
            });
          }, 50);
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * å·æ°æ»å¨æ¡
     */
    const refreshScroll = () => {
      const {
        lastScrollLeft,
        lastScrollTop
      } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    /**
     * éæ°è®¡ç®åè¡¨
     */
    const recalculate = () => {
      const {
        scrollYStore
      } = internalData;
      const {
        rowHeight
      } = scrollYStore;
      const el = refElem.value;
      if (el && el.clientWidth && el.clientHeight) {
        const parentEl = getParentElem();
        const headerWrapperEl = refHeaderWrapperElem.value;
        const footerWrapperEl = refFooterWrapperElem.value;
        const headHeight = headerWrapperEl ? headerWrapperEl.clientHeight : 0;
        const footHeight = footerWrapperEl ? footerWrapperEl.clientHeight : 0;
        if (parentEl) {
          const parentPaddingSize = getPaddingTopBottomSize(parentEl);
          reactData.parentHeight = Math.max(headHeight + footHeight + rowHeight, parentEl.clientHeight - parentPaddingSize - headHeight - footHeight);
        }
        updateHeight();
        return computeScrollLoad().then(() => {
          updateHeight();
          updateYSpace();
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const loadYData = () => {
      const {
        scrollYStore
      } = internalData;
      const {
        startIndex,
        endIndex,
        visibleSize,
        offsetSize,
        rowHeight
      } = scrollYStore;
      const scrollBodyElem = refVirtualWrapper.value;
      if (!scrollBodyElem) {
        return;
      }
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = evnt => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData();
      }
      internalData.lastScrollTime = Date.now();
      dispatchEvent('scroll', {
        scrollLeft,
        scrollTop,
        isX,
        isY
      }, evnt);
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
        scrollBodyElem.scrollLeft = 0;
      }
      internalData.lastScrollTop = 0;
      internalData.lastScrollLeft = 0;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleNodeClickEvent = (evnt, node) => {
      const {
        showRadio,
        showCheckbox,
        trigger
      } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const isRowCurrent = computeIsRowCurrent.value;
      let triggerCurrent = false;
      let triggerRadio = false;
      let triggerCheckbox = false;
      let triggerExpand = false;
      if (isRowCurrent) {
        triggerCurrent = true;
        changeCurrentEvent(evnt, node);
      } else if (reactData.currentNode) {
        reactData.currentNode = null;
      }
      if (trigger === 'node') {
        triggerExpand = true;
        toggleExpandEvent(evnt, node);
      }
      if (showRadio && radioOpts.trigger === 'node') {
        triggerRadio = true;
        changeRadioEvent(evnt, node);
      }
      if (showCheckbox && checkboxOpts.trigger === 'node') {
        triggerCheckbox = true;
        changeCheckboxEvent(evnt, node);
      }
      dispatchEvent('node-click', {
        node,
        triggerCurrent,
        triggerRadio,
        triggerCheckbox,
        triggerExpand
      }, evnt);
    };
    const handleNodeDblclickEvent = (evnt, node) => {
      dispatchEvent('node-dblclick', {
        node
      }, evnt);
    };
    const handleAsyncTreeExpandChilds = node => {
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        loadMethod
      } = props;
      const {
        checkStrictly
      } = checkboxOpts;
      return new Promise(resolve => {
        if (loadMethod) {
          const {
            nodeMaps
          } = internalData;
          const nodeid = getNodeId(node);
          const nodeItem = nodeMaps[nodeid];
          internalData.treeExpandLazyLoadedMaps[nodeid] = true;
          Promise.resolve(loadMethod({
            $tree: $xeTree,
            node
          })).then(childRecords => {
            const {
              treeExpandLazyLoadedMaps
            } = internalData;
            nodeItem.treeLoaded = true;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              treeExpandLazyLoadedMaps[nodeid] = false;
            }
            if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return $xeTree.loadChildrenNode(node, childRecords).then(childRows => {
                const {
                  treeExpandedMaps
                } = internalData;
                if (childRows.length && !treeExpandedMaps[nodeid]) {
                  treeExpandedMaps[nodeid] = true;
                }
                reactData.updateExpandedFlag++;
                // å¦æå½åèç¹å·²éä¸­ï¼åå±å¼åå­èç¹ä¹è¢«éä¸­
                if (!checkStrictly && $xeTree.isCheckedByCheckboxNodeId(nodeid)) {
                  handleCheckedCheckboxNode(childRows, true);
                }
                dispatchEvent('load-success', {
                  node,
                  data: childRecords
                }, new Event('load-success'));
                return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
              });
            } else {
              dispatchEvent('load-success', {
                node,
                data: childRecords
              }, new Event('load-success'));
            }
          }).catch(e => {
            const {
              treeExpandLazyLoadedMaps
            } = internalData;
            nodeItem.treeLoaded = false;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              treeExpandLazyLoadedMaps[nodeid] = false;
            }
            dispatchEvent('load-error', {
              node,
              data: e
            }, new Event('load-error'));
          }).finally(() => {
            handleTreeToList();
            handleData();
            return recalculate();
          });
        } else {
          resolve();
        }
      });
    };
    /**
     * å±å¼ä¸æ¶èµ·æ èç¹
     * @param nodeList
     * @param expanded
     * @returns
     */
    const handleBaseTreeExpand = (nodeList, expanded) => {
      const {
        lazy,
        accordion,
        toggleMethod
      } = props;
      const {
        treeExpandLazyLoadedMaps,
        treeExpandedMaps
      } = internalData;
      const {
        nodeMaps
      } = internalData;
      const childrenField = computeChildrenField.value;
      const hasChildField = computeHasChildField.value;
      const result = [];
      let validNodes = toggleMethod ? nodeList.filter(node => toggleMethod({
        $tree: $xeTree,
        expanded,
        node
      })) : nodeList;
      if (accordion) {
        validNodes = validNodes.length ? [validNodes[validNodes.length - 1]] : [];
        // åä¸çº§åªè½å±å¼ä¸ä¸ª
        const nodeid = getNodeId(validNodes[0]);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          nodeItem.items.forEach(item => {
            const itemNodeId = getNodeId(item);
            if (treeExpandedMaps[itemNodeId]) {
              delete treeExpandedMaps[itemNodeId];
            }
          });
        }
      }
      const expandNodes = [];
      if (expanded) {
        validNodes.forEach(item => {
          const itemNodeId = getNodeId(item);
          if (!treeExpandedMaps[itemNodeId]) {
            const nodeItem = nodeMaps[itemNodeId];
            const isLoad = lazy && item[hasChildField] && !nodeItem.treeLoaded && !treeExpandLazyLoadedMaps[itemNodeId];
            // æ¯å¦ä½¿ç¨æå è½½
            if (isLoad) {
              result.push(handleAsyncTreeExpandChilds(item));
            } else {
              if (item[childrenField] && item[childrenField].length) {
                treeExpandedMaps[itemNodeId] = true;
                expandNodes.push(item);
              }
            }
          }
        });
      } else {
        validNodes.forEach(item => {
          const itemNodeId = getNodeId(item);
          if (treeExpandedMaps[itemNodeId]) {
            delete treeExpandedMaps[itemNodeId];
            expandNodes.push(item);
          }
        });
      }
      reactData.updateExpandedFlag++;
      handleTreeToList();
      handleData();
      return Promise.all(result).then(() => recalculate());
    };
    const toggleExpandEvent = (evnt, node) => {
      const {
        lazy
      } = props;
      const {
        treeExpandedMaps,
        treeExpandLazyLoadedMaps
      } = internalData;
      const nodeid = getNodeId(node);
      const expanded = !treeExpandedMaps[nodeid];
      evnt.stopPropagation();
      if (!lazy || !treeExpandLazyLoadedMaps[nodeid]) {
        handleBaseTreeExpand([node], expanded);
      }
    };
    const updateCheckboxStatus = () => {
      const {
        transform
      } = props;
      const {
        selectCheckboxMaps,
        indeterminateRowMaps,
        afterTreeList
      } = internalData;
      const childrenField = computeChildrenField.value;
      const mapChildrenField = computeMapChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        checkStrictly,
        checkMethod
      } = checkboxOpts;
      if (!checkStrictly) {
        const childRowMaps = {};
        const childRowList = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeList, node => {
          const nodeid = getNodeId(node);
          const childList = node[childrenField];
          if (childList && childList.length && !childRowMaps[nodeid]) {
            childRowMaps[nodeid] = 1;
            childRowList.unshift([node, nodeid, childList]);
          }
        }, {
          children: transform ? mapChildrenField : childrenField
        });
        childRowList.forEach(vals => {
          const node = vals[0];
          const nodeid = vals[1];
          const childList = vals[2];
          let sLen = 0; // å·²é
          let hLen = 0; // åé
          let vLen = 0; // ææå­è¡
          const cLen = childList.length; // å­è¡
          childList.forEach(checkMethod ? item => {
            const childNodeid = getNodeId(item);
            const isSelect = selectCheckboxMaps[childNodeid];
            if (checkMethod({
              $tree: $xeTree,
              node: item
            })) {
              if (isSelect) {
                sLen++;
              } else if (indeterminateRowMaps[childNodeid]) {
                hLen++;
              }
              vLen++;
            } else {
              if (isSelect) {
                sLen++;
              } else if (indeterminateRowMaps[childNodeid]) {
                hLen++;
              }
            }
          } : item => {
            const childNodeid = getNodeId(item);
            const isSelect = selectCheckboxMaps[childNodeid];
            if (isSelect) {
              sLen++;
            } else if (indeterminateRowMaps[childNodeid]) {
              hLen++;
            }
            vLen++;
          });
          let isSelected = false;
          if (cLen > 0) {
            if (vLen > 0) {
              isSelected = (sLen > 0 || hLen > 0) && sLen >= vLen;
            } else {
              // å¦æå­å¨å­é¡¹ç¦ç¨
              if (sLen > 0 && sLen >= vLen) {
                isSelected = true;
              } else if (selectCheckboxMaps[nodeid]) {
                isSelected = true;
              } else {
                isSelected = false;
              }
            }
          } else {
            // å¦ææ å­é¡¹
            isSelected = selectCheckboxMaps[nodeid];
          }
          const halfSelect = !isSelected && (sLen > 0 || hLen > 0);
          if (isSelected) {
            selectCheckboxMaps[nodeid] = node;
            if (indeterminateRowMaps[nodeid]) {
              delete indeterminateRowMaps[nodeid];
            }
          } else {
            if (selectCheckboxMaps[nodeid]) {
              delete selectCheckboxMaps[nodeid];
            }
            if (halfSelect) {
              indeterminateRowMaps[nodeid] = node;
            } else {
              if (indeterminateRowMaps[nodeid]) {
                delete indeterminateRowMaps[nodeid];
              }
            }
          }
        });
        reactData.updateCheckboxFlag++;
      }
    };
    const changeCheckboxEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const {
        transform
      } = props;
      const {
        selectCheckboxMaps
      } = internalData;
      const childrenField = computeChildrenField.value;
      const mapChildrenField = computeMapChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        checkStrictly,
        checkMethod
      } = checkboxOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({
          $tree: $xeTree,
          node
        });
      }
      if (isDisabled) {
        return;
      }
      const nodeid = getNodeId(node);
      let isChecked = false;
      if (selectCheckboxMaps[nodeid]) {
        delete selectCheckboxMaps[nodeid];
      } else {
        isChecked = true;
        selectCheckboxMaps[nodeid] = node;
      }
      if (!checkStrictly) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, transform ? mapChildrenField : childrenField), childNode => {
          const childNodeid = getNodeId(childNode);
          if (isChecked) {
            if (!selectCheckboxMaps[childNodeid]) {
              selectCheckboxMaps[childNodeid] = true;
            }
          } else {
            if (selectCheckboxMaps[childNodeid]) {
              delete selectCheckboxMaps[childNodeid];
            }
          }
        }, {
          children: transform ? mapChildrenField : childrenField
        });
      }
      reactData.updateCheckboxFlag++;
      updateCheckboxStatus();
      const nodeids = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(selectCheckboxMaps);
      const value = nodeids.map(deNodeValue);
      emitCheckboxMode(value);
      dispatchEvent('checkbox-change', {
        node,
        value,
        checked: isChecked
      }, evnt);
    };
    const changeCurrentEvent = (evnt, node) => {
      evnt.preventDefault();
      const nodeOpts = computeNodeOpts.value;
      const {
        currentMethod,
        trigger
      } = nodeOpts;
      const childrenField = computeChildrenField.value;
      const childList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, childrenField);
      const hasChild = childList && childList.length;
      let isDisabled = !!currentMethod;
      if (trigger === 'child') {
        if (hasChild) {
          return;
        }
      } else if (trigger === 'parent') {
        if (!hasChild) {
          return;
        }
      }
      if (currentMethod) {
        isDisabled = !currentMethod({
          node
        });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      reactData.currentNode = node;
      dispatchEvent('current-change', {
        node,
        checked: isChecked
      }, evnt);
    };
    const changeRadioEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const radioOpts = computeRadioOpts.value;
      const {
        checkMethod
      } = radioOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({
          $tree: $xeTree,
          node
        });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      const nodeid = getNodeId(node);
      const value = deNodeValue(nodeid);
      reactData.selectRadioKey = nodeid;
      emitRadioMode(value);
      dispatchEvent('radio-change', {
        node,
        value,
        checked: isChecked
      }, evnt);
    };
    const handleGlobalResizeEvent = () => {
      const el = refElem.value;
      if (!el || !el.clientWidth) {
        return;
      }
      recalculate();
    };
    const treeMethods = {
      dispatchEvent,
      getNodeId,
      getNodeById(nodeid) {
        const {
          nodeMaps
        } = internalData;
        if (nodeid) {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      loadData(data) {
        return loadData(data || []);
      },
      reloadData(data) {
        return loadData(data || []);
      },
      clearCurrentNode() {
        reactData.currentNode = null;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      getCurrentNodeId() {
        const {
          currentNode
        } = reactData;
        if (currentNode) {
          return deNodeValue(getNodeId(currentNode));
        }
        return null;
      },
      getCurrentNode() {
        const {
          currentNode
        } = reactData;
        const {
          nodeMaps
        } = internalData;
        if (currentNode) {
          const nodeItem = nodeMaps[getNodeId(currentNode)];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      setCurrentNodeId(nodeKey) {
        const {
          nodeMaps
        } = internalData;
        const nodeItem = nodeMaps[enNodeValue(nodeKey)];
        reactData.currentNode = nodeItem ? nodeItem.item : null;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setCurrentNode(node) {
        reactData.currentNode = node;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      clearRadioNode() {
        reactData.selectRadioKey = null;
        emitRadioMode(null);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      getRadioNodeId() {
        return reactData.selectRadioKey || null;
      },
      getRadioNode() {
        const {
          selectRadioKey
        } = reactData;
        const {
          nodeMaps
        } = internalData;
        if (selectRadioKey) {
          const nodeItem = nodeMaps[selectRadioKey];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      setRadioNodeId(nodeKey) {
        reactData.selectRadioKey = enNodeValue(nodeKey);
        emitRadioMode(nodeKey);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setRadioNode(node) {
        if (node) {
          const nodeid = getNodeId(node);
          reactData.selectRadioKey = nodeid;
          emitRadioMode(deNodeValue(nodeid));
        } else {
          emitRadioMode(null);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setCheckboxNode(nodeList, checked) {
        if (nodeList) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodeList)) {
            nodeList = [nodeList];
          }
          handleCheckedCheckboxNode(nodeList, checked);
        }
        emitCheckboxMode($xeTree.getCheckboxNodeIds());
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setCheckboxByNodeId(nodeKeys, selected) {
        handleSetCheckboxByNodeId(nodeKeys, selected);
        emitCheckboxMode($xeTree.getCheckboxNodeIds());
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      getCheckboxNodeIds() {
        const {
          selectCheckboxMaps
        } = internalData;
        const nodeKeys = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(selectCheckboxMaps, (item, nodeId) => {
          nodeKeys.push(deNodeValue(nodeId));
        });
        return nodeKeys;
      },
      getCheckboxNodes() {
        const {
          nodeMaps,
          selectCheckboxMaps
        } = internalData;
        const list = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(selectCheckboxMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      clearCheckboxNode() {
        internalData.indeterminateRowMaps = {};
        internalData.selectCheckboxMaps = {};
        reactData.updateCheckboxFlag++;
        emitCheckboxMode([]);
        updateCheckboxStatus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          return {
            checkNodeKeys: [],
            checkNodes: []
          };
        });
      },
      setAllCheckboxNode(checked) {
        const {
          transform
        } = props;
        const selectMaps = {};
        const childrenField = computeChildrenField.value;
        const mapChildrenField = computeMapChildrenField.value;
        const checkKeys = [];
        const checkNodes = [];
        if (checked) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(internalData.afterTreeList, node => {
            const nodeid = getNodeId(node);
            checkKeys.push(nodeid);
            checkNodes.push(node);
            selectMaps[nodeid] = true;
          }, {
            children: transform ? mapChildrenField : childrenField
          });
        }
        internalData.indeterminateRowMaps = {};
        internalData.selectCheckboxMaps = selectMaps;
        reactData.updateCheckboxFlag++;
        updateCheckboxStatus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          return {
            checkNodeKeys: checkKeys,
            checkNodes
          };
        });
      },
      clearExpandNode() {
        return treeMethods.clearAllExpandNode();
      },
      clearAllExpandNode() {
        const {
          nodeMaps,
          scrollYStore
        } = internalData;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(nodeMaps, nodeItem => {
          nodeItem.treeLoaded = false;
        });
        internalData.treeExpandedMaps = {};
        reactData.updateExpandedFlag++;
        reactData.topSpaceHeight = 0;
        scrollYStore.startIndex = 0;
        scrollYStore.endIndex = 1;
        handleTreeToList();
        handleData();
        return recalculate();
      },
      setExpandByNodeId(nodeKeys, expanded) {
        const {
          treeExpandedMaps
        } = internalData;
        if (nodeKeys) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodeKeys)) {
            nodeKeys = [nodeKeys];
          }
          nodeKeys.forEach(nodeKey => {
            const nodeid = enNodeValue(nodeKey);
            handleSetExpand(nodeid, expanded, treeExpandedMaps);
          });
          reactData.updateExpandedFlag++;
        }
        handleTreeToList();
        handleData();
        return recalculate();
      },
      getExpandNodeIds() {
        const {
          treeExpandedMaps
        } = internalData;
        const nodeKeys = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(treeExpandedMaps, (item, nodeId) => {
          nodeKeys.push(deNodeValue(nodeId));
        });
        return nodeKeys;
      },
      getExpandNodes() {
        const {
          nodeMaps,
          treeExpandedMaps
        } = internalData;
        const list = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(treeExpandedMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      setExpandNode(nodes, expanded) {
        const {
          treeExpandedMaps
        } = internalData;
        if (nodes) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach(node => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, expanded, treeExpandedMaps);
          });
          reactData.updateExpandedFlag++;
        }
        handleTreeToList();
        handleData();
        return recalculate();
      },
      toggleExpandByNodeId(nodeKeys) {
        const {
          treeExpandedMaps
        } = internalData;
        if (nodeKeys) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodeKeys)) {
            nodeKeys = [nodeKeys];
          }
          nodeKeys.forEach(nodeKey => {
            const nodeid = enNodeValue(nodeKey);
            handleSetExpand(nodeid, !treeExpandedMaps[`${nodeid}`], treeExpandedMaps);
          });
          reactData.updateExpandedFlag++;
        }
        handleTreeToList();
        handleData();
        return recalculate();
      },
      toggleExpandNode(nodes) {
        const {
          treeExpandedMaps
        } = internalData;
        if (nodes) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach(node => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, !treeExpandedMaps[nodeid], treeExpandedMaps);
          });
          reactData.updateExpandedFlag++;
        }
        handleTreeToList();
        handleData();
        return recalculate();
      },
      setAllExpandNode(expanded) {
        const {
          transform
        } = props;
        const {
          scrollYLoad
        } = reactData;
        const {
          scrollYStore,
          treeExpandedMaps
        } = internalData;
        const childrenField = computeChildrenField.value;
        const mapChildrenField = computeMapChildrenField.value;
        if (expanded) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(internalData.afterTreeList, node => {
            const childList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, childrenField);
            const hasChild = childList && childList.length;
            if (hasChild) {
              const nodeid = getNodeId(node);
              treeExpandedMaps[nodeid] = true;
            }
          }, {
            children: transform ? mapChildrenField : childrenField
          });
        } else {
          internalData.treeExpandedMaps = {};
        }
        reactData.updateExpandedFlag++;
        reactData.topSpaceHeight = 0;
        scrollYStore.startIndex = 0;
        scrollYStore.endIndex = 1;
        handleTreeToList();
        handleData();
        return recalculate().then(() => {
          if (scrollYLoad) {
            loadYData();
          }
          return recalculate();
        });
      },
      reloadExpandNode(node) {
        const {
          lazy
        } = props;
        if (lazy) {
          treeMethods.clearExpandLoaded(node);
          return handleAsyncTreeExpandChilds(node);
        }
        return recalculate();
      },
      clearExpandLoaded(node) {
        const {
          lazy
        } = props;
        const {
          nodeMaps
        } = internalData;
        if (lazy) {
          const nodeItem = nodeMaps[getNodeId(node)];
          if (nodeItem) {
            nodeItem.treeLoaded = false;
          }
        }
        return recalculate();
      },
      /**
       * ç¨äºæ ç»æï¼ç»è¡æ°æ®å è½½å­èç¹
       */
      loadChildrenNode(node, childRecords) {
        const {
          lazy,
          transform
        } = props;
        const {
          nodeMaps
        } = internalData;
        if (!lazy) {
          return Promise.resolve([]);
        }
        const childrenField = computeChildrenField.value;
        const mapChildrenField = computeMapChildrenField.value;
        const parentNodeItem = nodeMaps[getNodeId(node)];
        const parentLevel = parentNodeItem ? parentNodeItem.level : 0;
        const parentNodes = parentNodeItem ? parentNodeItem.nodes : [];
        return createNode(childRecords).then(nodeList => {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(nodeList, (childRow, index, items, path, parent, nodes) => {
            const itemNodeId = getNodeId(childRow);
            nodeMaps[itemNodeId] = {
              item: childRow,
              index: -1,
              items,
              parent: parent || parentNodeItem.item,
              nodes: parentNodes.concat(nodes),
              level: parentLevel + nodes.length,
              treeIndex: -1,
              lineCount: 0,
              treeLoaded: false
            };
          }, {
            children: childrenField
          });
          node[childrenField] = nodeList;
          if (transform) {
            node[mapChildrenField] = nodeList;
          }
          updateAfterDataIndex();
          return nodeList;
        });
      },
      isExpandByNode,
      isCheckedByRadioNodeId,
      isCheckedByRadioNode,
      isCheckedByCheckboxNodeId,
      isIndeterminateByCheckboxNode,
      isCheckedByCheckboxNode,
      getCheckboxIndeterminateNodes() {
        const {
          nodeMaps,
          indeterminateRowMaps
        } = internalData;
        const list = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(indeterminateRowMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      recalculate,
      scrollTo: handleScrollTo,
      scrollToNode(node) {
        return $xeTree.scrollToNodeId(getNodeId(node));
      },
      scrollToNodeId(nodeid) {
        const {
          transform
        } = props;
        const {
          scrollYStore,
          afterTreeList
        } = internalData;
        const childrenField = computeChildrenField.value;
        const mapChildrenField = computeMapChildrenField.value;
        const scrollBodyElem = refVirtualWrapper.value;
        if (nodeid && scrollBodyElem) {
          if (transform) {
            const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(afterTreeList, item => getNodeId(item) === nodeid, {
              children: transform ? mapChildrenField : childrenField
            });
            if (matchObj) {
              return $xeTree.setExpandNode(matchObj.nodes, true).then(() => {
                const itemIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(internalData.afterVisibleList, item => getNodeId(item) === nodeid);
                if (itemIndex > -1) {
                  const targetTop = Math.max(0, (itemIndex - 1) * scrollYStore.rowHeight);
                  return handleScrollTo(scrollBodyElem.scrollLeft, targetTop);
                }
              });
            }
          } else {
            const itemEl = scrollBodyElem.querySelector(`.vxe-tree--node-wrapper[nodeid="${nodeid}"]`);
            if (itemEl) {
              return handleScrollTo(scrollBodyElem.scrollLeft, itemEl.offsetTop);
            }
          }
        }
        return recalculate();
      },
      clearScroll
    };
    const treePrivateMethods = {};
    Object.assign($xeTree, treeMethods, treePrivateMethods);
    const renderRadio = (node, nodeid, isChecked) => {
      const {
        showRadio
      } = props;
      const radioOpts = computeRadioOpts.value;
      const {
        showIcon,
        checkMethod,
        visibleMethod
      } = radioOpts;
      const isVisible = !visibleMethod || visibleMethod({
        $tree: $xeTree,
        node
      });
      let isDisabled = !!checkMethod;
      if (showRadio && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({
            $tree: $xeTree,
            node
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-tree--radio-option', {
            'is--checked': isChecked,
            'is--disabled': isDisabled
          }],
          onClick: evnt => {
            if (!isDisabled) {
              changeRadioEvent(evnt, node);
            }
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-radio--icon', isChecked ? getIcon().RADIO_CHECKED : getIcon().RADIO_UNCHECKED]
        })]);
      }
      return renderEmptyElement($xeTree);
    };
    const renderCheckbox = (node, nodeid, isChecked) => {
      const {
        showCheckbox
      } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        showIcon,
        checkMethod,
        visibleMethod
      } = checkboxOpts;
      const isIndeterminate = isIndeterminateByCheckboxNodeid(nodeid);
      const isVisible = !visibleMethod || visibleMethod({
        $tree: $xeTree,
        node
      });
      let isDisabled = !!checkMethod;
      if (showCheckbox && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({
            $tree: $xeTree,
            node
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-tree--checkbox-option', {
            'is--checked': isChecked,
            'is--indeterminate': isIndeterminate,
            'is--disabled': isDisabled
          }],
          onClick: evnt => {
            if (!isDisabled) {
              changeCheckboxEvent(evnt, node);
            }
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-checkbox--icon', isIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
        })]);
      }
      return renderEmptyElement($xeTree);
    };
    const renderNode = (node, nodeid) => {
      const {
        lazy,
        showRadio,
        showCheckbox,
        showLine,
        indent,
        iconOpen,
        iconClose,
        iconLoaded,
        showIcon
      } = props;
      const {
        currentNode,
        selectRadioKey,
        updateExpandedFlag
      } = reactData;
      const {
        afterTreeList,
        nodeMaps,
        treeExpandedMaps,
        treeExpandLazyLoadedMaps
      } = internalData;
      const childrenField = computeChildrenField.value;
      const titleField = computeTitleField.value;
      const hasChildField = computeHasChildField.value;
      const childList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, childrenField);
      const hasChild = childList && childList.length;
      const iconSlot = slots.icon;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const isExpand = updateExpandedFlag && treeExpandedMaps[nodeid];
      const nodeItem = nodeMaps[nodeid];
      const nodeValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, titleField);
      const nLevel = nodeItem.level;
      let isRadioChecked = false;
      if (showRadio) {
        isRadioChecked = nodeid === String(selectRadioKey);
      }
      let isCheckboxChecked = false;
      if (showCheckbox) {
        isCheckboxChecked = isCheckedByCheckboxNodeId(nodeid);
      }
      let hasLazyChilds = false;
      let isLazyLoading = false;
      let isLazyLoaded = false;
      if (lazy) {
        isLazyLoading = !!treeExpandLazyLoadedMaps[nodeid];
        hasLazyChilds = node[hasChildField];
        isLazyLoaded = !!nodeItem.treeLoaded;
      }
      const prevNode = nodeItem.items[nodeItem.treeIndex - 1];
      const nParams = {
        node,
        isExpand
      };
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: nodeid,
        class: ['vxe-tree--node-wrapper', `node--level-${nLevel}`],
        nodeid
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-tree--node-item', {
          'is--current': currentNode && nodeid === getNodeId(currentNode),
          'is-radio--checked': isRadioChecked,
          'is-checkbox--checked': isCheckboxChecked
        }],
        style: {
          paddingLeft: `${(nLevel - 1) * (indent || 1)}px`
        },
        onClick(evnt) {
          handleNodeClickEvent(evnt, node);
        },
        onDblclick(evnt) {
          handleNodeDblclickEvent(evnt, node);
        }
      }, [showLine ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-line-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-line',
        style: {
          height: `${getNodeId(afterTreeList[0]) === nodeid ? 1 : calcTreeLine($xeTree, node, prevNode)}px`
        }
      })]) : renderEmptyElement($xeTree), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-switcher'
      }, showIcon && (lazy ? isLazyLoaded ? hasChild : hasLazyChilds : hasChild) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-icon',
        onClick(evnt) {
          toggleExpandEvent(evnt, node);
        }
      }, iconSlot ? vn_getSlotVNs(iconSlot(nParams)) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: isLazyLoading ? iconLoaded || getIcon().TREE_NODE_LOADED : isExpand ? iconOpen || getIcon().TREE_NODE_OPEN : iconClose || getIcon().TREE_NODE_CLOSE
      })])] : []), renderRadio(node, nodeid, isRadioChecked), renderCheckbox(node, nodeid, isCheckboxChecked), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-inner'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-title'
      }, titleSlot ? vn_getSlotVNs(titleSlot(nParams)) : `${nodeValue}`), extraSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-extra'
      }, vn_getSlotVNs(extraSlot(nParams))) : renderEmptyElement($xeTree)])])]);
    };
    const renderList = treeList => {
      const {
        transform
      } = props;
      const {
        treeExpandedMaps
      } = internalData;
      const childrenField = computeChildrenField.value;
      if (!treeList.length) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tree--empty-placeholder'
        }, getI18n('vxe.tree.searchEmpty'))];
      }
      const nodeVNs = [];
      treeList.forEach(transform ? node => {
        const nodeid = getNodeId(node);
        nodeVNs.push(renderNode(node, nodeid));
      } : node => {
        const nodeid = getNodeId(node);
        nodeVNs.push(renderNode(node, nodeid));
        const childList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, childrenField);
        const hasChild = childList && childList.length;
        if (hasChild && treeExpandedMaps[nodeid]) {
          nodeVNs.push(...renderList(childList));
        }
      });
      return nodeVNs;
    };
    const renderVN = () => {
      const {
        loading,
        trigger,
        showLine
      } = props;
      const {
        bodyHeight,
        topSpaceHeight,
        treeList
      } = reactData;
      const vSize = computeSize.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const loadingOpts = computeLoadingOpts.value;
      const isRowHover = computeIsRowHover.value;
      const treeStyle = computeTreeStyle.value;
      const loadingSlot = slots.loading;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tree', {
          [`size--${vSize}`]: vSize,
          'show--line': showLine,
          'checkbox--highlight': checkboxOpts.highlight,
          'radio--highlight': radioOpts.highlight,
          'node--hover': isRowHover,
          'node--trigger': trigger === 'node',
          'is--loading': loading
        }]
      }, [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeaderWrapperElem,
        class: 'vxe-tree--header-wrapper'
      }, headerSlot({
        $tree: $xeTree
      })) : renderEmptyElement($xeTree), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualWrapper,
        class: 'vxe-tree--node-list-wrapper',
        style: treeStyle,
        onScroll: scrollEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--y-space',
        style: {
          height: bodyHeight ? `${bodyHeight}px` : ''
        }
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualBody,
        class: 'vxe-tree--node-list-body',
        style: {
          transform: `translateY(${topSpaceHeight}px)`
        }
      }, renderList(treeList))]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refFooterWrapperElem,
        class: 'vxe-tree--footer-wrapper'
      }, footerSlot({
        $tree: $xeTree
      })) : renderEmptyElement($xeTree),
      /**
       * å è½½ä¸­
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-tree--loading',
        modelValue: loading,
        icon: loadingOpts.icon,
        text: loadingOpts.text
      }, loadingSlot ? {
        default: () => loadingSlot({
          $tree: $xeTree
        })
      } : {})]);
    };
    const dataFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data ? props.data.length : 0, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(dataFlag, () => {
      loadData(props.data || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.checkNodeKey, nodeKey => {
      reactData.selectRadioKey = enNodeValue(nodeKey);
    });
    const checkboxFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.checkNodeKeys ? props.checkNodeKeys.length : 0, () => {
      checkboxFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.checkNodeKeys, () => {
      checkboxFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(checkboxFlag, () => {
      updateCheckboxChecked(props.checkNodeKeys || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.filterValue, () => {
      triggerSearchEvent(new Event('filter'));
    });
    const hFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, () => {
      hFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.minHeight, () => {
      hFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.maxHeight, () => {
      hFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(hFlag, () => {
      recalculate();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if (props.autoResize) {
        const el = refElem.value;
        const parentEl = getParentElem();
        const resizeObserver = globalResize.create(() => {
          if (props.autoResize) {
            recalculate();
          }
        });
        if (el) {
          resizeObserver.observe(el);
        }
        if (parentEl) {
          resizeObserver.observe(parentEl);
        }
        internalData.resizeObserver = resizeObserver;
      }
      globalEvents.on($xeTree, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      const {
        resizeObserver
      } = internalData;
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeTree, 'resize');
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData, tree_createInternalData());
    });
    loadData(props.data || []);
    $xeTree.renderVN = renderVN;
    return $xeTree;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tree/index.ts



const VxeTree = Object.assign({}, tree, {
  install(app) {
    app.component(tree.name, tree);
  }
});
dynamicApp.use(VxeTree);
index_esm_VxeUI.component(tree);
const Tree = VxeTree;
/* harmony default export */ var packages_tree = (VxeTree);
;// CONCATENATED MODULE: ./packages/tree-select/src/tree-select.ts











function tree_select_getOptUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('node_');
}
function tree_select_createInternalData() {
  return {
    // hpTimeout: undefined,
    fullOptionList: [],
    fullNodeMaps: {}
  };
}
/* harmony default export */ var tree_select = (defineVxeComponent({
  name: 'VxeTreeSelect',
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(getConfig().treeSelect.placeholder) ? getI18n('vxe.base.pleaseSelect') : getConfig().treeSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    filterable: Boolean,
    filterConfig: Object,
    multiple: Boolean,
    className: [String, Function],
    popupClassName: [String, Function],
    prefixIcon: String,
    placement: String,
    lazyOptions: Array,
    options: Array,
    optionProps: Object,
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().treeSelect.size || getConfig().size
    },
    remote: Boolean,
    remoteConfig: Function,
    popupConfig: Object,
    treeConfig: Object,
    virtualYConfig: Object,
    autoClose: {
      type: Boolean,
      default: () => getConfig().treeSelect.autoClose
    },
    showTotalButoon: {
      type: Boolean,
      default: () => getConfig().treeSelect.showTotalButoon
    },
    showCheckedButoon: {
      type: Boolean,
      default: () => getConfig().treeSelect.showCheckedButoon
    },
    showClearButton: {
      type: Boolean,
      default: () => getConfig().treeSelect.showClearButton
    },
    showExpandButton: {
      type: Boolean,
      default: () => getConfig().treeSelect.showExpandButton
    },
    transfer: {
      type: Boolean,
      default: null
    },
    /**
     * å·²åºå¼ï¼è¢« remote-config.queryMethod æ¿æ¢
     * @deprecated
     */
    remoteMethod: Function
  },
  emits: ['update:modelValue', 'change', 'all-change', 'clear', 'blur', 'focus', 'click', 'node-click'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInpSearch = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTreeWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTree = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      searchValue: '',
      searchLoading: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = tree_select_createInternalData();
    const refMaps = {
      refElem
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computePopupOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().treeSelect.popupConfig, props.popupConfig);
    });
    const computeTreeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().treeSelect.treeConfig, props.treeConfig, {
        data: undefined
      });
    });
    const computeTreeNodeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        isHover: true
      }, treeOpts.nodeConfig);
    });
    const computeTreeCheckboxOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showCheckbox
      }, treeOpts.checkboxConfig, {
        trigger: 'node'
      });
    });
    const computeTreeRadioOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showRadio
      }, treeOpts.radioConfig, {
        trigger: 'node'
      });
    });
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.optionProps || {};
    });
    const computeNodeKeyField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const treeOpts = computeTreeOpts.value;
      return treeOpts.keyField || 'id';
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeChildrenField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.children || 'children';
    });
    const computeParentField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.parent || 'parentField';
    });
    const computeHasChildField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.hasChild || 'hasChild';
    });
    const computeVirtualYOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().treeSelect.virtualYConfig, props.virtualYConfig);
    });
    const computeRemoteOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().treeSelect.remoteConfig, props.remoteConfig);
    });
    const computeFilterOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({}, treeOpts.filterConfig, props.filterConfig);
    });
    const computeSelectLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        lazyOptions
      } = props;
      const {
        fullNodeMaps
      } = internalData;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const selectVals = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(modelValue) ? [] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue];
      return selectVals.map(val => {
        const cacheItem = fullNodeMaps[val];
        if (cacheItem) {
          return cacheItem.item[labelField];
        }
        if (lazyOptions) {
          const lazyItem = lazyOptions.find(item => item[valueField] === val);
          if (lazyItem) {
            return lazyItem[labelField];
          }
        }
        return val;
      }).join(', ');
    });
    const computePopupWrapperStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const popupOpts = computePopupOpts.value;
      const {
        height,
        width
      } = popupOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
        stys.maxHeight = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeTreeSelect = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $treeSelect: $xeTreeSelect
      }, params));
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const treeSelectMethods = {
      dispatchEvent
    };
    const getNodeid = option => {
      const nodeKeyField = computeNodeKeyField.value;
      const nodeid = option[nodeKeyField];
      return nodeid ? encodeURIComponent(nodeid) : '';
    };
    const cacheDataMap = () => {
      const {
        options
      } = props;
      const treeOpts = computeTreeOpts.value;
      const nodeKeyField = computeNodeKeyField.value;
      const childrenField = computeChildrenField.value;
      const valueField = computeValueField.value;
      const {
        transform
      } = treeOpts;
      const nodeMaps = {};
      const keyMaps = {};
      const handleOptNode = (item, index, items, path, parent, nodes) => {
        let nodeid = getNodeid(item);
        if (!nodeid) {
          nodeid = tree_select_getOptUniqueId();
        }
        if (keyMaps[nodeid]) {
          errLog('vxe.error.repeatKey', [`[tree-select] ${nodeKeyField}`, nodeid]);
        }
        keyMaps[nodeid] = true;
        const value = item[valueField];
        if (nodeMaps[value]) {
          errLog('vxe.error.repeatKey', [`[tree-select] ${valueField}`, value]);
        }
        nodeMaps[value] = {
          item,
          index,
          items,
          parent,
          nodes
        };
      };
      if (options) {
        if (transform) {
          options.forEach((item, index, items) => {
            handleOptNode(item, index, items, [], null, []);
          });
        } else {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(options, handleOptNode, {
            children: childrenField
          });
        }
      }
      internalData.fullOptionList = options || [];
      internalData.fullNodeMaps = nodeMaps;
    };
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refElem.value;
      const panelElem = refOptionPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const showOptionPanel = () => {
      const {
        loading,
        remote,
        filterable
      } = props;
      const {
        fullOptionList
      } = internalData;
      const isDisabled = computeIsDisabled.value;
      const remoteOpts = computeRemoteOpts.value;
      if (!loading && !isDisabled) {
        clearTimeout(internalData.hpTimeout);
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (filterable) {
          if (remote && remoteOpts.enabled && remoteOpts.autoLoad && !fullOptionList.length) {
            handleSearchEvent();
          }
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
          handleFocusSearch();
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue, node) => {
      const value = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(selectValue) ? selectValue.map(deNodeValue) : deNodeValue(selectValue);
      emitModel(value);
      if (value !== props.modelValue) {
        dispatchEvent('change', {
          value,
          node,
          option: node
        }, evnt);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue, null);
      dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const allCheckedPanelEvent = params => {
      const {
        $event
      } = params;
      const {
        multiple,
        autoClose
      } = props;
      const $tree = refTree.value;
      if (multiple) {
        if ($tree) {
          $tree.setAllCheckboxNode(true).then(({
            checkNodeKeys,
            checkNodes
          }) => {
            changeEvent($event, checkNodeKeys, checkNodes[0]);
            dispatchEvent('all-change', {
              value: checkNodeKeys
            }, $event);
            if (autoClose) {
              hideOptionPanel();
            }
          });
        }
      }
    };
    const clearCheckedPanelEvent = params => {
      const {
        $event
      } = params;
      const {
        multiple,
        autoClose
      } = props;
      const $tree = refTree.value;
      if ($tree) {
        const value = multiple ? [] : null;
        $tree.clearCheckboxNode().then(() => {
          if (autoClose) {
            hideOptionPanel();
          }
        });
        changeEvent($event, value, null);
        dispatchEvent('clear', {
          value
        }, $event);
      }
    };
    const allExpandPanelEvent = () => {
      const $tree = refTree.value;
      if ($tree) {
        $tree.setAllExpandNode(true);
      }
    };
    const clearExpandPanelEvent = () => {
      const $tree = refTree.value;
      if ($tree) {
        $tree.clearAllExpandNode();
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const handleFocusSearch = () => {
      if (props.filterable) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    const focusEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent('focus', {}, evnt);
    };
    const clickEvent = evnt => {
      togglePanelEvent(evnt);
      dispatchEvent('click', {}, evnt);
    };
    const blurEvent = evnt => {
      reactData.isActivated = false;
      dispatchEvent('blur', {}, evnt);
    };
    const modelSearchEvent = value => {
      reactData.searchValue = value;
    };
    const handleSearchEvent = () => {
      const {
        modelValue,
        remote,
        remoteMethod
      } = props;
      const {
        searchValue
      } = reactData;
      const remoteOpts = computeRemoteOpts.value;
      const queryMethod = remoteOpts.queryMethod || remoteMethod;
      if (remote && queryMethod && remoteOpts.enabled) {
        reactData.searchLoading = true;
        Promise.resolve(queryMethod({
          $treeSelect: $xeTreeSelect,
          searchValue,
          value: modelValue
        })).then(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).catch(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).finally(() => {
          reactData.searchLoading = false;
        });
      }
    };
    const togglePanelEvent = params => {
      const {
        $event
      } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const nodeClickEvent = params => {
      const {
        $event
      } = params;
      dispatchEvent('node-click', params, $event);
    };
    const radioChangeEvent = params => {
      const {
        value,
        $event,
        node
      } = params;
      changeEvent($event, value, node);
      hideOptionPanel();
    };
    const checkboxChangeEvent = params => {
      const {
        value,
        $event,
        node
      } = params;
      changeEvent($event, value, node);
    };
    const loadSuccessEvent = () => {
      cacheDataMap();
    };
    const treeSelectPrivateMethods = {};
    Object.assign($xeTreeSelect, treeSelectMethods, treeSelectPrivateMethods);
    const renderVN = () => {
      const {
        className,
        modelValue,
        multiple,
        options,
        loading,
        filterable,
        showTotalButoon,
        showCheckedButoon,
        showClearButton,
        showExpandButton
      } = props;
      const {
        initialized,
        isActivated,
        isAniVisible,
        visiblePanel,
        searchValue
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const popupWrapperStyle = computePopupWrapperStyle.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      const popupOpts = computePopupOpts.value;
      const popupClassName = popupOpts.className || props.popupClassName;
      const treeOpts = computeTreeOpts.value;
      const treeNodeOpts = computeTreeNodeOpts.value;
      const treeCheckboxOpts = computeTreeCheckboxOpts.value;
      const treeRadioOpts = computeTreeRadioOpts.value;
      const nodeKeyField = computeNodeKeyField.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const parentField = computeParentField.value;
      const hasChildField = computeHasChildField.value;
      const virtualYOpts = computeVirtualYOpts.value;
      const filterOpts = computeFilterOpts.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-tree-select--readonly', className]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-tree-select-label'
        }, selectLabel)]);
      }
      const selectVals = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(modelValue) ? [] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue];
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tree-select', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $treeSelect: $xeTreeSelect
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--filterable': filterable,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--loading': loading,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInput,
        clearable: props.clearable,
        placeholder: loading ? getI18n('vxe.select.loadingText') : props.placeholder,
        readonly: true,
        disabled: isDisabled,
        type: 'text',
        prefixIcon: props.prefixIcon,
        suffixIcon: loading ? getIcon().TREE_SELECT_LOADED : visiblePanel ? getIcon().TREE_SELECT_OPEN : getIcon().TREE_SELECT_CLOSE,
        modelValue: loading ? '' : selectLabel,
        title: selectLabel,
        onClear: clearEvent,
        onClick: clickEvent,
        onFocus: focusEvent,
        onBlur: blurEvent,
        onSuffixClick: togglePanelEvent
      }, prefixSlot ? {
        prefix: () => prefixSlot({})
      } : {}), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-tree-select--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $treeSelect: $xeTreeSelect
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': !loading && isAniVisible,
          'ani--enter': !loading && visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, initialized ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-wrapper'
      }, [filterable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-search'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInpSearch,
        class: 'vxe-tree-select-search--input',
        modelValue: searchValue,
        clearable: true,
        disabled: false,
        readonly: false,
        placeholder: getI18n('vxe.treeSelect.search'),
        prefixIcon: getIcon().INPUT_SEARCH,
        'onUpdate:modelValue': modelSearchEvent
      })]) : renderEmptyElement($xeTreeSelect), showTotalButoon || showCheckedButoon && multiple || showClearButton || showExpandButton || headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-header'
      }, headerSlot ? headerSlot({}) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--header-button'
      }, [showTotalButoon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--header-total'
      }, getI18n('vxe.treeSelect.total', [selectVals.length])) : renderEmptyElement($xeTreeSelect), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--header-btns'
      }, [showCheckedButoon && multiple ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.treeSelect.allChecked'),
        mode: 'text',
        onClick: allCheckedPanelEvent
      }) : renderEmptyElement($xeTreeSelect), showClearButton ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.treeSelect.clearChecked'),
        mode: 'text',
        onClick: clearCheckedPanelEvent
      }) : renderEmptyElement($xeTreeSelect), showExpandButton ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.treeSelect.allExpand'),
        mode: 'text',
        onClick: allExpandPanelEvent
      }) : renderEmptyElement($xeTreeSelect), showExpandButton ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.treeSelect.clearExpand'),
        mode: 'text',
        onClick: clearExpandPanelEvent
      }) : renderEmptyElement($xeTreeSelect)])])]) : renderEmptyElement($xeTreeSelect), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refTreeWrapper,
        class: 'vxe-tree-select-tree--wrapper',
        style: popupWrapperStyle
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tree, {
        ref: refTree,
        class: 'vxe-tree-select--tree',
        height: popupOpts.height ? '100%' : treeOpts.height,
        minHeight: treeOpts.minHeight,
        maxHeight: popupOpts.height ? '' : treeOpts.maxHeight,
        autoResize: true,
        data: options,
        indent: treeOpts.indent,
        showRadio: !multiple,
        radioConfig: treeRadioOpts,
        checkNodeKey: multiple ? null : modelValue,
        showCheckbox: !!multiple,
        checkNodeKeys: multiple ? modelValue : null,
        checkboxConfig: treeCheckboxOpts,
        titleField: labelField,
        valueField: valueField,
        keyField: nodeKeyField,
        childrenField: treeOpts.childrenField || childrenField,
        parentField: treeOpts.parentField || parentField,
        hasChildField: treeOpts.hasChildField || hasChildField,
        accordion: treeOpts.accordion,
        expandAll: treeOpts.expandAll,
        expandNodeKeys: treeOpts.expandNodeKeys,
        nodeConfig: treeNodeOpts,
        lazy: treeOpts.lazy,
        loadMethod: treeOpts.loadMethod,
        toggleMethod: treeOpts.toggleMethod,
        transform: treeOpts.transform,
        trigger: treeOpts.trigger,
        showIcon: treeOpts.showIcon,
        showLine: treeOpts.showLine,
        iconOpen: treeOpts.iconOpen,
        iconLoaded: treeOpts.iconLoaded,
        iconClose: treeOpts.iconClose,
        filterValue: searchValue,
        filterConfig: filterOpts,
        virtualYConfig: virtualYOpts,
        onNodeClick: nodeClickEvent,
        onRadioChange: radioChangeEvent,
        onCheckboxChange: checkboxChangeEvent,
        onLoadSuccess: loadSuccessEvent
      })])]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-footer'
      }, footerSlot({})) : renderEmptyElement($xeTreeSelect)])] : [])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      cacheDataMap();
    });
    cacheDataMap();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeTreeSelect, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeTreeSelect, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeTreeSelect, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xeTreeSelect, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeTreeSelect, 'mousewheel');
      globalEvents.off($xeTreeSelect, 'mousedown');
      globalEvents.off($xeTreeSelect, 'blur');
      globalEvents.off($xeTreeSelect, 'resize');
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData, tree_select_createInternalData());
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeTreeSelect', $xeTreeSelect);
    $xeTreeSelect.renderVN = renderVN;
    return $xeTreeSelect;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tree-select/index.ts



const VxeTreeSelect = Object.assign({}, tree_select, {
  install(app) {
    app.component(tree_select.name, tree_select);
  }
});
dynamicApp.use(VxeTreeSelect);
index_esm_VxeUI.component(tree_select);
const TreeSelect = VxeTreeSelect;
/* harmony default export */ var packages_tree_select = (VxeTreeSelect);
;// CONCATENATED MODULE: ./packages/upload/src/util.ts





// å¯¼å¥
let fileForm = null;
let fileInput = null;
function parseFile(file) {
  const name = file.name;
  const tIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().lastIndexOf(name, '.');
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return {
    filename,
    type
  };
}
/**
 * è¯»åæ¬å°æä»¶
 */
const readLocalFile = options => {
  const opts = Object.assign({}, options);
  return new Promise((resolve, reject) => {
    if (!fileInput) {
      fileInput = document.createElement('input');
      fileInput.name = 'file';
      fileInput.type = 'file';
    }
    if (!fileForm) {
      fileForm = document.createElement('form');
      fileForm.style.display = 'none';
      fileForm.appendChild(fileInput);
      document.body.appendChild(fileForm);
    }
    const types = opts.types || [];
    const isAllType = !types.length || types.some(type => type === '*');
    fileInput.multiple = !!opts.multiple;
    fileInput.accept = isAllType ? '' : `.${types.join(', .')}`;
    fileInput.onchange = evnt => {
      const eventTarget = evnt.target;
      const files = Array.from(eventTarget.files || []);
      const file = files[0];
      let errType = '';
      // æ ¡éªç±»å
      if (!isAllType) {
        for (let fIndex = 0; fIndex < files.length; fIndex++) {
          const {
            type
          } = parseFile(files[fIndex]);
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(types, type)) {
            errType = type;
            break;
          }
        }
      }
      if (!errType) {
        resolve({
          status: true,
          files,
          file
        });
      } else {
        if (opts.message !== false) {
          if (index_esm_VxeUI.modal) {
            index_esm_VxeUI.modal.message({
              content: getI18n('vxe.error.notType', [errType]),
              status: 'error'
            });
          }
        }
        const params = {
          status: false,
          files,
          file
        };
        reject(params);
      }
    };
    fileForm.reset();
    fileInput.click();
  });
};
function getExportBlobByContent(content, options) {
  return new Blob([content], {
    type: `text/${options.type};charset=utf-8;`
  });
}
/**
 * ä¿å­æä»¶å°æ¬å°
 */
const saveLocalFile = options => {
  const opts = Object.assign({
    type: ''
  }, options);
  const {
    filename,
    type,
    content
  } = opts;
  const name = type ? `${filename}.${type}` : `${filename}`;
  if (window.Blob) {
    const blob = content instanceof Blob ? content : getExportBlobByContent(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content), opts);
    const winNavigator = window.navigator;
    if (winNavigator.msSaveBlob) {
      winNavigator.msSaveBlob(blob, name);
    } else {
      const url = URL.createObjectURL(blob);
      const linkElem = document.createElement('a');
      linkElem.target = '_blank';
      linkElem.download = name;
      linkElem.href = url;
      document.body.appendChild(linkElem);
      linkElem.click();
      requestAnimationFrame(() => {
        if (linkElem.parentNode) {
          linkElem.parentNode.removeChild(linkElem);
        }
        URL.revokeObjectURL(url);
      });
    }
    return Promise.resolve();
  }
  return Promise.reject(new Error(getI18n('vxe.error.notExp')));
};
;// CONCATENATED MODULE: ./packages/upload/src/upload.ts













/* harmony default export */ var upload = (defineVxeComponent({
  name: 'VxeUpload',
  props: {
    modelValue: [Array, String, Object],
    showList: {
      type: Boolean,
      default: () => getConfig().upload.showList
    },
    moreConfig: Object,
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    autoSubmit: {
      type: Boolean,
      default: () => getConfig().upload.autoSubmit
    },
    mode: {
      type: String,
      default: () => getConfig().upload.mode
    },
    imageTypes: {
      type: Array,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.imageTypes, true)
    },
    imageConfig: {
      type: Object,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.imageConfig, true)
    },
    /**
     * å·²åºå¼ï¼è¢« image-config æ¿æ¢
     * @deprecated
     */
    imageStyle: {
      type: Object,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.imageStyle, true)
    },
    fileTypes: {
      type: Array,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.fileTypes, true)
    },
    dragSort: Boolean,
    dragToUpload: {
      type: Boolean,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.dragToUpload, true)
    },
    pasteToUpload: {
      type: Boolean,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.pasteToUpload, true)
    },
    keyField: String,
    singleMode: Boolean,
    urlMode: Boolean,
    urlArgs: {
      type: Boolean,
      default: () => getConfig().upload.urlArgs
    },
    multiple: Boolean,
    limitSize: {
      type: [String, Number],
      default: () => getConfig().upload.limitSize
    },
    showLimitSize: {
      type: Boolean,
      default: () => getConfig().upload.showLimitSize
    },
    limitSizeText: {
      type: [String, Number, Function],
      default: () => getConfig().upload.limitSizeText
    },
    limitCount: {
      type: [String, Number],
      default: () => getConfig().upload.limitCount
    },
    showLimitCount: {
      type: Boolean,
      default: () => getConfig().upload.showLimitCount
    },
    limitCountText: {
      type: [String, Number, Function],
      default: () => getConfig().upload.limitCountText
    },
    nameField: {
      type: String,
      default: () => getConfig().upload.nameField
    },
    typeField: {
      type: String,
      default: () => getConfig().upload.typeField
    },
    urlField: {
      type: String,
      default: () => getConfig().upload.urlField
    },
    sizeField: {
      type: String,
      default: () => getConfig().upload.sizeField
    },
    showErrorStatus: {
      type: Boolean,
      default: () => getConfig().upload.showErrorStatus
    },
    showProgress: {
      type: Boolean,
      default: () => getConfig().upload.showProgress
    },
    progressText: {
      type: [String, Number, Function],
      default: () => getConfig().upload.progressText
    },
    showSubmitButton: Boolean,
    autoHiddenButton: {
      type: Boolean,
      default: () => getConfig().upload.autoHiddenButton
    },
    showUploadButton: {
      type: Boolean,
      default: () => getConfig().upload.showUploadButton
    },
    buttonText: {
      type: [String, Number, Function],
      default: () => getConfig().upload.buttonText
    },
    buttonIcon: {
      type: String,
      default: () => getConfig().upload.buttonIcon
    },
    showButtonText: {
      type: Boolean,
      default: () => getConfig().upload.showButtonText
    },
    showButtonIcon: {
      type: Boolean,
      default: () => getConfig().upload.showButtonIcon
    },
    showRemoveButton: {
      type: Boolean,
      default: () => getConfig().upload.showRemoveButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().upload.showDownloadButton
    },
    showPreview: {
      type: Boolean,
      default: () => getConfig().upload.showPreview
    },
    showTip: {
      type: Boolean,
      default: () => null
    },
    maxSimultaneousUploads: {
      type: Number,
      default: () => getConfig().upload.maxSimultaneousUploads
    },
    tipText: [String, Number, Function],
    hintText: String,
    previewMethod: Function,
    uploadMethod: Function,
    beforeRemoveMethod: Function,
    removeMethod: Function,
    beforeDownloadMethod: Function,
    downloadMethod: Function,
    getUrlMethod: Function,
    getThumbnailUrlMethod: Function,
    size: {
      type: String,
      default: () => getConfig().upload.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'add', 'remove', 'remove-fail', 'download', 'download-fail', 'upload-success', 'upload-error', 'sort-dragend', 'more-visible'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPopupElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refDragLineElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refModalDragLineElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isDragUploadStatus: false,
      showMorePopup: false,
      isActivated: false,
      fileList: [],
      fileCacheMaps: {},
      isDragMove: false,
      dragIndex: -1,
      dragTipText: ''
    });
    const internalData = {
      moreId: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('upload'),
      imagePreviewTypes: ['jpg', 'jpeg', 'png', 'gif'],
      prevDragIndex: -1
      // prevDragPos: ''
    };
    const refMaps = {
      refElem
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeKeyField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.keyField || '_X_KEY';
    });
    const computeIsImage = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.mode === 'image';
    });
    const computeNameProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.nameField || 'name';
    });
    const computeTypeProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.typeField || 'type';
    });
    const computeUrlProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.urlField || 'url';
    });
    const computeSizeProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.sizeField || 'size';
    });
    const computeLimitMaxSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.limitSize) * 1024 * 1024;
    });
    const computeLimitMaxCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.multiple ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.limitCount) : 1;
    });
    const computeOverCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        multiple
      } = props;
      const {
        fileList
      } = reactData;
      const limitMaxCount = computeLimitMaxCount.value;
      if (multiple) {
        if (limitMaxCount) {
          return fileList.length >= limitMaxCount;
        }
        return true;
      }
      return fileList.length >= 1;
    });
    const computeLimitSizeUnit = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const limitSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.limitSize);
      if (limitSize) {
        if (limitSize > 1048576) {
          return `${limitSize / 1048576}T`;
        }
        if (limitSize > 1024) {
          return `${limitSize / 1024}G`;
        }
        return `${limitSize}M`;
      }
      return '';
    });
    const computedShowTipText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        showTip,
        tipText
      } = props;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showTip)) {
        return showTip;
      }
      const defShowTip = getConfig().upload.showTip;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(defShowTip)) {
        return defShowTip;
      }
      if (tipText) {
        return true;
      }
      return false;
    });
    const computedDefTipText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        limitSize,
        fileTypes,
        multiple,
        limitCount
      } = props;
      const tipText = props.tipText || props.hintText;
      const isImage = computeIsImage.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(tipText)) {
        return tipText;
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(tipText)) {
        return `${tipText({})}`;
      }
      const defTips = [];
      if (isImage) {
        if (multiple && limitCount) {
          defTips.push(getI18n('vxe.upload.imgCountHint', [limitCount]));
        }
        if (limitSize && limitSizeUnit) {
          defTips.push(getI18n('vxe.upload.imgSizeHint', [limitSizeUnit]));
        }
      } else {
        if (fileTypes && fileTypes.length) {
          defTips.push(getI18n('vxe.upload.fileTypeHint', [fileTypes.join('/')]));
        }
        if (limitSize && limitSizeUnit) {
          defTips.push(getI18n('vxe.upload.fileSizeHint', [limitSizeUnit]));
        }
        if (multiple && limitCount) {
          defTips.push(getI18n('vxe.upload.fileCountHint', [limitCount]));
        }
      }
      return defTips.join(getI18n('vxe.base.comma'));
    });
    const computeImageOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.imageConfig || props.imageStyle);
    });
    const computeImgStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const imageOpts = computeImageOpts.value;
      const {
        width,
        height
      } = imageOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMoreOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        showMoreButton: true
      }, props.moreConfig);
    });
    const computeMaps = {};
    const $xeUpload = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getUniqueKey = () => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    };
    const getFieldKey = item => {
      const keyField = computeKeyField.value;
      return item[keyField];
    };
    const updateFileList = () => {
      const {
        modelValue,
        multiple
      } = props;
      const formReadonly = computeFormReadonly.value;
      const keyField = computeKeyField.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const fileList = modelValue ? (modelValue ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue] : []).map(item => {
        if (!item || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
          const url = `${item || ''}`;
          const urlObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().parseUrl(item);
          const name = (urlObj ? urlObj.searchQuery[nameProp] : '') || parseFileName(url);
          return {
            [nameProp]: name,
            [typeProp]: (urlObj ? urlObj.searchQuery[typeProp] : '') || parseFileType(name),
            [urlProp]: url,
            [sizeProp]: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(urlObj ? urlObj.searchQuery[sizeProp] : 0) || 0,
            [keyField]: getUniqueKey()
          };
        }
        const name = item[nameProp] || '';
        item[nameProp] = name;
        item[typeProp] = item[typeProp] || parseFileType(name);
        item[urlProp] = item[urlProp] || '';
        item[sizeProp] = item[sizeProp] || 0;
        item[keyField] = item[keyField] || getUniqueKey();
        return item;
      }) : [];
      reactData.fileList = formReadonly || multiple ? fileList : fileList.slice(0, 1);
    };
    const parseFileName = url => {
      return decodeURIComponent(`${url || ''}`).split('/').pop() || '';
    };
    const parseFileType = name => {
      // è¿éä¸ç¨split('.').pop()å ä¸ºæ²¡æåç¼æ¶ä¼è¿åèªèº«
      const index = name.lastIndexOf('.');
      if (index > 0) {
        return name.substring(index + 1).toLowerCase();
      }
      return '';
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $upload: $xeUpload
      }, params));
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const handleChange = value => {
      const {
        singleMode,
        urlArgs
      } = props;
      const urlProp = computeUrlProp.value;
      const nameProp = computeNameProp.value;
      let restList = value ? value.slice(0) : [];
      if (urlArgs) {
        restList = restList.map(item => {
          const url = item[urlProp];
          if (url) {
            const urlObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().parseUrl(url);
            if (!urlObj.searchQuery[nameProp]) {
              if (url.indexOf('blob:') === -1) {
                return `${url}${url.indexOf('?') === -1 ? '?' : '&'}${nameProp}=${encodeURIComponent(item[nameProp] || '')}`;
              }
            }
          }
          return url;
        });
      }
      emitModel(singleMode ? restList[0] || null : restList);
    };
    const getThumbnailFileUrl = item => {
      const getThumbnailUrlFn = props.getThumbnailUrlMethod || getConfig().upload.getThumbnailUrlMethod;
      if (getThumbnailUrlFn) {
        return getThumbnailUrlFn({
          $upload: $xeUpload,
          option: item
        });
      }
      return getFileUrl(item);
    };
    const getFileUrl = item => {
      const getUrlFn = props.getUrlMethod || getConfig().upload.getUrlMethod;
      const urlProp = computeUrlProp.value;
      return getUrlFn ? getUrlFn({
        $upload: $xeUpload,
        option: item
      }) : item[urlProp];
    };
    const handleDefaultFilePreview = item => {
      const {
        imageTypes,
        showDownloadButton
      } = props;
      const typeProp = computeTypeProp.value;
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      const {
        imagePreviewTypes
      } = internalData;
      // å¦ææ¯é¢è§å¾ç
      if (imagePreviewTypes.concat(imageTypes || []).some(type => `${type}`.toLowerCase() === `${item[typeProp]}`.toLowerCase())) {
        if (index_esm_VxeUI.previewImage) {
          index_esm_VxeUI.previewImage({
            urlList: [getFileUrl(item)],
            showDownloadButton,
            beforeDownloadMethod: beforeDownloadFn ? () => {
              return beforeDownloadFn({
                $upload: $xeUpload,
                option: item
              });
            } : undefined
          });
        }
      }
    };
    const handlePreviewFileEvent = (evnt, item) => {
      const previewFn = props.previewMethod || getConfig().upload.previewMethod;
      if (props.showPreview) {
        if (previewFn) {
          previewFn({
            $upload: $xeUpload,
            option: item
          });
        } else {
          handleDefaultFilePreview(item);
        }
      }
    };
    const handlePreviewImageEvent = (evnt, item, index) => {
      const {
        showDownloadButton
      } = props;
      const {
        fileList
      } = reactData;
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      if (props.showPreview) {
        if (index_esm_VxeUI.previewImage) {
          index_esm_VxeUI.previewImage({
            urlList: fileList.map(item => getFileUrl(item)),
            activeIndex: index,
            showDownloadButton,
            beforeDownloadMethod: beforeDownloadFn ? ({
              index
            }) => {
              return beforeDownloadFn({
                $upload: $xeUpload,
                option: fileList[index]
              });
            } : undefined
          });
        }
      }
    };
    const handleUploadResult = (item, file) => {
      const {
        showErrorStatus
      } = props;
      const fileKey = getFieldKey(item);
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn) {
        return Promise.resolve(uploadFn({
          $upload: $xeUpload,
          file,
          option: item,
          updateProgress(percentNum) {
            const {
              fileCacheMaps
            } = reactData;
            const cacheItem = fileCacheMaps[getFieldKey(item)];
            if (cacheItem) {
              cacheItem.percent = Math.max(0, Math.min(99, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(percentNum)));
            }
          }
        })).then(res => {
          const {
            fileCacheMaps
          } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.percent = 100;
            cacheItem.status = 'success';
          }
          Object.assign(item, res);
          dispatchEvent('upload-success', {
            option: item,
            data: res
          }, null);
        }).catch(res => {
          const {
            fileCacheMaps
          } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.status = 'error';
          }
          if (showErrorStatus) {
            Object.assign(item, res);
          } else {
            reactData.fileList = reactData.fileList.filter(obj => getFieldKey(obj) !== fileKey);
          }
          dispatchEvent('upload-error', {
            option: item,
            data: res
          }, null);
        }).finally(() => {
          const {
            fileCacheMaps
          } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.loading = false;
          }
        });
      } else {
        const {
          fileCacheMaps
        } = reactData;
        const cacheItem = fileCacheMaps[fileKey];
        if (cacheItem) {
          cacheItem.loading = false;
        }
      }
      return Promise.resolve();
    };
    const handleReUpload = item => {
      const {
        uploadMethod,
        urlMode
      } = props;
      const {
        fileCacheMaps
      } = reactData;
      const fileKey = getFieldKey(item);
      const cacheItem = fileCacheMaps[fileKey];
      const uploadFn = uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn && cacheItem) {
        const file = cacheItem.file;
        cacheItem.loading = true;
        cacheItem.status = 'pending';
        cacheItem.percent = 0;
        handleUploadResult(item, file).then(() => {
          if (urlMode) {
            handleChange(reactData.fileList);
          }
        });
      }
    };
    const handleUploadFile = (files, evnt) => {
      const {
        multiple,
        urlMode,
        showLimitSize,
        limitSizeText,
        showLimitCount,
        limitCountText,
        autoSubmit
      } = props;
      const {
        fileList
      } = reactData;
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      const keyField = computeKeyField.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const limitMaxSize = computeLimitMaxSize.value;
      const limitMaxCount = computeLimitMaxCount.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      let selectFiles = files;
      if (multiple && limitMaxCount) {
        // æ ¡éªæä»¶æ°é
        if (showLimitCount && fileList.length >= limitMaxCount) {
          if (index_esm_VxeUI.modal) {
            index_esm_VxeUI.modal.notification({
              title: getI18n('vxe.modal.errTitle'),
              status: 'error',
              content: limitCountText ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(limitCountText) ? limitCountText({
                maxCount: limitMaxCount
              }) : limitCountText}` : getI18n('vxe.upload.overCountErr', [limitMaxCount])
            });
          }
          return;
        }
        const overNum = selectFiles.length - (limitMaxCount - fileList.length);
        if (showLimitCount && overNum > 0) {
          const overExtraList = selectFiles.slice(limitMaxCount - fileList.length);
          if (limitCountText) {
            index_esm_VxeUI.modal.notification({
              title: getI18n('vxe.modal.errTitle'),
              status: 'error',
              content: `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(limitCountText) ? limitCountText({
                maxCount: limitMaxCount
              }) : limitCountText}`
            });
          } else if (index_esm_VxeUI.modal) {
            index_esm_VxeUI.modal.notification({
              title: getI18n('vxe.modal.errTitle'),
              status: 'error',
              width: null,
              slots: {
                default() {
                  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                    class: 'vxe-upload--file-message-over-error'
                  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {}, getI18n('vxe.upload.overCountExtraErr', [limitMaxCount, overNum])), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                    class: 'vxe-upload--file-message-over-extra'
                  }, overExtraList.map((file, index) => {
                    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                      key: index,
                      class: 'vxe-upload--file-message-over-extra-item'
                    }, file.name);
                  }))]);
                }
              }
            });
          }
        }
        selectFiles = selectFiles.slice(0, limitMaxCount - fileList.length);
      }
      // æ ¡éªæä»¶å¤§å°
      if (showLimitSize && limitMaxSize) {
        for (let i = 0; i < files.length; i++) {
          const file = files[0];
          if (file.size > limitMaxSize) {
            if (index_esm_VxeUI.modal) {
              index_esm_VxeUI.modal.notification({
                title: getI18n('vxe.modal.errTitle'),
                status: 'error',
                content: limitSizeText ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(limitSizeText) ? limitSizeText({
                  maxSize: limitMaxSize
                }) : limitSizeText}` : getI18n('vxe.upload.overSizeErr', [limitSizeUnit])
              });
            }
            return;
          }
        }
      }
      const cacheMaps = Object.assign({}, reactData.fileCacheMaps);
      const newFileList = multiple ? fileList : [];
      const uploadPromiseRests = [];
      selectFiles.forEach(file => {
        const {
          name
        } = file;
        const fileKey = getUniqueKey();
        const fileObj = {
          [nameProp]: name,
          [typeProp]: parseFileType(name),
          [sizeProp]: file.size,
          [urlProp]: URL.createObjectURL(file),
          [keyField]: fileKey
        };
        if (uploadFn) {
          cacheMaps[fileKey] = {
            file: file,
            loading: !!autoSubmit,
            status: 'pending',
            percent: 0
          };
        }
        const item = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(fileObj);
        if (uploadFn && autoSubmit) {
          uploadPromiseRests.push(handleUploadResult(item, file));
        }
        newFileList.push(item);
      });
      reactData.fileList = newFileList;
      reactData.fileCacheMaps = cacheMaps;
      newFileList.forEach(item => {
        dispatchEvent('add', {
          option: item
        }, evnt);
      });
      Promise.all(urlMode ? uploadPromiseRests : []).then(() => {
        handleChange(newFileList);
        // èªå¨æ´æ°æ ¡éªç¶æ
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, newFileList);
        }
      });
    };
    const handleChoose = evnt => {
      const {
        multiple,
        imageTypes,
        fileTypes
      } = props;
      const isDisabled = computeIsDisabled.value;
      const isImage = computeIsImage.value;
      if (isDisabled) {
        return Promise.resolve({
          status: false,
          files: [],
          file: null
        });
      }
      return readLocalFile({
        multiple,
        types: isImage ? imageTypes : fileTypes
      }).then(params => {
        handleUploadFile(params.files, evnt);
        return params;
      });
    };
    const clickEvent = evnt => {
      handleChoose(evnt).catch(() => {
        // éè¯¯æä»¶ç±»å
      });
    };
    const handleRemoveEvent = (evnt, item, index) => {
      const {
        fileList
      } = reactData;
      fileList.splice(index, 1);
      handleChange(fileList);
      // èªå¨æ´æ°æ ¡éªç¶æ
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, fileList);
      }
      dispatchEvent('remove', {
        option: item
      }, evnt);
    };
    const removeFileEvent = (evnt, item, index) => {
      const beforeRemoveFn = props.beforeRemoveMethod || getConfig().upload.beforeRemoveMethod;
      const removeFn = props.removeMethod || getConfig().upload.removeMethod;
      Promise.resolve(beforeRemoveFn ? beforeRemoveFn({
        $upload: $xeUpload,
        option: item
      }) : true).then(status => {
        if (status) {
          if (removeFn) {
            Promise.resolve(removeFn({
              $upload: $xeUpload,
              option: item
            })).then(() => {
              handleRemoveEvent(evnt, item, index);
            }).catch(e => e);
          } else {
            handleRemoveEvent(evnt, item, index);
          }
        } else {
          dispatchEvent('remove-fail', {
            option: item
          }, evnt);
        }
      });
    };
    const handleDownloadEvent = (evnt, item) => {
      dispatchEvent('download', {
        option: item
      }, evnt);
    };
    const downloadFileEvent = (evnt, item) => {
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      const downloadFn = props.downloadMethod || getConfig().upload.downloadMethod;
      Promise.resolve(beforeDownloadFn ? beforeDownloadFn({
        $upload: $xeUpload,
        option: item
      }) : true).then(status => {
        if (status) {
          if (downloadFn) {
            Promise.resolve(downloadFn({
              $upload: $xeUpload,
              option: item
            })).then(() => {
              handleDownloadEvent(evnt, item);
            }).catch(e => e);
          } else {
            handleDownloadEvent(evnt, item);
          }
        } else {
          dispatchEvent('download-fail', {
            option: item
          }, evnt);
        }
      });
    };
    const handleUploadDragleaveEvent = evnt => {
      const targetElem = evnt.currentTarget;
      const {
        clientX,
        clientY
      } = evnt;
      if (targetElem) {
        const {
          x: targetX,
          y: targetY,
          height: targetHeight,
          width: targetWidth
        } = targetElem.getBoundingClientRect();
        if (clientX < targetX || clientX > targetX + targetWidth || clientY < targetY || clientY > targetY + targetHeight) {
          reactData.isDragUploadStatus = false;
        }
      }
    };
    const handleUploadDragoverEvent = evnt => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const {
          items
        } = dataTransfer;
        if (items && items.length) {
          evnt.preventDefault();
          reactData.isDragUploadStatus = true;
        }
      }
    };
    const uploadTransferFileEvent = (evnt, files) => {
      const {
        imageTypes,
        fileTypes
      } = props;
      const {
        imagePreviewTypes
      } = internalData;
      const isImage = computeIsImage.value;
      if (isImage) {
        const pasteImgTypes = imagePreviewTypes.concat(imageTypes && imageTypes.length ? imageTypes : []);
        files = files.filter(file => {
          const fileType = `${file.type.split('/')[1] || ''}`.toLowerCase();
          if (pasteImgTypes.some(type => `${type}`.toLowerCase() === fileType)) {
            return true;
          }
          return false;
        });
      } else {
        if (fileTypes && fileTypes.length) {
          const errTypes = [];
          files.forEach(file => {
            const fileType = parseFileType(file.name);
            if (!fileTypes.some(type => `${type}`.toLowerCase() === fileType)) {
              errTypes.push(fileType);
            }
          });
          if (errTypes.length) {
            if (index_esm_VxeUI.modal) {
              index_esm_VxeUI.modal.message({
                content: getI18n('vxe.error.notType', [errTypes.join(', ')]),
                status: 'error'
              });
            }
            return;
          }
        }
      }
      // å¦æå¨é¨ä¸æ»¡è¶³æ¡ä»¶
      if (!files.length) {
        if (index_esm_VxeUI.modal) {
          index_esm_VxeUI.modal.notification({
            title: getI18n('vxe.modal.errTitle'),
            status: 'error',
            content: getI18n('vxe.upload.uploadTypeErr')
          });
        }
        return;
      }
      handleUploadFile(files, evnt);
    };
    const handleUploadDropEvent = evnt => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const {
          items
        } = dataTransfer;
        if (items && items.length) {
          evnt.preventDefault();
          const files = handleTransferFiles(items);
          if (files.length) {
            uploadTransferFileEvent(evnt, files);
          }
        }
      }
      reactData.isDragUploadStatus = false;
    };
    const handleTransferFiles = items => {
      const files = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(items, item => {
        const file = item.getAsFile();
        if (file) {
          files.push(file);
        }
      });
      return files;
    };
    const handleMoreEvent = evntParams => {
      const formReadonly = computeFormReadonly.value;
      const isImage = computeIsImage.value;
      const evnt = evntParams.$event;
      if (index_esm_VxeUI.modal) {
        index_esm_VxeUI.modal.open({
          id: internalData.moreId,
          title: formReadonly ? getI18n('vxe.upload.morePopup.readTitle') : getI18n(`vxe.upload.morePopup.${isImage ? 'imageTitle' : 'fileTitle'}`),
          width: 660,
          height: 500,
          escClosable: true,
          showMaximize: true,
          resize: true,
          maskClosable: true,
          slots: {
            default() {
              const {
                showErrorStatus,
                dragToUpload,
                dragSort
              } = props;
              const {
                isActivated,
                isDragMove,
                isDragUploadStatus,
                dragIndex
              } = reactData;
              const {
                fileList
              } = reactData;
              const isDisabled = computeIsDisabled.value;
              const moreContSlot = slots.moreContent || slots['more-content'];
              const ons = {};
              if (dragToUpload && dragIndex === -1) {
                ons.onDragover = handleUploadDragoverEvent;
                ons.onDragleave = handleUploadDragleaveEvent;
                ons.onDrop = handleUploadDropEvent;
              }
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                ref: refPopupElem,
                class: ['vxe-upload--more-popup', {
                  'is--readonly': formReadonly,
                  'is--disabled': isDisabled,
                  'is--active': isActivated,
                  'show--error': showErrorStatus,
                  'is--drag': isDragUploadStatus
                }],
                ...ons
              }, moreContSlot ? vn_getSlotVNs(moreContSlot({
                options: fileList
              })) : [isImage ? dragSort ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
                name: `vxe-upload--drag-list${isDragMove ? '' : '-disabled'}`,
                tag: 'div',
                class: 'vxe-upload--image-more-list'
              }, {
                default: () => renderImageItemList(fileList, true).concat(renderImageAction(true))
              }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-upload--image-more-list'
              }, renderImageItemList(fileList, true).concat(renderImageAction(true))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-upload--file-more-list'
              }, [renderFileAction(true), dragSort ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
                name: `vxe-upload--drag-list${isDragMove ? '' : '-disabled'}`,
                tag: 'div',
                class: 'vxe-upload--file-list'
              }, {
                default: () => renderFileItemList(fileList, false)
              }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-upload--file-list'
              }, renderFileItemList(fileList, true))]), dragSort ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                ref: refModalDragLineElem,
                class: 'vxe-upload--drag-line'
              }) : renderEmptyElement($xeUpload), isDragUploadStatus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-upload--drag-placeholder'
              }, getI18n('vxe.upload.dragPlaceholder')) : renderEmptyElement($xeUpload)]);
            }
          },
          onShow() {
            reactData.showMorePopup = true;
          },
          onHide({
            $event
          }) {
            reactData.showMorePopup = false;
            if ($event) {
              dispatchEvent('more-visible', {
                visible: false
              }, $event);
            }
          }
        });
        if (evnt) {
          dispatchEvent('more-visible', {
            visible: true
          }, evnt);
        }
      }
    };
    const showDropTip = (evnt, dragEl, dragPos) => {
      const {
        showMorePopup
      } = reactData;
      const el = refElem.value;
      const popupEl = refPopupElem.value;
      const wrapperEl = showMorePopup ? popupEl : el;
      if (!wrapperEl) {
        return;
      }
      const wrapperRect = wrapperEl.getBoundingClientRect();
      const ddLineEl = refDragLineElem.value;
      const mdLineEl = refModalDragLineElem.value;
      const currDLineEl = showMorePopup ? mdLineEl : ddLineEl;
      if (currDLineEl) {
        const dragRect = dragEl.getBoundingClientRect();
        currDLineEl.style.display = 'block';
        currDLineEl.style.top = `${Math.max(1, dragRect.y - wrapperRect.y)}px`;
        currDLineEl.style.left = `${Math.max(1, dragRect.x - wrapperRect.x)}px`;
        currDLineEl.style.height = `${dragRect.height}px`;
        currDLineEl.style.width = `${dragRect.width - 1}px`;
        currDLineEl.setAttribute('drag-pos', dragPos);
      }
    };
    const hideDropTip = () => {
      const ddLineEl = refDragLineElem.value;
      const mdLineEl = refModalDragLineElem.value;
      if (ddLineEl) {
        ddLineEl.style.display = '';
      }
      if (mdLineEl) {
        mdLineEl.style.display = '';
      }
    };
    // ææ½
    const handleDragSortDragstartEvent = evnt => {
      evnt.stopPropagation();
      if (evnt.dataTransfer) {
        evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
      }
      const dragEl = evnt.currentTarget;
      const parentEl = dragEl.parentElement;
      const dragIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(Array.from(parentEl.children), item => dragEl === item);
      reactData.isDragMove = true;
      reactData.dragIndex = dragIndex;
      setTimeout(() => {
        reactData.isDragMove = false;
      }, 500);
    };
    const handleDragSortDragoverEvent = evnt => {
      evnt.stopPropagation();
      evnt.preventDefault();
      const {
        dragIndex
      } = reactData;
      if (dragIndex === -1) {
        return;
      }
      const isImage = computeIsImage.value;
      const dragEl = evnt.currentTarget;
      const parentEl = dragEl.parentElement;
      const currIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(Array.from(parentEl.children), item => dragEl === item);
      let dragPos = '';
      if (isImage) {
        const offsetX = evnt.clientX - dragEl.getBoundingClientRect().x;
        dragPos = offsetX < dragEl.clientWidth / 2 ? 'left' : 'right';
      } else {
        const offsetY = evnt.clientY - dragEl.getBoundingClientRect().y;
        dragPos = offsetY < dragEl.clientHeight / 2 ? 'top' : 'bottom';
      }
      if (dragIndex === currIndex) {
        showDropTip(evnt, dragEl, dragPos);
        return;
      }
      showDropTip(evnt, dragEl, dragPos);
      internalData.prevDragIndex = currIndex;
      internalData.prevDragPos = dragPos;
    };
    const handleDragSortDragendEvent = evnt => {
      const {
        fileList,
        dragIndex
      } = reactData;
      const {
        prevDragIndex,
        prevDragPos
      } = internalData;
      const oldIndex = dragIndex;
      const targetIndex = prevDragIndex;
      const dragOffsetIndex = prevDragPos === 'bottom' || prevDragPos === 'right' ? 1 : 0;
      const oldItem = fileList[oldIndex];
      const newItem = fileList[targetIndex];
      if (oldItem && newItem) {
        fileList.splice(oldIndex, 1);
        const ptfIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(fileList, item => newItem === item);
        const nIndex = ptfIndex + dragOffsetIndex;
        fileList.splice(nIndex, 0, oldItem);
        dispatchEvent('sort-dragend', {
          oldItem: oldItem,
          newItem: newItem,
          dragPos: prevDragPos,
          offsetIndex: dragOffsetIndex,
          _index: {
            newIndex: nIndex,
            oldIndex: oldIndex
          }
        }, evnt);
      }
      hideDropTip();
      reactData.dragIndex = -1;
    };
    const handleItemMousedownEvent = evnt => {
      if ($xeTable) {
        evnt.stopPropagation();
      }
      reactData.isActivated = true;
    };
    const handleGlobalPasteEvent = evnt => {
      const {
        pasteToUpload
      } = props;
      const {
        isActivated
      } = reactData;
      if (!isActivated || !pasteToUpload) {
        return;
      }
      const clipboardData = evnt.clipboardData || evnt.originalEvent.clipboardData;
      if (!clipboardData) {
        return;
      }
      const {
        items
      } = clipboardData;
      if (!items) {
        return;
      }
      const files = handleTransferFiles(items);
      if (files.length) {
        evnt.preventDefault();
        uploadTransferFileEvent(evnt, files);
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const el = refElem.value;
      const popupEl = refPopupElem.value;
      let isActivated = getEventTargetNode(evnt, el).flag;
      if (!isActivated && popupEl) {
        const parentEl = popupEl.parentElement || popupEl;
        const modalEl = parentEl ? parentEl.parentElement : parentEl;
        isActivated = getEventTargetNode(evnt, modalEl).flag;
      }
      reactData.isActivated = isActivated;
    };
    const handleGlobalBlurEvent = () => {
      reactData.isActivated = false;
    };
    const uploadMethods = {
      dispatchEvent,
      choose() {
        return handleChoose(null);
      },
      submit(isFull) {
        const {
          maxSimultaneousUploads
        } = props;
        const msNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(maxSimultaneousUploads || 1) || 1;
        const {
          fileList,
          fileCacheMaps
        } = reactData;
        const allPendingList = fileList.filter(item => {
          const fileKey = getFieldKey(item);
          const cacheItem = fileCacheMaps[fileKey];
          return cacheItem && (cacheItem.status === 'pending' || isFull && cacheItem.status === 'error');
        });
        const handleSubmit = item => {
          const fileKey = getFieldKey(item);
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            const file = cacheItem.file;
            if (file && (cacheItem.status === 'pending' || isFull && cacheItem.status === 'error')) {
              cacheItem.loading = true;
              cacheItem.percent = 0;
              return handleUploadResult(item, file).then(handleNextSubmit);
            }
          }
          return handleNextSubmit();
        };
        const handleNextSubmit = () => {
          if (allPendingList.length) {
            const item = allPendingList[0];
            allPendingList.splice(0, 1);
            return handleSubmit(item).then(handleNextSubmit);
          }
          return Promise.resolve();
        };
        return Promise.all(allPendingList.splice(0, msNum).map(handleSubmit)).then(() => {
          // å®æ
        });
      },
      getMoreVisible() {
        return reactData.showMorePopup;
      },
      openMore() {
        handleMoreEvent({
          $event: new Event('click')
        });
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      openMoreByEvent(evnt) {
        handleMoreEvent({
          $event: evnt
        });
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      closeMore() {
        if (index_esm_VxeUI.modal) {
          index_esm_VxeUI.modal.close(internalData.moreId);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    const uploadPrivateMethods = {};
    Object.assign($xeUpload, uploadMethods, uploadPrivateMethods);
    const renderFileItemList = (currList, isMoreView) => {
      const {
        showRemoveButton,
        showDownloadButton,
        showProgress,
        progressText,
        showPreview,
        showErrorStatus,
        dragSort,
        autoSubmit,
        showSubmitButton
      } = props;
      const {
        fileList,
        fileCacheMaps
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const optionSlot = slots.option;
      const actionSlot = slots.action;
      const cornerSlot = slots.corner;
      const nameSlot = slots.name;
      const ons = {};
      if (dragSort && currList.length > 1) {
        ons.onDragstart = handleDragSortDragstartEvent;
        ons.onDragover = handleDragSortDragoverEvent;
        ons.onDragend = handleDragSortDragendEvent;
      }
      return currList.map((item, index) => {
        const fileKey = getFieldKey(item);
        const cacheItem = fileCacheMaps[fileKey];
        let isLoading = false;
        let isError = false;
        let isPending = false;
        const fileName = `${item[nameProp] || ''}`;
        if (cacheItem) {
          isLoading = cacheItem.loading;
          isError = cacheItem.status === 'error';
          isPending = cacheItem.status === 'pending';
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: dragSort ? fileKey : index,
          class: ['vxe-upload--file-item', {
            'is--preview': showPreview,
            'is--loading': isLoading,
            'is--pending': isPending,
            'is--error': isError
          }],
          fileid: fileKey,
          draggable: dragSort ? true : null,
          ...ons
        }, optionSlot ? vn_getSlotVNs(optionSlot({
          option: item,
          isMoreView,
          options: fileList
        })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon()[`UPLOAD_FILE_TYPE_${`${item[typeProp]}`.toLocaleUpperCase()}`] || getIcon().UPLOAD_FILE_TYPE_DEFAULT
        })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-name',
          title: fileName,
          onClick(evnt) {
            if (!isLoading && !isError) {
              handlePreviewFileEvent(evnt, item);
            }
          }
        }, nameSlot ? vn_getSlotVNs(nameSlot({
          option: item,
          isMoreView,
          options: fileList
        })) : fileName), isLoading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-loading-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_LOADING
        })]) : renderEmptyElement($xeUpload), showProgress && isLoading && cacheItem ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-loading-text'
        }, progressText ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFormatString(`${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(progressText) ? progressText({}) : progressText}`, {
          percent: cacheItem.percent
        }) : getI18n('vxe.upload.uploadProgress', [cacheItem.percent])) : renderEmptyElement($xeUpload), !isLoading && (isError && showErrorStatus || isPending && showSubmitButton && !autoSubmit) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-rebtn'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          icon: isError ? getIcon().UPLOAD_IMAGE_RE_UPLOAD : getIcon().UPLOAD_IMAGE_UPLOAD,
          mode: 'text',
          status: 'primary',
          content: isError ? getI18n('vxe.upload.reUpload') : getI18n('vxe.upload.manualUpload'),
          onClick() {
            handleReUpload(item);
          }
        })]) : renderEmptyElement($xeUpload), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-btn-wrapper'
        }, actionSlot ? vn_getSlotVNs(actionSlot({
          option: item,
          isMoreView,
          options: fileList,
          readonly: formReadonly
        })) : [cornerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-action'
        }, vn_getSlotVNs(cornerSlot({
          option: item,
          isMoreView,
          options: fileList,
          readonly: formReadonly
        }))) : renderEmptyElement($xeUpload), showDownloadButton && !(isLoading || isPending) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-download-btn',
          onClick(evnt) {
            downloadFileEvent(evnt, item);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_FILE_DOWNLOAD
        })]) : renderEmptyElement($xeUpload), showRemoveButton && !formReadonly && !isDisabled && !isLoading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-remove-btn',
          onClick(evnt) {
            removeFileEvent(evnt, item, index);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_FILE_REMOVE
        })]) : renderEmptyElement($xeUpload)])]);
      });
    };
    const renderFileAction = isMoreView => {
      const {
        showUploadButton,
        buttonText,
        buttonIcon,
        showButtonText,
        showButtonIcon,
        autoHiddenButton
      } = props;
      const {
        fileList
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const showTipText = computedShowTipText.value;
      const defTipText = computedDefTipText.value;
      const overCount = computeOverCount.value;
      const defaultSlot = slots.default;
      const tipSlot = slots.tip || slots.hint;
      if (formReadonly || !showUploadButton) {
        return renderEmptyElement($xeUpload);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-action'
      }, [autoHiddenButton && overCount ? renderEmptyElement($xeUpload) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-action-btn',
        onClick: clickEvent
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({
        isMoreView,
        options: fileList,
        $upload: $xeUpload
      })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        class: 'vxe-upload--file-action-button',
        content: isMoreView || showButtonText ? buttonText ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(buttonText) ? buttonText({}) : buttonText}` : getI18n('vxe.upload.fileBtnText') : '',
        icon: showButtonIcon ? buttonIcon || getIcon().UPLOAD_FILE_ADD : '',
        disabled: isDisabled
      })]), showTipText && (defTipText || tipSlot) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-action-tip'
      }, tipSlot ? vn_getSlotVNs(tipSlot({
        isMoreView,
        options: fileList,
        $upload: $xeUpload
      })) : `${defTipText}`) : renderEmptyElement($xeUpload)]);
    };
    const renderAllMode = () => {
      const {
        showList,
        moreConfig,
        dragSort
      } = props;
      const {
        fileList,
        isDragMove
      } = reactData;
      const moreOpts = computeMoreOpts.value;
      const {
        maxCount,
        showMoreButton,
        layout
      } = moreOpts;
      const isHorizontal = layout === 'horizontal';
      const moreBtnSlot = slots.moreButton || slots['more-button'];
      let currList = fileList;
      let overMaxNum = 0;
      if (maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'all',
        class: 'vxe-upload--file-wrapper'
      }, showList ? [showMoreButton && moreConfig && isHorizontal ? renderEmptyElement($xeUpload) : renderFileAction(true), currList.length || showMoreButton && isHorizontal ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-upload--file-list-wrapper', {
          'is--horizontal': isHorizontal
        }]
      }, [currList.length ? dragSort ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
        name: `vxe-upload--drag-list${isDragMove ? '' : '-disabled'}`,
        tag: 'div',
        class: 'vxe-upload--file-list'
      }, {
        default: () => renderFileItemList(currList, false)
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-list'
      }, renderFileItemList(currList, false)) : renderEmptyElement($xeUpload), showMoreButton && overMaxNum ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-over-more'
      }, moreBtnSlot ? vn_getSlotVNs(moreBtnSlot({
        options: fileList
      })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        mode: 'text',
        content: getI18n('vxe.upload.moreBtnText', [fileList.length]),
        status: 'primary',
        onClick: handleMoreEvent
      })]) : renderEmptyElement($xeUpload), showMoreButton && moreConfig && isHorizontal ? renderFileAction(false) : renderEmptyElement($xeUpload)]) : renderEmptyElement($xeUpload)] : [renderFileAction(false)]);
    };
    const renderImageItemList = (currList, isMoreView) => {
      const {
        showRemoveButton,
        showProgress,
        progressText,
        showPreview,
        showErrorStatus,
        dragSort,
        autoSubmit,
        showSubmitButton
      } = props;
      const {
        fileList,
        fileCacheMaps
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const imageOpts = computeImageOpts.value;
      const imgStyle = computeImgStyle.value;
      const optionSlot = slots.option;
      const actionSlot = slots.action;
      const cornerSlot = slots.corner;
      const ons = {
        onMousedown: handleItemMousedownEvent
      };
      if (dragSort && currList.length > 1) {
        ons.onDragstart = handleDragSortDragstartEvent;
        ons.onDragover = handleDragSortDragoverEvent;
        ons.onDragend = handleDragSortDragendEvent;
      }
      return currList.map((item, index) => {
        const fileKey = getFieldKey(item);
        const cacheItem = fileCacheMaps[fileKey];
        let isLoading = false;
        let isError = false;
        let isPending = false;
        if (cacheItem) {
          isLoading = cacheItem.loading;
          isError = cacheItem.status === 'error';
          isPending = cacheItem.status === 'pending';
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: dragSort ? fileKey : index,
          class: ['vxe-upload--image-item', {
            'is--preview': showPreview,
            'is--circle': imageOpts.circle,
            'is--loading': isLoading,
            'is--pending': isPending,
            'is--error': isError
          }],
          fileid: fileKey,
          draggable: dragSort ? true : null,
          ...ons
        }, optionSlot ? vn_getSlotVNs(optionSlot({
          option: item,
          isMoreView,
          options: fileList
        })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-box',
          style: isMoreView ? null : imgStyle,
          onClick(evnt) {
            if (!isLoading && !isError) {
              handlePreviewImageEvent(evnt, item, index);
            }
          }
        }, [isLoading && cacheItem ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-loading'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-loading-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_LOADING
        })]), showProgress ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-loading-text'
        }, progressText ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFormatString(`${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(progressText) ? progressText({}) : progressText}`, {
          percent: cacheItem.percent
        }) : getI18n('vxe.upload.uploadProgress', [cacheItem.percent])) : renderEmptyElement($xeUpload)]) : renderEmptyElement($xeUpload), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-img-wrapper',
          title: getI18n('vxe.upload.viewItemTitle')
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
          class: 'vxe-upload--image-item-img',
          src: getThumbnailFileUrl(item)
        })]), !isLoading && (isError && showErrorStatus || isPending && showSubmitButton && !autoSubmit) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-rebtn'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          icon: isError ? getIcon().UPLOAD_IMAGE_RE_UPLOAD : getIcon().UPLOAD_IMAGE_UPLOAD,
          mode: 'text',
          status: 'primary',
          content: isError ? getI18n('vxe.upload.reUpload') : getI18n('vxe.upload.manualUpload'),
          onClick() {
            handleReUpload(item);
          }
        })]) : renderEmptyElement($xeUpload), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-btn-wrapper',
          onClick(evnt) {
            evnt.stopPropagation();
          }
        }, actionSlot ? vn_getSlotVNs(actionSlot({
          option: item,
          isMoreView,
          options: fileList,
          readonly: formReadonly
        })) : [cornerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-action'
        }, vn_getSlotVNs(cornerSlot({
          option: item,
          isMoreView,
          options: fileList,
          readonly: formReadonly
        }))) : renderEmptyElement($xeUpload), showRemoveButton && !formReadonly && !isDisabled && !isLoading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-remove-btn',
          onClick(evnt) {
            evnt.stopPropagation();
            removeFileEvent(evnt, item, index);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_IMAGE_REMOVE
        })]) : renderEmptyElement($xeUpload)])])]);
      });
    };
    const renderImageAction = isMoreView => {
      const {
        showUploadButton,
        buttonText,
        buttonIcon,
        showButtonText,
        showButtonIcon,
        autoHiddenButton
      } = props;
      const {
        fileList
      } = reactData;
      const formReadonly = computeFormReadonly.value;
      const showTipText = computedShowTipText.value;
      const defTipText = computedDefTipText.value;
      const overCount = computeOverCount.value;
      const imgStyle = computeImgStyle.value;
      const defaultSlot = slots.default;
      const tipSlot = slots.tip || slots.hint;
      if (formReadonly || !showUploadButton || autoHiddenButton && overCount) {
        return renderEmptyElement($xeUpload);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'action',
        class: 'vxe-upload--image-action'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-btn',
        onClick: clickEvent
      }, defaultSlot ? defaultSlot({
        isMoreView,
        options: fileList,
        $upload: $xeUpload
      }) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-box',
        style: isMoreView ? null : imgStyle
      }, [showButtonIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: buttonIcon || getIcon().UPLOAD_IMAGE_ADD
      })]) : renderEmptyElement($xeUpload), isMoreView || showButtonText ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-content'
      }, buttonText ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(buttonText) ? buttonText({}) : buttonText}` : getI18n('vxe.upload.imgBtnText')) : renderEmptyElement($xeUpload), showTipText && (defTipText || tipSlot) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-hint'
      }, tipSlot ? vn_getSlotVNs(tipSlot({
        isMoreView,
        options: fileList,
        $upload: $xeUpload
      })) : `${defTipText}`) : renderEmptyElement($xeUpload)])])]);
    };
    const renderImageMode = () => {
      const {
        showList,
        dragSort
      } = props;
      const {
        fileList,
        isDragMove
      } = reactData;
      const moreOpts = computeMoreOpts.value;
      const moreBtnSlot = slots.moreButton || slots['more-button'];
      const {
        maxCount,
        showMoreButton
      } = moreOpts;
      let currList = fileList;
      let overMaxNum = 0;
      if (maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'image',
        class: 'vxe-upload--image-wrapper'
      }, showList ? [dragSort ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
        name: `vxe-upload--drag-list${isDragMove ? '' : '-disabled'}`,
        tag: 'div',
        class: 'vxe-upload--image-list'
      }, {
        default: () => renderImageItemList(currList, false).concat([showMoreButton && overMaxNum ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'om',
          class: 'vxe-upload--image-over-more'
        }, moreBtnSlot ? vn_getSlotVNs(moreBtnSlot({
          options: fileList
        })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          mode: 'text',
          content: getI18n('vxe.upload.moreBtnText', [fileList.length]),
          status: 'primary',
          onClick: handleMoreEvent
        })]) : renderEmptyElement($xeUpload), renderImageAction(false)])
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-list'
      }, renderImageItemList(currList, false).concat([showMoreButton && overMaxNum ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-over-more'
      }, moreBtnSlot ? vn_getSlotVNs(moreBtnSlot({
        options: fileList
      })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        mode: 'text',
        content: getI18n('vxe.upload.moreBtnText', [fileList.length]),
        status: 'primary',
        onClick: handleMoreEvent
      })]) : renderEmptyElement($xeUpload), renderImageAction(false)]))] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-list'
      }, [renderImageAction(false)])]);
    };
    const renderVN = () => {
      const {
        showErrorStatus,
        dragToUpload,
        pasteToUpload,
        dragSort
      } = props;
      const {
        isDragUploadStatus,
        showMorePopup,
        isActivated,
        dragIndex
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isImage = computeIsImage.value;
      const ons = {
        onMousedown: handleItemMousedownEvent
      };
      if (dragToUpload && dragIndex === -1) {
        ons.onDragover = handleUploadDragoverEvent;
        ons.onDragleave = handleUploadDragleaveEvent;
        ons.onDrop = handleUploadDropEvent;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-upload', {
          [`size--${vSize}`]: vSize,
          'is--active': isActivated,
          'is--readonly': formReadonly,
          'is--disabled': isDisabled,
          'is--paste': pasteToUpload,
          'show--error': showErrorStatus,
          'is--drag': isDragUploadStatus
        }],
        ...ons
      }, [isImage ? renderImageMode() : renderAllMode(), dragSort ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refDragLineElem,
        class: 'vxe-upload--drag-line'
      }) : renderEmptyElement($xeUpload), isDragUploadStatus && !showMorePopup ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--drag-placeholder'
      }, getI18n('vxe.upload.dragPlaceholder')) : renderEmptyElement($xeUpload)]);
    };
    const listFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue ? props.modelValue.length : 0, () => {
      listFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      listFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(listFlag, () => {
      updateFileList();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if (props.multiple && props.singleMode) {
        errLog('vxe.error.errConflicts', ['[upload] multiple', 'single-mode']);
      }
      if (props.imageStyle) {
        warnLog('vxe.error.delProp', ['[upload] image-style', 'image-config']);
      }
      if (props.dragSort) {
        initTpImg();
      }
      globalEvents.on($xeUpload, 'paste', handleGlobalPasteEvent);
      globalEvents.on($xeUpload, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeUpload, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      reactData.isDragUploadStatus = false;
      globalEvents.off($xeUpload, 'paste');
      globalEvents.off($xeUpload, 'mousedown');
      globalEvents.off($xeUpload, 'blur');
    });
    updateFileList();
    $xeUpload.renderVN = renderVN;
    return $xeUpload;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/upload/index.ts




const VxeUpload = Object.assign({}, upload, {
  install(app) {
    app.component(upload.name, upload);
  }
});
dynamicApp.use(VxeUpload);
index_esm_VxeUI.component(upload);
index_esm_VxeUI.saveFile = saveLocalFile;
index_esm_VxeUI.readFile = readLocalFile;
const Upload = VxeUpload;
/* harmony default export */ var packages_upload = (VxeUpload);
;// CONCATENATED MODULE: ./packages/watermark/src/util.ts


let canvasEl = null;
let fontEl = null;
const fontCacheMaps = {};
function getMarkCanvas() {
  if (!canvasEl) {
    canvasEl = document.createElement('canvas');
    canvasEl.style.position = 'absolute';
    canvasEl.style.top = '0';
    canvasEl.style.left = '0';
  }
  return canvasEl;
}
function removeMarkElement(elem) {
  if (elem) {
    const parentEl = elem.parentNode;
    if (parentEl) {
      parentEl.removeChild(elem);
    }
  }
}
function calcFontWH(text, fontSize) {
  const fKey = `${fontSize}_${text}`;
  if (!fontCacheMaps[fKey]) {
    if (!fontEl) {
      fontEl = document.createElement('span');
    }
    if (!fontEl.parentNode) {
      document.body.append(fontEl);
    }
    fontEl.textContent = text;
    fontEl.style.fontSize = toCssUnit(fontSize);
    const width = fontEl.offsetWidth;
    const height = fontEl.offsetHeight;
    fontCacheMaps[fKey] = {
      width,
      height
    };
  }
  return fontCacheMaps[fKey];
}
function calcContentWH(contList) {
  let contentWidth = 0;
  let contentHeight = 0;
  contList.forEach(item => {
    contentWidth = Math.max(item.width, contentWidth);
    contentHeight = Math.max(item.height, contentHeight);
  });
  return {
    contentWidth,
    contentHeight
  };
}
function calcCanvasWH(contentWidth, opts) {
  const {
    gap
  } = opts;
  const [gapX = 0, gapY = 0] = gap ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(gap) ? gap : [gap, gap] : [];
  const canvasWidth = contentWidth + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(gapX);
  const canvasHeight = contentWidth + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(gapY);
  return {
    canvasWidth,
    canvasHeight
  };
}
function getFontConf(item, key, opts) {
  return (item.font ? item.font[key] : '') || (opts.font ? opts.font[key] : '');
}
function createMarkFont(contConf, defaultFontSize, opts) {
  const {
    offset
  } = opts;
  const text = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(contConf.textContent);
  const fontSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getFontConf(contConf, 'fontSize', opts) || defaultFontSize) || 14;
  const [offsetX = 0, offsetY = 0] = offset ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(offset) ? offset : [offset, offset] : [];
  const {
    width,
    height
  } = calcFontWH(text, fontSize);
  return {
    text,
    fontSize,
    font: contConf.font,
    width: width + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetX),
    height: height + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetY)
  };
}
function drayFont(ctx, item, opts) {
  const fontWeight = getFontConf(item, 'fontWeight', opts);
  ctx.fillStyle = `${getFontConf(item, 'color', opts) || 'rgba(0, 0, 0, 0.15)'}`;
  ctx.font = [getFontConf(item, 'fontStyle', opts) || 'normal', fontWeight === 'bold' || fontWeight === 'bolder' ? 'bold' : '', toCssUnit(item.fontSize), getFontConf(item, 'fontFamily', opts) || 'sans-serif'].join(' ');
}
function getContentUrl(content, defaultFontSize, options) {
  const opts = Object.assign({}, options);
  const {
    rotate
  } = opts;
  const deg = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(rotate);
  const contList = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(content) ? content : [content]).map(item => {
    if (item) {
      if (item.textContent) {
        return createMarkFont(item, defaultFontSize, opts);
      }
      return createMarkFont({
        textContent: `${item}`
      }, defaultFontSize, opts);
    }
    return createMarkFont({
      textContent: ''
    }, defaultFontSize, opts);
  });
  removeMarkElement(fontEl);
  return new Promise(resolve => {
    const canvasEl = getMarkCanvas();
    if (!canvasEl.parentNode) {
      document.body.append(canvasEl);
    }
    const ctx = canvasEl.getContext('2d');
    if (ctx && contList.length) {
      const {
        contentWidth,
        contentHeight
      } = calcContentWH(contList);
      const {
        canvasWidth,
        canvasHeight
      } = calcCanvasWH(contentWidth, opts);
      canvasEl.width = canvasWidth;
      canvasEl.height = canvasHeight;
      const x = (canvasWidth - contentWidth) / 2;
      const y = (canvasHeight - contentHeight) / 2;
      const drayX = x + contentWidth / 2;
      const drayY = y + contentHeight / 2;
      ctx.save();
      ctx.translate(drayX, drayY);
      ctx.rotate(deg * Math.PI / 180);
      ctx.translate(-drayX, -drayY);
      let offsetHeight = 0;
      contList.forEach(item => {
        const align = getFontConf(item, 'align', opts);
        drayFont(ctx, item, opts);
        ctx.fillText(item.text, x + (align === 'center' ? (contentWidth - item.width) / 2 : 0), y + (contentHeight + contentHeight) / 2 + offsetHeight, contentWidth);
        offsetHeight += item.height;
      });
      ctx.restore();
      resolve(canvasEl.toDataURL());
      removeMarkElement(canvasEl);
    } else {
      resolve('');
      removeMarkElement(canvasEl);
    }
  });
}
;// CONCATENATED MODULE: ./packages/watermark/src/watermark.ts






/* harmony default export */ var watermark = (defineVxeComponent({
  name: 'VxeWatermark',
  props: {
    width: String,
    height: String,
    imageUrl: String,
    rotate: {
      type: [Number, String],
      default: () => getConfig().watermark.rotate
    },
    gap: {
      type: [Array, Number, String],
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().watermark.gap, true)
    },
    content: [String, Array],
    font: Object,
    offset: Object,
    zIndex: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      markUrl: ''
    });
    const refMaps = {
      refElem
    };
    const computeFontOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().watermark.font, true), props.font);
    });
    const computeWrapperStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        height,
        zIndex
      } = props;
      const {
        markUrl
      } = reactData;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (markUrl) {
        stys.backgroundImage = `url(${markUrl})`;
      }
      if (zIndex) {
        stys.zIndex = zIndex;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeWatermark = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $watermark: $xeWatermark
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const updateMarkStyle = () => {
      const {
        content,
        gap,
        rotate,
        offset
      } = props;
      const el = refElem.value;
      const fontOpts = computeFontOpts.value;
      if (el) {
        if (content) {
          getContentUrl(content, getComputedStyle(el).fontSize, {
            font: fontOpts,
            rotate,
            gap,
            offset
          }).then(url => {
            reactData.markUrl = url;
          });
        }
      }
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeWatermark, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const wrapperStyle = computeWrapperStyle.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: 'vxe-watermark',
        style: wrapperStyle
      });
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.imageUrl, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.content, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.gap, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.rotate, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.width, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.font, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      updateMarkStyle();
      globalEvents.on($xeWatermark, 'resize', external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().throttle(() => {
        updateMarkStyle();
      }, 300, {
        trailing: true,
        leading: true
      }));
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeWatermark, 'resize');
    });
    $xeWatermark.renderVN = renderVN;
    return $xeWatermark;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/watermark/index.ts



const VxeWatermark = Object.assign({}, watermark, {
  install(app) {
    app.component(watermark.name, watermark);
  }
});
dynamicApp.use(VxeWatermark);
index_esm_VxeUI.component(watermark);
const WatermarkController = {
  load(options) {
    checkDynamic();
    dynamicStore.globalWatermark = Object.assign({}, options);
    return Promise.resolve();
  },
  clear() {
    dynamicStore.globalWatermark = null;
    return Promise.resolve();
  }
};
index_esm_VxeUI.watermark = WatermarkController;
const Watermark = VxeWatermark;
/* harmony default export */ var packages_watermark = (VxeWatermark);
;// CONCATENATED MODULE: ./packages/components.ts






















































































const {
  setI18n: components_setI18n,
  setLanguage: components_setLanguage,
  setTheme: components_setTheme,
  setConfig: components_setConfig
} = index_esm_VxeUI;
const components_components = [packages_alert, packages_anchor, packages_anchor_link, packages_avatar, packages_badge, packages_breadcrumb, packages_breadcrumb_item, packages_button, packages_button_group, packages_calendar, packages_card, packages_carousel, packages_carousel_item, packages_checkbox, checkbox_button, checkbox_group, packages_col, packages_collapse, packages_collapse_pane, packages_color_picker, packages_countdown, packages_date_panel, packages_date_picker, packages_date_range_picker, packages_drawer, packages_empty, packages_form, form_gather, packages_form_group, packages_form_item, packages_icon, packages_icon_picker, packages_image, image_group, image_preview, packages_input, packages_layout_aside, packages_layout_body, packages_layout_container, packages_layout_footer, packages_layout_header, packages_link, packages_list, loading, packages_menu, packages_modal, packages_notice_bar, packages_number_input, packages_optgroup, packages_option, packages_pager, packages_password_input, print_page_break, packages_print, packages_pulldown, packages_radio, radio_button, radio_group, packages_rate, packages_result, packages_row, packages_select, packages_splitter, packages_splitter_panel, split, split_pane, packages_slider, packages_steps, packages_switch, packages_tab_pane, packages_table_select, packages_tabs, packages_tag, packages_text_ellipsis, packages_text, packages_textarea, packages_tip, packages_tooltip, packages_tree, packages_tree_select, packages_upload, packages_watermark];
function install(app, options) {
  components_setConfig(options);
  components_components.forEach(component => app.use(component));
}
// é»è®¤ä¸­æ
const defaultLanguage = 'zh-CN';
components_setI18n(defaultLanguage, zh_CN);
components_setLanguage(defaultLanguage);
components_setTheme('light');
// å¼å®¹èçæ¬
const components_loading = LoadingController;
const components_modal = ModalController;
const components_drawer = DrawerController;
const components_watermark = WatermarkController;
const components_print = printHtml;
const saveFile = saveLocalFile;
const readFile = readLocalFile;

// Components


















































































;// CONCATENATED MODULE: ./index.ts


if (typeof window !== 'undefined') {
  if (window.VxeUI && !window.VxeUIAll) {
    window.VxeUIAll = components_namespaceObject;
  }
  if (window.VxeUI && !window.VxeUIBase) {
    window.VxeUIBase = components_namespaceObject;
  }
}

/* harmony default export */ var index = (components_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = (index);


}();
/******/ 	return __webpack_exports__;
/******/ })()
;
});